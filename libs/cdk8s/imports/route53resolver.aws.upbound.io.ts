// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Endpoint is the Schema for the Endpoints API. Provides a Route 53 Resolver endpoint resource.
 *
 * @schema Endpoint
 */
export class Endpoint extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Endpoint"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53resolver.aws.upbound.io/v1beta1',
    kind: 'Endpoint',
  }

  /**
   * Renders a Kubernetes manifest for "Endpoint".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EndpointProps): any {
    return {
      ...Endpoint.GVK,
      ...toJson_EndpointProps(props),
    };
  }

  /**
   * Defines a "Endpoint" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EndpointProps) {
    super(scope, id, {
      ...Endpoint.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Endpoint.GVK,
      ...toJson_EndpointProps(resolved),
    };
  }
}

/**
 * Endpoint is the Schema for the Endpoints API. Provides a Route 53 Resolver endpoint resource.
 *
 * @schema Endpoint
 */
export interface EndpointProps {
  /**
   * @schema Endpoint#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EndpointSpec defines the desired state of Endpoint
   *
   * @schema Endpoint#spec
   */
  readonly spec: EndpointSpec;

}

/**
 * Converts an object of type 'EndpointProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointProps(obj: EndpointProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EndpointSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSpec defines the desired state of Endpoint
 *
 * @schema EndpointSpec
 */
export interface EndpointSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EndpointSpec#deletionPolicy
   */
  readonly deletionPolicy?: EndpointSpecDeletionPolicy;

  /**
   * @schema EndpointSpec#forProvider
   */
  readonly forProvider: EndpointSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EndpointSpec#managementPolicy
   */
  readonly managementPolicy?: EndpointSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EndpointSpec#providerConfigRef
   */
  readonly providerConfigRef?: EndpointSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EndpointSpec#providerRef
   */
  readonly providerRef?: EndpointSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EndpointSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EndpointSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EndpointSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EndpointSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EndpointSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpec(obj: EndpointSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EndpointSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_EndpointSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EndpointSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EndpointSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EndpointSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EndpointSpecDeletionPolicy
 */
export enum EndpointSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EndpointSpecForProvider
 */
export interface EndpointSpecForProvider {
  /**
   * The direction of DNS queries to or from the Route 53 Resolver endpoint. Valid values are INBOUND (resolver forwards DNS queries to the DNS service for a VPC from your network or another VPC) or OUTBOUND (resolver forwards DNS queries from the DNS service for a VPC to your network or another VPC).
   *
   * @schema EndpointSpecForProvider#direction
   */
  readonly direction?: string;

  /**
   * The subnets and IP addresses in your VPC that you want DNS queries to pass through on the way from your VPCs to your network (for outbound endpoints) or on the way from your network to your VPCs (for inbound endpoints). Described below.
   *
   * @schema EndpointSpecForProvider#ipAddress
   */
  readonly ipAddress?: EndpointSpecForProviderIpAddress[];

  /**
   * The friendly name of the Route 53 Resolver endpoint.
   *
   * @schema EndpointSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EndpointSpecForProvider#region
   */
  readonly region: string;

  /**
   * References to SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema EndpointSpecForProvider#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: EndpointSpecForProviderSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema EndpointSpecForProvider#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: EndpointSpecForProviderSecurityGroupIdSelector;

  /**
   * The ID of one or more security groups that you want to use to control access to this VPC.
   *
   * @schema EndpointSpecForProvider#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema EndpointSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'EndpointSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProvider(obj: EndpointSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'ipAddress': obj.ipAddress?.map(y => toJson_EndpointSpecForProviderIpAddress(y)),
    'name': obj.name,
    'region': obj.region,
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_EndpointSpecForProviderSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_EndpointSpecForProviderSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EndpointSpecManagementPolicy
 */
export enum EndpointSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EndpointSpecProviderConfigRef
 */
export interface EndpointSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointSpecProviderConfigRef#policy
   */
  readonly policy?: EndpointSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EndpointSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecProviderConfigRef(obj: EndpointSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EndpointSpecProviderRef
 */
export interface EndpointSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointSpecProviderRef#policy
   */
  readonly policy?: EndpointSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EndpointSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecProviderRef(obj: EndpointSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EndpointSpecPublishConnectionDetailsTo
 */
export interface EndpointSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EndpointSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EndpointSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EndpointSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EndpointSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EndpointSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EndpointSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecPublishConnectionDetailsTo(obj: EndpointSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EndpointSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EndpointSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EndpointSpecWriteConnectionSecretToRef
 */
export interface EndpointSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EndpointSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EndpointSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EndpointSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecWriteConnectionSecretToRef(obj: EndpointSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointSpecForProviderIpAddress
 */
export interface EndpointSpecForProviderIpAddress {
  /**
   * The IP address in the subnet that you want to use for DNS queries.
   *
   * @schema EndpointSpecForProviderIpAddress#ip
   */
  readonly ip?: string;

  /**
   * The ID of the subnet that contains the IP address.
   *
   * @schema EndpointSpecForProviderIpAddress#subnetId
   */
  readonly subnetId?: string;

  /**
   * Reference to a Subnet in ec2 to populate subnetId.
   *
   * @schema EndpointSpecForProviderIpAddress#subnetIdRef
   */
  readonly subnetIdRef?: EndpointSpecForProviderIpAddressSubnetIdRef;

  /**
   * Selector for a Subnet in ec2 to populate subnetId.
   *
   * @schema EndpointSpecForProviderIpAddress#subnetIdSelector
   */
  readonly subnetIdSelector?: EndpointSpecForProviderIpAddressSubnetIdSelector;

}

/**
 * Converts an object of type 'EndpointSpecForProviderIpAddress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderIpAddress(obj: EndpointSpecForProviderIpAddress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ip': obj.ip,
    'subnetId': obj.subnetId,
    'subnetIdRef': toJson_EndpointSpecForProviderIpAddressSubnetIdRef(obj.subnetIdRef),
    'subnetIdSelector': toJson_EndpointSpecForProviderIpAddressSubnetIdSelector(obj.subnetIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema EndpointSpecForProviderSecurityGroupIdRefs
 */
export interface EndpointSpecForProviderSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointSpecForProviderSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointSpecForProviderSecurityGroupIdRefs#policy
   */
  readonly policy?: EndpointSpecForProviderSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'EndpointSpecForProviderSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderSecurityGroupIdRefs(obj: EndpointSpecForProviderSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointSpecForProviderSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
 *
 * @schema EndpointSpecForProviderSecurityGroupIdSelector
 */
export interface EndpointSpecForProviderSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EndpointSpecForProviderSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EndpointSpecForProviderSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EndpointSpecForProviderSecurityGroupIdSelector#policy
   */
  readonly policy?: EndpointSpecForProviderSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'EndpointSpecForProviderSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderSecurityGroupIdSelector(obj: EndpointSpecForProviderSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EndpointSpecForProviderSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointSpecProviderConfigRefPolicy
 */
export interface EndpointSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EndpointSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EndpointSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecProviderConfigRefPolicy(obj: EndpointSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointSpecProviderRefPolicy
 */
export interface EndpointSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EndpointSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EndpointSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecProviderRefPolicy(obj: EndpointSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EndpointSpecPublishConnectionDetailsToConfigRef
 */
export interface EndpointSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EndpointSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EndpointSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecPublishConnectionDetailsToConfigRef(obj: EndpointSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EndpointSpecPublishConnectionDetailsToMetadata
 */
export interface EndpointSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EndpointSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EndpointSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EndpointSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EndpointSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecPublishConnectionDetailsToMetadata(obj: EndpointSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Subnet in ec2 to populate subnetId.
 *
 * @schema EndpointSpecForProviderIpAddressSubnetIdRef
 */
export interface EndpointSpecForProviderIpAddressSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointSpecForProviderIpAddressSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointSpecForProviderIpAddressSubnetIdRef#policy
   */
  readonly policy?: EndpointSpecForProviderIpAddressSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'EndpointSpecForProviderIpAddressSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderIpAddressSubnetIdRef(obj: EndpointSpecForProviderIpAddressSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointSpecForProviderIpAddressSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Subnet in ec2 to populate subnetId.
 *
 * @schema EndpointSpecForProviderIpAddressSubnetIdSelector
 */
export interface EndpointSpecForProviderIpAddressSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EndpointSpecForProviderIpAddressSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EndpointSpecForProviderIpAddressSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EndpointSpecForProviderIpAddressSubnetIdSelector#policy
   */
  readonly policy?: EndpointSpecForProviderIpAddressSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'EndpointSpecForProviderIpAddressSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderIpAddressSubnetIdSelector(obj: EndpointSpecForProviderIpAddressSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EndpointSpecForProviderIpAddressSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointSpecForProviderSecurityGroupIdRefsPolicy
 */
export interface EndpointSpecForProviderSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointSpecForProviderSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: EndpointSpecForProviderSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointSpecForProviderSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: EndpointSpecForProviderSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'EndpointSpecForProviderSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderSecurityGroupIdRefsPolicy(obj: EndpointSpecForProviderSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EndpointSpecForProviderSecurityGroupIdSelectorPolicy
 */
export interface EndpointSpecForProviderSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointSpecForProviderSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: EndpointSpecForProviderSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointSpecForProviderSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: EndpointSpecForProviderSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EndpointSpecForProviderSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderSecurityGroupIdSelectorPolicy(obj: EndpointSpecForProviderSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointSpecProviderConfigRefPolicyResolution
 */
export enum EndpointSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointSpecProviderConfigRefPolicyResolve
 */
export enum EndpointSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointSpecProviderRefPolicyResolution
 */
export enum EndpointSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointSpecProviderRefPolicyResolve
 */
export enum EndpointSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EndpointSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EndpointSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecPublishConnectionDetailsToConfigRefPolicy(obj: EndpointSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointSpecForProviderIpAddressSubnetIdRefPolicy
 */
export interface EndpointSpecForProviderIpAddressSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointSpecForProviderIpAddressSubnetIdRefPolicy#resolution
   */
  readonly resolution?: EndpointSpecForProviderIpAddressSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointSpecForProviderIpAddressSubnetIdRefPolicy#resolve
   */
  readonly resolve?: EndpointSpecForProviderIpAddressSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointSpecForProviderIpAddressSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderIpAddressSubnetIdRefPolicy(obj: EndpointSpecForProviderIpAddressSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EndpointSpecForProviderIpAddressSubnetIdSelectorPolicy
 */
export interface EndpointSpecForProviderIpAddressSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointSpecForProviderIpAddressSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: EndpointSpecForProviderIpAddressSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointSpecForProviderIpAddressSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: EndpointSpecForProviderIpAddressSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EndpointSpecForProviderIpAddressSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderIpAddressSubnetIdSelectorPolicy(obj: EndpointSpecForProviderIpAddressSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointSpecForProviderSecurityGroupIdRefsPolicyResolution
 */
export enum EndpointSpecForProviderSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointSpecForProviderSecurityGroupIdRefsPolicyResolve
 */
export enum EndpointSpecForProviderSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointSpecForProviderSecurityGroupIdSelectorPolicyResolution
 */
export enum EndpointSpecForProviderSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointSpecForProviderSecurityGroupIdSelectorPolicyResolve
 */
export enum EndpointSpecForProviderSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointSpecForProviderIpAddressSubnetIdRefPolicyResolution
 */
export enum EndpointSpecForProviderIpAddressSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointSpecForProviderIpAddressSubnetIdRefPolicyResolve
 */
export enum EndpointSpecForProviderIpAddressSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointSpecForProviderIpAddressSubnetIdSelectorPolicyResolution
 */
export enum EndpointSpecForProviderIpAddressSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointSpecForProviderIpAddressSubnetIdSelectorPolicyResolve
 */
export enum EndpointSpecForProviderIpAddressSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Rule is the Schema for the Rules API. Provides a Route53 Resolver rule.
 *
 * @schema Rule
 */
export class Rule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Rule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53resolver.aws.upbound.io/v1beta1',
    kind: 'Rule',
  }

  /**
   * Renders a Kubernetes manifest for "Rule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RuleProps): any {
    return {
      ...Rule.GVK,
      ...toJson_RuleProps(props),
    };
  }

  /**
   * Defines a "Rule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RuleProps) {
    super(scope, id, {
      ...Rule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Rule.GVK,
      ...toJson_RuleProps(resolved),
    };
  }
}

/**
 * Rule is the Schema for the Rules API. Provides a Route53 Resolver rule.
 *
 * @schema Rule
 */
export interface RuleProps {
  /**
   * @schema Rule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RuleSpec defines the desired state of Rule
   *
   * @schema Rule#spec
   */
  readonly spec: RuleSpec;

}

/**
 * Converts an object of type 'RuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleProps(obj: RuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RuleSpec defines the desired state of Rule
 *
 * @schema RuleSpec
 */
export interface RuleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RuleSpec#deletionPolicy
   */
  readonly deletionPolicy?: RuleSpecDeletionPolicy;

  /**
   * @schema RuleSpec#forProvider
   */
  readonly forProvider: RuleSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RuleSpec#managementPolicy
   */
  readonly managementPolicy?: RuleSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RuleSpec#providerConfigRef
   */
  readonly providerConfigRef?: RuleSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RuleSpec#providerRef
   */
  readonly providerRef?: RuleSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RuleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RuleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RuleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RuleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpec(obj: RuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RuleSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RuleSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RuleSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RuleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RuleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RuleSpecDeletionPolicy
 */
export enum RuleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RuleSpecForProvider
 */
export interface RuleSpecForProvider {
  /**
   * DNS queries for this domain name are forwarded to the IP addresses that are specified using target_ip.
   *
   * @schema RuleSpecForProvider#domainName
   */
  readonly domainName?: string;

  /**
   * A friendly name that lets you easily find a rule in the Resolver dashboard in the Route 53 console.
   *
   * @schema RuleSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RuleSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ID of the outbound resolver endpoint that you want to use to route DNS queries to the IP addresses that you specify using target_ip. This argument should only be specified for FORWARD type rules.
   *
   * @schema RuleSpecForProvider#resolverEndpointId
   */
  readonly resolverEndpointId?: string;

  /**
   * Reference to a Endpoint in route53resolver to populate resolverEndpointId.
   *
   * @schema RuleSpecForProvider#resolverEndpointIdRef
   */
  readonly resolverEndpointIdRef?: RuleSpecForProviderResolverEndpointIdRef;

  /**
   * Selector for a Endpoint in route53resolver to populate resolverEndpointId.
   *
   * @schema RuleSpecForProvider#resolverEndpointIdSelector
   */
  readonly resolverEndpointIdSelector?: RuleSpecForProviderResolverEndpointIdSelector;

  /**
   * The rule type. Valid values are FORWARD, SYSTEM and RECURSIVE.
   *
   * @schema RuleSpecForProvider#ruleType
   */
  readonly ruleType?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RuleSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Configuration block(s) indicating the IPs that you want Resolver to forward DNS queries to (documented below). This argument should only be specified for FORWARD type rules.
   *
   * @schema RuleSpecForProvider#targetIp
   */
  readonly targetIp?: RuleSpecForProviderTargetIp[];

}

/**
 * Converts an object of type 'RuleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProvider(obj: RuleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainName': obj.domainName,
    'name': obj.name,
    'region': obj.region,
    'resolverEndpointId': obj.resolverEndpointId,
    'resolverEndpointIdRef': toJson_RuleSpecForProviderResolverEndpointIdRef(obj.resolverEndpointIdRef),
    'resolverEndpointIdSelector': toJson_RuleSpecForProviderResolverEndpointIdSelector(obj.resolverEndpointIdSelector),
    'ruleType': obj.ruleType,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetIp': obj.targetIp?.map(y => toJson_RuleSpecForProviderTargetIp(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RuleSpecManagementPolicy
 */
export enum RuleSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RuleSpecProviderConfigRef
 */
export interface RuleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleSpecProviderConfigRef#policy
   */
  readonly policy?: RuleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecProviderConfigRef(obj: RuleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RuleSpecProviderRef
 */
export interface RuleSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleSpecProviderRef#policy
   */
  readonly policy?: RuleSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RuleSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecProviderRef(obj: RuleSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RuleSpecPublishConnectionDetailsTo
 */
export interface RuleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RuleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RuleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RuleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RuleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RuleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RuleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecPublishConnectionDetailsTo(obj: RuleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RuleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RuleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RuleSpecWriteConnectionSecretToRef
 */
export interface RuleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RuleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RuleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RuleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecWriteConnectionSecretToRef(obj: RuleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Endpoint in route53resolver to populate resolverEndpointId.
 *
 * @schema RuleSpecForProviderResolverEndpointIdRef
 */
export interface RuleSpecForProviderResolverEndpointIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleSpecForProviderResolverEndpointIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleSpecForProviderResolverEndpointIdRef#policy
   */
  readonly policy?: RuleSpecForProviderResolverEndpointIdRefPolicy;

}

/**
 * Converts an object of type 'RuleSpecForProviderResolverEndpointIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderResolverEndpointIdRef(obj: RuleSpecForProviderResolverEndpointIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleSpecForProviderResolverEndpointIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Endpoint in route53resolver to populate resolverEndpointId.
 *
 * @schema RuleSpecForProviderResolverEndpointIdSelector
 */
export interface RuleSpecForProviderResolverEndpointIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RuleSpecForProviderResolverEndpointIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RuleSpecForProviderResolverEndpointIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RuleSpecForProviderResolverEndpointIdSelector#policy
   */
  readonly policy?: RuleSpecForProviderResolverEndpointIdSelectorPolicy;

}

/**
 * Converts an object of type 'RuleSpecForProviderResolverEndpointIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderResolverEndpointIdSelector(obj: RuleSpecForProviderResolverEndpointIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RuleSpecForProviderResolverEndpointIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleSpecForProviderTargetIp
 */
export interface RuleSpecForProviderTargetIp {
  /**
   * One IP address that you want to forward DNS queries to. You can specify only IPv4 addresses.
   *
   * @schema RuleSpecForProviderTargetIp#ip
   */
  readonly ip: string;

  /**
   * The port at ip that you want to forward DNS queries to. Default value is 53
   *
   * @schema RuleSpecForProviderTargetIp#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'RuleSpecForProviderTargetIp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderTargetIp(obj: RuleSpecForProviderTargetIp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ip': obj.ip,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleSpecProviderConfigRefPolicy
 */
export interface RuleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RuleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RuleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecProviderConfigRefPolicy(obj: RuleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleSpecProviderRefPolicy
 */
export interface RuleSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RuleSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RuleSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecProviderRefPolicy(obj: RuleSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RuleSpecPublishConnectionDetailsToConfigRef
 */
export interface RuleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RuleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecPublishConnectionDetailsToConfigRef(obj: RuleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RuleSpecPublishConnectionDetailsToMetadata
 */
export interface RuleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RuleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecPublishConnectionDetailsToMetadata(obj: RuleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleSpecForProviderResolverEndpointIdRefPolicy
 */
export interface RuleSpecForProviderResolverEndpointIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleSpecForProviderResolverEndpointIdRefPolicy#resolution
   */
  readonly resolution?: RuleSpecForProviderResolverEndpointIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleSpecForProviderResolverEndpointIdRefPolicy#resolve
   */
  readonly resolve?: RuleSpecForProviderResolverEndpointIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleSpecForProviderResolverEndpointIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderResolverEndpointIdRefPolicy(obj: RuleSpecForProviderResolverEndpointIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RuleSpecForProviderResolverEndpointIdSelectorPolicy
 */
export interface RuleSpecForProviderResolverEndpointIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleSpecForProviderResolverEndpointIdSelectorPolicy#resolution
   */
  readonly resolution?: RuleSpecForProviderResolverEndpointIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleSpecForProviderResolverEndpointIdSelectorPolicy#resolve
   */
  readonly resolve?: RuleSpecForProviderResolverEndpointIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RuleSpecForProviderResolverEndpointIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderResolverEndpointIdSelectorPolicy(obj: RuleSpecForProviderResolverEndpointIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleSpecProviderConfigRefPolicyResolution
 */
export enum RuleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleSpecProviderConfigRefPolicyResolve
 */
export enum RuleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleSpecProviderRefPolicyResolution
 */
export enum RuleSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleSpecProviderRefPolicyResolve
 */
export enum RuleSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RuleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RuleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RuleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RuleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecPublishConnectionDetailsToConfigRefPolicy(obj: RuleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleSpecForProviderResolverEndpointIdRefPolicyResolution
 */
export enum RuleSpecForProviderResolverEndpointIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleSpecForProviderResolverEndpointIdRefPolicyResolve
 */
export enum RuleSpecForProviderResolverEndpointIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleSpecForProviderResolverEndpointIdSelectorPolicyResolution
 */
export enum RuleSpecForProviderResolverEndpointIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleSpecForProviderResolverEndpointIdSelectorPolicyResolve
 */
export enum RuleSpecForProviderResolverEndpointIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RuleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RuleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RuleAssociation is the Schema for the RuleAssociations API. Provides a Route53 Resolver rule association.
 *
 * @schema RuleAssociation
 */
export class RuleAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RuleAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53resolver.aws.upbound.io/v1beta1',
    kind: 'RuleAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "RuleAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RuleAssociationProps): any {
    return {
      ...RuleAssociation.GVK,
      ...toJson_RuleAssociationProps(props),
    };
  }

  /**
   * Defines a "RuleAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RuleAssociationProps) {
    super(scope, id, {
      ...RuleAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RuleAssociation.GVK,
      ...toJson_RuleAssociationProps(resolved),
    };
  }
}

/**
 * RuleAssociation is the Schema for the RuleAssociations API. Provides a Route53 Resolver rule association.
 *
 * @schema RuleAssociation
 */
export interface RuleAssociationProps {
  /**
   * @schema RuleAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RuleAssociationSpec defines the desired state of RuleAssociation
   *
   * @schema RuleAssociation#spec
   */
  readonly spec: RuleAssociationSpec;

}

/**
 * Converts an object of type 'RuleAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationProps(obj: RuleAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RuleAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RuleAssociationSpec defines the desired state of RuleAssociation
 *
 * @schema RuleAssociationSpec
 */
export interface RuleAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RuleAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: RuleAssociationSpecDeletionPolicy;

  /**
   * @schema RuleAssociationSpec#forProvider
   */
  readonly forProvider: RuleAssociationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RuleAssociationSpec#managementPolicy
   */
  readonly managementPolicy?: RuleAssociationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RuleAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: RuleAssociationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RuleAssociationSpec#providerRef
   */
  readonly providerRef?: RuleAssociationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RuleAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RuleAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RuleAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RuleAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RuleAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpec(obj: RuleAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RuleAssociationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RuleAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RuleAssociationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RuleAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RuleAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RuleAssociationSpecDeletionPolicy
 */
export enum RuleAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RuleAssociationSpecForProvider
 */
export interface RuleAssociationSpecForProvider {
  /**
   * A name for the association that you're creating between a resolver rule and a VPC.
   *
   * @schema RuleAssociationSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RuleAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ID of the resolver rule that you want to associate with the VPC.
   *
   * @schema RuleAssociationSpecForProvider#resolverRuleId
   */
  readonly resolverRuleId?: string;

  /**
   * Reference to a Rule in route53resolver to populate resolverRuleId.
   *
   * @schema RuleAssociationSpecForProvider#resolverRuleIdRef
   */
  readonly resolverRuleIdRef?: RuleAssociationSpecForProviderResolverRuleIdRef;

  /**
   * Selector for a Rule in route53resolver to populate resolverRuleId.
   *
   * @schema RuleAssociationSpecForProvider#resolverRuleIdSelector
   */
  readonly resolverRuleIdSelector?: RuleAssociationSpecForProviderResolverRuleIdSelector;

  /**
   * The ID of the VPC that you want to associate the resolver rule with.
   *
   * @schema RuleAssociationSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema RuleAssociationSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: RuleAssociationSpecForProviderVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema RuleAssociationSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: RuleAssociationSpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'RuleAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecForProvider(obj: RuleAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'region': obj.region,
    'resolverRuleId': obj.resolverRuleId,
    'resolverRuleIdRef': toJson_RuleAssociationSpecForProviderResolverRuleIdRef(obj.resolverRuleIdRef),
    'resolverRuleIdSelector': toJson_RuleAssociationSpecForProviderResolverRuleIdSelector(obj.resolverRuleIdSelector),
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_RuleAssociationSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_RuleAssociationSpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RuleAssociationSpecManagementPolicy
 */
export enum RuleAssociationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RuleAssociationSpecProviderConfigRef
 */
export interface RuleAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: RuleAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecProviderConfigRef(obj: RuleAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RuleAssociationSpecProviderRef
 */
export interface RuleAssociationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleAssociationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleAssociationSpecProviderRef#policy
   */
  readonly policy?: RuleAssociationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RuleAssociationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecProviderRef(obj: RuleAssociationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleAssociationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RuleAssociationSpecPublishConnectionDetailsTo
 */
export interface RuleAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RuleAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RuleAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RuleAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RuleAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RuleAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RuleAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecPublishConnectionDetailsTo(obj: RuleAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RuleAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RuleAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RuleAssociationSpecWriteConnectionSecretToRef
 */
export interface RuleAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RuleAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RuleAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RuleAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecWriteConnectionSecretToRef(obj: RuleAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Rule in route53resolver to populate resolverRuleId.
 *
 * @schema RuleAssociationSpecForProviderResolverRuleIdRef
 */
export interface RuleAssociationSpecForProviderResolverRuleIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleAssociationSpecForProviderResolverRuleIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleAssociationSpecForProviderResolverRuleIdRef#policy
   */
  readonly policy?: RuleAssociationSpecForProviderResolverRuleIdRefPolicy;

}

/**
 * Converts an object of type 'RuleAssociationSpecForProviderResolverRuleIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecForProviderResolverRuleIdRef(obj: RuleAssociationSpecForProviderResolverRuleIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleAssociationSpecForProviderResolverRuleIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Rule in route53resolver to populate resolverRuleId.
 *
 * @schema RuleAssociationSpecForProviderResolverRuleIdSelector
 */
export interface RuleAssociationSpecForProviderResolverRuleIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RuleAssociationSpecForProviderResolverRuleIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RuleAssociationSpecForProviderResolverRuleIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RuleAssociationSpecForProviderResolverRuleIdSelector#policy
   */
  readonly policy?: RuleAssociationSpecForProviderResolverRuleIdSelectorPolicy;

}

/**
 * Converts an object of type 'RuleAssociationSpecForProviderResolverRuleIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecForProviderResolverRuleIdSelector(obj: RuleAssociationSpecForProviderResolverRuleIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RuleAssociationSpecForProviderResolverRuleIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema RuleAssociationSpecForProviderVpcIdRef
 */
export interface RuleAssociationSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleAssociationSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleAssociationSpecForProviderVpcIdRef#policy
   */
  readonly policy?: RuleAssociationSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'RuleAssociationSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecForProviderVpcIdRef(obj: RuleAssociationSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleAssociationSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema RuleAssociationSpecForProviderVpcIdSelector
 */
export interface RuleAssociationSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RuleAssociationSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RuleAssociationSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RuleAssociationSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: RuleAssociationSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'RuleAssociationSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecForProviderVpcIdSelector(obj: RuleAssociationSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RuleAssociationSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleAssociationSpecProviderConfigRefPolicy
 */
export interface RuleAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RuleAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RuleAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecProviderConfigRefPolicy(obj: RuleAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleAssociationSpecProviderRefPolicy
 */
export interface RuleAssociationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleAssociationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RuleAssociationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleAssociationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RuleAssociationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleAssociationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecProviderRefPolicy(obj: RuleAssociationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RuleAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface RuleAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecPublishConnectionDetailsToConfigRef(obj: RuleAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RuleAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface RuleAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RuleAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuleAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecPublishConnectionDetailsToMetadata(obj: RuleAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleAssociationSpecForProviderResolverRuleIdRefPolicy
 */
export interface RuleAssociationSpecForProviderResolverRuleIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleAssociationSpecForProviderResolverRuleIdRefPolicy#resolution
   */
  readonly resolution?: RuleAssociationSpecForProviderResolverRuleIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleAssociationSpecForProviderResolverRuleIdRefPolicy#resolve
   */
  readonly resolve?: RuleAssociationSpecForProviderResolverRuleIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleAssociationSpecForProviderResolverRuleIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecForProviderResolverRuleIdRefPolicy(obj: RuleAssociationSpecForProviderResolverRuleIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RuleAssociationSpecForProviderResolverRuleIdSelectorPolicy
 */
export interface RuleAssociationSpecForProviderResolverRuleIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleAssociationSpecForProviderResolverRuleIdSelectorPolicy#resolution
   */
  readonly resolution?: RuleAssociationSpecForProviderResolverRuleIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleAssociationSpecForProviderResolverRuleIdSelectorPolicy#resolve
   */
  readonly resolve?: RuleAssociationSpecForProviderResolverRuleIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RuleAssociationSpecForProviderResolverRuleIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecForProviderResolverRuleIdSelectorPolicy(obj: RuleAssociationSpecForProviderResolverRuleIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleAssociationSpecForProviderVpcIdRefPolicy
 */
export interface RuleAssociationSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleAssociationSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: RuleAssociationSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleAssociationSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: RuleAssociationSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleAssociationSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecForProviderVpcIdRefPolicy(obj: RuleAssociationSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RuleAssociationSpecForProviderVpcIdSelectorPolicy
 */
export interface RuleAssociationSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleAssociationSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: RuleAssociationSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleAssociationSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: RuleAssociationSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RuleAssociationSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecForProviderVpcIdSelectorPolicy(obj: RuleAssociationSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleAssociationSpecProviderConfigRefPolicyResolution
 */
export enum RuleAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleAssociationSpecProviderConfigRefPolicyResolve
 */
export enum RuleAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleAssociationSpecProviderRefPolicyResolution
 */
export enum RuleAssociationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleAssociationSpecProviderRefPolicyResolve
 */
export enum RuleAssociationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RuleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RuleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: RuleAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleAssociationSpecForProviderResolverRuleIdRefPolicyResolution
 */
export enum RuleAssociationSpecForProviderResolverRuleIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleAssociationSpecForProviderResolverRuleIdRefPolicyResolve
 */
export enum RuleAssociationSpecForProviderResolverRuleIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleAssociationSpecForProviderResolverRuleIdSelectorPolicyResolution
 */
export enum RuleAssociationSpecForProviderResolverRuleIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleAssociationSpecForProviderResolverRuleIdSelectorPolicyResolve
 */
export enum RuleAssociationSpecForProviderResolverRuleIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleAssociationSpecForProviderVpcIdRefPolicyResolution
 */
export enum RuleAssociationSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleAssociationSpecForProviderVpcIdRefPolicyResolve
 */
export enum RuleAssociationSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleAssociationSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum RuleAssociationSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleAssociationSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum RuleAssociationSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RuleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RuleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

