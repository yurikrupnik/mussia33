// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Cluster is the Schema for the Clusters API. Provides an AWS Route 53 Recovery Control Config Cluster
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53recoverycontrolconfig.aws.upbound.io/v1beta1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * Cluster is the Schema for the Clusters API. Provides an AWS Route 53 Recovery Control Config Cluster
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSpec defines the desired state of Cluster
   *
   * @schema Cluster#spec
   */
  readonly spec: ClusterSpec;

}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSpec defines the desired state of Cluster
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSpecDeletionPolicy;

  /**
   * @schema ClusterSpec#forProvider
   */
  readonly forProvider: ClusterSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ClusterSpec#providerRef
   */
  readonly providerRef?: ClusterSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ClusterSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ClusterSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ClusterSpecDeletionPolicy
 */
export enum ClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterSpecForProvider
 */
export interface ClusterSpecForProvider {
  /**
   * Unique name describing the cluster.
   *
   * @schema ClusterSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region of the endpoint. Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProvider(obj: ClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterSpecProviderConfigRef
 */
export interface ClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRef(obj: ClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ClusterSpecProviderRef
 */
export interface ClusterSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderRef#policy
   */
  readonly policy?: ClusterSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderRef(obj: ClusterSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterSpecPublishConnectionDetailsTo
 */
export interface ClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsTo(obj: ClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterSpecWriteConnectionSecretToRef
 */
export interface ClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWriteConnectionSecretToRef(obj: ClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderConfigRefPolicy
 */
export interface ClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRefPolicy(obj: ClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderRefPolicy
 */
export interface ClusterSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderRefPolicy(obj: ClusterSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj: ClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj: ClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderRefPolicyResolution
 */
export enum ClusterSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderRefPolicyResolve
 */
export enum ClusterSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ControlPanel is the Schema for the ControlPanels API. Provides an AWS Route 53 Recovery Control Config Control Panel
 *
 * @schema ControlPanel
 */
export class ControlPanel extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ControlPanel"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53recoverycontrolconfig.aws.upbound.io/v1beta1',
    kind: 'ControlPanel',
  }

  /**
   * Renders a Kubernetes manifest for "ControlPanel".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ControlPanelProps): any {
    return {
      ...ControlPanel.GVK,
      ...toJson_ControlPanelProps(props),
    };
  }

  /**
   * Defines a "ControlPanel" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ControlPanelProps) {
    super(scope, id, {
      ...ControlPanel.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ControlPanel.GVK,
      ...toJson_ControlPanelProps(resolved),
    };
  }
}

/**
 * ControlPanel is the Schema for the ControlPanels API. Provides an AWS Route 53 Recovery Control Config Control Panel
 *
 * @schema ControlPanel
 */
export interface ControlPanelProps {
  /**
   * @schema ControlPanel#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ControlPanelSpec defines the desired state of ControlPanel
   *
   * @schema ControlPanel#spec
   */
  readonly spec: ControlPanelSpec;

}

/**
 * Converts an object of type 'ControlPanelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ControlPanelProps(obj: ControlPanelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ControlPanelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ControlPanelSpec defines the desired state of ControlPanel
 *
 * @schema ControlPanelSpec
 */
export interface ControlPanelSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ControlPanelSpec#deletionPolicy
   */
  readonly deletionPolicy?: ControlPanelSpecDeletionPolicy;

  /**
   * @schema ControlPanelSpec#forProvider
   */
  readonly forProvider: ControlPanelSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ControlPanelSpec#providerConfigRef
   */
  readonly providerConfigRef?: ControlPanelSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ControlPanelSpec#providerRef
   */
  readonly providerRef?: ControlPanelSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ControlPanelSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ControlPanelSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ControlPanelSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ControlPanelSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ControlPanelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ControlPanelSpec(obj: ControlPanelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ControlPanelSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ControlPanelSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ControlPanelSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ControlPanelSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ControlPanelSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ControlPanelSpecDeletionPolicy
 */
export enum ControlPanelSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ControlPanelSpecForProvider
 */
export interface ControlPanelSpecForProvider {
  /**
   * ARN of the cluster in which this control panel will reside.
   *
   * @schema ControlPanelSpecForProvider#clusterArn
   */
  readonly clusterArn?: string;

  /**
   * Reference to a Cluster in route53recoverycontrolconfig to populate clusterArn.
   *
   * @schema ControlPanelSpecForProvider#clusterArnRef
   */
  readonly clusterArnRef?: ControlPanelSpecForProviderClusterArnRef;

  /**
   * Selector for a Cluster in route53recoverycontrolconfig to populate clusterArn.
   *
   * @schema ControlPanelSpecForProvider#clusterArnSelector
   */
  readonly clusterArnSelector?: ControlPanelSpecForProviderClusterArnSelector;

  /**
   * Name describing the control panel.
   *
   * @schema ControlPanelSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ControlPanelSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ControlPanelSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ControlPanelSpecForProvider(obj: ControlPanelSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterArn': obj.clusterArn,
    'clusterArnRef': toJson_ControlPanelSpecForProviderClusterArnRef(obj.clusterArnRef),
    'clusterArnSelector': toJson_ControlPanelSpecForProviderClusterArnSelector(obj.clusterArnSelector),
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ControlPanelSpecProviderConfigRef
 */
export interface ControlPanelSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ControlPanelSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ControlPanelSpecProviderConfigRef#policy
   */
  readonly policy?: ControlPanelSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ControlPanelSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ControlPanelSpecProviderConfigRef(obj: ControlPanelSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ControlPanelSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ControlPanelSpecProviderRef
 */
export interface ControlPanelSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ControlPanelSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ControlPanelSpecProviderRef#policy
   */
  readonly policy?: ControlPanelSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ControlPanelSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ControlPanelSpecProviderRef(obj: ControlPanelSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ControlPanelSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ControlPanelSpecPublishConnectionDetailsTo
 */
export interface ControlPanelSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ControlPanelSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ControlPanelSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ControlPanelSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ControlPanelSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ControlPanelSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ControlPanelSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ControlPanelSpecPublishConnectionDetailsTo(obj: ControlPanelSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ControlPanelSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ControlPanelSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ControlPanelSpecWriteConnectionSecretToRef
 */
export interface ControlPanelSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ControlPanelSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ControlPanelSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ControlPanelSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ControlPanelSpecWriteConnectionSecretToRef(obj: ControlPanelSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in route53recoverycontrolconfig to populate clusterArn.
 *
 * @schema ControlPanelSpecForProviderClusterArnRef
 */
export interface ControlPanelSpecForProviderClusterArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ControlPanelSpecForProviderClusterArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ControlPanelSpecForProviderClusterArnRef#policy
   */
  readonly policy?: ControlPanelSpecForProviderClusterArnRefPolicy;

}

/**
 * Converts an object of type 'ControlPanelSpecForProviderClusterArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ControlPanelSpecForProviderClusterArnRef(obj: ControlPanelSpecForProviderClusterArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ControlPanelSpecForProviderClusterArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in route53recoverycontrolconfig to populate clusterArn.
 *
 * @schema ControlPanelSpecForProviderClusterArnSelector
 */
export interface ControlPanelSpecForProviderClusterArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ControlPanelSpecForProviderClusterArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ControlPanelSpecForProviderClusterArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ControlPanelSpecForProviderClusterArnSelector#policy
   */
  readonly policy?: ControlPanelSpecForProviderClusterArnSelectorPolicy;

}

/**
 * Converts an object of type 'ControlPanelSpecForProviderClusterArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ControlPanelSpecForProviderClusterArnSelector(obj: ControlPanelSpecForProviderClusterArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ControlPanelSpecForProviderClusterArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ControlPanelSpecProviderConfigRefPolicy
 */
export interface ControlPanelSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ControlPanelSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ControlPanelSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ControlPanelSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ControlPanelSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ControlPanelSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ControlPanelSpecProviderConfigRefPolicy(obj: ControlPanelSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ControlPanelSpecProviderRefPolicy
 */
export interface ControlPanelSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ControlPanelSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ControlPanelSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ControlPanelSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ControlPanelSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ControlPanelSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ControlPanelSpecProviderRefPolicy(obj: ControlPanelSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ControlPanelSpecPublishConnectionDetailsToConfigRef
 */
export interface ControlPanelSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ControlPanelSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ControlPanelSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ControlPanelSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ControlPanelSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ControlPanelSpecPublishConnectionDetailsToConfigRef(obj: ControlPanelSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ControlPanelSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ControlPanelSpecPublishConnectionDetailsToMetadata
 */
export interface ControlPanelSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ControlPanelSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ControlPanelSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ControlPanelSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ControlPanelSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ControlPanelSpecPublishConnectionDetailsToMetadata(obj: ControlPanelSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ControlPanelSpecForProviderClusterArnRefPolicy
 */
export interface ControlPanelSpecForProviderClusterArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ControlPanelSpecForProviderClusterArnRefPolicy#resolution
   */
  readonly resolution?: ControlPanelSpecForProviderClusterArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ControlPanelSpecForProviderClusterArnRefPolicy#resolve
   */
  readonly resolve?: ControlPanelSpecForProviderClusterArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ControlPanelSpecForProviderClusterArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ControlPanelSpecForProviderClusterArnRefPolicy(obj: ControlPanelSpecForProviderClusterArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ControlPanelSpecForProviderClusterArnSelectorPolicy
 */
export interface ControlPanelSpecForProviderClusterArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ControlPanelSpecForProviderClusterArnSelectorPolicy#resolution
   */
  readonly resolution?: ControlPanelSpecForProviderClusterArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ControlPanelSpecForProviderClusterArnSelectorPolicy#resolve
   */
  readonly resolve?: ControlPanelSpecForProviderClusterArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ControlPanelSpecForProviderClusterArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ControlPanelSpecForProviderClusterArnSelectorPolicy(obj: ControlPanelSpecForProviderClusterArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ControlPanelSpecProviderConfigRefPolicyResolution
 */
export enum ControlPanelSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ControlPanelSpecProviderConfigRefPolicyResolve
 */
export enum ControlPanelSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ControlPanelSpecProviderRefPolicyResolution
 */
export enum ControlPanelSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ControlPanelSpecProviderRefPolicyResolve
 */
export enum ControlPanelSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ControlPanelSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ControlPanelSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ControlPanelSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ControlPanelSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ControlPanelSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ControlPanelSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ControlPanelSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ControlPanelSpecPublishConnectionDetailsToConfigRefPolicy(obj: ControlPanelSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ControlPanelSpecForProviderClusterArnRefPolicyResolution
 */
export enum ControlPanelSpecForProviderClusterArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ControlPanelSpecForProviderClusterArnRefPolicyResolve
 */
export enum ControlPanelSpecForProviderClusterArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ControlPanelSpecForProviderClusterArnSelectorPolicyResolution
 */
export enum ControlPanelSpecForProviderClusterArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ControlPanelSpecForProviderClusterArnSelectorPolicyResolve
 */
export enum ControlPanelSpecForProviderClusterArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ControlPanelSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ControlPanelSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ControlPanelSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ControlPanelSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RoutingControl is the Schema for the RoutingControls API. Provides an AWS Route 53 Recovery Control Config Routing Control
 *
 * @schema RoutingControl
 */
export class RoutingControl extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RoutingControl"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53recoverycontrolconfig.aws.upbound.io/v1beta1',
    kind: 'RoutingControl',
  }

  /**
   * Renders a Kubernetes manifest for "RoutingControl".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RoutingControlProps): any {
    return {
      ...RoutingControl.GVK,
      ...toJson_RoutingControlProps(props),
    };
  }

  /**
   * Defines a "RoutingControl" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RoutingControlProps) {
    super(scope, id, {
      ...RoutingControl.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RoutingControl.GVK,
      ...toJson_RoutingControlProps(resolved),
    };
  }
}

/**
 * RoutingControl is the Schema for the RoutingControls API. Provides an AWS Route 53 Recovery Control Config Routing Control
 *
 * @schema RoutingControl
 */
export interface RoutingControlProps {
  /**
   * @schema RoutingControl#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RoutingControlSpec defines the desired state of RoutingControl
   *
   * @schema RoutingControl#spec
   */
  readonly spec: RoutingControlSpec;

}

/**
 * Converts an object of type 'RoutingControlProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlProps(obj: RoutingControlProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RoutingControlSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoutingControlSpec defines the desired state of RoutingControl
 *
 * @schema RoutingControlSpec
 */
export interface RoutingControlSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema RoutingControlSpec#deletionPolicy
   */
  readonly deletionPolicy?: RoutingControlSpecDeletionPolicy;

  /**
   * @schema RoutingControlSpec#forProvider
   */
  readonly forProvider: RoutingControlSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RoutingControlSpec#providerConfigRef
   */
  readonly providerConfigRef?: RoutingControlSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RoutingControlSpec#providerRef
   */
  readonly providerRef?: RoutingControlSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RoutingControlSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RoutingControlSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RoutingControlSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RoutingControlSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RoutingControlSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpec(obj: RoutingControlSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RoutingControlSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_RoutingControlSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RoutingControlSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RoutingControlSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RoutingControlSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema RoutingControlSpecDeletionPolicy
 */
export enum RoutingControlSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RoutingControlSpecForProvider
 */
export interface RoutingControlSpecForProvider {
  /**
   * ARN of the cluster in which this routing control will reside.
   *
   * @schema RoutingControlSpecForProvider#clusterArn
   */
  readonly clusterArn?: string;

  /**
   * Reference to a Cluster in route53recoverycontrolconfig to populate clusterArn.
   *
   * @schema RoutingControlSpecForProvider#clusterArnRef
   */
  readonly clusterArnRef?: RoutingControlSpecForProviderClusterArnRef;

  /**
   * Selector for a Cluster in route53recoverycontrolconfig to populate clusterArn.
   *
   * @schema RoutingControlSpecForProvider#clusterArnSelector
   */
  readonly clusterArnSelector?: RoutingControlSpecForProviderClusterArnSelector;

  /**
   * ARN of the control panel in which this routing control will reside.
   *
   * @schema RoutingControlSpecForProvider#controlPanelArn
   */
  readonly controlPanelArn?: string;

  /**
   * Reference to a ControlPanel in route53recoverycontrolconfig to populate controlPanelArn.
   *
   * @schema RoutingControlSpecForProvider#controlPanelArnRef
   */
  readonly controlPanelArnRef?: RoutingControlSpecForProviderControlPanelArnRef;

  /**
   * Selector for a ControlPanel in route53recoverycontrolconfig to populate controlPanelArn.
   *
   * @schema RoutingControlSpecForProvider#controlPanelArnSelector
   */
  readonly controlPanelArnSelector?: RoutingControlSpecForProviderControlPanelArnSelector;

  /**
   * The name describing the routing control.
   *
   * @schema RoutingControlSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RoutingControlSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'RoutingControlSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecForProvider(obj: RoutingControlSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterArn': obj.clusterArn,
    'clusterArnRef': toJson_RoutingControlSpecForProviderClusterArnRef(obj.clusterArnRef),
    'clusterArnSelector': toJson_RoutingControlSpecForProviderClusterArnSelector(obj.clusterArnSelector),
    'controlPanelArn': obj.controlPanelArn,
    'controlPanelArnRef': toJson_RoutingControlSpecForProviderControlPanelArnRef(obj.controlPanelArnRef),
    'controlPanelArnSelector': toJson_RoutingControlSpecForProviderControlPanelArnSelector(obj.controlPanelArnSelector),
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RoutingControlSpecProviderConfigRef
 */
export interface RoutingControlSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoutingControlSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoutingControlSpecProviderConfigRef#policy
   */
  readonly policy?: RoutingControlSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RoutingControlSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecProviderConfigRef(obj: RoutingControlSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoutingControlSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RoutingControlSpecProviderRef
 */
export interface RoutingControlSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoutingControlSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoutingControlSpecProviderRef#policy
   */
  readonly policy?: RoutingControlSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RoutingControlSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecProviderRef(obj: RoutingControlSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoutingControlSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RoutingControlSpecPublishConnectionDetailsTo
 */
export interface RoutingControlSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RoutingControlSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RoutingControlSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RoutingControlSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RoutingControlSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RoutingControlSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RoutingControlSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecPublishConnectionDetailsTo(obj: RoutingControlSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RoutingControlSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RoutingControlSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RoutingControlSpecWriteConnectionSecretToRef
 */
export interface RoutingControlSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RoutingControlSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RoutingControlSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RoutingControlSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecWriteConnectionSecretToRef(obj: RoutingControlSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in route53recoverycontrolconfig to populate clusterArn.
 *
 * @schema RoutingControlSpecForProviderClusterArnRef
 */
export interface RoutingControlSpecForProviderClusterArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoutingControlSpecForProviderClusterArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoutingControlSpecForProviderClusterArnRef#policy
   */
  readonly policy?: RoutingControlSpecForProviderClusterArnRefPolicy;

}

/**
 * Converts an object of type 'RoutingControlSpecForProviderClusterArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecForProviderClusterArnRef(obj: RoutingControlSpecForProviderClusterArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoutingControlSpecForProviderClusterArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in route53recoverycontrolconfig to populate clusterArn.
 *
 * @schema RoutingControlSpecForProviderClusterArnSelector
 */
export interface RoutingControlSpecForProviderClusterArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RoutingControlSpecForProviderClusterArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RoutingControlSpecForProviderClusterArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RoutingControlSpecForProviderClusterArnSelector#policy
   */
  readonly policy?: RoutingControlSpecForProviderClusterArnSelectorPolicy;

}

/**
 * Converts an object of type 'RoutingControlSpecForProviderClusterArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecForProviderClusterArnSelector(obj: RoutingControlSpecForProviderClusterArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RoutingControlSpecForProviderClusterArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ControlPanel in route53recoverycontrolconfig to populate controlPanelArn.
 *
 * @schema RoutingControlSpecForProviderControlPanelArnRef
 */
export interface RoutingControlSpecForProviderControlPanelArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoutingControlSpecForProviderControlPanelArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoutingControlSpecForProviderControlPanelArnRef#policy
   */
  readonly policy?: RoutingControlSpecForProviderControlPanelArnRefPolicy;

}

/**
 * Converts an object of type 'RoutingControlSpecForProviderControlPanelArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecForProviderControlPanelArnRef(obj: RoutingControlSpecForProviderControlPanelArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoutingControlSpecForProviderControlPanelArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ControlPanel in route53recoverycontrolconfig to populate controlPanelArn.
 *
 * @schema RoutingControlSpecForProviderControlPanelArnSelector
 */
export interface RoutingControlSpecForProviderControlPanelArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RoutingControlSpecForProviderControlPanelArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RoutingControlSpecForProviderControlPanelArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RoutingControlSpecForProviderControlPanelArnSelector#policy
   */
  readonly policy?: RoutingControlSpecForProviderControlPanelArnSelectorPolicy;

}

/**
 * Converts an object of type 'RoutingControlSpecForProviderControlPanelArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecForProviderControlPanelArnSelector(obj: RoutingControlSpecForProviderControlPanelArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RoutingControlSpecForProviderControlPanelArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RoutingControlSpecProviderConfigRefPolicy
 */
export interface RoutingControlSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutingControlSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RoutingControlSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutingControlSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RoutingControlSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RoutingControlSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecProviderConfigRefPolicy(obj: RoutingControlSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RoutingControlSpecProviderRefPolicy
 */
export interface RoutingControlSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutingControlSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RoutingControlSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutingControlSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RoutingControlSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RoutingControlSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecProviderRefPolicy(obj: RoutingControlSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RoutingControlSpecPublishConnectionDetailsToConfigRef
 */
export interface RoutingControlSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoutingControlSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoutingControlSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RoutingControlSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RoutingControlSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecPublishConnectionDetailsToConfigRef(obj: RoutingControlSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoutingControlSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RoutingControlSpecPublishConnectionDetailsToMetadata
 */
export interface RoutingControlSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RoutingControlSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RoutingControlSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RoutingControlSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RoutingControlSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecPublishConnectionDetailsToMetadata(obj: RoutingControlSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RoutingControlSpecForProviderClusterArnRefPolicy
 */
export interface RoutingControlSpecForProviderClusterArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutingControlSpecForProviderClusterArnRefPolicy#resolution
   */
  readonly resolution?: RoutingControlSpecForProviderClusterArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutingControlSpecForProviderClusterArnRefPolicy#resolve
   */
  readonly resolve?: RoutingControlSpecForProviderClusterArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RoutingControlSpecForProviderClusterArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecForProviderClusterArnRefPolicy(obj: RoutingControlSpecForProviderClusterArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RoutingControlSpecForProviderClusterArnSelectorPolicy
 */
export interface RoutingControlSpecForProviderClusterArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutingControlSpecForProviderClusterArnSelectorPolicy#resolution
   */
  readonly resolution?: RoutingControlSpecForProviderClusterArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutingControlSpecForProviderClusterArnSelectorPolicy#resolve
   */
  readonly resolve?: RoutingControlSpecForProviderClusterArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RoutingControlSpecForProviderClusterArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecForProviderClusterArnSelectorPolicy(obj: RoutingControlSpecForProviderClusterArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RoutingControlSpecForProviderControlPanelArnRefPolicy
 */
export interface RoutingControlSpecForProviderControlPanelArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutingControlSpecForProviderControlPanelArnRefPolicy#resolution
   */
  readonly resolution?: RoutingControlSpecForProviderControlPanelArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutingControlSpecForProviderControlPanelArnRefPolicy#resolve
   */
  readonly resolve?: RoutingControlSpecForProviderControlPanelArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RoutingControlSpecForProviderControlPanelArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecForProviderControlPanelArnRefPolicy(obj: RoutingControlSpecForProviderControlPanelArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RoutingControlSpecForProviderControlPanelArnSelectorPolicy
 */
export interface RoutingControlSpecForProviderControlPanelArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutingControlSpecForProviderControlPanelArnSelectorPolicy#resolution
   */
  readonly resolution?: RoutingControlSpecForProviderControlPanelArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutingControlSpecForProviderControlPanelArnSelectorPolicy#resolve
   */
  readonly resolve?: RoutingControlSpecForProviderControlPanelArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RoutingControlSpecForProviderControlPanelArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecForProviderControlPanelArnSelectorPolicy(obj: RoutingControlSpecForProviderControlPanelArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutingControlSpecProviderConfigRefPolicyResolution
 */
export enum RoutingControlSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutingControlSpecProviderConfigRefPolicyResolve
 */
export enum RoutingControlSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutingControlSpecProviderRefPolicyResolution
 */
export enum RoutingControlSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutingControlSpecProviderRefPolicyResolve
 */
export enum RoutingControlSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RoutingControlSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RoutingControlSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutingControlSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RoutingControlSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutingControlSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RoutingControlSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RoutingControlSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingControlSpecPublishConnectionDetailsToConfigRefPolicy(obj: RoutingControlSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutingControlSpecForProviderClusterArnRefPolicyResolution
 */
export enum RoutingControlSpecForProviderClusterArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutingControlSpecForProviderClusterArnRefPolicyResolve
 */
export enum RoutingControlSpecForProviderClusterArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutingControlSpecForProviderClusterArnSelectorPolicyResolution
 */
export enum RoutingControlSpecForProviderClusterArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutingControlSpecForProviderClusterArnSelectorPolicyResolve
 */
export enum RoutingControlSpecForProviderClusterArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutingControlSpecForProviderControlPanelArnRefPolicyResolution
 */
export enum RoutingControlSpecForProviderControlPanelArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutingControlSpecForProviderControlPanelArnRefPolicyResolve
 */
export enum RoutingControlSpecForProviderControlPanelArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutingControlSpecForProviderControlPanelArnSelectorPolicyResolution
 */
export enum RoutingControlSpecForProviderControlPanelArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutingControlSpecForProviderControlPanelArnSelectorPolicyResolve
 */
export enum RoutingControlSpecForProviderControlPanelArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutingControlSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RoutingControlSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutingControlSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RoutingControlSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SafetyRule is the Schema for the SafetyRules API. Provides an AWS Route 53 Recovery Control Config Safety Rule
 *
 * @schema SafetyRule
 */
export class SafetyRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SafetyRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53recoverycontrolconfig.aws.upbound.io/v1beta1',
    kind: 'SafetyRule',
  }

  /**
   * Renders a Kubernetes manifest for "SafetyRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SafetyRuleProps): any {
    return {
      ...SafetyRule.GVK,
      ...toJson_SafetyRuleProps(props),
    };
  }

  /**
   * Defines a "SafetyRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SafetyRuleProps) {
    super(scope, id, {
      ...SafetyRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SafetyRule.GVK,
      ...toJson_SafetyRuleProps(resolved),
    };
  }
}

/**
 * SafetyRule is the Schema for the SafetyRules API. Provides an AWS Route 53 Recovery Control Config Safety Rule
 *
 * @schema SafetyRule
 */
export interface SafetyRuleProps {
  /**
   * @schema SafetyRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SafetyRuleSpec defines the desired state of SafetyRule
   *
   * @schema SafetyRule#spec
   */
  readonly spec: SafetyRuleSpec;

}

/**
 * Converts an object of type 'SafetyRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleProps(obj: SafetyRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SafetyRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SafetyRuleSpec defines the desired state of SafetyRule
 *
 * @schema SafetyRuleSpec
 */
export interface SafetyRuleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema SafetyRuleSpec#deletionPolicy
   */
  readonly deletionPolicy?: SafetyRuleSpecDeletionPolicy;

  /**
   * @schema SafetyRuleSpec#forProvider
   */
  readonly forProvider: SafetyRuleSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SafetyRuleSpec#providerConfigRef
   */
  readonly providerConfigRef?: SafetyRuleSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SafetyRuleSpec#providerRef
   */
  readonly providerRef?: SafetyRuleSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SafetyRuleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SafetyRuleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SafetyRuleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SafetyRuleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SafetyRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpec(obj: SafetyRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SafetyRuleSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_SafetyRuleSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SafetyRuleSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SafetyRuleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SafetyRuleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema SafetyRuleSpecDeletionPolicy
 */
export enum SafetyRuleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SafetyRuleSpecForProvider
 */
export interface SafetyRuleSpecForProvider {
  /**
   * Routing controls that are part of transactions that are evaluated to determine if a request to change a routing control state is allowed.
   *
   * @schema SafetyRuleSpecForProvider#assertedControls
   */
  readonly assertedControls?: string[];

  /**
   * References to RoutingControl in route53recoverycontrolconfig to populate assertedControls.
   *
   * @schema SafetyRuleSpecForProvider#assertedControlsRefs
   */
  readonly assertedControlsRefs?: SafetyRuleSpecForProviderAssertedControlsRefs[];

  /**
   * Selector for a list of RoutingControl in route53recoverycontrolconfig to populate assertedControls.
   *
   * @schema SafetyRuleSpecForProvider#assertedControlsSelector
   */
  readonly assertedControlsSelector?: SafetyRuleSpecForProviderAssertedControlsSelector;

  /**
   * ARN of the control panel in which this safety rule will reside.
   *
   * @schema SafetyRuleSpecForProvider#controlPanelArn
   */
  readonly controlPanelArn?: string;

  /**
   * Reference to a ControlPanel in route53recoverycontrolconfig to populate controlPanelArn.
   *
   * @schema SafetyRuleSpecForProvider#controlPanelArnRef
   */
  readonly controlPanelArnRef?: SafetyRuleSpecForProviderControlPanelArnRef;

  /**
   * Selector for a ControlPanel in route53recoverycontrolconfig to populate controlPanelArn.
   *
   * @schema SafetyRuleSpecForProvider#controlPanelArnSelector
   */
  readonly controlPanelArnSelector?: SafetyRuleSpecForProviderControlPanelArnSelector;

  /**
   * Gating controls for the new gating rule. That is, routing controls that are evaluated by the rule configuration that you specify.
   *
   * @schema SafetyRuleSpecForProvider#gatingControls
   */
  readonly gatingControls?: string[];

  /**
   * Name describing the safety rule.
   *
   * @schema SafetyRuleSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SafetyRuleSpecForProvider#region
   */
  readonly region: string;

  /**
   * Configuration block for safety rule criteria. See below.
   *
   * @schema SafetyRuleSpecForProvider#ruleConfig
   */
  readonly ruleConfig: SafetyRuleSpecForProviderRuleConfig[];

  /**
   * Routing controls that can only be set or unset if the specified rule_config evaluates to true for the specified gating_controls.
   *
   * @schema SafetyRuleSpecForProvider#targetControls
   */
  readonly targetControls?: string[];

  /**
   * Evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail.
   *
   * @schema SafetyRuleSpecForProvider#waitPeriodMs
   */
  readonly waitPeriodMs: number;

}

/**
 * Converts an object of type 'SafetyRuleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecForProvider(obj: SafetyRuleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'assertedControls': obj.assertedControls?.map(y => y),
    'assertedControlsRefs': obj.assertedControlsRefs?.map(y => toJson_SafetyRuleSpecForProviderAssertedControlsRefs(y)),
    'assertedControlsSelector': toJson_SafetyRuleSpecForProviderAssertedControlsSelector(obj.assertedControlsSelector),
    'controlPanelArn': obj.controlPanelArn,
    'controlPanelArnRef': toJson_SafetyRuleSpecForProviderControlPanelArnRef(obj.controlPanelArnRef),
    'controlPanelArnSelector': toJson_SafetyRuleSpecForProviderControlPanelArnSelector(obj.controlPanelArnSelector),
    'gatingControls': obj.gatingControls?.map(y => y),
    'name': obj.name,
    'region': obj.region,
    'ruleConfig': obj.ruleConfig?.map(y => toJson_SafetyRuleSpecForProviderRuleConfig(y)),
    'targetControls': obj.targetControls?.map(y => y),
    'waitPeriodMs': obj.waitPeriodMs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SafetyRuleSpecProviderConfigRef
 */
export interface SafetyRuleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SafetyRuleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SafetyRuleSpecProviderConfigRef#policy
   */
  readonly policy?: SafetyRuleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SafetyRuleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecProviderConfigRef(obj: SafetyRuleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SafetyRuleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SafetyRuleSpecProviderRef
 */
export interface SafetyRuleSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SafetyRuleSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SafetyRuleSpecProviderRef#policy
   */
  readonly policy?: SafetyRuleSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SafetyRuleSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecProviderRef(obj: SafetyRuleSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SafetyRuleSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SafetyRuleSpecPublishConnectionDetailsTo
 */
export interface SafetyRuleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SafetyRuleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SafetyRuleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SafetyRuleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SafetyRuleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SafetyRuleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SafetyRuleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecPublishConnectionDetailsTo(obj: SafetyRuleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SafetyRuleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SafetyRuleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SafetyRuleSpecWriteConnectionSecretToRef
 */
export interface SafetyRuleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SafetyRuleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SafetyRuleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SafetyRuleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecWriteConnectionSecretToRef(obj: SafetyRuleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema SafetyRuleSpecForProviderAssertedControlsRefs
 */
export interface SafetyRuleSpecForProviderAssertedControlsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema SafetyRuleSpecForProviderAssertedControlsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SafetyRuleSpecForProviderAssertedControlsRefs#policy
   */
  readonly policy?: SafetyRuleSpecForProviderAssertedControlsRefsPolicy;

}

/**
 * Converts an object of type 'SafetyRuleSpecForProviderAssertedControlsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecForProviderAssertedControlsRefs(obj: SafetyRuleSpecForProviderAssertedControlsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SafetyRuleSpecForProviderAssertedControlsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of RoutingControl in route53recoverycontrolconfig to populate assertedControls.
 *
 * @schema SafetyRuleSpecForProviderAssertedControlsSelector
 */
export interface SafetyRuleSpecForProviderAssertedControlsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SafetyRuleSpecForProviderAssertedControlsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SafetyRuleSpecForProviderAssertedControlsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SafetyRuleSpecForProviderAssertedControlsSelector#policy
   */
  readonly policy?: SafetyRuleSpecForProviderAssertedControlsSelectorPolicy;

}

/**
 * Converts an object of type 'SafetyRuleSpecForProviderAssertedControlsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecForProviderAssertedControlsSelector(obj: SafetyRuleSpecForProviderAssertedControlsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SafetyRuleSpecForProviderAssertedControlsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ControlPanel in route53recoverycontrolconfig to populate controlPanelArn.
 *
 * @schema SafetyRuleSpecForProviderControlPanelArnRef
 */
export interface SafetyRuleSpecForProviderControlPanelArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema SafetyRuleSpecForProviderControlPanelArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SafetyRuleSpecForProviderControlPanelArnRef#policy
   */
  readonly policy?: SafetyRuleSpecForProviderControlPanelArnRefPolicy;

}

/**
 * Converts an object of type 'SafetyRuleSpecForProviderControlPanelArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecForProviderControlPanelArnRef(obj: SafetyRuleSpecForProviderControlPanelArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SafetyRuleSpecForProviderControlPanelArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ControlPanel in route53recoverycontrolconfig to populate controlPanelArn.
 *
 * @schema SafetyRuleSpecForProviderControlPanelArnSelector
 */
export interface SafetyRuleSpecForProviderControlPanelArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SafetyRuleSpecForProviderControlPanelArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SafetyRuleSpecForProviderControlPanelArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SafetyRuleSpecForProviderControlPanelArnSelector#policy
   */
  readonly policy?: SafetyRuleSpecForProviderControlPanelArnSelectorPolicy;

}

/**
 * Converts an object of type 'SafetyRuleSpecForProviderControlPanelArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecForProviderControlPanelArnSelector(obj: SafetyRuleSpecForProviderControlPanelArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SafetyRuleSpecForProviderControlPanelArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SafetyRuleSpecForProviderRuleConfig
 */
export interface SafetyRuleSpecForProviderRuleConfig {
  /**
   * Logical negation of the rule.
   *
   * @schema SafetyRuleSpecForProviderRuleConfig#inverted
   */
  readonly inverted: boolean;

  /**
   * Number of controls that must be set when you specify an ATLEAST type rule.
   *
   * @schema SafetyRuleSpecForProviderRuleConfig#threshold
   */
  readonly threshold: number;

  /**
   * Rule type. Valid values are ATLEAST, AND, and OR.
   *
   * @schema SafetyRuleSpecForProviderRuleConfig#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'SafetyRuleSpecForProviderRuleConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecForProviderRuleConfig(obj: SafetyRuleSpecForProviderRuleConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inverted': obj.inverted,
    'threshold': obj.threshold,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SafetyRuleSpecProviderConfigRefPolicy
 */
export interface SafetyRuleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SafetyRuleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SafetyRuleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SafetyRuleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SafetyRuleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SafetyRuleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecProviderConfigRefPolicy(obj: SafetyRuleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SafetyRuleSpecProviderRefPolicy
 */
export interface SafetyRuleSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SafetyRuleSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SafetyRuleSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SafetyRuleSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SafetyRuleSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SafetyRuleSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecProviderRefPolicy(obj: SafetyRuleSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SafetyRuleSpecPublishConnectionDetailsToConfigRef
 */
export interface SafetyRuleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SafetyRuleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SafetyRuleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SafetyRuleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SafetyRuleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecPublishConnectionDetailsToConfigRef(obj: SafetyRuleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SafetyRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SafetyRuleSpecPublishConnectionDetailsToMetadata
 */
export interface SafetyRuleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SafetyRuleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SafetyRuleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SafetyRuleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SafetyRuleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecPublishConnectionDetailsToMetadata(obj: SafetyRuleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SafetyRuleSpecForProviderAssertedControlsRefsPolicy
 */
export interface SafetyRuleSpecForProviderAssertedControlsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SafetyRuleSpecForProviderAssertedControlsRefsPolicy#resolution
   */
  readonly resolution?: SafetyRuleSpecForProviderAssertedControlsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SafetyRuleSpecForProviderAssertedControlsRefsPolicy#resolve
   */
  readonly resolve?: SafetyRuleSpecForProviderAssertedControlsRefsPolicyResolve;

}

/**
 * Converts an object of type 'SafetyRuleSpecForProviderAssertedControlsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecForProviderAssertedControlsRefsPolicy(obj: SafetyRuleSpecForProviderAssertedControlsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SafetyRuleSpecForProviderAssertedControlsSelectorPolicy
 */
export interface SafetyRuleSpecForProviderAssertedControlsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SafetyRuleSpecForProviderAssertedControlsSelectorPolicy#resolution
   */
  readonly resolution?: SafetyRuleSpecForProviderAssertedControlsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SafetyRuleSpecForProviderAssertedControlsSelectorPolicy#resolve
   */
  readonly resolve?: SafetyRuleSpecForProviderAssertedControlsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SafetyRuleSpecForProviderAssertedControlsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecForProviderAssertedControlsSelectorPolicy(obj: SafetyRuleSpecForProviderAssertedControlsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SafetyRuleSpecForProviderControlPanelArnRefPolicy
 */
export interface SafetyRuleSpecForProviderControlPanelArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SafetyRuleSpecForProviderControlPanelArnRefPolicy#resolution
   */
  readonly resolution?: SafetyRuleSpecForProviderControlPanelArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SafetyRuleSpecForProviderControlPanelArnRefPolicy#resolve
   */
  readonly resolve?: SafetyRuleSpecForProviderControlPanelArnRefPolicyResolve;

}

/**
 * Converts an object of type 'SafetyRuleSpecForProviderControlPanelArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecForProviderControlPanelArnRefPolicy(obj: SafetyRuleSpecForProviderControlPanelArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SafetyRuleSpecForProviderControlPanelArnSelectorPolicy
 */
export interface SafetyRuleSpecForProviderControlPanelArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SafetyRuleSpecForProviderControlPanelArnSelectorPolicy#resolution
   */
  readonly resolution?: SafetyRuleSpecForProviderControlPanelArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SafetyRuleSpecForProviderControlPanelArnSelectorPolicy#resolve
   */
  readonly resolve?: SafetyRuleSpecForProviderControlPanelArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SafetyRuleSpecForProviderControlPanelArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecForProviderControlPanelArnSelectorPolicy(obj: SafetyRuleSpecForProviderControlPanelArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SafetyRuleSpecProviderConfigRefPolicyResolution
 */
export enum SafetyRuleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SafetyRuleSpecProviderConfigRefPolicyResolve
 */
export enum SafetyRuleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SafetyRuleSpecProviderRefPolicyResolution
 */
export enum SafetyRuleSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SafetyRuleSpecProviderRefPolicyResolve
 */
export enum SafetyRuleSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SafetyRuleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SafetyRuleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SafetyRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SafetyRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SafetyRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SafetyRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SafetyRuleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SafetyRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj: SafetyRuleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SafetyRuleSpecForProviderAssertedControlsRefsPolicyResolution
 */
export enum SafetyRuleSpecForProviderAssertedControlsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SafetyRuleSpecForProviderAssertedControlsRefsPolicyResolve
 */
export enum SafetyRuleSpecForProviderAssertedControlsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SafetyRuleSpecForProviderAssertedControlsSelectorPolicyResolution
 */
export enum SafetyRuleSpecForProviderAssertedControlsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SafetyRuleSpecForProviderAssertedControlsSelectorPolicyResolve
 */
export enum SafetyRuleSpecForProviderAssertedControlsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SafetyRuleSpecForProviderControlPanelArnRefPolicyResolution
 */
export enum SafetyRuleSpecForProviderControlPanelArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SafetyRuleSpecForProviderControlPanelArnRefPolicyResolve
 */
export enum SafetyRuleSpecForProviderControlPanelArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SafetyRuleSpecForProviderControlPanelArnSelectorPolicyResolution
 */
export enum SafetyRuleSpecForProviderControlPanelArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SafetyRuleSpecForProviderControlPanelArnSelectorPolicyResolve
 */
export enum SafetyRuleSpecForProviderControlPanelArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SafetyRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SafetyRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SafetyRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SafetyRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

