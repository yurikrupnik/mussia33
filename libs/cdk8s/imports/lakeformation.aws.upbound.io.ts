// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * DataLakeSettings is the Schema for the DataLakeSettingss API. Manages data lake administrators and default database and table permissions
 *
 * @schema DataLakeSettings
 */
export class DataLakeSettings extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DataLakeSettings"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lakeformation.aws.upbound.io/v1beta1',
    kind: 'DataLakeSettings',
  }

  /**
   * Renders a Kubernetes manifest for "DataLakeSettings".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DataLakeSettingsProps): any {
    return {
      ...DataLakeSettings.GVK,
      ...toJson_DataLakeSettingsProps(props),
    };
  }

  /**
   * Defines a "DataLakeSettings" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DataLakeSettingsProps) {
    super(scope, id, {
      ...DataLakeSettings.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DataLakeSettings.GVK,
      ...toJson_DataLakeSettingsProps(resolved),
    };
  }
}

/**
 * DataLakeSettings is the Schema for the DataLakeSettingss API. Manages data lake administrators and default database and table permissions
 *
 * @schema DataLakeSettings
 */
export interface DataLakeSettingsProps {
  /**
   * @schema DataLakeSettings#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DataLakeSettingsSpec defines the desired state of DataLakeSettings
   *
   * @schema DataLakeSettings#spec
   */
  readonly spec: DataLakeSettingsSpec;

}

/**
 * Converts an object of type 'DataLakeSettingsProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeSettingsProps(obj: DataLakeSettingsProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DataLakeSettingsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataLakeSettingsSpec defines the desired state of DataLakeSettings
 *
 * @schema DataLakeSettingsSpec
 */
export interface DataLakeSettingsSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DataLakeSettingsSpec#deletionPolicy
   */
  readonly deletionPolicy?: DataLakeSettingsSpecDeletionPolicy;

  /**
   * @schema DataLakeSettingsSpec#forProvider
   */
  readonly forProvider: DataLakeSettingsSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DataLakeSettingsSpec#initProvider
   */
  readonly initProvider?: DataLakeSettingsSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DataLakeSettingsSpec#managementPolicies
   */
  readonly managementPolicies?: DataLakeSettingsSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DataLakeSettingsSpec#providerConfigRef
   */
  readonly providerConfigRef?: DataLakeSettingsSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DataLakeSettingsSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DataLakeSettingsSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DataLakeSettingsSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DataLakeSettingsSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DataLakeSettingsSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeSettingsSpec(obj: DataLakeSettingsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DataLakeSettingsSpecForProvider(obj.forProvider),
    'initProvider': toJson_DataLakeSettingsSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DataLakeSettingsSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DataLakeSettingsSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DataLakeSettingsSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DataLakeSettingsSpecDeletionPolicy
 */
export enum DataLakeSettingsSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DataLakeSettingsSpecForProvider
 */
export interface DataLakeSettingsSpecForProvider {
  /**
   * –  Set of ARNs of AWS Lake Formation principals (IAM users or roles).
   *
   * @schema DataLakeSettingsSpecForProvider#admins
   */
  readonly admins?: string[];

  /**
   * Whether to allow Amazon EMR clusters to access data managed by Lake Formation.
   *
   * @schema DataLakeSettingsSpecForProvider#allowExternalDataFiltering
   */
  readonly allowExternalDataFiltering?: boolean;

  /**
   * Lake Formation relies on a privileged process secured by Amazon EMR or the third party integrator to tag the user's role while assuming it.
   *
   * @schema DataLakeSettingsSpecForProvider#authorizedSessionTagValueList
   */
  readonly authorizedSessionTagValueList?: string[];

  /**
   * –  Identifier for the Data Catalog. By default, the account ID.
   *
   * @schema DataLakeSettingsSpecForProvider#catalogId
   */
  readonly catalogId?: string;

  /**
   * Up to three configuration blocks of principal permissions for default create database permissions. Detailed below.
   *
   * @schema DataLakeSettingsSpecForProvider#createDatabaseDefaultPermissions
   */
  readonly createDatabaseDefaultPermissions?: DataLakeSettingsSpecForProviderCreateDatabaseDefaultPermissions[];

  /**
   * Up to three configuration blocks of principal permissions for default create table permissions. Detailed below.
   *
   * @schema DataLakeSettingsSpecForProvider#createTableDefaultPermissions
   */
  readonly createTableDefaultPermissions?: DataLakeSettingsSpecForProviderCreateTableDefaultPermissions[];

  /**
   * A list of the account IDs of Amazon Web Services accounts with Amazon EMR clusters that are to perform data filtering.
   *
   * @schema DataLakeSettingsSpecForProvider#externalDataFilteringAllowList
   */
  readonly externalDataFilteringAllowList?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DataLakeSettingsSpecForProvider#region
   */
  readonly region: string;

  /**
   * owning account IDs that the caller's account can use to share their user access details (user ARNs).
   *
   * @schema DataLakeSettingsSpecForProvider#trustedResourceOwners
   */
  readonly trustedResourceOwners?: string[];

}

/**
 * Converts an object of type 'DataLakeSettingsSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeSettingsSpecForProvider(obj: DataLakeSettingsSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'admins': obj.admins?.map(y => y),
    'allowExternalDataFiltering': obj.allowExternalDataFiltering,
    'authorizedSessionTagValueList': obj.authorizedSessionTagValueList?.map(y => y),
    'catalogId': obj.catalogId,
    'createDatabaseDefaultPermissions': obj.createDatabaseDefaultPermissions?.map(y => toJson_DataLakeSettingsSpecForProviderCreateDatabaseDefaultPermissions(y)),
    'createTableDefaultPermissions': obj.createTableDefaultPermissions?.map(y => toJson_DataLakeSettingsSpecForProviderCreateTableDefaultPermissions(y)),
    'externalDataFilteringAllowList': obj.externalDataFilteringAllowList?.map(y => y),
    'region': obj.region,
    'trustedResourceOwners': obj.trustedResourceOwners?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DataLakeSettingsSpecInitProvider
 */
export interface DataLakeSettingsSpecInitProvider {
  /**
   * –  Set of ARNs of AWS Lake Formation principals (IAM users or roles).
   *
   * @schema DataLakeSettingsSpecInitProvider#admins
   */
  readonly admins?: string[];

  /**
   * Whether to allow Amazon EMR clusters to access data managed by Lake Formation.
   *
   * @schema DataLakeSettingsSpecInitProvider#allowExternalDataFiltering
   */
  readonly allowExternalDataFiltering?: boolean;

  /**
   * Lake Formation relies on a privileged process secured by Amazon EMR or the third party integrator to tag the user's role while assuming it.
   *
   * @schema DataLakeSettingsSpecInitProvider#authorizedSessionTagValueList
   */
  readonly authorizedSessionTagValueList?: string[];

  /**
   * –  Identifier for the Data Catalog. By default, the account ID.
   *
   * @schema DataLakeSettingsSpecInitProvider#catalogId
   */
  readonly catalogId?: string;

  /**
   * Up to three configuration blocks of principal permissions for default create database permissions. Detailed below.
   *
   * @schema DataLakeSettingsSpecInitProvider#createDatabaseDefaultPermissions
   */
  readonly createDatabaseDefaultPermissions?: DataLakeSettingsSpecInitProviderCreateDatabaseDefaultPermissions[];

  /**
   * Up to three configuration blocks of principal permissions for default create table permissions. Detailed below.
   *
   * @schema DataLakeSettingsSpecInitProvider#createTableDefaultPermissions
   */
  readonly createTableDefaultPermissions?: DataLakeSettingsSpecInitProviderCreateTableDefaultPermissions[];

  /**
   * A list of the account IDs of Amazon Web Services accounts with Amazon EMR clusters that are to perform data filtering.
   *
   * @schema DataLakeSettingsSpecInitProvider#externalDataFilteringAllowList
   */
  readonly externalDataFilteringAllowList?: string[];

  /**
   * owning account IDs that the caller's account can use to share their user access details (user ARNs).
   *
   * @schema DataLakeSettingsSpecInitProvider#trustedResourceOwners
   */
  readonly trustedResourceOwners?: string[];

}

/**
 * Converts an object of type 'DataLakeSettingsSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeSettingsSpecInitProvider(obj: DataLakeSettingsSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'admins': obj.admins?.map(y => y),
    'allowExternalDataFiltering': obj.allowExternalDataFiltering,
    'authorizedSessionTagValueList': obj.authorizedSessionTagValueList?.map(y => y),
    'catalogId': obj.catalogId,
    'createDatabaseDefaultPermissions': obj.createDatabaseDefaultPermissions?.map(y => toJson_DataLakeSettingsSpecInitProviderCreateDatabaseDefaultPermissions(y)),
    'createTableDefaultPermissions': obj.createTableDefaultPermissions?.map(y => toJson_DataLakeSettingsSpecInitProviderCreateTableDefaultPermissions(y)),
    'externalDataFilteringAllowList': obj.externalDataFilteringAllowList?.map(y => y),
    'trustedResourceOwners': obj.trustedResourceOwners?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DataLakeSettingsSpecManagementPolicies
 */
export enum DataLakeSettingsSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DataLakeSettingsSpecProviderConfigRef
 */
export interface DataLakeSettingsSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataLakeSettingsSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataLakeSettingsSpecProviderConfigRef#policy
   */
  readonly policy?: DataLakeSettingsSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DataLakeSettingsSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeSettingsSpecProviderConfigRef(obj: DataLakeSettingsSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataLakeSettingsSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DataLakeSettingsSpecPublishConnectionDetailsTo
 */
export interface DataLakeSettingsSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DataLakeSettingsSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DataLakeSettingsSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DataLakeSettingsSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DataLakeSettingsSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DataLakeSettingsSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DataLakeSettingsSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeSettingsSpecPublishConnectionDetailsTo(obj: DataLakeSettingsSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DataLakeSettingsSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DataLakeSettingsSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DataLakeSettingsSpecWriteConnectionSecretToRef
 */
export interface DataLakeSettingsSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DataLakeSettingsSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DataLakeSettingsSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DataLakeSettingsSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeSettingsSpecWriteConnectionSecretToRef(obj: DataLakeSettingsSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataLakeSettingsSpecForProviderCreateDatabaseDefaultPermissions
 */
export interface DataLakeSettingsSpecForProviderCreateDatabaseDefaultPermissions {
  /**
   * List of permissions that are granted to the principal. Valid values may include ALL, SELECT, ALTER, DROP, DELETE, INSERT, DESCRIBE, and CREATE_TABLE. For more details, see Lake Formation Permissions Reference.
   *
   * @schema DataLakeSettingsSpecForProviderCreateDatabaseDefaultPermissions#permissions
   */
  readonly permissions?: string[];

  /**
   * Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set principal to IAM_ALLOWED_PRINCIPALS and permissions to ["ALL"].
   *
   * @schema DataLakeSettingsSpecForProviderCreateDatabaseDefaultPermissions#principal
   */
  readonly principal?: string;

}

/**
 * Converts an object of type 'DataLakeSettingsSpecForProviderCreateDatabaseDefaultPermissions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeSettingsSpecForProviderCreateDatabaseDefaultPermissions(obj: DataLakeSettingsSpecForProviderCreateDatabaseDefaultPermissions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'permissions': obj.permissions?.map(y => y),
    'principal': obj.principal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataLakeSettingsSpecForProviderCreateTableDefaultPermissions
 */
export interface DataLakeSettingsSpecForProviderCreateTableDefaultPermissions {
  /**
   * List of permissions that are granted to the principal. Valid values may include ALL, SELECT, ALTER, DROP, DELETE, INSERT, and DESCRIBE. For more details, see Lake Formation Permissions Reference.
   *
   * @schema DataLakeSettingsSpecForProviderCreateTableDefaultPermissions#permissions
   */
  readonly permissions?: string[];

  /**
   * Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set principal to IAM_ALLOWED_PRINCIPALS and permissions to ["ALL"].
   *
   * @schema DataLakeSettingsSpecForProviderCreateTableDefaultPermissions#principal
   */
  readonly principal?: string;

}

/**
 * Converts an object of type 'DataLakeSettingsSpecForProviderCreateTableDefaultPermissions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeSettingsSpecForProviderCreateTableDefaultPermissions(obj: DataLakeSettingsSpecForProviderCreateTableDefaultPermissions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'permissions': obj.permissions?.map(y => y),
    'principal': obj.principal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataLakeSettingsSpecInitProviderCreateDatabaseDefaultPermissions
 */
export interface DataLakeSettingsSpecInitProviderCreateDatabaseDefaultPermissions {
  /**
   * List of permissions that are granted to the principal. Valid values may include ALL, SELECT, ALTER, DROP, DELETE, INSERT, DESCRIBE, and CREATE_TABLE. For more details, see Lake Formation Permissions Reference.
   *
   * @schema DataLakeSettingsSpecInitProviderCreateDatabaseDefaultPermissions#permissions
   */
  readonly permissions?: string[];

  /**
   * Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set principal to IAM_ALLOWED_PRINCIPALS and permissions to ["ALL"].
   *
   * @schema DataLakeSettingsSpecInitProviderCreateDatabaseDefaultPermissions#principal
   */
  readonly principal?: string;

}

/**
 * Converts an object of type 'DataLakeSettingsSpecInitProviderCreateDatabaseDefaultPermissions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeSettingsSpecInitProviderCreateDatabaseDefaultPermissions(obj: DataLakeSettingsSpecInitProviderCreateDatabaseDefaultPermissions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'permissions': obj.permissions?.map(y => y),
    'principal': obj.principal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataLakeSettingsSpecInitProviderCreateTableDefaultPermissions
 */
export interface DataLakeSettingsSpecInitProviderCreateTableDefaultPermissions {
  /**
   * List of permissions that are granted to the principal. Valid values may include ALL, SELECT, ALTER, DROP, DELETE, INSERT, and DESCRIBE. For more details, see Lake Formation Permissions Reference.
   *
   * @schema DataLakeSettingsSpecInitProviderCreateTableDefaultPermissions#permissions
   */
  readonly permissions?: string[];

  /**
   * Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set principal to IAM_ALLOWED_PRINCIPALS and permissions to ["ALL"].
   *
   * @schema DataLakeSettingsSpecInitProviderCreateTableDefaultPermissions#principal
   */
  readonly principal?: string;

}

/**
 * Converts an object of type 'DataLakeSettingsSpecInitProviderCreateTableDefaultPermissions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeSettingsSpecInitProviderCreateTableDefaultPermissions(obj: DataLakeSettingsSpecInitProviderCreateTableDefaultPermissions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'permissions': obj.permissions?.map(y => y),
    'principal': obj.principal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DataLakeSettingsSpecProviderConfigRefPolicy
 */
export interface DataLakeSettingsSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataLakeSettingsSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DataLakeSettingsSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataLakeSettingsSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DataLakeSettingsSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DataLakeSettingsSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeSettingsSpecProviderConfigRefPolicy(obj: DataLakeSettingsSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DataLakeSettingsSpecPublishConnectionDetailsToConfigRef
 */
export interface DataLakeSettingsSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataLakeSettingsSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataLakeSettingsSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DataLakeSettingsSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DataLakeSettingsSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeSettingsSpecPublishConnectionDetailsToConfigRef(obj: DataLakeSettingsSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataLakeSettingsSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DataLakeSettingsSpecPublishConnectionDetailsToMetadata
 */
export interface DataLakeSettingsSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DataLakeSettingsSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DataLakeSettingsSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DataLakeSettingsSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DataLakeSettingsSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeSettingsSpecPublishConnectionDetailsToMetadata(obj: DataLakeSettingsSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataLakeSettingsSpecProviderConfigRefPolicyResolution
 */
export enum DataLakeSettingsSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataLakeSettingsSpecProviderConfigRefPolicyResolve
 */
export enum DataLakeSettingsSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DataLakeSettingsSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DataLakeSettingsSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataLakeSettingsSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DataLakeSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataLakeSettingsSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DataLakeSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DataLakeSettingsSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataLakeSettingsSpecPublishConnectionDetailsToConfigRefPolicy(obj: DataLakeSettingsSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataLakeSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DataLakeSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataLakeSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DataLakeSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Permissions is the Schema for the Permissionss API. Grants permissions to the principal to access metadata in the Data Catalog and data organized in underlying data storage such as Amazon S3.
 *
 * @schema Permissions
 */
export class Permissions extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Permissions"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lakeformation.aws.upbound.io/v1beta1',
    kind: 'Permissions',
  }

  /**
   * Renders a Kubernetes manifest for "Permissions".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PermissionsProps): any {
    return {
      ...Permissions.GVK,
      ...toJson_PermissionsProps(props),
    };
  }

  /**
   * Defines a "Permissions" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PermissionsProps) {
    super(scope, id, {
      ...Permissions.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Permissions.GVK,
      ...toJson_PermissionsProps(resolved),
    };
  }
}

/**
 * Permissions is the Schema for the Permissionss API. Grants permissions to the principal to access metadata in the Data Catalog and data organized in underlying data storage such as Amazon S3.
 *
 * @schema Permissions
 */
export interface PermissionsProps {
  /**
   * @schema Permissions#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PermissionsSpec defines the desired state of Permissions
   *
   * @schema Permissions#spec
   */
  readonly spec: PermissionsSpec;

}

/**
 * Converts an object of type 'PermissionsProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsProps(obj: PermissionsProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PermissionsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PermissionsSpec defines the desired state of Permissions
 *
 * @schema PermissionsSpec
 */
export interface PermissionsSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PermissionsSpec#deletionPolicy
   */
  readonly deletionPolicy?: PermissionsSpecDeletionPolicy;

  /**
   * @schema PermissionsSpec#forProvider
   */
  readonly forProvider: PermissionsSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema PermissionsSpec#initProvider
   */
  readonly initProvider?: PermissionsSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PermissionsSpec#managementPolicies
   */
  readonly managementPolicies?: PermissionsSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PermissionsSpec#providerConfigRef
   */
  readonly providerConfigRef?: PermissionsSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PermissionsSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PermissionsSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PermissionsSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PermissionsSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PermissionsSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpec(obj: PermissionsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PermissionsSpecForProvider(obj.forProvider),
    'initProvider': toJson_PermissionsSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PermissionsSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PermissionsSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PermissionsSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PermissionsSpecDeletionPolicy
 */
export enum PermissionsSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PermissionsSpecForProvider
 */
export interface PermissionsSpecForProvider {
  /**
   * –  Identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
   *
   * @schema PermissionsSpecForProvider#catalogId
   */
  readonly catalogId?: string;

  /**
   * Whether the permissions are to be granted for the Data Catalog. Defaults to false.
   *
   * @default false.
   * @schema PermissionsSpecForProvider#catalogResource
   */
  readonly catalogResource?: boolean;

  /**
   * Configuration block for a data location resource. Detailed below.
   *
   * @schema PermissionsSpecForProvider#dataLocation
   */
  readonly dataLocation?: PermissionsSpecForProviderDataLocation[];

  /**
   * Configuration block for a database resource. Detailed below.
   *
   * @schema PermissionsSpecForProvider#database
   */
  readonly database?: PermissionsSpecForProviderDatabase[];

  /**
   * Configuration block for an LF-tag resource. Detailed below.
   *
   * @schema PermissionsSpecForProvider#lfTag
   */
  readonly lfTag?: PermissionsSpecForProviderLfTag[];

  /**
   * Configuration block for an LF-tag policy resource. Detailed below.
   *
   * @schema PermissionsSpecForProvider#lfTagPolicy
   */
  readonly lfTagPolicy?: PermissionsSpecForProviderLfTagPolicy[];

  /**
   * –  List of permissions granted to the principal. Valid values may include ALL, ALTER, ASSOCIATE, CREATE_DATABASE, CREATE_TABLE, DATA_LOCATION_ACCESS, DELETE, DESCRIBE, DROP, INSERT, and SELECT. For details on each permission, see Lake Formation Permissions Reference.
   *
   * @schema PermissionsSpecForProvider#permissions
   */
  readonly permissions?: string[];

  /**
   * Subset of permissions which the principal can pass.
   *
   * @schema PermissionsSpecForProvider#permissionsWithGrantOption
   */
  readonly permissionsWithGrantOption?: string[];

  /**
   * account permissions. For more information, see Lake Formation Permissions Reference.
   *
   * @schema PermissionsSpecForProvider#principal
   */
  readonly principal?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PermissionsSpecForProvider#region
   */
  readonly region: string;

  /**
   * Configuration block for a table resource. Detailed below.
   *
   * @schema PermissionsSpecForProvider#table
   */
  readonly table?: PermissionsSpecForProviderTable[];

  /**
   * Configuration block for a table with columns resource. Detailed below.
   *
   * @schema PermissionsSpecForProvider#tableWithColumns
   */
  readonly tableWithColumns?: PermissionsSpecForProviderTableWithColumns[];

}

/**
 * Converts an object of type 'PermissionsSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProvider(obj: PermissionsSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'catalogResource': obj.catalogResource,
    'dataLocation': obj.dataLocation?.map(y => toJson_PermissionsSpecForProviderDataLocation(y)),
    'database': obj.database?.map(y => toJson_PermissionsSpecForProviderDatabase(y)),
    'lfTag': obj.lfTag?.map(y => toJson_PermissionsSpecForProviderLfTag(y)),
    'lfTagPolicy': obj.lfTagPolicy?.map(y => toJson_PermissionsSpecForProviderLfTagPolicy(y)),
    'permissions': obj.permissions?.map(y => y),
    'permissionsWithGrantOption': obj.permissionsWithGrantOption?.map(y => y),
    'principal': obj.principal,
    'region': obj.region,
    'table': obj.table?.map(y => toJson_PermissionsSpecForProviderTable(y)),
    'tableWithColumns': obj.tableWithColumns?.map(y => toJson_PermissionsSpecForProviderTableWithColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema PermissionsSpecInitProvider
 */
export interface PermissionsSpecInitProvider {
  /**
   * –  Identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
   *
   * @schema PermissionsSpecInitProvider#catalogId
   */
  readonly catalogId?: string;

  /**
   * Whether the permissions are to be granted for the Data Catalog. Defaults to false.
   *
   * @default false.
   * @schema PermissionsSpecInitProvider#catalogResource
   */
  readonly catalogResource?: boolean;

  /**
   * Configuration block for a data location resource. Detailed below.
   *
   * @schema PermissionsSpecInitProvider#dataLocation
   */
  readonly dataLocation?: PermissionsSpecInitProviderDataLocation[];

  /**
   * Configuration block for a database resource. Detailed below.
   *
   * @schema PermissionsSpecInitProvider#database
   */
  readonly database?: PermissionsSpecInitProviderDatabase[];

  /**
   * Configuration block for an LF-tag resource. Detailed below.
   *
   * @schema PermissionsSpecInitProvider#lfTag
   */
  readonly lfTag?: PermissionsSpecInitProviderLfTag[];

  /**
   * Configuration block for an LF-tag policy resource. Detailed below.
   *
   * @schema PermissionsSpecInitProvider#lfTagPolicy
   */
  readonly lfTagPolicy?: PermissionsSpecInitProviderLfTagPolicy[];

  /**
   * –  List of permissions granted to the principal. Valid values may include ALL, ALTER, ASSOCIATE, CREATE_DATABASE, CREATE_TABLE, DATA_LOCATION_ACCESS, DELETE, DESCRIBE, DROP, INSERT, and SELECT. For details on each permission, see Lake Formation Permissions Reference.
   *
   * @schema PermissionsSpecInitProvider#permissions
   */
  readonly permissions?: string[];

  /**
   * Subset of permissions which the principal can pass.
   *
   * @schema PermissionsSpecInitProvider#permissionsWithGrantOption
   */
  readonly permissionsWithGrantOption?: string[];

  /**
   * account permissions. For more information, see Lake Formation Permissions Reference.
   *
   * @schema PermissionsSpecInitProvider#principal
   */
  readonly principal?: string;

  /**
   * Configuration block for a table resource. Detailed below.
   *
   * @schema PermissionsSpecInitProvider#table
   */
  readonly table?: PermissionsSpecInitProviderTable[];

  /**
   * Configuration block for a table with columns resource. Detailed below.
   *
   * @schema PermissionsSpecInitProvider#tableWithColumns
   */
  readonly tableWithColumns?: PermissionsSpecInitProviderTableWithColumns[];

}

/**
 * Converts an object of type 'PermissionsSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecInitProvider(obj: PermissionsSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'catalogResource': obj.catalogResource,
    'dataLocation': obj.dataLocation?.map(y => toJson_PermissionsSpecInitProviderDataLocation(y)),
    'database': obj.database?.map(y => toJson_PermissionsSpecInitProviderDatabase(y)),
    'lfTag': obj.lfTag?.map(y => toJson_PermissionsSpecInitProviderLfTag(y)),
    'lfTagPolicy': obj.lfTagPolicy?.map(y => toJson_PermissionsSpecInitProviderLfTagPolicy(y)),
    'permissions': obj.permissions?.map(y => y),
    'permissionsWithGrantOption': obj.permissionsWithGrantOption?.map(y => y),
    'principal': obj.principal,
    'table': obj.table?.map(y => toJson_PermissionsSpecInitProviderTable(y)),
    'tableWithColumns': obj.tableWithColumns?.map(y => toJson_PermissionsSpecInitProviderTableWithColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PermissionsSpecManagementPolicies
 */
export enum PermissionsSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PermissionsSpecProviderConfigRef
 */
export interface PermissionsSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionsSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionsSpecProviderConfigRef#policy
   */
  readonly policy?: PermissionsSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionsSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecProviderConfigRef(obj: PermissionsSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionsSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PermissionsSpecPublishConnectionDetailsTo
 */
export interface PermissionsSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PermissionsSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PermissionsSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PermissionsSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PermissionsSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PermissionsSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PermissionsSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecPublishConnectionDetailsTo(obj: PermissionsSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PermissionsSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PermissionsSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PermissionsSpecWriteConnectionSecretToRef
 */
export interface PermissionsSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PermissionsSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PermissionsSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PermissionsSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecWriteConnectionSecretToRef(obj: PermissionsSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsSpecForProviderDataLocation
 */
export interface PermissionsSpecForProviderDataLocation {
  /**
   * –  Amazon Resource Name (ARN) that uniquely identifies the data location resource.
   *
   * @schema PermissionsSpecForProviderDataLocation#arn
   */
  readonly arn?: string;

  /**
   * Reference to a Resource in lakeformation to populate arn.
   *
   * @schema PermissionsSpecForProviderDataLocation#arnRef
   */
  readonly arnRef?: PermissionsSpecForProviderDataLocationArnRef;

  /**
   * Selector for a Resource in lakeformation to populate arn.
   *
   * @schema PermissionsSpecForProviderDataLocation#arnSelector
   */
  readonly arnSelector?: PermissionsSpecForProviderDataLocationArnSelector;

  /**
   * Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
   *
   * @schema PermissionsSpecForProviderDataLocation#catalogId
   */
  readonly catalogId?: string;

}

/**
 * Converts an object of type 'PermissionsSpecForProviderDataLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderDataLocation(obj: PermissionsSpecForProviderDataLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'arnRef': toJson_PermissionsSpecForProviderDataLocationArnRef(obj.arnRef),
    'arnSelector': toJson_PermissionsSpecForProviderDataLocationArnSelector(obj.arnSelector),
    'catalogId': obj.catalogId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsSpecForProviderDatabase
 */
export interface PermissionsSpecForProviderDatabase {
  /**
   * Identifier for the Data Catalog. By default, it is the account ID of the caller.
   *
   * @schema PermissionsSpecForProviderDatabase#catalogId
   */
  readonly catalogId?: string;

  /**
   * –  Name of the database resource. Unique to the Data Catalog.
   *
   * @schema PermissionsSpecForProviderDatabase#name
   */
  readonly name?: string;

  /**
   * Reference to a CatalogDatabase in glue to populate name.
   *
   * @schema PermissionsSpecForProviderDatabase#nameRef
   */
  readonly nameRef?: PermissionsSpecForProviderDatabaseNameRef;

  /**
   * Selector for a CatalogDatabase in glue to populate name.
   *
   * @schema PermissionsSpecForProviderDatabase#nameSelector
   */
  readonly nameSelector?: PermissionsSpecForProviderDatabaseNameSelector;

}

/**
 * Converts an object of type 'PermissionsSpecForProviderDatabase' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderDatabase(obj: PermissionsSpecForProviderDatabase | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'name': obj.name,
    'nameRef': toJson_PermissionsSpecForProviderDatabaseNameRef(obj.nameRef),
    'nameSelector': toJson_PermissionsSpecForProviderDatabaseNameSelector(obj.nameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsSpecForProviderLfTag
 */
export interface PermissionsSpecForProviderLfTag {
  /**
   * Identifier for the Data Catalog. By default, it is the account ID of the caller.
   *
   * @schema PermissionsSpecForProviderLfTag#catalogId
   */
  readonly catalogId?: string;

  /**
   * name for the tag.
   *
   * @schema PermissionsSpecForProviderLfTag#key
   */
  readonly key?: string;

  /**
   * A list of possible values an attribute can take.
   *
   * @schema PermissionsSpecForProviderLfTag#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PermissionsSpecForProviderLfTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderLfTag(obj: PermissionsSpecForProviderLfTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsSpecForProviderLfTagPolicy
 */
export interface PermissionsSpecForProviderLfTagPolicy {
  /**
   * Identifier for the Data Catalog. By default, it is the account ID of the caller.
   *
   * @schema PermissionsSpecForProviderLfTagPolicy#catalogId
   */
  readonly catalogId?: string;

  /**
   * A list of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See expression below.
   *
   * @schema PermissionsSpecForProviderLfTagPolicy#expression
   */
  readonly expression?: PermissionsSpecForProviderLfTagPolicyExpression[];

  /**
   * –  The resource type for which the tag policy applies. Valid values are DATABASE and TABLE.
   *
   * @schema PermissionsSpecForProviderLfTagPolicy#resourceType
   */
  readonly resourceType?: string;

}

/**
 * Converts an object of type 'PermissionsSpecForProviderLfTagPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderLfTagPolicy(obj: PermissionsSpecForProviderLfTagPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'expression': obj.expression?.map(y => toJson_PermissionsSpecForProviderLfTagPolicyExpression(y)),
    'resourceType': obj.resourceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsSpecForProviderTable
 */
export interface PermissionsSpecForProviderTable {
  /**
   * Identifier for the Data Catalog. By default, it is the account ID of the caller.
   *
   * @schema PermissionsSpecForProviderTable#catalogId
   */
  readonly catalogId?: string;

  /**
   * –  Name of the database for the table. Unique to a Data Catalog.
   *
   * @schema PermissionsSpecForProviderTable#databaseName
   */
  readonly databaseName?: string;

  /**
   * Name of the table.
   *
   * @schema PermissionsSpecForProviderTable#name
   */
  readonly name?: string;

  /**
   * Whether to use a wildcard representing every table under a database. Defaults to false.
   *
   * @default false.
   * @schema PermissionsSpecForProviderTable#wildcard
   */
  readonly wildcard?: boolean;

}

/**
 * Converts an object of type 'PermissionsSpecForProviderTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderTable(obj: PermissionsSpecForProviderTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'databaseName': obj.databaseName,
    'name': obj.name,
    'wildcard': obj.wildcard,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsSpecForProviderTableWithColumns
 */
export interface PermissionsSpecForProviderTableWithColumns {
  /**
   * Identifier for the Data Catalog. By default, it is the account ID of the caller.
   *
   * @schema PermissionsSpecForProviderTableWithColumns#catalogId
   */
  readonly catalogId?: string;

  /**
   * Set of column names for the table.
   *
   * @schema PermissionsSpecForProviderTableWithColumns#columnNames
   */
  readonly columnNames?: string[];

  /**
   * –  Name of the database for the table with columns resource. Unique to the Data Catalog.
   *
   * @schema PermissionsSpecForProviderTableWithColumns#databaseName
   */
  readonly databaseName?: string;

  /**
   * Set of column names for the table to exclude.
   *
   * @schema PermissionsSpecForProviderTableWithColumns#excludedColumnNames
   */
  readonly excludedColumnNames?: string[];

  /**
   * –  Name of the table resource.
   *
   * @schema PermissionsSpecForProviderTableWithColumns#name
   */
  readonly name?: string;

  /**
   * Reference to a CatalogTable in glue to populate name.
   *
   * @schema PermissionsSpecForProviderTableWithColumns#nameRef
   */
  readonly nameRef?: PermissionsSpecForProviderTableWithColumnsNameRef;

  /**
   * Selector for a CatalogTable in glue to populate name.
   *
   * @schema PermissionsSpecForProviderTableWithColumns#nameSelector
   */
  readonly nameSelector?: PermissionsSpecForProviderTableWithColumnsNameSelector;

  /**
   * Whether to use a column wildcard.
   *
   * @schema PermissionsSpecForProviderTableWithColumns#wildcard
   */
  readonly wildcard?: boolean;

}

/**
 * Converts an object of type 'PermissionsSpecForProviderTableWithColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderTableWithColumns(obj: PermissionsSpecForProviderTableWithColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'columnNames': obj.columnNames?.map(y => y),
    'databaseName': obj.databaseName,
    'excludedColumnNames': obj.excludedColumnNames?.map(y => y),
    'name': obj.name,
    'nameRef': toJson_PermissionsSpecForProviderTableWithColumnsNameRef(obj.nameRef),
    'nameSelector': toJson_PermissionsSpecForProviderTableWithColumnsNameSelector(obj.nameSelector),
    'wildcard': obj.wildcard,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsSpecInitProviderDataLocation
 */
export interface PermissionsSpecInitProviderDataLocation {
  /**
   * Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
   *
   * @schema PermissionsSpecInitProviderDataLocation#catalogId
   */
  readonly catalogId?: string;

}

/**
 * Converts an object of type 'PermissionsSpecInitProviderDataLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecInitProviderDataLocation(obj: PermissionsSpecInitProviderDataLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsSpecInitProviderDatabase
 */
export interface PermissionsSpecInitProviderDatabase {
  /**
   * Identifier for the Data Catalog. By default, it is the account ID of the caller.
   *
   * @schema PermissionsSpecInitProviderDatabase#catalogId
   */
  readonly catalogId?: string;

}

/**
 * Converts an object of type 'PermissionsSpecInitProviderDatabase' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecInitProviderDatabase(obj: PermissionsSpecInitProviderDatabase | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsSpecInitProviderLfTag
 */
export interface PermissionsSpecInitProviderLfTag {
  /**
   * Identifier for the Data Catalog. By default, it is the account ID of the caller.
   *
   * @schema PermissionsSpecInitProviderLfTag#catalogId
   */
  readonly catalogId?: string;

  /**
   * name for the tag.
   *
   * @schema PermissionsSpecInitProviderLfTag#key
   */
  readonly key?: string;

  /**
   * A list of possible values an attribute can take.
   *
   * @schema PermissionsSpecInitProviderLfTag#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PermissionsSpecInitProviderLfTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecInitProviderLfTag(obj: PermissionsSpecInitProviderLfTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsSpecInitProviderLfTagPolicy
 */
export interface PermissionsSpecInitProviderLfTagPolicy {
  /**
   * Identifier for the Data Catalog. By default, it is the account ID of the caller.
   *
   * @schema PermissionsSpecInitProviderLfTagPolicy#catalogId
   */
  readonly catalogId?: string;

  /**
   * A list of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See expression below.
   *
   * @schema PermissionsSpecInitProviderLfTagPolicy#expression
   */
  readonly expression?: PermissionsSpecInitProviderLfTagPolicyExpression[];

  /**
   * –  The resource type for which the tag policy applies. Valid values are DATABASE and TABLE.
   *
   * @schema PermissionsSpecInitProviderLfTagPolicy#resourceType
   */
  readonly resourceType?: string;

}

/**
 * Converts an object of type 'PermissionsSpecInitProviderLfTagPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecInitProviderLfTagPolicy(obj: PermissionsSpecInitProviderLfTagPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'expression': obj.expression?.map(y => toJson_PermissionsSpecInitProviderLfTagPolicyExpression(y)),
    'resourceType': obj.resourceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsSpecInitProviderTable
 */
export interface PermissionsSpecInitProviderTable {
  /**
   * Identifier for the Data Catalog. By default, it is the account ID of the caller.
   *
   * @schema PermissionsSpecInitProviderTable#catalogId
   */
  readonly catalogId?: string;

  /**
   * –  Name of the database for the table. Unique to a Data Catalog.
   *
   * @schema PermissionsSpecInitProviderTable#databaseName
   */
  readonly databaseName?: string;

  /**
   * Name of the table.
   *
   * @schema PermissionsSpecInitProviderTable#name
   */
  readonly name?: string;

  /**
   * Whether to use a wildcard representing every table under a database. Defaults to false.
   *
   * @default false.
   * @schema PermissionsSpecInitProviderTable#wildcard
   */
  readonly wildcard?: boolean;

}

/**
 * Converts an object of type 'PermissionsSpecInitProviderTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecInitProviderTable(obj: PermissionsSpecInitProviderTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'databaseName': obj.databaseName,
    'name': obj.name,
    'wildcard': obj.wildcard,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsSpecInitProviderTableWithColumns
 */
export interface PermissionsSpecInitProviderTableWithColumns {
  /**
   * Identifier for the Data Catalog. By default, it is the account ID of the caller.
   *
   * @schema PermissionsSpecInitProviderTableWithColumns#catalogId
   */
  readonly catalogId?: string;

  /**
   * Set of column names for the table.
   *
   * @schema PermissionsSpecInitProviderTableWithColumns#columnNames
   */
  readonly columnNames?: string[];

  /**
   * –  Name of the database for the table with columns resource. Unique to the Data Catalog.
   *
   * @schema PermissionsSpecInitProviderTableWithColumns#databaseName
   */
  readonly databaseName?: string;

  /**
   * Set of column names for the table to exclude.
   *
   * @schema PermissionsSpecInitProviderTableWithColumns#excludedColumnNames
   */
  readonly excludedColumnNames?: string[];

  /**
   * Whether to use a column wildcard.
   *
   * @schema PermissionsSpecInitProviderTableWithColumns#wildcard
   */
  readonly wildcard?: boolean;

}

/**
 * Converts an object of type 'PermissionsSpecInitProviderTableWithColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecInitProviderTableWithColumns(obj: PermissionsSpecInitProviderTableWithColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'columnNames': obj.columnNames?.map(y => y),
    'databaseName': obj.databaseName,
    'excludedColumnNames': obj.excludedColumnNames?.map(y => y),
    'wildcard': obj.wildcard,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionsSpecProviderConfigRefPolicy
 */
export interface PermissionsSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionsSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionsSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionsSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionsSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecProviderConfigRefPolicy(obj: PermissionsSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PermissionsSpecPublishConnectionDetailsToConfigRef
 */
export interface PermissionsSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionsSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionsSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PermissionsSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionsSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecPublishConnectionDetailsToConfigRef(obj: PermissionsSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionsSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PermissionsSpecPublishConnectionDetailsToMetadata
 */
export interface PermissionsSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionsSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionsSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PermissionsSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PermissionsSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecPublishConnectionDetailsToMetadata(obj: PermissionsSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Resource in lakeformation to populate arn.
 *
 * @schema PermissionsSpecForProviderDataLocationArnRef
 */
export interface PermissionsSpecForProviderDataLocationArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionsSpecForProviderDataLocationArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionsSpecForProviderDataLocationArnRef#policy
   */
  readonly policy?: PermissionsSpecForProviderDataLocationArnRefPolicy;

}

/**
 * Converts an object of type 'PermissionsSpecForProviderDataLocationArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderDataLocationArnRef(obj: PermissionsSpecForProviderDataLocationArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionsSpecForProviderDataLocationArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Resource in lakeformation to populate arn.
 *
 * @schema PermissionsSpecForProviderDataLocationArnSelector
 */
export interface PermissionsSpecForProviderDataLocationArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PermissionsSpecForProviderDataLocationArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionsSpecForProviderDataLocationArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionsSpecForProviderDataLocationArnSelector#policy
   */
  readonly policy?: PermissionsSpecForProviderDataLocationArnSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionsSpecForProviderDataLocationArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderDataLocationArnSelector(obj: PermissionsSpecForProviderDataLocationArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionsSpecForProviderDataLocationArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CatalogDatabase in glue to populate name.
 *
 * @schema PermissionsSpecForProviderDatabaseNameRef
 */
export interface PermissionsSpecForProviderDatabaseNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionsSpecForProviderDatabaseNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionsSpecForProviderDatabaseNameRef#policy
   */
  readonly policy?: PermissionsSpecForProviderDatabaseNameRefPolicy;

}

/**
 * Converts an object of type 'PermissionsSpecForProviderDatabaseNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderDatabaseNameRef(obj: PermissionsSpecForProviderDatabaseNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionsSpecForProviderDatabaseNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CatalogDatabase in glue to populate name.
 *
 * @schema PermissionsSpecForProviderDatabaseNameSelector
 */
export interface PermissionsSpecForProviderDatabaseNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PermissionsSpecForProviderDatabaseNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionsSpecForProviderDatabaseNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionsSpecForProviderDatabaseNameSelector#policy
   */
  readonly policy?: PermissionsSpecForProviderDatabaseNameSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionsSpecForProviderDatabaseNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderDatabaseNameSelector(obj: PermissionsSpecForProviderDatabaseNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionsSpecForProviderDatabaseNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsSpecForProviderLfTagPolicyExpression
 */
export interface PermissionsSpecForProviderLfTagPolicyExpression {
  /**
   * name of an LF-Tag.
   *
   * @schema PermissionsSpecForProviderLfTagPolicyExpression#key
   */
  readonly key?: string;

  /**
   * A list of possible values of an LF-Tag.
   *
   * @schema PermissionsSpecForProviderLfTagPolicyExpression#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PermissionsSpecForProviderLfTagPolicyExpression' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderLfTagPolicyExpression(obj: PermissionsSpecForProviderLfTagPolicyExpression | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CatalogTable in glue to populate name.
 *
 * @schema PermissionsSpecForProviderTableWithColumnsNameRef
 */
export interface PermissionsSpecForProviderTableWithColumnsNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionsSpecForProviderTableWithColumnsNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionsSpecForProviderTableWithColumnsNameRef#policy
   */
  readonly policy?: PermissionsSpecForProviderTableWithColumnsNameRefPolicy;

}

/**
 * Converts an object of type 'PermissionsSpecForProviderTableWithColumnsNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderTableWithColumnsNameRef(obj: PermissionsSpecForProviderTableWithColumnsNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionsSpecForProviderTableWithColumnsNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CatalogTable in glue to populate name.
 *
 * @schema PermissionsSpecForProviderTableWithColumnsNameSelector
 */
export interface PermissionsSpecForProviderTableWithColumnsNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PermissionsSpecForProviderTableWithColumnsNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionsSpecForProviderTableWithColumnsNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionsSpecForProviderTableWithColumnsNameSelector#policy
   */
  readonly policy?: PermissionsSpecForProviderTableWithColumnsNameSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionsSpecForProviderTableWithColumnsNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderTableWithColumnsNameSelector(obj: PermissionsSpecForProviderTableWithColumnsNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionsSpecForProviderTableWithColumnsNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsSpecInitProviderLfTagPolicyExpression
 */
export interface PermissionsSpecInitProviderLfTagPolicyExpression {
  /**
   * name of an LF-Tag.
   *
   * @schema PermissionsSpecInitProviderLfTagPolicyExpression#key
   */
  readonly key?: string;

  /**
   * A list of possible values of an LF-Tag.
   *
   * @schema PermissionsSpecInitProviderLfTagPolicyExpression#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PermissionsSpecInitProviderLfTagPolicyExpression' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecInitProviderLfTagPolicyExpression(obj: PermissionsSpecInitProviderLfTagPolicyExpression | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionsSpecProviderConfigRefPolicyResolution
 */
export enum PermissionsSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionsSpecProviderConfigRefPolicyResolve
 */
export enum PermissionsSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PermissionsSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PermissionsSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionsSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionsSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionsSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionsSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecPublishConnectionDetailsToConfigRefPolicy(obj: PermissionsSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionsSpecForProviderDataLocationArnRefPolicy
 */
export interface PermissionsSpecForProviderDataLocationArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionsSpecForProviderDataLocationArnRefPolicy#resolution
   */
  readonly resolution?: PermissionsSpecForProviderDataLocationArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionsSpecForProviderDataLocationArnRefPolicy#resolve
   */
  readonly resolve?: PermissionsSpecForProviderDataLocationArnRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsSpecForProviderDataLocationArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderDataLocationArnRefPolicy(obj: PermissionsSpecForProviderDataLocationArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionsSpecForProviderDataLocationArnSelectorPolicy
 */
export interface PermissionsSpecForProviderDataLocationArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionsSpecForProviderDataLocationArnSelectorPolicy#resolution
   */
  readonly resolution?: PermissionsSpecForProviderDataLocationArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionsSpecForProviderDataLocationArnSelectorPolicy#resolve
   */
  readonly resolve?: PermissionsSpecForProviderDataLocationArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsSpecForProviderDataLocationArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderDataLocationArnSelectorPolicy(obj: PermissionsSpecForProviderDataLocationArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionsSpecForProviderDatabaseNameRefPolicy
 */
export interface PermissionsSpecForProviderDatabaseNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionsSpecForProviderDatabaseNameRefPolicy#resolution
   */
  readonly resolution?: PermissionsSpecForProviderDatabaseNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionsSpecForProviderDatabaseNameRefPolicy#resolve
   */
  readonly resolve?: PermissionsSpecForProviderDatabaseNameRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsSpecForProviderDatabaseNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderDatabaseNameRefPolicy(obj: PermissionsSpecForProviderDatabaseNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionsSpecForProviderDatabaseNameSelectorPolicy
 */
export interface PermissionsSpecForProviderDatabaseNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionsSpecForProviderDatabaseNameSelectorPolicy#resolution
   */
  readonly resolution?: PermissionsSpecForProviderDatabaseNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionsSpecForProviderDatabaseNameSelectorPolicy#resolve
   */
  readonly resolve?: PermissionsSpecForProviderDatabaseNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsSpecForProviderDatabaseNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderDatabaseNameSelectorPolicy(obj: PermissionsSpecForProviderDatabaseNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionsSpecForProviderTableWithColumnsNameRefPolicy
 */
export interface PermissionsSpecForProviderTableWithColumnsNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionsSpecForProviderTableWithColumnsNameRefPolicy#resolution
   */
  readonly resolution?: PermissionsSpecForProviderTableWithColumnsNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionsSpecForProviderTableWithColumnsNameRefPolicy#resolve
   */
  readonly resolve?: PermissionsSpecForProviderTableWithColumnsNameRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsSpecForProviderTableWithColumnsNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderTableWithColumnsNameRefPolicy(obj: PermissionsSpecForProviderTableWithColumnsNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionsSpecForProviderTableWithColumnsNameSelectorPolicy
 */
export interface PermissionsSpecForProviderTableWithColumnsNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionsSpecForProviderTableWithColumnsNameSelectorPolicy#resolution
   */
  readonly resolution?: PermissionsSpecForProviderTableWithColumnsNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionsSpecForProviderTableWithColumnsNameSelectorPolicy#resolve
   */
  readonly resolve?: PermissionsSpecForProviderTableWithColumnsNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsSpecForProviderTableWithColumnsNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsSpecForProviderTableWithColumnsNameSelectorPolicy(obj: PermissionsSpecForProviderTableWithColumnsNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionsSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PermissionsSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionsSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PermissionsSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionsSpecForProviderDataLocationArnRefPolicyResolution
 */
export enum PermissionsSpecForProviderDataLocationArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionsSpecForProviderDataLocationArnRefPolicyResolve
 */
export enum PermissionsSpecForProviderDataLocationArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionsSpecForProviderDataLocationArnSelectorPolicyResolution
 */
export enum PermissionsSpecForProviderDataLocationArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionsSpecForProviderDataLocationArnSelectorPolicyResolve
 */
export enum PermissionsSpecForProviderDataLocationArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionsSpecForProviderDatabaseNameRefPolicyResolution
 */
export enum PermissionsSpecForProviderDatabaseNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionsSpecForProviderDatabaseNameRefPolicyResolve
 */
export enum PermissionsSpecForProviderDatabaseNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionsSpecForProviderDatabaseNameSelectorPolicyResolution
 */
export enum PermissionsSpecForProviderDatabaseNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionsSpecForProviderDatabaseNameSelectorPolicyResolve
 */
export enum PermissionsSpecForProviderDatabaseNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionsSpecForProviderTableWithColumnsNameRefPolicyResolution
 */
export enum PermissionsSpecForProviderTableWithColumnsNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionsSpecForProviderTableWithColumnsNameRefPolicyResolve
 */
export enum PermissionsSpecForProviderTableWithColumnsNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionsSpecForProviderTableWithColumnsNameSelectorPolicyResolution
 */
export enum PermissionsSpecForProviderTableWithColumnsNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionsSpecForProviderTableWithColumnsNameSelectorPolicyResolve
 */
export enum PermissionsSpecForProviderTableWithColumnsNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Resource is the Schema for the Resources API. Registers a Lake Formation resource as managed by the Data Catalog.
 *
 * @schema Resource
 */
export class Resource extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Resource"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lakeformation.aws.upbound.io/v1beta1',
    kind: 'Resource',
  }

  /**
   * Renders a Kubernetes manifest for "Resource".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ResourceProps): any {
    return {
      ...Resource.GVK,
      ...toJson_ResourceProps(props),
    };
  }

  /**
   * Defines a "Resource" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ResourceProps) {
    super(scope, id, {
      ...Resource.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Resource.GVK,
      ...toJson_ResourceProps(resolved),
    };
  }
}

/**
 * Resource is the Schema for the Resources API. Registers a Lake Formation resource as managed by the Data Catalog.
 *
 * @schema Resource
 */
export interface ResourceProps {
  /**
   * @schema Resource#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ResourceSpec defines the desired state of Resource
   *
   * @schema Resource#spec
   */
  readonly spec: ResourceSpec;

}

/**
 * Converts an object of type 'ResourceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceProps(obj: ResourceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResourceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceSpec defines the desired state of Resource
 *
 * @schema ResourceSpec
 */
export interface ResourceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ResourceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ResourceSpecDeletionPolicy;

  /**
   * @schema ResourceSpec#forProvider
   */
  readonly forProvider: ResourceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ResourceSpec#initProvider
   */
  readonly initProvider?: ResourceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ResourceSpec#managementPolicies
   */
  readonly managementPolicies?: ResourceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ResourceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ResourceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ResourceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ResourceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ResourceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ResourceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpec(obj: ResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ResourceSpecForProvider(obj.forProvider),
    'initProvider': toJson_ResourceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ResourceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ResourceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ResourceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ResourceSpecDeletionPolicy
 */
export enum ResourceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ResourceSpecForProvider
 */
export interface ResourceSpecForProvider {
  /**
   * –  Amazon Resource Name (ARN) of the resource, an S3 path.
   *
   * @schema ResourceSpecForProvider#arn
   */
  readonly arn?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ResourceSpecForProvider#region
   */
  readonly region: string;

  /**
   * linked role must exist and is used.
   *
   * @schema ResourceSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ResourceSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: ResourceSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ResourceSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: ResourceSpecForProviderRoleArnSelector;

}

/**
 * Converts an object of type 'ResourceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProvider(obj: ResourceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ResourceSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ResourceSpecForProviderRoleArnSelector(obj.roleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ResourceSpecInitProvider
 */
export interface ResourceSpecInitProvider {
  /**
   * –  Amazon Resource Name (ARN) of the resource, an S3 path.
   *
   * @schema ResourceSpecInitProvider#arn
   */
  readonly arn?: string;

}

/**
 * Converts an object of type 'ResourceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecInitProvider(obj: ResourceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ResourceSpecManagementPolicies
 */
export enum ResourceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ResourceSpecProviderConfigRef
 */
export interface ResourceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceSpecProviderConfigRef#policy
   */
  readonly policy?: ResourceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecProviderConfigRef(obj: ResourceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ResourceSpecPublishConnectionDetailsTo
 */
export interface ResourceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ResourceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ResourceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ResourceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ResourceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ResourceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ResourceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecPublishConnectionDetailsTo(obj: ResourceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ResourceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ResourceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ResourceSpecWriteConnectionSecretToRef
 */
export interface ResourceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ResourceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ResourceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ResourceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecWriteConnectionSecretToRef(obj: ResourceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ResourceSpecForProviderRoleArnRef
 */
export interface ResourceSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceSpecForProviderRoleArnRef#policy
   */
  readonly policy?: ResourceSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ResourceSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderRoleArnRef(obj: ResourceSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ResourceSpecForProviderRoleArnSelector
 */
export interface ResourceSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResourceSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResourceSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResourceSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: ResourceSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ResourceSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderRoleArnSelector(obj: ResourceSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResourceSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceSpecProviderConfigRefPolicy
 */
export interface ResourceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ResourceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ResourceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecProviderConfigRefPolicy(obj: ResourceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ResourceSpecPublishConnectionDetailsToConfigRef
 */
export interface ResourceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ResourceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecPublishConnectionDetailsToConfigRef(obj: ResourceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ResourceSpecPublishConnectionDetailsToMetadata
 */
export interface ResourceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ResourceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ResourceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecPublishConnectionDetailsToMetadata(obj: ResourceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceSpecForProviderRoleArnRefPolicy
 */
export interface ResourceSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: ResourceSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: ResourceSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderRoleArnRefPolicy(obj: ResourceSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResourceSpecForProviderRoleArnSelectorPolicy
 */
export interface ResourceSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ResourceSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ResourceSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderRoleArnSelectorPolicy(obj: ResourceSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecProviderConfigRefPolicyResolution
 */
export enum ResourceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecProviderConfigRefPolicyResolve
 */
export enum ResourceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ResourceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ResourceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecForProviderRoleArnRefPolicyResolution
 */
export enum ResourceSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecForProviderRoleArnRefPolicyResolve
 */
export enum ResourceSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum ResourceSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum ResourceSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

