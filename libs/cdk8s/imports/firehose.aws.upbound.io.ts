// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * DeliveryStream is the Schema for the DeliveryStreams API. Provides a AWS Kinesis Firehose Delivery Stream
 *
 * @schema DeliveryStream
 */
export class DeliveryStream extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DeliveryStream"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'firehose.aws.upbound.io/v1beta1',
    kind: 'DeliveryStream',
  }

  /**
   * Renders a Kubernetes manifest for "DeliveryStream".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DeliveryStreamProps): any {
    return {
      ...DeliveryStream.GVK,
      ...toJson_DeliveryStreamProps(props),
    };
  }

  /**
   * Defines a "DeliveryStream" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DeliveryStreamProps) {
    super(scope, id, {
      ...DeliveryStream.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DeliveryStream.GVK,
      ...toJson_DeliveryStreamProps(resolved),
    };
  }
}

/**
 * DeliveryStream is the Schema for the DeliveryStreams API. Provides a AWS Kinesis Firehose Delivery Stream
 *
 * @schema DeliveryStream
 */
export interface DeliveryStreamProps {
  /**
   * @schema DeliveryStream#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeliveryStreamSpec defines the desired state of DeliveryStream
   *
   * @schema DeliveryStream#spec
   */
  readonly spec: DeliveryStreamSpec;

}

/**
 * Converts an object of type 'DeliveryStreamProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamProps(obj: DeliveryStreamProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DeliveryStreamSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeliveryStreamSpec defines the desired state of DeliveryStream
 *
 * @schema DeliveryStreamSpec
 */
export interface DeliveryStreamSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeliveryStreamSpec#deletionPolicy
   */
  readonly deletionPolicy?: DeliveryStreamSpecDeletionPolicy;

  /**
   * @schema DeliveryStreamSpec#forProvider
   */
  readonly forProvider: DeliveryStreamSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DeliveryStreamSpec#initProvider
   */
  readonly initProvider?: DeliveryStreamSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DeliveryStreamSpec#managementPolicies
   */
  readonly managementPolicies?: DeliveryStreamSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DeliveryStreamSpec#providerConfigRef
   */
  readonly providerConfigRef?: DeliveryStreamSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DeliveryStreamSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DeliveryStreamSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DeliveryStreamSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DeliveryStreamSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DeliveryStreamSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpec(obj: DeliveryStreamSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DeliveryStreamSpecForProvider(obj.forProvider),
    'initProvider': toJson_DeliveryStreamSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DeliveryStreamSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DeliveryStreamSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DeliveryStreamSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeliveryStreamSpecDeletionPolicy
 */
export enum DeliveryStreamSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DeliveryStreamSpecForProvider
 */
export interface DeliveryStreamSpecForProvider {
  /**
   * The Amazon Resource Name (ARN) specifying the Stream
   *
   * @schema DeliveryStreamSpecForProvider#arn
   */
  readonly arn?: string;

  /**
   * –  This is the destination to where the data is delivered. The only options are s3 (Deprecated, use extended_s3 instead), extended_s3, redshift, elasticsearch, splunk, http_endpoint and opensearch.
   *
   * @schema DeliveryStreamSpecForProvider#destination
   */
  readonly destination?: string;

  /**
   * @schema DeliveryStreamSpecForProvider#destinationId
   */
  readonly destinationId?: string;

  /**
   * Configuration options if elasticsearch is the destination. More details are given below.
   *
   * @schema DeliveryStreamSpecForProvider#elasticsearchConfiguration
   */
  readonly elasticsearchConfiguration?: DeliveryStreamSpecForProviderElasticsearchConfiguration[];

  /**
   * Enhanced configuration options for the s3 destination. More details are given below.
   *
   * @schema DeliveryStreamSpecForProvider#extendedS3Configuration
   */
  readonly extendedS3Configuration?: DeliveryStreamSpecForProviderExtendedS3Configuration[];

  /**
   * Configuration options if http_endpoint is the destination. requires the user to also specify a s3_configuration block.  More details are given below.
   *
   * @schema DeliveryStreamSpecForProvider#httpEndpointConfiguration
   */
  readonly httpEndpointConfiguration?: DeliveryStreamSpecForProviderHttpEndpointConfiguration[];

  /**
   * Allows the ability to specify the kinesis stream that is used as the source of the firehose delivery stream.
   *
   * @schema DeliveryStreamSpecForProvider#kinesisSourceConfiguration
   */
  readonly kinesisSourceConfiguration?: DeliveryStreamSpecForProviderKinesisSourceConfiguration[];

  /**
   * A name to identify the stream. This is unique to the AWS account and region the Stream is created in. When using for WAF logging, name must be prefixed with aws-waf-logs-. See AWS Documentation for more details.
   *
   * @schema DeliveryStreamSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Configuration options if opensearch is the destination. More details are given below.
   *
   * @schema DeliveryStreamSpecForProvider#opensearchConfiguration
   */
  readonly opensearchConfiguration?: DeliveryStreamSpecForProviderOpensearchConfiguration[];

  /**
   * Configuration options if redshift is the destination. Using redshift_configuration requires the user to also specify a s3_configuration block. More details are given below.
   *
   * @schema DeliveryStreamSpecForProvider#redshiftConfiguration
   */
  readonly redshiftConfiguration?: DeliveryStreamSpecForProviderRedshiftConfiguration[];

  /**
   * If you don't specify an AWS Region, the default is the current region. Region is the region you'd like your resource to be created in.
   *
   * @schema DeliveryStreamSpecForProvider#region
   */
  readonly region: string;

  /**
   * Required for non-S3 destinations. For S3 destination, use extended_s3_configuration instead. Configuration options for the s3 destination (or the intermediate bucket if the destination is redshift). More details are given below.
   *
   * @schema DeliveryStreamSpecForProvider#s3Configuration
   */
  readonly s3Configuration?: DeliveryStreamSpecForProviderS3Configuration[];

  /**
   * Encrypt at rest options. Server-side encryption should not be enabled when a kinesis stream is configured as the source of the firehose delivery stream.
   *
   * @schema DeliveryStreamSpecForProvider#serverSideEncryption
   */
  readonly serverSideEncryption?: DeliveryStreamSpecForProviderServerSideEncryption[];

  /**
   * Configuration options if splunk is the destination. More details are given below.
   *
   * @schema DeliveryStreamSpecForProvider#splunkConfiguration
   */
  readonly splunkConfiguration?: DeliveryStreamSpecForProviderSplunkConfiguration[];

  /**
   * Key-value map of resource tags.
   *
   * @schema DeliveryStreamSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Specifies the table version for the output data schema. Defaults to LATEST.
   *
   * @default LATEST.
   * @schema DeliveryStreamSpecForProvider#versionId
   */
  readonly versionId?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProvider(obj: DeliveryStreamSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'destination': obj.destination,
    'destinationId': obj.destinationId,
    'elasticsearchConfiguration': obj.elasticsearchConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderElasticsearchConfiguration(y)),
    'extendedS3Configuration': obj.extendedS3Configuration?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3Configuration(y)),
    'httpEndpointConfiguration': obj.httpEndpointConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderHttpEndpointConfiguration(y)),
    'kinesisSourceConfiguration': obj.kinesisSourceConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderKinesisSourceConfiguration(y)),
    'name': obj.name,
    'opensearchConfiguration': obj.opensearchConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderOpensearchConfiguration(y)),
    'redshiftConfiguration': obj.redshiftConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderRedshiftConfiguration(y)),
    'region': obj.region,
    's3Configuration': obj.s3Configuration?.map(y => toJson_DeliveryStreamSpecForProviderS3Configuration(y)),
    'serverSideEncryption': obj.serverSideEncryption?.map(y => toJson_DeliveryStreamSpecForProviderServerSideEncryption(y)),
    'splunkConfiguration': obj.splunkConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderSplunkConfiguration(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'versionId': obj.versionId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DeliveryStreamSpecInitProvider
 */
export interface DeliveryStreamSpecInitProvider {
  /**
   * The Amazon Resource Name (ARN) specifying the Stream
   *
   * @schema DeliveryStreamSpecInitProvider#arn
   */
  readonly arn?: string;

  /**
   * –  This is the destination to where the data is delivered. The only options are s3 (Deprecated, use extended_s3 instead), extended_s3, redshift, elasticsearch, splunk, http_endpoint and opensearch.
   *
   * @schema DeliveryStreamSpecInitProvider#destination
   */
  readonly destination?: string;

  /**
   * @schema DeliveryStreamSpecInitProvider#destinationId
   */
  readonly destinationId?: string;

  /**
   * Configuration options if elasticsearch is the destination. More details are given below.
   *
   * @schema DeliveryStreamSpecInitProvider#elasticsearchConfiguration
   */
  readonly elasticsearchConfiguration?: DeliveryStreamSpecInitProviderElasticsearchConfiguration[];

  /**
   * Enhanced configuration options for the s3 destination. More details are given below.
   *
   * @schema DeliveryStreamSpecInitProvider#extendedS3Configuration
   */
  readonly extendedS3Configuration?: DeliveryStreamSpecInitProviderExtendedS3Configuration[];

  /**
   * Configuration options if http_endpoint is the destination. requires the user to also specify a s3_configuration block.  More details are given below.
   *
   * @schema DeliveryStreamSpecInitProvider#httpEndpointConfiguration
   */
  readonly httpEndpointConfiguration?: DeliveryStreamSpecInitProviderHttpEndpointConfiguration[];

  /**
   * Allows the ability to specify the kinesis stream that is used as the source of the firehose delivery stream.
   *
   * @schema DeliveryStreamSpecInitProvider#kinesisSourceConfiguration
   */
  readonly kinesisSourceConfiguration?: DeliveryStreamSpecInitProviderKinesisSourceConfiguration[];

  /**
   * A name to identify the stream. This is unique to the AWS account and region the Stream is created in. When using for WAF logging, name must be prefixed with aws-waf-logs-. See AWS Documentation for more details.
   *
   * @schema DeliveryStreamSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Configuration options if opensearch is the destination. More details are given below.
   *
   * @schema DeliveryStreamSpecInitProvider#opensearchConfiguration
   */
  readonly opensearchConfiguration?: DeliveryStreamSpecInitProviderOpensearchConfiguration[];

  /**
   * Configuration options if redshift is the destination. Using redshift_configuration requires the user to also specify a s3_configuration block. More details are given below.
   *
   * @schema DeliveryStreamSpecInitProvider#redshiftConfiguration
   */
  readonly redshiftConfiguration?: DeliveryStreamSpecInitProviderRedshiftConfiguration[];

  /**
   * Required for non-S3 destinations. For S3 destination, use extended_s3_configuration instead. Configuration options for the s3 destination (or the intermediate bucket if the destination is redshift). More details are given below.
   *
   * @schema DeliveryStreamSpecInitProvider#s3Configuration
   */
  readonly s3Configuration?: DeliveryStreamSpecInitProviderS3Configuration[];

  /**
   * Encrypt at rest options. Server-side encryption should not be enabled when a kinesis stream is configured as the source of the firehose delivery stream.
   *
   * @schema DeliveryStreamSpecInitProvider#serverSideEncryption
   */
  readonly serverSideEncryption?: DeliveryStreamSpecInitProviderServerSideEncryption[];

  /**
   * Configuration options if splunk is the destination. More details are given below.
   *
   * @schema DeliveryStreamSpecInitProvider#splunkConfiguration
   */
  readonly splunkConfiguration?: DeliveryStreamSpecInitProviderSplunkConfiguration[];

  /**
   * Key-value map of resource tags.
   *
   * @schema DeliveryStreamSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Specifies the table version for the output data schema. Defaults to LATEST.
   *
   * @default LATEST.
   * @schema DeliveryStreamSpecInitProvider#versionId
   */
  readonly versionId?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProvider(obj: DeliveryStreamSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'destination': obj.destination,
    'destinationId': obj.destinationId,
    'elasticsearchConfiguration': obj.elasticsearchConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderElasticsearchConfiguration(y)),
    'extendedS3Configuration': obj.extendedS3Configuration?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3Configuration(y)),
    'httpEndpointConfiguration': obj.httpEndpointConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderHttpEndpointConfiguration(y)),
    'kinesisSourceConfiguration': obj.kinesisSourceConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderKinesisSourceConfiguration(y)),
    'name': obj.name,
    'opensearchConfiguration': obj.opensearchConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderOpensearchConfiguration(y)),
    'redshiftConfiguration': obj.redshiftConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderRedshiftConfiguration(y)),
    's3Configuration': obj.s3Configuration?.map(y => toJson_DeliveryStreamSpecInitProviderS3Configuration(y)),
    'serverSideEncryption': obj.serverSideEncryption?.map(y => toJson_DeliveryStreamSpecInitProviderServerSideEncryption(y)),
    'splunkConfiguration': obj.splunkConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderSplunkConfiguration(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'versionId': obj.versionId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DeliveryStreamSpecManagementPolicies
 */
export enum DeliveryStreamSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DeliveryStreamSpecProviderConfigRef
 */
export interface DeliveryStreamSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecProviderConfigRef#policy
   */
  readonly policy?: DeliveryStreamSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecProviderConfigRef(obj: DeliveryStreamSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DeliveryStreamSpecPublishConnectionDetailsTo
 */
export interface DeliveryStreamSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DeliveryStreamSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DeliveryStreamSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DeliveryStreamSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DeliveryStreamSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DeliveryStreamSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecPublishConnectionDetailsTo(obj: DeliveryStreamSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DeliveryStreamSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DeliveryStreamSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DeliveryStreamSpecWriteConnectionSecretToRef
 */
export interface DeliveryStreamSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DeliveryStreamSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeliveryStreamSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecWriteConnectionSecretToRef(obj: DeliveryStreamSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfiguration {
  /**
   * Buffer incoming data for the specified period of time, in seconds between 60 to 900, before delivering it to the destination.  The default value is 300s.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration#bufferingInterval
   */
  readonly bufferingInterval?: number;

  /**
   * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration#bufferingSize
   */
  readonly bufferingSize?: number;

  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecForProviderElasticsearchConfigurationCloudwatchLoggingOptions[];

  /**
   * The endpoint to use when communicating with the cluster. Conflicts with domain_arn.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration#clusterEndpoint
   */
  readonly clusterEndpoint?: string;

  /**
   * The ARN of the Amazon ES domain.  The pattern needs to be arn:.*.  Conflicts with cluster_endpoint.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration#domainArn
   */
  readonly domainArn?: string;

  /**
   * Reference to a Domain in elasticsearch to populate domainArn.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration#domainArnRef
   */
  readonly domainArnRef?: DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRef;

  /**
   * Selector for a Domain in elasticsearch to populate domainArn.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration#domainArnSelector
   */
  readonly domainArnSelector?: DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelector;

  /**
   * The Elasticsearch index name.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration#indexName
   */
  readonly indexName?: string;

  /**
   * The Elasticsearch index rotation period.  Index rotation appends a timestamp to the IndexName to facilitate expiration of old data.  Valid values are NoRotation, OneHour, OneDay, OneWeek, and OneMonth.  The default value is OneDay.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration#indexRotationPeriod
   */
  readonly indexRotationPeriod?: string;

  /**
   * The data processing configuration.  More details are given below.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration#processingConfiguration
   */
  readonly processingConfiguration?: DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfiguration[];

  /**
   * The length of time during which Firehose retries delivery after a failure, starting from the initial request and including the first attempt. The default value is 3600 seconds (60 minutes). Firehose does not retry if the value of DurationInSeconds is 0 (zero) or if the first delivery attempt takes longer than the current value.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration#retryDuration
   */
  readonly retryDuration?: number;

  /**
   * The ARN of the AWS credentials.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration#roleArnRef
   */
  readonly roleArnRef?: DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration#roleArnSelector
   */
  readonly roleArnSelector?: DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelector;

  /**
   * The Amazon S3 backup mode.  Valid values are Disabled and Enabled.  Default value is Disabled.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration#s3BackupMode
   */
  readonly s3BackupMode?: string;

  /**
   * The Elasticsearch type name with maximum length of 100 characters.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration#typeName
   */
  readonly typeName?: string;

  /**
   * The VPC configuration for the delivery stream to connect to Elastic Search associated with the VPC. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfiguration#vpcConfig
   */
  readonly vpcConfig?: DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfig[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfiguration(obj: DeliveryStreamSpecForProviderElasticsearchConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferingInterval': obj.bufferingInterval,
    'bufferingSize': obj.bufferingSize,
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationCloudwatchLoggingOptions(y)),
    'clusterEndpoint': obj.clusterEndpoint,
    'domainArn': obj.domainArn,
    'domainArnRef': toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRef(obj.domainArnRef),
    'domainArnSelector': toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelector(obj.domainArnSelector),
    'indexName': obj.indexName,
    'indexRotationPeriod': obj.indexRotationPeriod,
    'processingConfiguration': obj.processingConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfiguration(y)),
    'retryDuration': obj.retryDuration,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelector(obj.roleArnSelector),
    's3BackupMode': obj.s3BackupMode,
    'typeName': obj.typeName,
    'vpcConfig': obj.vpcConfig?.map(y => toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3Configuration
 */
export interface DeliveryStreamSpecForProviderExtendedS3Configuration {
  /**
   * The ARN of the S3 bucket
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#bucketArn
   */
  readonly bucketArn?: string;

  /**
   * Reference to a Bucket in s3 to populate bucketArn.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#bucketArnRef
   */
  readonly bucketArnRef?: DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRef;

  /**
   * Selector for a Bucket in s3 to populate bucketArn.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#bucketArnSelector
   */
  readonly bucketArnSelector?: DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelector;

  /**
   * Buffer incoming data for the specified period of time, in seconds, before delivering it to the destination. The default value is 300.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#bufferInterval
   */
  readonly bufferInterval?: number;

  /**
   * Buffer incoming data to the specified size, in MBs, before delivering it to the destination. The default value is 5. We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#bufferSize
   */
  readonly bufferSize?: number;

  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecForProviderExtendedS3ConfigurationCloudwatchLoggingOptions[];

  /**
   * The compression format. If no value is specified, the default is UNCOMPRESSED. Other supported values are GZIP, ZIP, Snappy, & HADOOP_SNAPPY.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#compressionFormat
   */
  readonly compressionFormat?: string;

  /**
   * Nested argument for the serializer, deserializer, and schema for converting data from the JSON format to the Parquet or ORC format before writing it to Amazon S3. More details given below.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#dataFormatConversionConfiguration
   */
  readonly dataFormatConversionConfiguration?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfiguration[];

  /**
   * The configuration for dynamic partitioning. See Dynamic Partitioning Configuration below for more details. Required when using dynamic partitioning.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#dynamicPartitioningConfiguration
   */
  readonly dynamicPartitioningConfiguration?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDynamicPartitioningConfiguration[];

  /**
   * Prefix added to failed records before writing them to S3. Not currently supported for redshift destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see Custom Prefixes for Amazon S3 Objects.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#errorOutputPrefix
   */
  readonly errorOutputPrefix?: string;

  /**
   * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will be used.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#prefix
   */
  readonly prefix?: string;

  /**
   * The data processing configuration.  More details are given below.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#processingConfiguration
   */
  readonly processingConfiguration?: DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfiguration[];

  /**
   * The ARN of the AWS credentials.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#roleArnRef
   */
  readonly roleArnRef?: DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#roleArnSelector
   */
  readonly roleArnSelector?: DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelector;

  /**
   * The configuration for backup in Amazon S3. Required if s3_backup_mode is Enabled. Supports the same fields as s3_configuration object.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#s3BackupConfiguration
   */
  readonly s3BackupConfiguration?: DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfiguration[];

  /**
   * The Amazon S3 backup mode.  Valid values are Disabled and Enabled.  Default value is Disabled.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3Configuration#s3BackupMode
   */
  readonly s3BackupMode?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3Configuration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3Configuration(obj: DeliveryStreamSpecForProviderExtendedS3Configuration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketArn': obj.bucketArn,
    'bucketArnRef': toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRef(obj.bucketArnRef),
    'bucketArnSelector': toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelector(obj.bucketArnSelector),
    'bufferInterval': obj.bufferInterval,
    'bufferSize': obj.bufferSize,
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationCloudwatchLoggingOptions(y)),
    'compressionFormat': obj.compressionFormat,
    'dataFormatConversionConfiguration': obj.dataFormatConversionConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfiguration(y)),
    'dynamicPartitioningConfiguration': obj.dynamicPartitioningConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDynamicPartitioningConfiguration(y)),
    'errorOutputPrefix': obj.errorOutputPrefix,
    'kmsKeyArn': obj.kmsKeyArn,
    'prefix': obj.prefix,
    'processingConfiguration': obj.processingConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfiguration(y)),
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelector(obj.roleArnSelector),
    's3BackupConfiguration': obj.s3BackupConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfiguration(y)),
    's3BackupMode': obj.s3BackupMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderHttpEndpointConfiguration
 */
export interface DeliveryStreamSpecForProviderHttpEndpointConfiguration {
  /**
   * The access key required for Kinesis Firehose to authenticate with the HTTP endpoint selected as the destination.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfiguration#accessKeySecretRef
   */
  readonly accessKeySecretRef?: DeliveryStreamSpecForProviderHttpEndpointConfigurationAccessKeySecretRef;

  /**
   * Buffer incoming data for the specified period of time, in seconds between 60 to 900, before delivering it to the destination.  The default value is 300s.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfiguration#bufferingInterval
   */
  readonly bufferingInterval?: number;

  /**
   * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfiguration#bufferingSize
   */
  readonly bufferingSize?: number;

  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfiguration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecForProviderHttpEndpointConfigurationCloudwatchLoggingOptions[];

  /**
   * The HTTP endpoint name.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfiguration#name
   */
  readonly name?: string;

  /**
   * The data processing configuration.  More details are given below.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfiguration#processingConfiguration
   */
  readonly processingConfiguration?: DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfiguration[];

  /**
   * The request configuration.  More details are given below.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfiguration#requestConfiguration
   */
  readonly requestConfiguration?: DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfiguration[];

  /**
   * The length of time during which Firehose retries delivery after a failure, starting from the initial request and including the first attempt. The default value is 3600 seconds (60 minutes). Firehose does not retry if the value of DurationInSeconds is 0 (zero) or if the first delivery attempt takes longer than the current value.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfiguration#retryDuration
   */
  readonly retryDuration?: number;

  /**
   * The ARN of the AWS credentials.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfiguration#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfiguration#roleArnRef
   */
  readonly roleArnRef?: DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfiguration#roleArnSelector
   */
  readonly roleArnSelector?: DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelector;

  /**
   * The Amazon S3 backup mode.  Valid values are Disabled and Enabled.  Default value is Disabled.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfiguration#s3BackupMode
   */
  readonly s3BackupMode?: string;

  /**
   * The HTTP endpoint URL to which Kinesis Firehose sends your data.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfiguration#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderHttpEndpointConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderHttpEndpointConfiguration(obj: DeliveryStreamSpecForProviderHttpEndpointConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeySecretRef': toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationAccessKeySecretRef(obj.accessKeySecretRef),
    'bufferingInterval': obj.bufferingInterval,
    'bufferingSize': obj.bufferingSize,
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationCloudwatchLoggingOptions(y)),
    'name': obj.name,
    'processingConfiguration': obj.processingConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfiguration(y)),
    'requestConfiguration': obj.requestConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfiguration(y)),
    'retryDuration': obj.retryDuration,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelector(obj.roleArnSelector),
    's3BackupMode': obj.s3BackupMode,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderKinesisSourceConfiguration
 */
export interface DeliveryStreamSpecForProviderKinesisSourceConfiguration {
  /**
   * The kinesis stream used as the source of the firehose delivery stream.
   *
   * @schema DeliveryStreamSpecForProviderKinesisSourceConfiguration#kinesisStreamArn
   */
  readonly kinesisStreamArn?: string;

  /**
   * The ARN of the AWS credentials.
   *
   * @schema DeliveryStreamSpecForProviderKinesisSourceConfiguration#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderKinesisSourceConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderKinesisSourceConfiguration(obj: DeliveryStreamSpecForProviderKinesisSourceConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kinesisStreamArn': obj.kinesisStreamArn,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderOpensearchConfiguration
 */
export interface DeliveryStreamSpecForProviderOpensearchConfiguration {
  /**
   * Buffer incoming data for the specified period of time, in seconds between 60 to 900, before delivering it to the destination.  The default value is 300s.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfiguration#bufferingInterval
   */
  readonly bufferingInterval?: number;

  /**
   * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfiguration#bufferingSize
   */
  readonly bufferingSize?: number;

  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfiguration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecForProviderOpensearchConfigurationCloudwatchLoggingOptions[];

  /**
   * The endpoint to use when communicating with the cluster. Conflicts with domain_arn.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfiguration#clusterEndpoint
   */
  readonly clusterEndpoint?: string;

  /**
   * The ARN of the Amazon ES domain.  The pattern needs to be arn:.*.  Conflicts with cluster_endpoint.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfiguration#domainArn
   */
  readonly domainArn?: string;

  /**
   * Reference to a Domain in opensearch to populate domainArn.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfiguration#domainArnRef
   */
  readonly domainArnRef?: DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRef;

  /**
   * Selector for a Domain in opensearch to populate domainArn.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfiguration#domainArnSelector
   */
  readonly domainArnSelector?: DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelector;

  /**
   * The Elasticsearch index name.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfiguration#indexName
   */
  readonly indexName?: string;

  /**
   * The Elasticsearch index rotation period.  Index rotation appends a timestamp to the IndexName to facilitate expiration of old data.  Valid values are NoRotation, OneHour, OneDay, OneWeek, and OneMonth.  The default value is OneDay.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfiguration#indexRotationPeriod
   */
  readonly indexRotationPeriod?: string;

  /**
   * The data processing configuration.  More details are given below.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfiguration#processingConfiguration
   */
  readonly processingConfiguration?: DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfiguration[];

  /**
   * The length of time during which Firehose retries delivery after a failure, starting from the initial request and including the first attempt. The default value is 3600 seconds (60 minutes). Firehose does not retry if the value of DurationInSeconds is 0 (zero) or if the first delivery attempt takes longer than the current value.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfiguration#retryDuration
   */
  readonly retryDuration?: number;

  /**
   * The ARN of the AWS credentials.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfiguration#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfiguration#roleArnRef
   */
  readonly roleArnRef?: DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfiguration#roleArnSelector
   */
  readonly roleArnSelector?: DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelector;

  /**
   * The Amazon S3 backup mode.  Valid values are Disabled and Enabled.  Default value is Disabled.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfiguration#s3BackupMode
   */
  readonly s3BackupMode?: string;

  /**
   * The Elasticsearch type name with maximum length of 100 characters.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfiguration#typeName
   */
  readonly typeName?: string;

  /**
   * The VPC configuration for the delivery stream to connect to Elastic Search associated with the VPC. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfiguration#vpcConfig
   */
  readonly vpcConfig?: DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfig[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfiguration(obj: DeliveryStreamSpecForProviderOpensearchConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferingInterval': obj.bufferingInterval,
    'bufferingSize': obj.bufferingSize,
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecForProviderOpensearchConfigurationCloudwatchLoggingOptions(y)),
    'clusterEndpoint': obj.clusterEndpoint,
    'domainArn': obj.domainArn,
    'domainArnRef': toJson_DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRef(obj.domainArnRef),
    'domainArnSelector': toJson_DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelector(obj.domainArnSelector),
    'indexName': obj.indexName,
    'indexRotationPeriod': obj.indexRotationPeriod,
    'processingConfiguration': obj.processingConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfiguration(y)),
    'retryDuration': obj.retryDuration,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelector(obj.roleArnSelector),
    's3BackupMode': obj.s3BackupMode,
    'typeName': obj.typeName,
    'vpcConfig': obj.vpcConfig?.map(y => toJson_DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderRedshiftConfiguration
 */
export interface DeliveryStreamSpecForProviderRedshiftConfiguration {
  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfiguration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecForProviderRedshiftConfigurationCloudwatchLoggingOptions[];

  /**
   * The jdbcurl of the redshift cluster.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfiguration#clusterJdbcurl
   */
  readonly clusterJdbcurl?: string;

  /**
   * Copy options for copying the data from the s3 intermediate bucket into redshift, for example to change the default delimiter. For valid values, see the AWS documentation
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfiguration#copyOptions
   */
  readonly copyOptions?: string;

  /**
   * The data table columns that will be targeted by the copy command.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfiguration#dataTableColumns
   */
  readonly dataTableColumns?: string;

  /**
   * The name of the table in the redshift cluster that the s3 bucket will copy to.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfiguration#dataTableName
   */
  readonly dataTableName?: string;

  /**
   * The password for the username above.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfiguration#passwordSecretRef
   */
  readonly passwordSecretRef: DeliveryStreamSpecForProviderRedshiftConfigurationPasswordSecretRef;

  /**
   * The data processing configuration.  More details are given below.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfiguration#processingConfiguration
   */
  readonly processingConfiguration?: DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfiguration[];

  /**
   * The length of time during which Firehose retries delivery after a failure, starting from the initial request and including the first attempt. The default value is 3600 seconds (60 minutes). Firehose does not retry if the value of DurationInSeconds is 0 (zero) or if the first delivery attempt takes longer than the current value.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfiguration#retryDuration
   */
  readonly retryDuration?: number;

  /**
   * The ARN of the AWS credentials.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfiguration#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfiguration#roleArnRef
   */
  readonly roleArnRef?: DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfiguration#roleArnSelector
   */
  readonly roleArnSelector?: DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelector;

  /**
   * The configuration for backup in Amazon S3. Required if s3_backup_mode is Enabled. Supports the same fields as s3_configuration object.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfiguration#s3BackupConfiguration
   */
  readonly s3BackupConfiguration?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration[];

  /**
   * The Amazon S3 backup mode.  Valid values are Disabled and Enabled.  Default value is Disabled.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfiguration#s3BackupMode
   */
  readonly s3BackupMode?: string;

  /**
   * The username that the firehose delivery stream will assume. It is strongly recommended that the username and password provided is used exclusively for Amazon Kinesis Firehose purposes, and that the permissions for the account are restricted for Amazon Redshift INSERT permissions.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfiguration#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfiguration(obj: DeliveryStreamSpecForProviderRedshiftConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecForProviderRedshiftConfigurationCloudwatchLoggingOptions(y)),
    'clusterJdbcurl': obj.clusterJdbcurl,
    'copyOptions': obj.copyOptions,
    'dataTableColumns': obj.dataTableColumns,
    'dataTableName': obj.dataTableName,
    'passwordSecretRef': toJson_DeliveryStreamSpecForProviderRedshiftConfigurationPasswordSecretRef(obj.passwordSecretRef),
    'processingConfiguration': obj.processingConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfiguration(y)),
    'retryDuration': obj.retryDuration,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelector(obj.roleArnSelector),
    's3BackupConfiguration': obj.s3BackupConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration(y)),
    's3BackupMode': obj.s3BackupMode,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderS3Configuration
 */
export interface DeliveryStreamSpecForProviderS3Configuration {
  /**
   * The ARN of the S3 bucket
   *
   * @schema DeliveryStreamSpecForProviderS3Configuration#bucketArn
   */
  readonly bucketArn?: string;

  /**
   * Reference to a Bucket in s3 to populate bucketArn.
   *
   * @schema DeliveryStreamSpecForProviderS3Configuration#bucketArnRef
   */
  readonly bucketArnRef?: DeliveryStreamSpecForProviderS3ConfigurationBucketArnRef;

  /**
   * Selector for a Bucket in s3 to populate bucketArn.
   *
   * @schema DeliveryStreamSpecForProviderS3Configuration#bucketArnSelector
   */
  readonly bucketArnSelector?: DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelector;

  /**
   * Buffer incoming data for the specified period of time, in seconds, before delivering it to the destination. The default value is 300.
   *
   * @schema DeliveryStreamSpecForProviderS3Configuration#bufferInterval
   */
  readonly bufferInterval?: number;

  /**
   * Buffer incoming data to the specified size, in MBs, before delivering it to the destination. The default value is 5. We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
   *
   * @schema DeliveryStreamSpecForProviderS3Configuration#bufferSize
   */
  readonly bufferSize?: number;

  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderS3Configuration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecForProviderS3ConfigurationCloudwatchLoggingOptions[];

  /**
   * The compression format. If no value is specified, the default is UNCOMPRESSED. Other supported values are GZIP, ZIP, Snappy, & HADOOP_SNAPPY.
   *
   * @schema DeliveryStreamSpecForProviderS3Configuration#compressionFormat
   */
  readonly compressionFormat?: string;

  /**
   * Prefix added to failed records before writing them to S3. Not currently supported for redshift destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see Custom Prefixes for Amazon S3 Objects.
   *
   * @schema DeliveryStreamSpecForProviderS3Configuration#errorOutputPrefix
   */
  readonly errorOutputPrefix?: string;

  /**
   * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will be used.
   *
   * @schema DeliveryStreamSpecForProviderS3Configuration#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
   *
   * @schema DeliveryStreamSpecForProviderS3Configuration#prefix
   */
  readonly prefix?: string;

  /**
   * The ARN of the AWS credentials.
   *
   * @schema DeliveryStreamSpecForProviderS3Configuration#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderS3Configuration#roleArnRef
   */
  readonly roleArnRef?: DeliveryStreamSpecForProviderS3ConfigurationRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderS3Configuration#roleArnSelector
   */
  readonly roleArnSelector?: DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelector;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderS3Configuration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderS3Configuration(obj: DeliveryStreamSpecForProviderS3Configuration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketArn': obj.bucketArn,
    'bucketArnRef': toJson_DeliveryStreamSpecForProviderS3ConfigurationBucketArnRef(obj.bucketArnRef),
    'bucketArnSelector': toJson_DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelector(obj.bucketArnSelector),
    'bufferInterval': obj.bufferInterval,
    'bufferSize': obj.bufferSize,
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecForProviderS3ConfigurationCloudwatchLoggingOptions(y)),
    'compressionFormat': obj.compressionFormat,
    'errorOutputPrefix': obj.errorOutputPrefix,
    'kmsKeyArn': obj.kmsKeyArn,
    'prefix': obj.prefix,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_DeliveryStreamSpecForProviderS3ConfigurationRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelector(obj.roleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderServerSideEncryption
 */
export interface DeliveryStreamSpecForProviderServerSideEncryption {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderServerSideEncryption#enabled
   */
  readonly enabled?: boolean;

  /**
   * Amazon Resource Name (ARN) of the encryption key. Required when key_type is CUSTOMER_MANAGED_CMK.
   *
   * @schema DeliveryStreamSpecForProviderServerSideEncryption#keyArn
   */
  readonly keyArn?: string;

  /**
   * Type of encryption key. Default is AWS_OWNED_CMK. Valid values are AWS_OWNED_CMK and CUSTOMER_MANAGED_CMK
   *
   * @default AWS_OWNED_CMK. Valid values are AWS_OWNED_CMK and CUSTOMER_MANAGED_CMK
   * @schema DeliveryStreamSpecForProviderServerSideEncryption#keyType
   */
  readonly keyType?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderServerSideEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderServerSideEncryption(obj: DeliveryStreamSpecForProviderServerSideEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'keyArn': obj.keyArn,
    'keyType': obj.keyType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderSplunkConfiguration
 */
export interface DeliveryStreamSpecForProviderSplunkConfiguration {
  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfiguration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecForProviderSplunkConfigurationCloudwatchLoggingOptions[];

  /**
   * The amount of time, in seconds between 180 and 600, that Kinesis Firehose waits to receive an acknowledgment from Splunk after it sends it data.
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfiguration#hecAcknowledgmentTimeout
   */
  readonly hecAcknowledgmentTimeout?: number;

  /**
   * The HTTP Event Collector (HEC) endpoint to which Kinesis Firehose sends your data.
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfiguration#hecEndpoint
   */
  readonly hecEndpoint?: string;

  /**
   * The HEC endpoint type. Valid values are Raw or Event. The default value is Raw.
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfiguration#hecEndpointType
   */
  readonly hecEndpointType?: string;

  /**
   * The GUID that you obtain from your Splunk cluster when you create a new HEC endpoint.
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfiguration#hecTokenSecretRef
   */
  readonly hecTokenSecretRef: DeliveryStreamSpecForProviderSplunkConfigurationHecTokenSecretRef;

  /**
   * The data processing configuration.  More details are given below.
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfiguration#processingConfiguration
   */
  readonly processingConfiguration?: DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfiguration[];

  /**
   * The length of time during which Firehose retries delivery after a failure, starting from the initial request and including the first attempt. The default value is 3600 seconds (60 minutes). Firehose does not retry if the value of DurationInSeconds is 0 (zero) or if the first delivery attempt takes longer than the current value.
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfiguration#retryDuration
   */
  readonly retryDuration?: number;

  /**
   * The Amazon S3 backup mode.  Valid values are Disabled and Enabled.  Default value is Disabled.
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfiguration#s3BackupMode
   */
  readonly s3BackupMode?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderSplunkConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderSplunkConfiguration(obj: DeliveryStreamSpecForProviderSplunkConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecForProviderSplunkConfigurationCloudwatchLoggingOptions(y)),
    'hecAcknowledgmentTimeout': obj.hecAcknowledgmentTimeout,
    'hecEndpoint': obj.hecEndpoint,
    'hecEndpointType': obj.hecEndpointType,
    'hecTokenSecretRef': toJson_DeliveryStreamSpecForProviderSplunkConfigurationHecTokenSecretRef(obj.hecTokenSecretRef),
    'processingConfiguration': obj.processingConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfiguration(y)),
    'retryDuration': obj.retryDuration,
    's3BackupMode': obj.s3BackupMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderElasticsearchConfiguration
 */
export interface DeliveryStreamSpecInitProviderElasticsearchConfiguration {
  /**
   * Buffer incoming data for the specified period of time, in seconds between 60 to 900, before delivering it to the destination.  The default value is 300s.
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfiguration#bufferingInterval
   */
  readonly bufferingInterval?: number;

  /**
   * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfiguration#bufferingSize
   */
  readonly bufferingSize?: number;

  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfiguration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecInitProviderElasticsearchConfigurationCloudwatchLoggingOptions[];

  /**
   * The endpoint to use when communicating with the cluster. Conflicts with domain_arn.
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfiguration#clusterEndpoint
   */
  readonly clusterEndpoint?: string;

  /**
   * The Elasticsearch index name.
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfiguration#indexName
   */
  readonly indexName?: string;

  /**
   * The Elasticsearch index rotation period.  Index rotation appends a timestamp to the IndexName to facilitate expiration of old data.  Valid values are NoRotation, OneHour, OneDay, OneWeek, and OneMonth.  The default value is OneDay.
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfiguration#indexRotationPeriod
   */
  readonly indexRotationPeriod?: string;

  /**
   * The data processing configuration.  More details are given below.
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfiguration#processingConfiguration
   */
  readonly processingConfiguration?: DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfiguration[];

  /**
   * The length of time during which Firehose retries delivery after a failure, starting from the initial request and including the first attempt. The default value is 3600 seconds (60 minutes). Firehose does not retry if the value of DurationInSeconds is 0 (zero) or if the first delivery attempt takes longer than the current value.
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfiguration#retryDuration
   */
  readonly retryDuration?: number;

  /**
   * The Amazon S3 backup mode.  Valid values are Disabled and Enabled.  Default value is Disabled.
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfiguration#s3BackupMode
   */
  readonly s3BackupMode?: string;

  /**
   * The Elasticsearch type name with maximum length of 100 characters.
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfiguration#typeName
   */
  readonly typeName?: string;

  /**
   * The VPC configuration for the delivery stream to connect to Elastic Search associated with the VPC. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfiguration#vpcConfig
   */
  readonly vpcConfig?: DeliveryStreamSpecInitProviderElasticsearchConfigurationVpcConfig[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderElasticsearchConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderElasticsearchConfiguration(obj: DeliveryStreamSpecInitProviderElasticsearchConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferingInterval': obj.bufferingInterval,
    'bufferingSize': obj.bufferingSize,
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecInitProviderElasticsearchConfigurationCloudwatchLoggingOptions(y)),
    'clusterEndpoint': obj.clusterEndpoint,
    'indexName': obj.indexName,
    'indexRotationPeriod': obj.indexRotationPeriod,
    'processingConfiguration': obj.processingConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfiguration(y)),
    'retryDuration': obj.retryDuration,
    's3BackupMode': obj.s3BackupMode,
    'typeName': obj.typeName,
    'vpcConfig': obj.vpcConfig?.map(y => toJson_DeliveryStreamSpecInitProviderElasticsearchConfigurationVpcConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3Configuration
 */
export interface DeliveryStreamSpecInitProviderExtendedS3Configuration {
  /**
   * Buffer incoming data for the specified period of time, in seconds, before delivering it to the destination. The default value is 300.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3Configuration#bufferInterval
   */
  readonly bufferInterval?: number;

  /**
   * Buffer incoming data to the specified size, in MBs, before delivering it to the destination. The default value is 5. We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3Configuration#bufferSize
   */
  readonly bufferSize?: number;

  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3Configuration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecInitProviderExtendedS3ConfigurationCloudwatchLoggingOptions[];

  /**
   * The compression format. If no value is specified, the default is UNCOMPRESSED. Other supported values are GZIP, ZIP, Snappy, & HADOOP_SNAPPY.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3Configuration#compressionFormat
   */
  readonly compressionFormat?: string;

  /**
   * Nested argument for the serializer, deserializer, and schema for converting data from the JSON format to the Parquet or ORC format before writing it to Amazon S3. More details given below.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3Configuration#dataFormatConversionConfiguration
   */
  readonly dataFormatConversionConfiguration?: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfiguration[];

  /**
   * The configuration for dynamic partitioning. See Dynamic Partitioning Configuration below for more details. Required when using dynamic partitioning.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3Configuration#dynamicPartitioningConfiguration
   */
  readonly dynamicPartitioningConfiguration?: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDynamicPartitioningConfiguration[];

  /**
   * Prefix added to failed records before writing them to S3. Not currently supported for redshift destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see Custom Prefixes for Amazon S3 Objects.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3Configuration#errorOutputPrefix
   */
  readonly errorOutputPrefix?: string;

  /**
   * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will be used.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3Configuration#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3Configuration#prefix
   */
  readonly prefix?: string;

  /**
   * The data processing configuration.  More details are given below.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3Configuration#processingConfiguration
   */
  readonly processingConfiguration?: DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfiguration[];

  /**
   * The configuration for backup in Amazon S3. Required if s3_backup_mode is Enabled. Supports the same fields as s3_configuration object.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3Configuration#s3BackupConfiguration
   */
  readonly s3BackupConfiguration?: DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfiguration[];

  /**
   * The Amazon S3 backup mode.  Valid values are Disabled and Enabled.  Default value is Disabled.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3Configuration#s3BackupMode
   */
  readonly s3BackupMode?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3Configuration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3Configuration(obj: DeliveryStreamSpecInitProviderExtendedS3Configuration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferInterval': obj.bufferInterval,
    'bufferSize': obj.bufferSize,
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationCloudwatchLoggingOptions(y)),
    'compressionFormat': obj.compressionFormat,
    'dataFormatConversionConfiguration': obj.dataFormatConversionConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfiguration(y)),
    'dynamicPartitioningConfiguration': obj.dynamicPartitioningConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDynamicPartitioningConfiguration(y)),
    'errorOutputPrefix': obj.errorOutputPrefix,
    'kmsKeyArn': obj.kmsKeyArn,
    'prefix': obj.prefix,
    'processingConfiguration': obj.processingConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfiguration(y)),
    's3BackupConfiguration': obj.s3BackupConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfiguration(y)),
    's3BackupMode': obj.s3BackupMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderHttpEndpointConfiguration
 */
export interface DeliveryStreamSpecInitProviderHttpEndpointConfiguration {
  /**
   * Buffer incoming data for the specified period of time, in seconds between 60 to 900, before delivering it to the destination.  The default value is 300s.
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfiguration#bufferingInterval
   */
  readonly bufferingInterval?: number;

  /**
   * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfiguration#bufferingSize
   */
  readonly bufferingSize?: number;

  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfiguration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecInitProviderHttpEndpointConfigurationCloudwatchLoggingOptions[];

  /**
   * The HTTP endpoint name.
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfiguration#name
   */
  readonly name?: string;

  /**
   * The data processing configuration.  More details are given below.
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfiguration#processingConfiguration
   */
  readonly processingConfiguration?: DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfiguration[];

  /**
   * The request configuration.  More details are given below.
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfiguration#requestConfiguration
   */
  readonly requestConfiguration?: DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfiguration[];

  /**
   * The length of time during which Firehose retries delivery after a failure, starting from the initial request and including the first attempt. The default value is 3600 seconds (60 minutes). Firehose does not retry if the value of DurationInSeconds is 0 (zero) or if the first delivery attempt takes longer than the current value.
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfiguration#retryDuration
   */
  readonly retryDuration?: number;

  /**
   * The Amazon S3 backup mode.  Valid values are Disabled and Enabled.  Default value is Disabled.
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfiguration#s3BackupMode
   */
  readonly s3BackupMode?: string;

  /**
   * The HTTP endpoint URL to which Kinesis Firehose sends your data.
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfiguration#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderHttpEndpointConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderHttpEndpointConfiguration(obj: DeliveryStreamSpecInitProviderHttpEndpointConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferingInterval': obj.bufferingInterval,
    'bufferingSize': obj.bufferingSize,
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecInitProviderHttpEndpointConfigurationCloudwatchLoggingOptions(y)),
    'name': obj.name,
    'processingConfiguration': obj.processingConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfiguration(y)),
    'requestConfiguration': obj.requestConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfiguration(y)),
    'retryDuration': obj.retryDuration,
    's3BackupMode': obj.s3BackupMode,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderKinesisSourceConfiguration
 */
export interface DeliveryStreamSpecInitProviderKinesisSourceConfiguration {
  /**
   * The kinesis stream used as the source of the firehose delivery stream.
   *
   * @schema DeliveryStreamSpecInitProviderKinesisSourceConfiguration#kinesisStreamArn
   */
  readonly kinesisStreamArn?: string;

  /**
   * The ARN of the AWS credentials.
   *
   * @schema DeliveryStreamSpecInitProviderKinesisSourceConfiguration#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderKinesisSourceConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderKinesisSourceConfiguration(obj: DeliveryStreamSpecInitProviderKinesisSourceConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kinesisStreamArn': obj.kinesisStreamArn,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderOpensearchConfiguration
 */
export interface DeliveryStreamSpecInitProviderOpensearchConfiguration {
  /**
   * Buffer incoming data for the specified period of time, in seconds between 60 to 900, before delivering it to the destination.  The default value is 300s.
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfiguration#bufferingInterval
   */
  readonly bufferingInterval?: number;

  /**
   * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfiguration#bufferingSize
   */
  readonly bufferingSize?: number;

  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfiguration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecInitProviderOpensearchConfigurationCloudwatchLoggingOptions[];

  /**
   * The endpoint to use when communicating with the cluster. Conflicts with domain_arn.
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfiguration#clusterEndpoint
   */
  readonly clusterEndpoint?: string;

  /**
   * The Elasticsearch index name.
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfiguration#indexName
   */
  readonly indexName?: string;

  /**
   * The Elasticsearch index rotation period.  Index rotation appends a timestamp to the IndexName to facilitate expiration of old data.  Valid values are NoRotation, OneHour, OneDay, OneWeek, and OneMonth.  The default value is OneDay.
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfiguration#indexRotationPeriod
   */
  readonly indexRotationPeriod?: string;

  /**
   * The data processing configuration.  More details are given below.
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfiguration#processingConfiguration
   */
  readonly processingConfiguration?: DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfiguration[];

  /**
   * The length of time during which Firehose retries delivery after a failure, starting from the initial request and including the first attempt. The default value is 3600 seconds (60 minutes). Firehose does not retry if the value of DurationInSeconds is 0 (zero) or if the first delivery attempt takes longer than the current value.
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfiguration#retryDuration
   */
  readonly retryDuration?: number;

  /**
   * The Amazon S3 backup mode.  Valid values are Disabled and Enabled.  Default value is Disabled.
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfiguration#s3BackupMode
   */
  readonly s3BackupMode?: string;

  /**
   * The Elasticsearch type name with maximum length of 100 characters.
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfiguration#typeName
   */
  readonly typeName?: string;

  /**
   * The VPC configuration for the delivery stream to connect to Elastic Search associated with the VPC. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfiguration#vpcConfig
   */
  readonly vpcConfig?: DeliveryStreamSpecInitProviderOpensearchConfigurationVpcConfig[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderOpensearchConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderOpensearchConfiguration(obj: DeliveryStreamSpecInitProviderOpensearchConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferingInterval': obj.bufferingInterval,
    'bufferingSize': obj.bufferingSize,
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecInitProviderOpensearchConfigurationCloudwatchLoggingOptions(y)),
    'clusterEndpoint': obj.clusterEndpoint,
    'indexName': obj.indexName,
    'indexRotationPeriod': obj.indexRotationPeriod,
    'processingConfiguration': obj.processingConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfiguration(y)),
    'retryDuration': obj.retryDuration,
    's3BackupMode': obj.s3BackupMode,
    'typeName': obj.typeName,
    'vpcConfig': obj.vpcConfig?.map(y => toJson_DeliveryStreamSpecInitProviderOpensearchConfigurationVpcConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderRedshiftConfiguration
 */
export interface DeliveryStreamSpecInitProviderRedshiftConfiguration {
  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfiguration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecInitProviderRedshiftConfigurationCloudwatchLoggingOptions[];

  /**
   * The jdbcurl of the redshift cluster.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfiguration#clusterJdbcurl
   */
  readonly clusterJdbcurl?: string;

  /**
   * Copy options for copying the data from the s3 intermediate bucket into redshift, for example to change the default delimiter. For valid values, see the AWS documentation
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfiguration#copyOptions
   */
  readonly copyOptions?: string;

  /**
   * The data table columns that will be targeted by the copy command.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfiguration#dataTableColumns
   */
  readonly dataTableColumns?: string;

  /**
   * The name of the table in the redshift cluster that the s3 bucket will copy to.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfiguration#dataTableName
   */
  readonly dataTableName?: string;

  /**
   * The data processing configuration.  More details are given below.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfiguration#processingConfiguration
   */
  readonly processingConfiguration?: DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfiguration[];

  /**
   * The length of time during which Firehose retries delivery after a failure, starting from the initial request and including the first attempt. The default value is 3600 seconds (60 minutes). Firehose does not retry if the value of DurationInSeconds is 0 (zero) or if the first delivery attempt takes longer than the current value.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfiguration#retryDuration
   */
  readonly retryDuration?: number;

  /**
   * The configuration for backup in Amazon S3. Required if s3_backup_mode is Enabled. Supports the same fields as s3_configuration object.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfiguration#s3BackupConfiguration
   */
  readonly s3BackupConfiguration?: DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfiguration[];

  /**
   * The Amazon S3 backup mode.  Valid values are Disabled and Enabled.  Default value is Disabled.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfiguration#s3BackupMode
   */
  readonly s3BackupMode?: string;

  /**
   * The username that the firehose delivery stream will assume. It is strongly recommended that the username and password provided is used exclusively for Amazon Kinesis Firehose purposes, and that the permissions for the account are restricted for Amazon Redshift INSERT permissions.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfiguration#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderRedshiftConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderRedshiftConfiguration(obj: DeliveryStreamSpecInitProviderRedshiftConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecInitProviderRedshiftConfigurationCloudwatchLoggingOptions(y)),
    'clusterJdbcurl': obj.clusterJdbcurl,
    'copyOptions': obj.copyOptions,
    'dataTableColumns': obj.dataTableColumns,
    'dataTableName': obj.dataTableName,
    'processingConfiguration': obj.processingConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfiguration(y)),
    'retryDuration': obj.retryDuration,
    's3BackupConfiguration': obj.s3BackupConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfiguration(y)),
    's3BackupMode': obj.s3BackupMode,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderS3Configuration
 */
export interface DeliveryStreamSpecInitProviderS3Configuration {
  /**
   * Buffer incoming data for the specified period of time, in seconds, before delivering it to the destination. The default value is 300.
   *
   * @schema DeliveryStreamSpecInitProviderS3Configuration#bufferInterval
   */
  readonly bufferInterval?: number;

  /**
   * Buffer incoming data to the specified size, in MBs, before delivering it to the destination. The default value is 5. We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
   *
   * @schema DeliveryStreamSpecInitProviderS3Configuration#bufferSize
   */
  readonly bufferSize?: number;

  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderS3Configuration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecInitProviderS3ConfigurationCloudwatchLoggingOptions[];

  /**
   * The compression format. If no value is specified, the default is UNCOMPRESSED. Other supported values are GZIP, ZIP, Snappy, & HADOOP_SNAPPY.
   *
   * @schema DeliveryStreamSpecInitProviderS3Configuration#compressionFormat
   */
  readonly compressionFormat?: string;

  /**
   * Prefix added to failed records before writing them to S3. Not currently supported for redshift destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see Custom Prefixes for Amazon S3 Objects.
   *
   * @schema DeliveryStreamSpecInitProviderS3Configuration#errorOutputPrefix
   */
  readonly errorOutputPrefix?: string;

  /**
   * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will be used.
   *
   * @schema DeliveryStreamSpecInitProviderS3Configuration#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
   *
   * @schema DeliveryStreamSpecInitProviderS3Configuration#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderS3Configuration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderS3Configuration(obj: DeliveryStreamSpecInitProviderS3Configuration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferInterval': obj.bufferInterval,
    'bufferSize': obj.bufferSize,
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecInitProviderS3ConfigurationCloudwatchLoggingOptions(y)),
    'compressionFormat': obj.compressionFormat,
    'errorOutputPrefix': obj.errorOutputPrefix,
    'kmsKeyArn': obj.kmsKeyArn,
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderServerSideEncryption
 */
export interface DeliveryStreamSpecInitProviderServerSideEncryption {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderServerSideEncryption#enabled
   */
  readonly enabled?: boolean;

  /**
   * Amazon Resource Name (ARN) of the encryption key. Required when key_type is CUSTOMER_MANAGED_CMK.
   *
   * @schema DeliveryStreamSpecInitProviderServerSideEncryption#keyArn
   */
  readonly keyArn?: string;

  /**
   * Type of encryption key. Default is AWS_OWNED_CMK. Valid values are AWS_OWNED_CMK and CUSTOMER_MANAGED_CMK
   *
   * @default AWS_OWNED_CMK. Valid values are AWS_OWNED_CMK and CUSTOMER_MANAGED_CMK
   * @schema DeliveryStreamSpecInitProviderServerSideEncryption#keyType
   */
  readonly keyType?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderServerSideEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderServerSideEncryption(obj: DeliveryStreamSpecInitProviderServerSideEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'keyArn': obj.keyArn,
    'keyType': obj.keyType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderSplunkConfiguration
 */
export interface DeliveryStreamSpecInitProviderSplunkConfiguration {
  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderSplunkConfiguration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecInitProviderSplunkConfigurationCloudwatchLoggingOptions[];

  /**
   * The amount of time, in seconds between 180 and 600, that Kinesis Firehose waits to receive an acknowledgment from Splunk after it sends it data.
   *
   * @schema DeliveryStreamSpecInitProviderSplunkConfiguration#hecAcknowledgmentTimeout
   */
  readonly hecAcknowledgmentTimeout?: number;

  /**
   * The HTTP Event Collector (HEC) endpoint to which Kinesis Firehose sends your data.
   *
   * @schema DeliveryStreamSpecInitProviderSplunkConfiguration#hecEndpoint
   */
  readonly hecEndpoint?: string;

  /**
   * The HEC endpoint type. Valid values are Raw or Event. The default value is Raw.
   *
   * @schema DeliveryStreamSpecInitProviderSplunkConfiguration#hecEndpointType
   */
  readonly hecEndpointType?: string;

  /**
   * The data processing configuration.  More details are given below.
   *
   * @schema DeliveryStreamSpecInitProviderSplunkConfiguration#processingConfiguration
   */
  readonly processingConfiguration?: DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfiguration[];

  /**
   * The length of time during which Firehose retries delivery after a failure, starting from the initial request and including the first attempt. The default value is 3600 seconds (60 minutes). Firehose does not retry if the value of DurationInSeconds is 0 (zero) or if the first delivery attempt takes longer than the current value.
   *
   * @schema DeliveryStreamSpecInitProviderSplunkConfiguration#retryDuration
   */
  readonly retryDuration?: number;

  /**
   * The Amazon S3 backup mode.  Valid values are Disabled and Enabled.  Default value is Disabled.
   *
   * @schema DeliveryStreamSpecInitProviderSplunkConfiguration#s3BackupMode
   */
  readonly s3BackupMode?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderSplunkConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderSplunkConfiguration(obj: DeliveryStreamSpecInitProviderSplunkConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecInitProviderSplunkConfigurationCloudwatchLoggingOptions(y)),
    'hecAcknowledgmentTimeout': obj.hecAcknowledgmentTimeout,
    'hecEndpoint': obj.hecEndpoint,
    'hecEndpointType': obj.hecEndpointType,
    'processingConfiguration': obj.processingConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfiguration(y)),
    'retryDuration': obj.retryDuration,
    's3BackupMode': obj.s3BackupMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecProviderConfigRefPolicy
 */
export interface DeliveryStreamSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecProviderConfigRefPolicy(obj: DeliveryStreamSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DeliveryStreamSpecPublishConnectionDetailsToConfigRef
 */
export interface DeliveryStreamSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DeliveryStreamSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecPublishConnectionDetailsToConfigRef(obj: DeliveryStreamSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DeliveryStreamSpecPublishConnectionDetailsToMetadata
 */
export interface DeliveryStreamSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeliveryStreamSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeliveryStreamSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DeliveryStreamSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecPublishConnectionDetailsToMetadata(obj: DeliveryStreamSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecForProviderElasticsearchConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Domain in elasticsearch to populate domainArn.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRef
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRef#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRef(obj: DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Domain in elasticsearch to populate domainArn.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelector
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelector#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelector(obj: DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfiguration
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfiguration {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Array of data processors. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfiguration#processors
   */
  readonly processors?: DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessors[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfiguration(obj: DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'processors': obj.processors?.map(y => toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRef
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRef#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRef(obj: DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelector
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelector#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelector(obj: DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfig
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfig {
  /**
   * The ARN of the AWS credentials.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfig#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfig#roleArnRef
   */
  readonly roleArnRef?: DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfig#roleArnSelector
   */
  readonly roleArnSelector?: DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelector;

  /**
   * A list of security group IDs to associate with Kinesis Firehose.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfig#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * A list of subnet IDs to associate with Kinesis Firehose.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfig#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfig(obj: DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelector(obj.roleArnSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucketArn.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRef
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRef#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRef(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucketArn.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelector
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelector#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelector(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfiguration
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfiguration {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Nested argument that specifies the deserializer that you want Kinesis Data Firehose to use to convert the format of your data from JSON. More details below.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfiguration#inputFormatConfiguration
   */
  readonly inputFormatConfiguration?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration[];

  /**
   * Nested argument that specifies the serializer that you want Kinesis Data Firehose to use to convert the format of your data to the Parquet or ORC format. More details below.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfiguration#outputFormatConfiguration
   */
  readonly outputFormatConfiguration?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration[];

  /**
   * Nested argument that specifies the AWS Glue Data Catalog table that contains the column information. More details below.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfiguration#schemaConfiguration
   */
  readonly schemaConfiguration?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfiguration(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'inputFormatConfiguration': obj.inputFormatConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration(y)),
    'outputFormatConfiguration': obj.outputFormatConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration(y)),
    'schemaConfiguration': obj.schemaConfiguration?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDynamicPartitioningConfiguration
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDynamicPartitioningConfiguration {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDynamicPartitioningConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * The length of time during which Firehose retries delivery after a failure, starting from the initial request and including the first attempt. The default value is 3600 seconds (60 minutes). Firehose does not retry if the value of DurationInSeconds is 0 (zero) or if the first delivery attempt takes longer than the current value.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDynamicPartitioningConfiguration#retryDuration
   */
  readonly retryDuration?: number;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDynamicPartitioningConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDynamicPartitioningConfiguration(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDynamicPartitioningConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'retryDuration': obj.retryDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfiguration
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfiguration {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Array of data processors. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfiguration#processors
   */
  readonly processors?: DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessors[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfiguration(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'processors': obj.processors?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRef
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRef#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRef(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelector
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelector#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelector(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfiguration
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfiguration {
  /**
   * The ARN of the S3 bucket
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfiguration#bucketArn
   */
  readonly bucketArn?: string;

  /**
   * Buffer incoming data for the specified period of time, in seconds, before delivering it to the destination. The default value is 300.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfiguration#bufferInterval
   */
  readonly bufferInterval?: number;

  /**
   * Buffer incoming data to the specified size, in MBs, before delivering it to the destination. The default value is 5. We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfiguration#bufferSize
   */
  readonly bufferSize?: number;

  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfiguration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions[];

  /**
   * The compression format. If no value is specified, the default is UNCOMPRESSED. Other supported values are GZIP, ZIP, Snappy, & HADOOP_SNAPPY.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfiguration#compressionFormat
   */
  readonly compressionFormat?: string;

  /**
   * Prefix added to failed records before writing them to S3. Not currently supported for redshift destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see Custom Prefixes for Amazon S3 Objects.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfiguration#errorOutputPrefix
   */
  readonly errorOutputPrefix?: string;

  /**
   * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will be used.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfiguration#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfiguration#prefix
   */
  readonly prefix?: string;

  /**
   * The ARN of the AWS credentials.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfiguration#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfiguration(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketArn': obj.bucketArn,
    'bufferInterval': obj.bufferInterval,
    'bufferSize': obj.bufferSize,
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions(y)),
    'compressionFormat': obj.compressionFormat,
    'errorOutputPrefix': obj.errorOutputPrefix,
    'kmsKeyArn': obj.kmsKeyArn,
    'prefix': obj.prefix,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The access key required for Kinesis Firehose to authenticate with the HTTP endpoint selected as the destination.
 *
 * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationAccessKeySecretRef
 */
export interface DeliveryStreamSpecForProviderHttpEndpointConfigurationAccessKeySecretRef {
  /**
   * The key to select.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationAccessKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationAccessKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationAccessKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderHttpEndpointConfigurationAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationAccessKeySecretRef(obj: DeliveryStreamSpecForProviderHttpEndpointConfigurationAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecForProviderHttpEndpointConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderHttpEndpointConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecForProviderHttpEndpointConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfiguration
 */
export interface DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfiguration {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Array of data processors. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfiguration#processors
   */
  readonly processors?: DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessors[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfiguration(obj: DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'processors': obj.processors?.map(y => toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfiguration
 */
export interface DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfiguration {
  /**
   * Describes the metadata sent to the HTTP endpoint destination. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfiguration#commonAttributes
   */
  readonly commonAttributes?: DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes[];

  /**
   * Kinesis Data Firehose uses the content encoding to compress the body of a request before sending the request to the destination. Valid values are NONE and GZIP.  Default value is NONE.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfiguration#contentEncoding
   */
  readonly contentEncoding?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfiguration(obj: DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonAttributes': obj.commonAttributes?.map(y => toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes(y)),
    'contentEncoding': obj.contentEncoding,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRef
 */
export interface DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRef#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRef(obj: DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelector
 */
export interface DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelector#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelector(obj: DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecForProviderOpensearchConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecForProviderOpensearchConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Domain in opensearch to populate domainArn.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRef
 */
export interface DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRef#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRef(obj: DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Domain in opensearch to populate domainArn.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelector
 */
export interface DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelector#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelector(obj: DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfiguration
 */
export interface DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfiguration {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Array of data processors. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfiguration#processors
   */
  readonly processors?: DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessors[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfiguration(obj: DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'processors': obj.processors?.map(y => toJson_DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRef
 */
export interface DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRef#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRef(obj: DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelector
 */
export interface DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelector#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelector(obj: DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfig
 */
export interface DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfig {
  /**
   * The ARN of the AWS credentials.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfig#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfig#roleArnRef
   */
  readonly roleArnRef?: DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfig#roleArnSelector
   */
  readonly roleArnSelector?: DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelector;

  /**
   * A list of security group IDs to associate with Kinesis Firehose.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfig#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * A list of subnet IDs to associate with Kinesis Firehose.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfig#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfig(obj: DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelector(obj.roleArnSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecForProviderRedshiftConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The password for the username above.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationPasswordSecretRef
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationPasswordSecretRef(obj: DeliveryStreamSpecForProviderRedshiftConfigurationPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfiguration
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfiguration {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Array of data processors. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfiguration#processors
   */
  readonly processors?: DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessors[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfiguration(obj: DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'processors': obj.processors?.map(y => toJson_DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRef
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRef#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRef(obj: DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelector
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelector#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelector(obj: DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration {
  /**
   * The ARN of the S3 bucket
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration#bucketArn
   */
  readonly bucketArn?: string;

  /**
   * Reference to a Bucket in s3 to populate bucketArn.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration#bucketArnRef
   */
  readonly bucketArnRef?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRef;

  /**
   * Selector for a Bucket in s3 to populate bucketArn.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration#bucketArnSelector
   */
  readonly bucketArnSelector?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelector;

  /**
   * Buffer incoming data for the specified period of time, in seconds, before delivering it to the destination. The default value is 300.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration#bufferInterval
   */
  readonly bufferInterval?: number;

  /**
   * Buffer incoming data to the specified size, in MBs, before delivering it to the destination. The default value is 5. We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration#bufferSize
   */
  readonly bufferSize?: number;

  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions[];

  /**
   * The compression format. If no value is specified, the default is UNCOMPRESSED. Other supported values are GZIP, ZIP, Snappy, & HADOOP_SNAPPY.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration#compressionFormat
   */
  readonly compressionFormat?: string;

  /**
   * Prefix added to failed records before writing them to S3. Not currently supported for redshift destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see Custom Prefixes for Amazon S3 Objects.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration#errorOutputPrefix
   */
  readonly errorOutputPrefix?: string;

  /**
   * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will be used.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration#prefix
   */
  readonly prefix?: string;

  /**
   * The ARN of the AWS credentials.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration#roleArnRef
   */
  readonly roleArnRef?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration#roleArnSelector
   */
  readonly roleArnSelector?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelector;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration(obj: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketArn': obj.bucketArn,
    'bucketArnRef': toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRef(obj.bucketArnRef),
    'bucketArnSelector': toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelector(obj.bucketArnSelector),
    'bufferInterval': obj.bufferInterval,
    'bufferSize': obj.bufferSize,
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions(y)),
    'compressionFormat': obj.compressionFormat,
    'errorOutputPrefix': obj.errorOutputPrefix,
    'kmsKeyArn': obj.kmsKeyArn,
    'prefix': obj.prefix,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelector(obj.roleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucketArn.
 *
 * @schema DeliveryStreamSpecForProviderS3ConfigurationBucketArnRef
 */
export interface DeliveryStreamSpecForProviderS3ConfigurationBucketArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationBucketArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationBucketArnRef#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderS3ConfigurationBucketArnRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderS3ConfigurationBucketArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderS3ConfigurationBucketArnRef(obj: DeliveryStreamSpecForProviderS3ConfigurationBucketArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecForProviderS3ConfigurationBucketArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucketArn.
 *
 * @schema DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelector
 */
export interface DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelector#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelector(obj: DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderS3ConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecForProviderS3ConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderS3ConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderS3ConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderS3ConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecForProviderS3ConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderS3ConfigurationRoleArnRef
 */
export interface DeliveryStreamSpecForProviderS3ConfigurationRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationRoleArnRef#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderS3ConfigurationRoleArnRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderS3ConfigurationRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderS3ConfigurationRoleArnRef(obj: DeliveryStreamSpecForProviderS3ConfigurationRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecForProviderS3ConfigurationRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelector
 */
export interface DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelector#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelector(obj: DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderSplunkConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecForProviderSplunkConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderSplunkConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderSplunkConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderSplunkConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecForProviderSplunkConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The GUID that you obtain from your Splunk cluster when you create a new HEC endpoint.
 *
 * @schema DeliveryStreamSpecForProviderSplunkConfigurationHecTokenSecretRef
 */
export interface DeliveryStreamSpecForProviderSplunkConfigurationHecTokenSecretRef {
  /**
   * The key to select.
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfigurationHecTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfigurationHecTokenSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfigurationHecTokenSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderSplunkConfigurationHecTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderSplunkConfigurationHecTokenSecretRef(obj: DeliveryStreamSpecForProviderSplunkConfigurationHecTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfiguration
 */
export interface DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfiguration {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Array of data processors. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfiguration#processors
   */
  readonly processors?: DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessors[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfiguration(obj: DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'processors': obj.processors?.map(y => toJson_DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderElasticsearchConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecInitProviderElasticsearchConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderElasticsearchConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderElasticsearchConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecInitProviderElasticsearchConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfiguration
 */
export interface DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfiguration {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Array of data processors. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfiguration#processors
   */
  readonly processors?: DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessors[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfiguration(obj: DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'processors': obj.processors?.map(y => toJson_DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderElasticsearchConfigurationVpcConfig
 */
export interface DeliveryStreamSpecInitProviderElasticsearchConfigurationVpcConfig {
  /**
   * A list of security group IDs to associate with Kinesis Firehose.
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfigurationVpcConfig#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * A list of subnet IDs to associate with Kinesis Firehose.
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfigurationVpcConfig#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderElasticsearchConfigurationVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderElasticsearchConfigurationVpcConfig(obj: DeliveryStreamSpecInitProviderElasticsearchConfigurationVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecInitProviderExtendedS3ConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3ConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecInitProviderExtendedS3ConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfiguration
 */
export interface DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfiguration {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Nested argument that specifies the deserializer that you want Kinesis Data Firehose to use to convert the format of your data from JSON. More details below.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfiguration#inputFormatConfiguration
   */
  readonly inputFormatConfiguration?: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration[];

  /**
   * Nested argument that specifies the serializer that you want Kinesis Data Firehose to use to convert the format of your data to the Parquet or ORC format. More details below.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfiguration#outputFormatConfiguration
   */
  readonly outputFormatConfiguration?: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration[];

  /**
   * Nested argument that specifies the AWS Glue Data Catalog table that contains the column information. More details below.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfiguration#schemaConfiguration
   */
  readonly schemaConfiguration?: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfiguration(obj: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'inputFormatConfiguration': obj.inputFormatConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration(y)),
    'outputFormatConfiguration': obj.outputFormatConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration(y)),
    'schemaConfiguration': obj.schemaConfiguration?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDynamicPartitioningConfiguration
 */
export interface DeliveryStreamSpecInitProviderExtendedS3ConfigurationDynamicPartitioningConfiguration {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDynamicPartitioningConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * The length of time during which Firehose retries delivery after a failure, starting from the initial request and including the first attempt. The default value is 3600 seconds (60 minutes). Firehose does not retry if the value of DurationInSeconds is 0 (zero) or if the first delivery attempt takes longer than the current value.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDynamicPartitioningConfiguration#retryDuration
   */
  readonly retryDuration?: number;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3ConfigurationDynamicPartitioningConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDynamicPartitioningConfiguration(obj: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDynamicPartitioningConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'retryDuration': obj.retryDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfiguration
 */
export interface DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfiguration {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Array of data processors. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfiguration#processors
   */
  readonly processors?: DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessors[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfiguration(obj: DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'processors': obj.processors?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfiguration
 */
export interface DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfiguration {
  /**
   * The ARN of the S3 bucket
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfiguration#bucketArn
   */
  readonly bucketArn?: string;

  /**
   * Buffer incoming data for the specified period of time, in seconds, before delivering it to the destination. The default value is 300.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfiguration#bufferInterval
   */
  readonly bufferInterval?: number;

  /**
   * Buffer incoming data to the specified size, in MBs, before delivering it to the destination. The default value is 5. We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfiguration#bufferSize
   */
  readonly bufferSize?: number;

  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfiguration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions[];

  /**
   * The compression format. If no value is specified, the default is UNCOMPRESSED. Other supported values are GZIP, ZIP, Snappy, & HADOOP_SNAPPY.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfiguration#compressionFormat
   */
  readonly compressionFormat?: string;

  /**
   * Prefix added to failed records before writing them to S3. Not currently supported for redshift destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see Custom Prefixes for Amazon S3 Objects.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfiguration#errorOutputPrefix
   */
  readonly errorOutputPrefix?: string;

  /**
   * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will be used.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfiguration#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfiguration#prefix
   */
  readonly prefix?: string;

  /**
   * The ARN of the AWS credentials.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfiguration#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfiguration(obj: DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketArn': obj.bucketArn,
    'bufferInterval': obj.bufferInterval,
    'bufferSize': obj.bufferSize,
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions(y)),
    'compressionFormat': obj.compressionFormat,
    'errorOutputPrefix': obj.errorOutputPrefix,
    'kmsKeyArn': obj.kmsKeyArn,
    'prefix': obj.prefix,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecInitProviderHttpEndpointConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderHttpEndpointConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderHttpEndpointConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecInitProviderHttpEndpointConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfiguration
 */
export interface DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfiguration {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Array of data processors. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfiguration#processors
   */
  readonly processors?: DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessors[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfiguration(obj: DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'processors': obj.processors?.map(y => toJson_DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfiguration
 */
export interface DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfiguration {
  /**
   * Describes the metadata sent to the HTTP endpoint destination. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfiguration#commonAttributes
   */
  readonly commonAttributes?: DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes[];

  /**
   * Kinesis Data Firehose uses the content encoding to compress the body of a request before sending the request to the destination. Valid values are NONE and GZIP.  Default value is NONE.
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfiguration#contentEncoding
   */
  readonly contentEncoding?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfiguration(obj: DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonAttributes': obj.commonAttributes?.map(y => toJson_DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes(y)),
    'contentEncoding': obj.contentEncoding,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderOpensearchConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecInitProviderOpensearchConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderOpensearchConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderOpensearchConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderOpensearchConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecInitProviderOpensearchConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfiguration
 */
export interface DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfiguration {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Array of data processors. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfiguration#processors
   */
  readonly processors?: DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessors[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfiguration(obj: DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'processors': obj.processors?.map(y => toJson_DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderOpensearchConfigurationVpcConfig
 */
export interface DeliveryStreamSpecInitProviderOpensearchConfigurationVpcConfig {
  /**
   * A list of security group IDs to associate with Kinesis Firehose.
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfigurationVpcConfig#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * A list of subnet IDs to associate with Kinesis Firehose.
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfigurationVpcConfig#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderOpensearchConfigurationVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderOpensearchConfigurationVpcConfig(obj: DeliveryStreamSpecInitProviderOpensearchConfigurationVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecInitProviderRedshiftConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderRedshiftConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderRedshiftConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecInitProviderRedshiftConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfiguration
 */
export interface DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfiguration {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Array of data processors. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfiguration#processors
   */
  readonly processors?: DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessors[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfiguration(obj: DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'processors': obj.processors?.map(y => toJson_DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfiguration
 */
export interface DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfiguration {
  /**
   * Buffer incoming data for the specified period of time, in seconds, before delivering it to the destination. The default value is 300.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfiguration#bufferInterval
   */
  readonly bufferInterval?: number;

  /**
   * Buffer incoming data to the specified size, in MBs, before delivering it to the destination. The default value is 5. We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfiguration#bufferSize
   */
  readonly bufferSize?: number;

  /**
   * The CloudWatch Logging Options for the delivery stream. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfiguration#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions[];

  /**
   * The compression format. If no value is specified, the default is UNCOMPRESSED. Other supported values are GZIP, ZIP, Snappy, & HADOOP_SNAPPY.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfiguration#compressionFormat
   */
  readonly compressionFormat?: string;

  /**
   * Prefix added to failed records before writing them to S3. Not currently supported for redshift destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see Custom Prefixes for Amazon S3 Objects.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfiguration#errorOutputPrefix
   */
  readonly errorOutputPrefix?: string;

  /**
   * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will be used.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfiguration#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfiguration#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfiguration(obj: DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferInterval': obj.bufferInterval,
    'bufferSize': obj.bufferSize,
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions(y)),
    'compressionFormat': obj.compressionFormat,
    'errorOutputPrefix': obj.errorOutputPrefix,
    'kmsKeyArn': obj.kmsKeyArn,
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderS3ConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecInitProviderS3ConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderS3ConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderS3ConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderS3ConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderS3ConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderS3ConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecInitProviderS3ConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderSplunkConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecInitProviderSplunkConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderSplunkConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderSplunkConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderSplunkConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderSplunkConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderSplunkConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecInitProviderSplunkConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfiguration
 */
export interface DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfiguration {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Array of data processors. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfiguration#processors
   */
  readonly processors?: DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessors[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfiguration(obj: DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'processors': obj.processors?.map(y => toJson_DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecProviderConfigRefPolicyResolution
 */
export enum DeliveryStreamSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecProviderConfigRefPolicyResolve
 */
export enum DeliveryStreamSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DeliveryStreamSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecPublishConnectionDetailsToConfigRefPolicy(obj: DeliveryStreamSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRefPolicy
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRefPolicy(obj: DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelectorPolicy
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelectorPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelectorPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelectorPolicy(obj: DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessors
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessors {
  /**
   * Array of processor parameters. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessors#parameters
   */
  readonly parameters?: DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters[];

  /**
   * The type of processor. Valid Values: RecordDeAggregation, Lambda, MetadataExtraction, AppendDelimiterToRecord. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessors#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessors(obj: DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameters': obj.parameters?.map(y => toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRefPolicy
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRefPolicy(obj: DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelectorPolicy
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelectorPolicy(obj: DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRef
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRef#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRef(obj: DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelector
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelector#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelector(obj: DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRefPolicy
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRefPolicy(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelectorPolicy
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelectorPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelectorPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelectorPolicy(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration {
  /**
   * Nested argument that specifies which deserializer to use. You can choose either the Apache Hive JSON SerDe or the OpenX JSON SerDe. More details below.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration#deserializer
   */
  readonly deserializer?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deserializer': obj.deserializer?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration {
  /**
   * Nested argument that specifies which serializer to use. You can choose either the ORC SerDe or the Parquet SerDe. More details below.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration#serializer
   */
  readonly serializer?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serializer': obj.serializer?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration {
  /**
   * The ID of the AWS Glue Data Catalog. If you don't supply this, the AWS account ID is used by default.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration#catalogId
   */
  readonly catalogId?: string;

  /**
   * Specifies the name of the AWS Glue database that contains the schema for the output data.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration#databaseName
   */
  readonly databaseName?: string;

  /**
   * If you don't specify an AWS Region, the default is the current region.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration#region
   */
  readonly region?: string;

  /**
   * The ARN of the AWS credentials.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration#roleArnRef
   */
  readonly roleArnRef?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration#roleArnSelector
   */
  readonly roleArnSelector?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelector;

  /**
   * Specifies the AWS Glue table that contains the column information that constitutes your data schema.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration#tableName
   */
  readonly tableName?: string;

  /**
   * Reference to a CatalogTable in glue to populate tableName.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration#tableNameRef
   */
  readonly tableNameRef?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRef;

  /**
   * Selector for a CatalogTable in glue to populate tableName.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration#tableNameSelector
   */
  readonly tableNameSelector?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelector;

  /**
   * Specifies the table version for the output data schema. Defaults to LATEST.
   *
   * @default LATEST.
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration#versionId
   */
  readonly versionId?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'databaseName': obj.databaseName,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelector(obj.roleArnSelector),
    'tableName': obj.tableName,
    'tableNameRef': toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRef(obj.tableNameRef),
    'tableNameSelector': toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelector(obj.tableNameSelector),
    'versionId': obj.versionId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessors
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessors {
  /**
   * Array of processor parameters. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessors#parameters
   */
  readonly parameters?: DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters[];

  /**
   * The type of processor. Valid Values: RecordDeAggregation, Lambda, MetadataExtraction, AppendDelimiterToRecord. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessors#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessors(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameters': obj.parameters?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRefPolicy
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRefPolicy(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelectorPolicy
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelectorPolicy(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessors
 */
export interface DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessors {
  /**
   * Array of processor parameters. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessors#parameters
   */
  readonly parameters?: DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters[];

  /**
   * The type of processor. Valid Values: RecordDeAggregation, Lambda, MetadataExtraction, AppendDelimiterToRecord. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessors#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessors(obj: DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameters': obj.parameters?.map(y => toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes
 */
export interface DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes {
  /**
   * The HTTP endpoint name.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes#name
   */
  readonly name?: string;

  /**
   * The value of the HTTP endpoint common attribute.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes(obj: DeliveryStreamSpecForProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRefPolicy
 */
export interface DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRefPolicy(obj: DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelectorPolicy
 */
export interface DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelectorPolicy(obj: DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRefPolicy
 */
export interface DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRefPolicy(obj: DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelectorPolicy
 */
export interface DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelectorPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelectorPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelectorPolicy(obj: DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessors
 */
export interface DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessors {
  /**
   * Array of processor parameters. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessors#parameters
   */
  readonly parameters?: DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters[];

  /**
   * The type of processor. Valid Values: RecordDeAggregation, Lambda, MetadataExtraction, AppendDelimiterToRecord. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessors#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessors(obj: DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameters': obj.parameters?.map(y => toJson_DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRefPolicy
 */
export interface DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRefPolicy(obj: DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelectorPolicy
 */
export interface DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelectorPolicy(obj: DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRef
 */
export interface DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRef#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRef(obj: DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelector
 */
export interface DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelector#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelector(obj: DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessors
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessors {
  /**
   * Array of processor parameters. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessors#parameters
   */
  readonly parameters?: DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters[];

  /**
   * The type of processor. Valid Values: RecordDeAggregation, Lambda, MetadataExtraction, AppendDelimiterToRecord. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessors#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessors(obj: DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameters': obj.parameters?.map(y => toJson_DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRefPolicy
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRefPolicy(obj: DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelectorPolicy
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelectorPolicy(obj: DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucketArn.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRef
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRef#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRef(obj: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucketArn.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelector
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelector#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelector(obj: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRef
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRef#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRef(obj: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelector
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelector#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelector(obj: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecForProviderS3ConfigurationBucketArnRefPolicy
 */
export interface DeliveryStreamSpecForProviderS3ConfigurationBucketArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationBucketArnRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderS3ConfigurationBucketArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationBucketArnRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderS3ConfigurationBucketArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderS3ConfigurationBucketArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderS3ConfigurationBucketArnRefPolicy(obj: DeliveryStreamSpecForProviderS3ConfigurationBucketArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelectorPolicy
 */
export interface DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelectorPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelectorPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelectorPolicy(obj: DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecForProviderS3ConfigurationRoleArnRefPolicy
 */
export interface DeliveryStreamSpecForProviderS3ConfigurationRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationRoleArnRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderS3ConfigurationRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationRoleArnRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderS3ConfigurationRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderS3ConfigurationRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderS3ConfigurationRoleArnRefPolicy(obj: DeliveryStreamSpecForProviderS3ConfigurationRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelectorPolicy
 */
export interface DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelectorPolicy(obj: DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessors
 */
export interface DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessors {
  /**
   * Array of processor parameters. More details are given below
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessors#parameters
   */
  readonly parameters?: DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessorsParameters[];

  /**
   * The type of processor. Valid Values: RecordDeAggregation, Lambda, MetadataExtraction, AppendDelimiterToRecord. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessors#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessors(obj: DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameters': obj.parameters?.map(y => toJson_DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessorsParameters(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessors
 */
export interface DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessors {
  /**
   * Array of processor parameters. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessors#parameters
   */
  readonly parameters?: DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters[];

  /**
   * The type of processor. Valid Values: RecordDeAggregation, Lambda, MetadataExtraction, AppendDelimiterToRecord. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessors#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessors(obj: DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameters': obj.parameters?.map(y => toJson_DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration
 */
export interface DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration {
  /**
   * Nested argument that specifies which deserializer to use. You can choose either the Apache Hive JSON SerDe or the OpenX JSON SerDe. More details below.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration#deserializer
   */
  readonly deserializer?: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration(obj: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deserializer': obj.deserializer?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration
 */
export interface DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration {
  /**
   * Nested argument that specifies which serializer to use. You can choose either the ORC SerDe or the Parquet SerDe. More details below.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration#serializer
   */
  readonly serializer?: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration(obj: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serializer': obj.serializer?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration
 */
export interface DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration {
  /**
   * The ID of the AWS Glue Data Catalog. If you don't supply this, the AWS account ID is used by default.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration#catalogId
   */
  readonly catalogId?: string;

  /**
   * Specifies the name of the AWS Glue database that contains the schema for the output data.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration#databaseName
   */
  readonly databaseName?: string;

  /**
   * Specifies the table version for the output data schema. Defaults to LATEST.
   *
   * @default LATEST.
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration#versionId
   */
  readonly versionId?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration(obj: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'databaseName': obj.databaseName,
    'versionId': obj.versionId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessors
 */
export interface DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessors {
  /**
   * Array of processor parameters. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessors#parameters
   */
  readonly parameters?: DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters[];

  /**
   * The type of processor. Valid Values: RecordDeAggregation, Lambda, MetadataExtraction, AppendDelimiterToRecord. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessors#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessors(obj: DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameters': obj.parameters?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecInitProviderExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessors
 */
export interface DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessors {
  /**
   * Array of processor parameters. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessors#parameters
   */
  readonly parameters?: DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters[];

  /**
   * The type of processor. Valid Values: RecordDeAggregation, Lambda, MetadataExtraction, AppendDelimiterToRecord. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessors#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessors(obj: DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameters': obj.parameters?.map(y => toJson_DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes
 */
export interface DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes {
  /**
   * The HTTP endpoint name.
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes#name
   */
  readonly name?: string;

  /**
   * The value of the HTTP endpoint common attribute.
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes(obj: DeliveryStreamSpecInitProviderHttpEndpointConfigurationRequestConfigurationCommonAttributes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessors
 */
export interface DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessors {
  /**
   * Array of processor parameters. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessors#parameters
   */
  readonly parameters?: DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters[];

  /**
   * The type of processor. Valid Values: RecordDeAggregation, Lambda, MetadataExtraction, AppendDelimiterToRecord. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessors#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessors(obj: DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameters': obj.parameters?.map(y => toJson_DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessors
 */
export interface DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessors {
  /**
   * Array of processor parameters. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessors#parameters
   */
  readonly parameters?: DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters[];

  /**
   * The type of processor. Valid Values: RecordDeAggregation, Lambda, MetadataExtraction, AppendDelimiterToRecord. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessors#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessors(obj: DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameters': obj.parameters?.map(y => toJson_DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions
 */
export interface DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions {
  /**
   * Enables or disables the logging. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The CloudWatch group name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The CloudWatch log stream name for logging. This value is required if enabled is true.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions#logStreamName
   */
  readonly logStreamName?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions(obj: DeliveryStreamSpecInitProviderRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroupName': obj.logGroupName,
    'logStreamName': obj.logStreamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessors
 */
export interface DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessors {
  /**
   * Array of processor parameters. More details are given below
   *
   * @schema DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessors#parameters
   */
  readonly parameters?: DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessorsParameters[];

  /**
   * The type of processor. Valid Values: RecordDeAggregation, Lambda, MetadataExtraction, AppendDelimiterToRecord. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessors#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessors(obj: DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameters': obj.parameters?.map(y => toJson_DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessorsParameters(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DeliveryStreamSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DeliveryStreamSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRefPolicyResolution
 */
export enum DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRefPolicyResolve
 */
export enum DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelectorPolicyResolution
 */
export enum DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelectorPolicyResolve
 */
export enum DeliveryStreamSpecForProviderElasticsearchConfigurationDomainArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters {
  /**
   * Parameter name. Valid Values: LambdaArn, NumberOfRetries, MetadataExtractionQuery, JsonParsingEngine, RoleArn, BufferSizeInMBs, BufferIntervalInSeconds, SubRecordType, Delimiter. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters#parameterName
   */
  readonly parameterName?: string;

  /**
   * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters#parameterValue
   */
  readonly parameterValue?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters(obj: DeliveryStreamSpecForProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRefPolicyResolution
 */
export enum DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRefPolicyResolve
 */
export enum DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelectorPolicyResolution
 */
export enum DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelectorPolicyResolve
 */
export enum DeliveryStreamSpecForProviderElasticsearchConfigurationRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRefPolicy
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRefPolicy(obj: DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelectorPolicy
 */
export interface DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelectorPolicy(obj: DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRefPolicyResolution
 */
export enum DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRefPolicyResolve
 */
export enum DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelectorPolicyResolution
 */
export enum DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelectorPolicyResolve
 */
export enum DeliveryStreamSpecForProviderExtendedS3ConfigurationBucketArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer {
  /**
   * Nested argument that specifies the native Hive / HCatalog JsonSerDe. More details below.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer#hiveJsonSerDe
   */
  readonly hiveJsonSerDe?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe[];

  /**
   * Nested argument that specifies the OpenX SerDe. More details below.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer#openXJsonSerDe
   */
  readonly openXJsonSerDe?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hiveJsonSerDe': obj.hiveJsonSerDe?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe(y)),
    'openXJsonSerDe': obj.openXJsonSerDe?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer {
  /**
   * Nested argument that specifies converting data to the ORC format before storing it in Amazon S3. For more information, see Apache ORC. More details below.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer#orcSerDe
   */
  readonly orcSerDe?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe[];

  /**
   * Nested argument that specifies converting data to the Parquet format before storing it in Amazon S3. For more information, see Apache Parquet. More details below.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer#parquetSerDe
   */
  readonly parquetSerDe?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'orcSerDe': obj.orcSerDe?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe(y)),
    'parquetSerDe': obj.parquetSerDe?.map(y => toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRef
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRef#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRef(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelector
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelector#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelector(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CatalogTable in glue to populate tableName.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRef
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRef#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRefPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRef(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CatalogTable in glue to populate tableName.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelector
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelector#policy
   */
  readonly policy?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelectorPolicy;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelector(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters {
  /**
   * Parameter name. Valid Values: LambdaArn, NumberOfRetries, MetadataExtractionQuery, JsonParsingEngine, RoleArn, BufferSizeInMBs, BufferIntervalInSeconds, SubRecordType, Delimiter. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters#parameterName
   */
  readonly parameterName?: string;

  /**
   * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters#parameterValue
   */
  readonly parameterValue?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRefPolicyResolution
 */
export enum DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRefPolicyResolve
 */
export enum DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelectorPolicyResolution
 */
export enum DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelectorPolicyResolve
 */
export enum DeliveryStreamSpecForProviderExtendedS3ConfigurationRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters
 */
export interface DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters {
  /**
   * Parameter name. Valid Values: LambdaArn, NumberOfRetries, MetadataExtractionQuery, JsonParsingEngine, RoleArn, BufferSizeInMBs, BufferIntervalInSeconds, SubRecordType, Delimiter. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters#parameterName
   */
  readonly parameterName?: string;

  /**
   * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
   *
   * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters#parameterValue
   */
  readonly parameterValue?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters(obj: DeliveryStreamSpecForProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRefPolicyResolution
 */
export enum DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRefPolicyResolve
 */
export enum DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelectorPolicyResolution
 */
export enum DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelectorPolicyResolve
 */
export enum DeliveryStreamSpecForProviderHttpEndpointConfigurationRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRefPolicyResolution
 */
export enum DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRefPolicyResolve
 */
export enum DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelectorPolicyResolution
 */
export enum DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelectorPolicyResolve
 */
export enum DeliveryStreamSpecForProviderOpensearchConfigurationDomainArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters
 */
export interface DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters {
  /**
   * Parameter name. Valid Values: LambdaArn, NumberOfRetries, MetadataExtractionQuery, JsonParsingEngine, RoleArn, BufferSizeInMBs, BufferIntervalInSeconds, SubRecordType, Delimiter. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters#parameterName
   */
  readonly parameterName?: string;

  /**
   * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters#parameterValue
   */
  readonly parameterValue?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters(obj: DeliveryStreamSpecForProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRefPolicyResolution
 */
export enum DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRefPolicyResolve
 */
export enum DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelectorPolicyResolution
 */
export enum DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelectorPolicyResolve
 */
export enum DeliveryStreamSpecForProviderOpensearchConfigurationRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRefPolicy
 */
export interface DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRefPolicy(obj: DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelectorPolicy
 */
export interface DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelectorPolicy(obj: DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters {
  /**
   * Parameter name. Valid Values: LambdaArn, NumberOfRetries, MetadataExtractionQuery, JsonParsingEngine, RoleArn, BufferSizeInMBs, BufferIntervalInSeconds, SubRecordType, Delimiter. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters#parameterName
   */
  readonly parameterName?: string;

  /**
   * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters#parameterValue
   */
  readonly parameterValue?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters(obj: DeliveryStreamSpecForProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRefPolicyResolution
 */
export enum DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRefPolicyResolve
 */
export enum DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelectorPolicyResolution
 */
export enum DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelectorPolicyResolve
 */
export enum DeliveryStreamSpecForProviderRedshiftConfigurationRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRefPolicy
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRefPolicy(obj: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelectorPolicy
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelectorPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelectorPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelectorPolicy(obj: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRefPolicy
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRefPolicy(obj: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelectorPolicy
 */
export interface DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelectorPolicy(obj: DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderS3ConfigurationBucketArnRefPolicyResolution
 */
export enum DeliveryStreamSpecForProviderS3ConfigurationBucketArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderS3ConfigurationBucketArnRefPolicyResolve
 */
export enum DeliveryStreamSpecForProviderS3ConfigurationBucketArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelectorPolicyResolution
 */
export enum DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelectorPolicyResolve
 */
export enum DeliveryStreamSpecForProviderS3ConfigurationBucketArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderS3ConfigurationRoleArnRefPolicyResolution
 */
export enum DeliveryStreamSpecForProviderS3ConfigurationRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderS3ConfigurationRoleArnRefPolicyResolve
 */
export enum DeliveryStreamSpecForProviderS3ConfigurationRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelectorPolicyResolution
 */
export enum DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelectorPolicyResolve
 */
export enum DeliveryStreamSpecForProviderS3ConfigurationRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessorsParameters
 */
export interface DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessorsParameters {
  /**
   * Parameter name. Valid Values: LambdaArn, NumberOfRetries, MetadataExtractionQuery, JsonParsingEngine, RoleArn, BufferSizeInMBs, BufferIntervalInSeconds, SubRecordType, Delimiter. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessorsParameters#parameterName
   */
  readonly parameterName?: string;

  /**
   * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
   *
   * @schema DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessorsParameters#parameterValue
   */
  readonly parameterValue?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessorsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessorsParameters(obj: DeliveryStreamSpecForProviderSplunkConfigurationProcessingConfigurationProcessorsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters
 */
export interface DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters {
  /**
   * Parameter name. Valid Values: LambdaArn, NumberOfRetries, MetadataExtractionQuery, JsonParsingEngine, RoleArn, BufferSizeInMBs, BufferIntervalInSeconds, SubRecordType, Delimiter. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters#parameterName
   */
  readonly parameterName?: string;

  /**
   * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
   *
   * @schema DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters#parameterValue
   */
  readonly parameterValue?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters(obj: DeliveryStreamSpecInitProviderElasticsearchConfigurationProcessingConfigurationProcessorsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer
 */
export interface DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer {
  /**
   * Nested argument that specifies the native Hive / HCatalog JsonSerDe. More details below.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer#hiveJsonSerDe
   */
  readonly hiveJsonSerDe?: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe[];

  /**
   * Nested argument that specifies the OpenX SerDe. More details below.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer#openXJsonSerDe
   */
  readonly openXJsonSerDe?: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer(obj: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hiveJsonSerDe': obj.hiveJsonSerDe?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe(y)),
    'openXJsonSerDe': obj.openXJsonSerDe?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer
 */
export interface DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer {
  /**
   * Nested argument that specifies converting data to the ORC format before storing it in Amazon S3. For more information, see Apache ORC. More details below.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer#orcSerDe
   */
  readonly orcSerDe?: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe[];

  /**
   * Nested argument that specifies converting data to the Parquet format before storing it in Amazon S3. For more information, see Apache Parquet. More details below.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer#parquetSerDe
   */
  readonly parquetSerDe?: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer(obj: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'orcSerDe': obj.orcSerDe?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe(y)),
    'parquetSerDe': obj.parquetSerDe?.map(y => toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters
 */
export interface DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters {
  /**
   * Parameter name. Valid Values: LambdaArn, NumberOfRetries, MetadataExtractionQuery, JsonParsingEngine, RoleArn, BufferSizeInMBs, BufferIntervalInSeconds, SubRecordType, Delimiter. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters#parameterName
   */
  readonly parameterName?: string;

  /**
   * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters#parameterValue
   */
  readonly parameterValue?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters(obj: DeliveryStreamSpecInitProviderExtendedS3ConfigurationProcessingConfigurationProcessorsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters
 */
export interface DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters {
  /**
   * Parameter name. Valid Values: LambdaArn, NumberOfRetries, MetadataExtractionQuery, JsonParsingEngine, RoleArn, BufferSizeInMBs, BufferIntervalInSeconds, SubRecordType, Delimiter. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters#parameterName
   */
  readonly parameterName?: string;

  /**
   * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
   *
   * @schema DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters#parameterValue
   */
  readonly parameterValue?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters(obj: DeliveryStreamSpecInitProviderHttpEndpointConfigurationProcessingConfigurationProcessorsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters
 */
export interface DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters {
  /**
   * Parameter name. Valid Values: LambdaArn, NumberOfRetries, MetadataExtractionQuery, JsonParsingEngine, RoleArn, BufferSizeInMBs, BufferIntervalInSeconds, SubRecordType, Delimiter. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters#parameterName
   */
  readonly parameterName?: string;

  /**
   * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
   *
   * @schema DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters#parameterValue
   */
  readonly parameterValue?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters(obj: DeliveryStreamSpecInitProviderOpensearchConfigurationProcessingConfigurationProcessorsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters
 */
export interface DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters {
  /**
   * Parameter name. Valid Values: LambdaArn, NumberOfRetries, MetadataExtractionQuery, JsonParsingEngine, RoleArn, BufferSizeInMBs, BufferIntervalInSeconds, SubRecordType, Delimiter. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters#parameterName
   */
  readonly parameterName?: string;

  /**
   * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
   *
   * @schema DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters#parameterValue
   */
  readonly parameterValue?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters(obj: DeliveryStreamSpecInitProviderRedshiftConfigurationProcessingConfigurationProcessorsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessorsParameters
 */
export interface DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessorsParameters {
  /**
   * Parameter name. Valid Values: LambdaArn, NumberOfRetries, MetadataExtractionQuery, JsonParsingEngine, RoleArn, BufferSizeInMBs, BufferIntervalInSeconds, SubRecordType, Delimiter. Validation is done against AWS SDK constants; so that values not explicitly listed may also work.
   *
   * @schema DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessorsParameters#parameterName
   */
  readonly parameterName?: string;

  /**
   * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
   *
   * @schema DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessorsParameters#parameterValue
   */
  readonly parameterValue?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessorsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessorsParameters(obj: DeliveryStreamSpecInitProviderSplunkConfigurationProcessingConfigurationProcessorsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRefPolicyResolution
 */
export enum DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRefPolicyResolve
 */
export enum DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelectorPolicyResolution
 */
export enum DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelectorPolicyResolve
 */
export enum DeliveryStreamSpecForProviderElasticsearchConfigurationVpcConfigRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe {
  /**
   * A list of how you want Kinesis Data Firehose to parse the date and time stamps that may be present in your input data JSON. To specify these format strings, follow the pattern syntax of JodaTime's DateTimeFormat format strings. For more information, see Class DateTimeFormat. You can also use the special value millis to parse time stamps in epoch milliseconds. If you don't specify a format, Kinesis Data Firehose uses java.sql.Timestamp::valueOf by default.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe#timestampFormats
   */
  readonly timestampFormats?: string[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'timestampFormats': obj.timestampFormats?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe {
  /**
   * When set to true, which is the default, Kinesis Data Firehose converts JSON keys to lowercase before deserializing them.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe#caseInsensitive
   */
  readonly caseInsensitive?: boolean;

  /**
   * A map of column names to JSON keys that aren't identical to the column names. This is useful when the JSON contains keys that are Hive keywords. For example, timestamp is a Hive keyword. If you have a JSON key named timestamp, set this parameter to { ts = "timestamp" } to map this key to a column named ts.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe#columnToJsonKeyMappings
   */
  readonly columnToJsonKeyMappings?: { [key: string]: string };

  /**
   * When set to true, specifies that the names of the keys include dots and that you want Kinesis Data Firehose to replace them with underscores. This is useful because Apache Hive does not allow dots in column names. For example, if the JSON contains a key whose name is "a.b", you can define the column name to be "a_b" when using this option. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe#convertDotsInJsonKeysToUnderscores
   */
  readonly convertDotsInJsonKeysToUnderscores?: boolean;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caseInsensitive': obj.caseInsensitive,
    'columnToJsonKeyMappings': ((obj.columnToJsonKeyMappings) === undefined) ? undefined : (Object.entries(obj.columnToJsonKeyMappings).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'convertDotsInJsonKeysToUnderscores': obj.convertDotsInJsonKeysToUnderscores,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe {
  /**
   * The Hadoop Distributed File System (HDFS) block size. This is useful if you intend to copy the data from Amazon S3 to HDFS before querying. The default is 256 MiB and the minimum is 64 MiB. Kinesis Data Firehose uses this value for padding calculations.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#blockSizeBytes
   */
  readonly blockSizeBytes?: number;

  /**
   * A list of column names for which you want Kinesis Data Firehose to create bloom filters.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#bloomFilterColumns
   */
  readonly bloomFilterColumns?: string[];

  /**
   * The Bloom filter false positive probability (FPP). The lower the FPP, the bigger the Bloom filter. The default value is 0.05, the minimum is 0, and the maximum is 1.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#bloomFilterFalsePositiveProbability
   */
  readonly bloomFilterFalsePositiveProbability?: number;

  /**
   * The compression code to use over data blocks. The possible values are UNCOMPRESSED, SNAPPY, and GZIP, with the default being SNAPPY. Use SNAPPY for higher decompression speed. Use GZIP if the compression ratio is more important than speed.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#compression
   */
  readonly compression?: string;

  /**
   * A float that represents the fraction of the total number of non-null rows. To turn off dictionary encoding, set this fraction to a number that is less than the number of distinct keys in a dictionary. To always use dictionary encoding, set this threshold to 1.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#dictionaryKeyThreshold
   */
  readonly dictionaryKeyThreshold?: number;

  /**
   * Set this to true to indicate that you want stripes to be padded to the HDFS block boundaries. This is useful if you intend to copy the data from Amazon S3 to HDFS before querying. The default is false.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#enablePadding
   */
  readonly enablePadding?: boolean;

  /**
   * The version of the file to write. The possible values are V0_11 and V0_12. The default is V0_12.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#formatVersion
   */
  readonly formatVersion?: string;

  /**
   * A float between 0 and 1 that defines the tolerance for block padding as a decimal fraction of stripe size. The default value is 0.05, which means 5 percent of stripe size. For the default values of 64 MiB ORC stripes and 256 MiB HDFS blocks, the default block padding tolerance of 5 percent reserves a maximum of 3.2 MiB for padding within the 256 MiB block. In such a case, if the available size within the block is more than 3.2 MiB, a new, smaller stripe is inserted to fit within that space. This ensures that no stripe crosses block boundaries and causes remote reads within a node-local task. Kinesis Data Firehose ignores this parameter when enable_padding is false.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#paddingTolerance
   */
  readonly paddingTolerance?: number;

  /**
   * The number of rows between index entries. The default is 10000 and the minimum is 1000.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#rowIndexStride
   */
  readonly rowIndexStride?: number;

  /**
   * The number of bytes in each stripe. The default is 64 MiB and the minimum is 8 MiB.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#stripeSizeBytes
   */
  readonly stripeSizeBytes?: number;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockSizeBytes': obj.blockSizeBytes,
    'bloomFilterColumns': obj.bloomFilterColumns?.map(y => y),
    'bloomFilterFalsePositiveProbability': obj.bloomFilterFalsePositiveProbability,
    'compression': obj.compression,
    'dictionaryKeyThreshold': obj.dictionaryKeyThreshold,
    'enablePadding': obj.enablePadding,
    'formatVersion': obj.formatVersion,
    'paddingTolerance': obj.paddingTolerance,
    'rowIndexStride': obj.rowIndexStride,
    'stripeSizeBytes': obj.stripeSizeBytes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe {
  /**
   * The Hadoop Distributed File System (HDFS) block size. This is useful if you intend to copy the data from Amazon S3 to HDFS before querying. The default is 256 MiB and the minimum is 64 MiB. Kinesis Data Firehose uses this value for padding calculations.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe#blockSizeBytes
   */
  readonly blockSizeBytes?: number;

  /**
   * The compression code to use over data blocks. The possible values are UNCOMPRESSED, SNAPPY, and GZIP, with the default being SNAPPY. Use SNAPPY for higher decompression speed. Use GZIP if the compression ratio is more important than speed.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe#compression
   */
  readonly compression?: string;

  /**
   * Indicates whether to enable dictionary compression.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe#enableDictionaryCompression
   */
  readonly enableDictionaryCompression?: boolean;

  /**
   * The maximum amount of padding to apply. This is useful if you intend to copy the data from Amazon S3 to HDFS before querying. The default is 0.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe#maxPaddingBytes
   */
  readonly maxPaddingBytes?: number;

  /**
   * The Parquet page size. Column chunks are divided into pages. A page is conceptually an indivisible unit (in terms of compression and encoding). The minimum value is 64 KiB and the default is 1 MiB.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe#pageSizeBytes
   */
  readonly pageSizeBytes?: number;

  /**
   * Indicates the version of row format to output. The possible values are V1 and V2. The default is V1.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe#writerVersion
   */
  readonly writerVersion?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockSizeBytes': obj.blockSizeBytes,
    'compression': obj.compression,
    'enableDictionaryCompression': obj.enableDictionaryCompression,
    'maxPaddingBytes': obj.maxPaddingBytes,
    'pageSizeBytes': obj.pageSizeBytes,
    'writerVersion': obj.writerVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRefPolicy
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRefPolicy(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelectorPolicy
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelectorPolicy(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRefPolicy
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRefPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRefPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRefPolicy(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelectorPolicy
 */
export interface DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelectorPolicy#resolution
   */
  readonly resolution?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelectorPolicy#resolve
   */
  readonly resolve?: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelectorPolicy(obj: DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRefPolicyResolution
 */
export enum DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRefPolicyResolve
 */
export enum DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelectorPolicyResolution
 */
export enum DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelectorPolicyResolve
 */
export enum DeliveryStreamSpecForProviderOpensearchConfigurationVpcConfigRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRefPolicyResolution
 */
export enum DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRefPolicyResolve
 */
export enum DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelectorPolicyResolution
 */
export enum DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelectorPolicyResolve
 */
export enum DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationBucketArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRefPolicyResolution
 */
export enum DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRefPolicyResolve
 */
export enum DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelectorPolicyResolution
 */
export enum DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelectorPolicyResolve
 */
export enum DeliveryStreamSpecForProviderRedshiftConfigurationS3BackupConfigurationRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe
 */
export interface DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe {
  /**
   * A list of how you want Kinesis Data Firehose to parse the date and time stamps that may be present in your input data JSON. To specify these format strings, follow the pattern syntax of JodaTime's DateTimeFormat format strings. For more information, see Class DateTimeFormat. You can also use the special value millis to parse time stamps in epoch milliseconds. If you don't specify a format, Kinesis Data Firehose uses java.sql.Timestamp::valueOf by default.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe#timestampFormats
   */
  readonly timestampFormats?: string[];

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe(obj: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'timestampFormats': obj.timestampFormats?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe
 */
export interface DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe {
  /**
   * When set to true, which is the default, Kinesis Data Firehose converts JSON keys to lowercase before deserializing them.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe#caseInsensitive
   */
  readonly caseInsensitive?: boolean;

  /**
   * A map of column names to JSON keys that aren't identical to the column names. This is useful when the JSON contains keys that are Hive keywords. For example, timestamp is a Hive keyword. If you have a JSON key named timestamp, set this parameter to { ts = "timestamp" } to map this key to a column named ts.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe#columnToJsonKeyMappings
   */
  readonly columnToJsonKeyMappings?: { [key: string]: string };

  /**
   * When set to true, specifies that the names of the keys include dots and that you want Kinesis Data Firehose to replace them with underscores. This is useful because Apache Hive does not allow dots in column names. For example, if the JSON contains a key whose name is "a.b", you can define the column name to be "a_b" when using this option. Defaults to false.
   *
   * @default false.
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe#convertDotsInJsonKeysToUnderscores
   */
  readonly convertDotsInJsonKeysToUnderscores?: boolean;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe(obj: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caseInsensitive': obj.caseInsensitive,
    'columnToJsonKeyMappings': ((obj.columnToJsonKeyMappings) === undefined) ? undefined : (Object.entries(obj.columnToJsonKeyMappings).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'convertDotsInJsonKeysToUnderscores': obj.convertDotsInJsonKeysToUnderscores,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe
 */
export interface DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe {
  /**
   * The Hadoop Distributed File System (HDFS) block size. This is useful if you intend to copy the data from Amazon S3 to HDFS before querying. The default is 256 MiB and the minimum is 64 MiB. Kinesis Data Firehose uses this value for padding calculations.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#blockSizeBytes
   */
  readonly blockSizeBytes?: number;

  /**
   * A list of column names for which you want Kinesis Data Firehose to create bloom filters.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#bloomFilterColumns
   */
  readonly bloomFilterColumns?: string[];

  /**
   * The Bloom filter false positive probability (FPP). The lower the FPP, the bigger the Bloom filter. The default value is 0.05, the minimum is 0, and the maximum is 1.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#bloomFilterFalsePositiveProbability
   */
  readonly bloomFilterFalsePositiveProbability?: number;

  /**
   * The compression code to use over data blocks. The possible values are UNCOMPRESSED, SNAPPY, and GZIP, with the default being SNAPPY. Use SNAPPY for higher decompression speed. Use GZIP if the compression ratio is more important than speed.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#compression
   */
  readonly compression?: string;

  /**
   * A float that represents the fraction of the total number of non-null rows. To turn off dictionary encoding, set this fraction to a number that is less than the number of distinct keys in a dictionary. To always use dictionary encoding, set this threshold to 1.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#dictionaryKeyThreshold
   */
  readonly dictionaryKeyThreshold?: number;

  /**
   * Set this to true to indicate that you want stripes to be padded to the HDFS block boundaries. This is useful if you intend to copy the data from Amazon S3 to HDFS before querying. The default is false.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#enablePadding
   */
  readonly enablePadding?: boolean;

  /**
   * The version of the file to write. The possible values are V0_11 and V0_12. The default is V0_12.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#formatVersion
   */
  readonly formatVersion?: string;

  /**
   * A float between 0 and 1 that defines the tolerance for block padding as a decimal fraction of stripe size. The default value is 0.05, which means 5 percent of stripe size. For the default values of 64 MiB ORC stripes and 256 MiB HDFS blocks, the default block padding tolerance of 5 percent reserves a maximum of 3.2 MiB for padding within the 256 MiB block. In such a case, if the available size within the block is more than 3.2 MiB, a new, smaller stripe is inserted to fit within that space. This ensures that no stripe crosses block boundaries and causes remote reads within a node-local task. Kinesis Data Firehose ignores this parameter when enable_padding is false.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#paddingTolerance
   */
  readonly paddingTolerance?: number;

  /**
   * The number of rows between index entries. The default is 10000 and the minimum is 1000.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#rowIndexStride
   */
  readonly rowIndexStride?: number;

  /**
   * The number of bytes in each stripe. The default is 64 MiB and the minimum is 8 MiB.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe#stripeSizeBytes
   */
  readonly stripeSizeBytes?: number;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe(obj: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockSizeBytes': obj.blockSizeBytes,
    'bloomFilterColumns': obj.bloomFilterColumns?.map(y => y),
    'bloomFilterFalsePositiveProbability': obj.bloomFilterFalsePositiveProbability,
    'compression': obj.compression,
    'dictionaryKeyThreshold': obj.dictionaryKeyThreshold,
    'enablePadding': obj.enablePadding,
    'formatVersion': obj.formatVersion,
    'paddingTolerance': obj.paddingTolerance,
    'rowIndexStride': obj.rowIndexStride,
    'stripeSizeBytes': obj.stripeSizeBytes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe
 */
export interface DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe {
  /**
   * The Hadoop Distributed File System (HDFS) block size. This is useful if you intend to copy the data from Amazon S3 to HDFS before querying. The default is 256 MiB and the minimum is 64 MiB. Kinesis Data Firehose uses this value for padding calculations.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe#blockSizeBytes
   */
  readonly blockSizeBytes?: number;

  /**
   * The compression code to use over data blocks. The possible values are UNCOMPRESSED, SNAPPY, and GZIP, with the default being SNAPPY. Use SNAPPY for higher decompression speed. Use GZIP if the compression ratio is more important than speed.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe#compression
   */
  readonly compression?: string;

  /**
   * Indicates whether to enable dictionary compression.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe#enableDictionaryCompression
   */
  readonly enableDictionaryCompression?: boolean;

  /**
   * The maximum amount of padding to apply. This is useful if you intend to copy the data from Amazon S3 to HDFS before querying. The default is 0.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe#maxPaddingBytes
   */
  readonly maxPaddingBytes?: number;

  /**
   * The Parquet page size. Column chunks are divided into pages. A page is conceptually an indivisible unit (in terms of compression and encoding). The minimum value is 64 KiB and the default is 1 MiB.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe#pageSizeBytes
   */
  readonly pageSizeBytes?: number;

  /**
   * Indicates the version of row format to output. The possible values are V1 and V2. The default is V1.
   *
   * @schema DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe#writerVersion
   */
  readonly writerVersion?: string;

}

/**
 * Converts an object of type 'DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe(obj: DeliveryStreamSpecInitProviderExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockSizeBytes': obj.blockSizeBytes,
    'compression': obj.compression,
    'enableDictionaryCompression': obj.enableDictionaryCompression,
    'maxPaddingBytes': obj.maxPaddingBytes,
    'pageSizeBytes': obj.pageSizeBytes,
    'writerVersion': obj.writerVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRefPolicyResolution
 */
export enum DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRefPolicyResolve
 */
export enum DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelectorPolicyResolution
 */
export enum DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelectorPolicyResolve
 */
export enum DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRefPolicyResolution
 */
export enum DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRefPolicyResolve
 */
export enum DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelectorPolicyResolution
 */
export enum DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelectorPolicyResolve
 */
export enum DeliveryStreamSpecForProviderExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationTableNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

