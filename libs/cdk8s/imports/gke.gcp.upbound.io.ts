// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * BackupBackupPlan is the Schema for the BackupBackupPlans API. Represents a Backup Plan instance.
 *
 * @schema BackupBackupPlan
 */
export class BackupBackupPlan extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackupBackupPlan"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gke.gcp.upbound.io/v1beta1',
    kind: 'BackupBackupPlan',
  }

  /**
   * Renders a Kubernetes manifest for "BackupBackupPlan".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupBackupPlanProps): any {
    return {
      ...BackupBackupPlan.GVK,
      ...toJson_BackupBackupPlanProps(props),
    };
  }

  /**
   * Defines a "BackupBackupPlan" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupBackupPlanProps) {
    super(scope, id, {
      ...BackupBackupPlan.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackupBackupPlan.GVK,
      ...toJson_BackupBackupPlanProps(resolved),
    };
  }
}

/**
 * BackupBackupPlan is the Schema for the BackupBackupPlans API. Represents a Backup Plan instance.
 *
 * @schema BackupBackupPlan
 */
export interface BackupBackupPlanProps {
  /**
   * @schema BackupBackupPlan#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackupBackupPlanSpec defines the desired state of BackupBackupPlan
   *
   * @schema BackupBackupPlan#spec
   */
  readonly spec: BackupBackupPlanSpec;

}

/**
 * Converts an object of type 'BackupBackupPlanProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanProps(obj: BackupBackupPlanProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackupBackupPlanSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BackupBackupPlanSpec defines the desired state of BackupBackupPlan
 *
 * @schema BackupBackupPlanSpec
 */
export interface BackupBackupPlanSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BackupBackupPlanSpec#deletionPolicy
   */
  readonly deletionPolicy?: BackupBackupPlanSpecDeletionPolicy;

  /**
   * @schema BackupBackupPlanSpec#forProvider
   */
  readonly forProvider: BackupBackupPlanSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BackupBackupPlanSpec#providerConfigRef
   */
  readonly providerConfigRef?: BackupBackupPlanSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BackupBackupPlanSpec#providerRef
   */
  readonly providerRef?: BackupBackupPlanSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BackupBackupPlanSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BackupBackupPlanSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BackupBackupPlanSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BackupBackupPlanSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BackupBackupPlanSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpec(obj: BackupBackupPlanSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BackupBackupPlanSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BackupBackupPlanSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BackupBackupPlanSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BackupBackupPlanSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BackupBackupPlanSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BackupBackupPlanSpecDeletionPolicy
 */
export enum BackupBackupPlanSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BackupBackupPlanSpecForProvider
 */
export interface BackupBackupPlanSpecForProvider {
  /**
   * Defines the configuration of Backups created via this BackupPlan. Structure is documented below.
   *
   * @schema BackupBackupPlanSpecForProvider#backupConfig
   */
  readonly backupConfig?: BackupBackupPlanSpecForProviderBackupConfig[];

  /**
   * Defines a schedule for automatic Backup creation via this BackupPlan. Structure is documented below.
   *
   * @schema BackupBackupPlanSpecForProvider#backupSchedule
   */
  readonly backupSchedule?: BackupBackupPlanSpecForProviderBackupSchedule[];

  /**
   * The source cluster from which Backups will be created via this BackupPlan.
   *
   * @schema BackupBackupPlanSpecForProvider#cluster
   */
  readonly cluster?: string;

  /**
   * Reference to a Cluster in container to populate cluster.
   *
   * @schema BackupBackupPlanSpecForProvider#clusterRef
   */
  readonly clusterRef?: BackupBackupPlanSpecForProviderClusterRef;

  /**
   * Selector for a Cluster in container to populate cluster.
   *
   * @schema BackupBackupPlanSpecForProvider#clusterSelector
   */
  readonly clusterSelector?: BackupBackupPlanSpecForProviderClusterSelector;

  /**
   * This flag indicates whether this BackupPlan has been deactivated. Setting this field to True locks the BackupPlan such that no further updates will be allowed (except deletes), including the deactivated field itself. It also prevents any new Backups from being created via this BackupPlan (including scheduled Backups).
   *
   * @schema BackupBackupPlanSpecForProvider#deactivated
   */
  readonly deactivated?: boolean;

  /**
   * User specified descriptive string for this BackupPlan.
   *
   * @schema BackupBackupPlanSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Description: A set of custom labels supplied by the user. A list of key->value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
   *
   * @schema BackupBackupPlanSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The region of the Backup Plan.
   *
   * @schema BackupBackupPlanSpecForProvider#location
   */
  readonly location: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema BackupBackupPlanSpecForProvider#project
   */
  readonly project?: string;

  /**
   * RetentionPolicy governs lifecycle of Backups created under this plan. Structure is documented below.
   *
   * @schema BackupBackupPlanSpecForProvider#retentionPolicy
   */
  readonly retentionPolicy?: BackupBackupPlanSpecForProviderRetentionPolicy[];

}

/**
 * Converts an object of type 'BackupBackupPlanSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecForProvider(obj: BackupBackupPlanSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupConfig': obj.backupConfig?.map(y => toJson_BackupBackupPlanSpecForProviderBackupConfig(y)),
    'backupSchedule': obj.backupSchedule?.map(y => toJson_BackupBackupPlanSpecForProviderBackupSchedule(y)),
    'cluster': obj.cluster,
    'clusterRef': toJson_BackupBackupPlanSpecForProviderClusterRef(obj.clusterRef),
    'clusterSelector': toJson_BackupBackupPlanSpecForProviderClusterSelector(obj.clusterSelector),
    'deactivated': obj.deactivated,
    'description': obj.description,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'location': obj.location,
    'project': obj.project,
    'retentionPolicy': obj.retentionPolicy?.map(y => toJson_BackupBackupPlanSpecForProviderRetentionPolicy(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BackupBackupPlanSpecProviderConfigRef
 */
export interface BackupBackupPlanSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupBackupPlanSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupBackupPlanSpecProviderConfigRef#policy
   */
  readonly policy?: BackupBackupPlanSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecProviderConfigRef(obj: BackupBackupPlanSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupBackupPlanSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BackupBackupPlanSpecProviderRef
 */
export interface BackupBackupPlanSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupBackupPlanSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupBackupPlanSpecProviderRef#policy
   */
  readonly policy?: BackupBackupPlanSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecProviderRef(obj: BackupBackupPlanSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupBackupPlanSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BackupBackupPlanSpecPublishConnectionDetailsTo
 */
export interface BackupBackupPlanSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BackupBackupPlanSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BackupBackupPlanSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BackupBackupPlanSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BackupBackupPlanSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BackupBackupPlanSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecPublishConnectionDetailsTo(obj: BackupBackupPlanSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BackupBackupPlanSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BackupBackupPlanSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BackupBackupPlanSpecWriteConnectionSecretToRef
 */
export interface BackupBackupPlanSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BackupBackupPlanSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BackupBackupPlanSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecWriteConnectionSecretToRef(obj: BackupBackupPlanSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackupBackupPlanSpecForProviderBackupConfig
 */
export interface BackupBackupPlanSpecForProviderBackupConfig {
  /**
   * If True, include all namespaced resources.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfig#allNamespaces
   */
  readonly allNamespaces?: boolean;

  /**
   * This defines a customer managed encryption key that will be used to encrypt the "config" portion (the Kubernetes resources) of Backups created via this plan. Structure is documented below.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfig#encryptionKey
   */
  readonly encryptionKey?: BackupBackupPlanSpecForProviderBackupConfigEncryptionKey[];

  /**
   * This flag specifies whether Kubernetes Secret resources should be included when they fall into the scope of Backups.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfig#includeSecrets
   */
  readonly includeSecrets?: boolean;

  /**
   * This flag specifies whether volume data should be backed up when PVCs are included in the scope of a Backup.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfig#includeVolumeData
   */
  readonly includeVolumeData?: boolean;

  /**
   * A list of namespaced Kubernetes Resources. Structure is documented below.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfig#selectedApplications
   */
  readonly selectedApplications?: BackupBackupPlanSpecForProviderBackupConfigSelectedApplications[];

  /**
   * If set, include just the resources in the listed namespaces. Structure is documented below.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfig#selectedNamespaces
   */
  readonly selectedNamespaces?: BackupBackupPlanSpecForProviderBackupConfigSelectedNamespaces[];

}

/**
 * Converts an object of type 'BackupBackupPlanSpecForProviderBackupConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecForProviderBackupConfig(obj: BackupBackupPlanSpecForProviderBackupConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allNamespaces': obj.allNamespaces,
    'encryptionKey': obj.encryptionKey?.map(y => toJson_BackupBackupPlanSpecForProviderBackupConfigEncryptionKey(y)),
    'includeSecrets': obj.includeSecrets,
    'includeVolumeData': obj.includeVolumeData,
    'selectedApplications': obj.selectedApplications?.map(y => toJson_BackupBackupPlanSpecForProviderBackupConfigSelectedApplications(y)),
    'selectedNamespaces': obj.selectedNamespaces?.map(y => toJson_BackupBackupPlanSpecForProviderBackupConfigSelectedNamespaces(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackupBackupPlanSpecForProviderBackupSchedule
 */
export interface BackupBackupPlanSpecForProviderBackupSchedule {
  /**
   * A standard cron string that defines a repeating schedule for creating Backups via this BackupPlan. If this is defined, then backupRetainDays must also be defined.
   *
   * @schema BackupBackupPlanSpecForProviderBackupSchedule#cronSchedule
   */
  readonly cronSchedule?: string;

  /**
   * This flag denotes whether automatic Backup creation is paused for this BackupPlan.
   *
   * @schema BackupBackupPlanSpecForProviderBackupSchedule#paused
   */
  readonly paused?: boolean;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecForProviderBackupSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecForProviderBackupSchedule(obj: BackupBackupPlanSpecForProviderBackupSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cronSchedule': obj.cronSchedule,
    'paused': obj.paused,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in container to populate cluster.
 *
 * @schema BackupBackupPlanSpecForProviderClusterRef
 */
export interface BackupBackupPlanSpecForProviderClusterRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupBackupPlanSpecForProviderClusterRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupBackupPlanSpecForProviderClusterRef#policy
   */
  readonly policy?: BackupBackupPlanSpecForProviderClusterRefPolicy;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecForProviderClusterRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecForProviderClusterRef(obj: BackupBackupPlanSpecForProviderClusterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupBackupPlanSpecForProviderClusterRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in container to populate cluster.
 *
 * @schema BackupBackupPlanSpecForProviderClusterSelector
 */
export interface BackupBackupPlanSpecForProviderClusterSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BackupBackupPlanSpecForProviderClusterSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BackupBackupPlanSpecForProviderClusterSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BackupBackupPlanSpecForProviderClusterSelector#policy
   */
  readonly policy?: BackupBackupPlanSpecForProviderClusterSelectorPolicy;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecForProviderClusterSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecForProviderClusterSelector(obj: BackupBackupPlanSpecForProviderClusterSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BackupBackupPlanSpecForProviderClusterSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackupBackupPlanSpecForProviderRetentionPolicy
 */
export interface BackupBackupPlanSpecForProviderRetentionPolicy {
  /**
   * Minimum age for a Backup created via this BackupPlan (in days). Must be an integer value between 0-90 (inclusive). A Backup created under this BackupPlan will not be deletable until it reaches Backup's (create time + backup_delete_lock_days). Updating this field of a BackupPlan does not affect existing Backups. Backups created after a successful update will inherit this new value.
   *
   * @schema BackupBackupPlanSpecForProviderRetentionPolicy#backupDeleteLockDays
   */
  readonly backupDeleteLockDays?: number;

  /**
   * The default maximum age of a Backup created via this BackupPlan. This field MUST be an integer value >= 0 and <= 365. If specified, a Backup created under this BackupPlan will be automatically deleted after its age reaches (createTime + backupRetainDays). If not specified, Backups created under this BackupPlan will NOT be subject to automatic deletion. Updating this field does NOT affect existing Backups under it. Backups created AFTER a successful update will automatically pick up the new value. NOTE: backupRetainDays must be >= backupDeleteLockDays. If cronSchedule is defined, then this must be <= 360 * the creation interval.]
   *
   * @schema BackupBackupPlanSpecForProviderRetentionPolicy#backupRetainDays
   */
  readonly backupRetainDays?: number;

  /**
   * This flag denotes whether the retention policy of this BackupPlan is locked. If set to True, no further update is allowed on this policy, including the locked field itself.
   *
   * @schema BackupBackupPlanSpecForProviderRetentionPolicy#locked
   */
  readonly locked?: boolean;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecForProviderRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecForProviderRetentionPolicy(obj: BackupBackupPlanSpecForProviderRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupDeleteLockDays': obj.backupDeleteLockDays,
    'backupRetainDays': obj.backupRetainDays,
    'locked': obj.locked,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackupBackupPlanSpecProviderConfigRefPolicy
 */
export interface BackupBackupPlanSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupBackupPlanSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BackupBackupPlanSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupBackupPlanSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BackupBackupPlanSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecProviderConfigRefPolicy(obj: BackupBackupPlanSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackupBackupPlanSpecProviderRefPolicy
 */
export interface BackupBackupPlanSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupBackupPlanSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BackupBackupPlanSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupBackupPlanSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BackupBackupPlanSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecProviderRefPolicy(obj: BackupBackupPlanSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BackupBackupPlanSpecPublishConnectionDetailsToConfigRef
 */
export interface BackupBackupPlanSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupBackupPlanSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupBackupPlanSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BackupBackupPlanSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecPublishConnectionDetailsToConfigRef(obj: BackupBackupPlanSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupBackupPlanSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BackupBackupPlanSpecPublishConnectionDetailsToMetadata
 */
export interface BackupBackupPlanSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BackupBackupPlanSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BackupBackupPlanSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BackupBackupPlanSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecPublishConnectionDetailsToMetadata(obj: BackupBackupPlanSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKey
 */
export interface BackupBackupPlanSpecForProviderBackupConfigEncryptionKey {
  /**
   * Google Cloud KMS encryption key. Format: projects//locations//keyRings//cryptoKeys/
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKey#gcpKmsEncryptionKey
   */
  readonly gcpKmsEncryptionKey?: string;

  /**
   * Reference to a CryptoKey in kms to populate gcpKmsEncryptionKey.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKey#gcpKmsEncryptionKeyRef
   */
  readonly gcpKmsEncryptionKeyRef?: BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRef;

  /**
   * Selector for a CryptoKey in kms to populate gcpKmsEncryptionKey.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKey#gcpKmsEncryptionKeySelector
   */
  readonly gcpKmsEncryptionKeySelector?: BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelector;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecForProviderBackupConfigEncryptionKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecForProviderBackupConfigEncryptionKey(obj: BackupBackupPlanSpecForProviderBackupConfigEncryptionKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gcpKmsEncryptionKey': obj.gcpKmsEncryptionKey,
    'gcpKmsEncryptionKeyRef': toJson_BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRef(obj.gcpKmsEncryptionKeyRef),
    'gcpKmsEncryptionKeySelector': toJson_BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelector(obj.gcpKmsEncryptionKeySelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackupBackupPlanSpecForProviderBackupConfigSelectedApplications
 */
export interface BackupBackupPlanSpecForProviderBackupConfigSelectedApplications {
  /**
   * A list of namespaced Kubernetes resources. Structure is documented below.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfigSelectedApplications#namespacedNames
   */
  readonly namespacedNames: BackupBackupPlanSpecForProviderBackupConfigSelectedApplicationsNamespacedNames[];

}

/**
 * Converts an object of type 'BackupBackupPlanSpecForProviderBackupConfigSelectedApplications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecForProviderBackupConfigSelectedApplications(obj: BackupBackupPlanSpecForProviderBackupConfigSelectedApplications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespacedNames': obj.namespacedNames?.map(y => toJson_BackupBackupPlanSpecForProviderBackupConfigSelectedApplicationsNamespacedNames(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackupBackupPlanSpecForProviderBackupConfigSelectedNamespaces
 */
export interface BackupBackupPlanSpecForProviderBackupConfigSelectedNamespaces {
  /**
   * A list of Kubernetes Namespaces.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfigSelectedNamespaces#namespaces
   */
  readonly namespaces: string[];

}

/**
 * Converts an object of type 'BackupBackupPlanSpecForProviderBackupConfigSelectedNamespaces' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecForProviderBackupConfigSelectedNamespaces(obj: BackupBackupPlanSpecForProviderBackupConfigSelectedNamespaces | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaces': obj.namespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackupBackupPlanSpecForProviderClusterRefPolicy
 */
export interface BackupBackupPlanSpecForProviderClusterRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupBackupPlanSpecForProviderClusterRefPolicy#resolution
   */
  readonly resolution?: BackupBackupPlanSpecForProviderClusterRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupBackupPlanSpecForProviderClusterRefPolicy#resolve
   */
  readonly resolve?: BackupBackupPlanSpecForProviderClusterRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecForProviderClusterRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecForProviderClusterRefPolicy(obj: BackupBackupPlanSpecForProviderClusterRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BackupBackupPlanSpecForProviderClusterSelectorPolicy
 */
export interface BackupBackupPlanSpecForProviderClusterSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupBackupPlanSpecForProviderClusterSelectorPolicy#resolution
   */
  readonly resolution?: BackupBackupPlanSpecForProviderClusterSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupBackupPlanSpecForProviderClusterSelectorPolicy#resolve
   */
  readonly resolve?: BackupBackupPlanSpecForProviderClusterSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecForProviderClusterSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecForProviderClusterSelectorPolicy(obj: BackupBackupPlanSpecForProviderClusterSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupBackupPlanSpecProviderConfigRefPolicyResolution
 */
export enum BackupBackupPlanSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupBackupPlanSpecProviderConfigRefPolicyResolve
 */
export enum BackupBackupPlanSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupBackupPlanSpecProviderRefPolicyResolution
 */
export enum BackupBackupPlanSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupBackupPlanSpecProviderRefPolicyResolve
 */
export enum BackupBackupPlanSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BackupBackupPlanSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BackupBackupPlanSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupBackupPlanSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BackupBackupPlanSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupBackupPlanSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BackupBackupPlanSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecPublishConnectionDetailsToConfigRefPolicy(obj: BackupBackupPlanSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CryptoKey in kms to populate gcpKmsEncryptionKey.
 *
 * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRef
 */
export interface BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRef#policy
   */
  readonly policy?: BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicy;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRef(obj: BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CryptoKey in kms to populate gcpKmsEncryptionKey.
 *
 * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelector
 */
export interface BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelector#policy
   */
  readonly policy?: BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicy;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelector(obj: BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackupBackupPlanSpecForProviderBackupConfigSelectedApplicationsNamespacedNames
 */
export interface BackupBackupPlanSpecForProviderBackupConfigSelectedApplicationsNamespacedNames {
  /**
   * The name of a Kubernetes Resource.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfigSelectedApplicationsNamespacedNames#name
   */
  readonly name: string;

  /**
   * The namespace of a Kubernetes Resource.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfigSelectedApplicationsNamespacedNames#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecForProviderBackupConfigSelectedApplicationsNamespacedNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecForProviderBackupConfigSelectedApplicationsNamespacedNames(obj: BackupBackupPlanSpecForProviderBackupConfigSelectedApplicationsNamespacedNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupBackupPlanSpecForProviderClusterRefPolicyResolution
 */
export enum BackupBackupPlanSpecForProviderClusterRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupBackupPlanSpecForProviderClusterRefPolicyResolve
 */
export enum BackupBackupPlanSpecForProviderClusterRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupBackupPlanSpecForProviderClusterSelectorPolicyResolution
 */
export enum BackupBackupPlanSpecForProviderClusterSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupBackupPlanSpecForProviderClusterSelectorPolicyResolve
 */
export enum BackupBackupPlanSpecForProviderClusterSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupBackupPlanSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BackupBackupPlanSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupBackupPlanSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BackupBackupPlanSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicy
 */
export interface BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicy#resolution
   */
  readonly resolution?: BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicy#resolve
   */
  readonly resolve?: BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicy(obj: BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicy
 */
export interface BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicy#resolution
   */
  readonly resolution?: BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicy#resolve
   */
  readonly resolve?: BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicyResolve;

}

/**
 * Converts an object of type 'BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicy(obj: BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicyResolution
 */
export enum BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicyResolve
 */
export enum BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeyRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicyResolution
 */
export enum BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicyResolve
 */
export enum BackupBackupPlanSpecForProviderBackupConfigEncryptionKeyGcpKmsEncryptionKeySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

