// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AppCookieStickinessPolicy is the Schema for the AppCookieStickinessPolicys API. Provides an application cookie stickiness policy, which allows an ELB to wed its stickiness cookie to a cookie generated by your application.
 *
 * @schema AppCookieStickinessPolicy
 */
export class AppCookieStickinessPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AppCookieStickinessPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elb.aws.upbound.io/v1beta1',
    kind: 'AppCookieStickinessPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "AppCookieStickinessPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AppCookieStickinessPolicyProps): any {
    return {
      ...AppCookieStickinessPolicy.GVK,
      ...toJson_AppCookieStickinessPolicyProps(props),
    };
  }

  /**
   * Defines a "AppCookieStickinessPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AppCookieStickinessPolicyProps) {
    super(scope, id, {
      ...AppCookieStickinessPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AppCookieStickinessPolicy.GVK,
      ...toJson_AppCookieStickinessPolicyProps(resolved),
    };
  }
}

/**
 * AppCookieStickinessPolicy is the Schema for the AppCookieStickinessPolicys API. Provides an application cookie stickiness policy, which allows an ELB to wed its stickiness cookie to a cookie generated by your application.
 *
 * @schema AppCookieStickinessPolicy
 */
export interface AppCookieStickinessPolicyProps {
  /**
   * @schema AppCookieStickinessPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AppCookieStickinessPolicySpec defines the desired state of AppCookieStickinessPolicy
   *
   * @schema AppCookieStickinessPolicy#spec
   */
  readonly spec: AppCookieStickinessPolicySpec;

}

/**
 * Converts an object of type 'AppCookieStickinessPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppCookieStickinessPolicyProps(obj: AppCookieStickinessPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AppCookieStickinessPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppCookieStickinessPolicySpec defines the desired state of AppCookieStickinessPolicy
 *
 * @schema AppCookieStickinessPolicySpec
 */
export interface AppCookieStickinessPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema AppCookieStickinessPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: AppCookieStickinessPolicySpecDeletionPolicy;

  /**
   * @schema AppCookieStickinessPolicySpec#forProvider
   */
  readonly forProvider: AppCookieStickinessPolicySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AppCookieStickinessPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: AppCookieStickinessPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AppCookieStickinessPolicySpec#providerRef
   */
  readonly providerRef?: AppCookieStickinessPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AppCookieStickinessPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AppCookieStickinessPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AppCookieStickinessPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AppCookieStickinessPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AppCookieStickinessPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppCookieStickinessPolicySpec(obj: AppCookieStickinessPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AppCookieStickinessPolicySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_AppCookieStickinessPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AppCookieStickinessPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AppCookieStickinessPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AppCookieStickinessPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema AppCookieStickinessPolicySpecDeletionPolicy
 */
export enum AppCookieStickinessPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AppCookieStickinessPolicySpecForProvider
 */
export interface AppCookieStickinessPolicySpecForProvider {
  /**
   * Application cookie whose lifetime the ELB's cookie should follow.
   *
   * @schema AppCookieStickinessPolicySpecForProvider#cookieName
   */
  readonly cookieName: string;

  /**
   * Load balancer port to which the policy should be applied. This must be an active listener on the load balancer.
   *
   * @schema AppCookieStickinessPolicySpecForProvider#lbPort
   */
  readonly lbPort: number;

  /**
   * Name of load balancer to which the policy should be attached.
   *
   * @schema AppCookieStickinessPolicySpecForProvider#loadBalancer
   */
  readonly loadBalancer?: string;

  /**
   * Reference to a ELB in elb to populate loadBalancer.
   *
   * @schema AppCookieStickinessPolicySpecForProvider#loadBalancerRef
   */
  readonly loadBalancerRef?: AppCookieStickinessPolicySpecForProviderLoadBalancerRef;

  /**
   * Selector for a ELB in elb to populate loadBalancer.
   *
   * @schema AppCookieStickinessPolicySpecForProvider#loadBalancerSelector
   */
  readonly loadBalancerSelector?: AppCookieStickinessPolicySpecForProviderLoadBalancerSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AppCookieStickinessPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'AppCookieStickinessPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppCookieStickinessPolicySpecForProvider(obj: AppCookieStickinessPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookieName': obj.cookieName,
    'lbPort': obj.lbPort,
    'loadBalancer': obj.loadBalancer,
    'loadBalancerRef': toJson_AppCookieStickinessPolicySpecForProviderLoadBalancerRef(obj.loadBalancerRef),
    'loadBalancerSelector': toJson_AppCookieStickinessPolicySpecForProviderLoadBalancerSelector(obj.loadBalancerSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AppCookieStickinessPolicySpecProviderConfigRef
 */
export interface AppCookieStickinessPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppCookieStickinessPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppCookieStickinessPolicySpecProviderConfigRef#policy
   */
  readonly policy?: AppCookieStickinessPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AppCookieStickinessPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppCookieStickinessPolicySpecProviderConfigRef(obj: AppCookieStickinessPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppCookieStickinessPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AppCookieStickinessPolicySpecProviderRef
 */
export interface AppCookieStickinessPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppCookieStickinessPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppCookieStickinessPolicySpecProviderRef#policy
   */
  readonly policy?: AppCookieStickinessPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AppCookieStickinessPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppCookieStickinessPolicySpecProviderRef(obj: AppCookieStickinessPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppCookieStickinessPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AppCookieStickinessPolicySpecPublishConnectionDetailsTo
 */
export interface AppCookieStickinessPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AppCookieStickinessPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AppCookieStickinessPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AppCookieStickinessPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AppCookieStickinessPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AppCookieStickinessPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppCookieStickinessPolicySpecPublishConnectionDetailsTo(obj: AppCookieStickinessPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AppCookieStickinessPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AppCookieStickinessPolicySpecWriteConnectionSecretToRef
 */
export interface AppCookieStickinessPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AppCookieStickinessPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AppCookieStickinessPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AppCookieStickinessPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppCookieStickinessPolicySpecWriteConnectionSecretToRef(obj: AppCookieStickinessPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ELB in elb to populate loadBalancer.
 *
 * @schema AppCookieStickinessPolicySpecForProviderLoadBalancerRef
 */
export interface AppCookieStickinessPolicySpecForProviderLoadBalancerRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppCookieStickinessPolicySpecForProviderLoadBalancerRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppCookieStickinessPolicySpecForProviderLoadBalancerRef#policy
   */
  readonly policy?: AppCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy;

}

/**
 * Converts an object of type 'AppCookieStickinessPolicySpecForProviderLoadBalancerRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppCookieStickinessPolicySpecForProviderLoadBalancerRef(obj: AppCookieStickinessPolicySpecForProviderLoadBalancerRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ELB in elb to populate loadBalancer.
 *
 * @schema AppCookieStickinessPolicySpecForProviderLoadBalancerSelector
 */
export interface AppCookieStickinessPolicySpecForProviderLoadBalancerSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AppCookieStickinessPolicySpecForProviderLoadBalancerSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AppCookieStickinessPolicySpecForProviderLoadBalancerSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AppCookieStickinessPolicySpecForProviderLoadBalancerSelector#policy
   */
  readonly policy?: AppCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy;

}

/**
 * Converts an object of type 'AppCookieStickinessPolicySpecForProviderLoadBalancerSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppCookieStickinessPolicySpecForProviderLoadBalancerSelector(obj: AppCookieStickinessPolicySpecForProviderLoadBalancerSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AppCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppCookieStickinessPolicySpecProviderConfigRefPolicy
 */
export interface AppCookieStickinessPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppCookieStickinessPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AppCookieStickinessPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppCookieStickinessPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AppCookieStickinessPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppCookieStickinessPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppCookieStickinessPolicySpecProviderConfigRefPolicy(obj: AppCookieStickinessPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppCookieStickinessPolicySpecProviderRefPolicy
 */
export interface AppCookieStickinessPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppCookieStickinessPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: AppCookieStickinessPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppCookieStickinessPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: AppCookieStickinessPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AppCookieStickinessPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppCookieStickinessPolicySpecProviderRefPolicy(obj: AppCookieStickinessPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef(obj: AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AppCookieStickinessPolicySpecPublishConnectionDetailsToMetadata
 */
export interface AppCookieStickinessPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppCookieStickinessPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppCookieStickinessPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AppCookieStickinessPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppCookieStickinessPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppCookieStickinessPolicySpecPublishConnectionDetailsToMetadata(obj: AppCookieStickinessPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy
 */
export interface AppCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy#resolution
   */
  readonly resolution?: AppCookieStickinessPolicySpecForProviderLoadBalancerRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy#resolve
   */
  readonly resolve?: AppCookieStickinessPolicySpecForProviderLoadBalancerRefPolicyResolve;

}

/**
 * Converts an object of type 'AppCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy(obj: AppCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AppCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy
 */
export interface AppCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy#resolution
   */
  readonly resolution?: AppCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy#resolve
   */
  readonly resolve?: AppCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AppCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy(obj: AppCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppCookieStickinessPolicySpecProviderConfigRefPolicyResolution
 */
export enum AppCookieStickinessPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppCookieStickinessPolicySpecProviderConfigRefPolicyResolve
 */
export enum AppCookieStickinessPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppCookieStickinessPolicySpecProviderRefPolicyResolution
 */
export enum AppCookieStickinessPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppCookieStickinessPolicySpecProviderRefPolicyResolve
 */
export enum AppCookieStickinessPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppCookieStickinessPolicySpecForProviderLoadBalancerRefPolicyResolution
 */
export enum AppCookieStickinessPolicySpecForProviderLoadBalancerRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppCookieStickinessPolicySpecForProviderLoadBalancerRefPolicyResolve
 */
export enum AppCookieStickinessPolicySpecForProviderLoadBalancerRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicyResolution
 */
export enum AppCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicyResolve
 */
export enum AppCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AppCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Attachment is the Schema for the Attachments API. Provides an Elastic Load Balancer Attachment resource.
 *
 * @schema Attachment
 */
export class Attachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Attachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elb.aws.upbound.io/v1beta1',
    kind: 'Attachment',
  }

  /**
   * Renders a Kubernetes manifest for "Attachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AttachmentProps): any {
    return {
      ...Attachment.GVK,
      ...toJson_AttachmentProps(props),
    };
  }

  /**
   * Defines a "Attachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AttachmentProps) {
    super(scope, id, {
      ...Attachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Attachment.GVK,
      ...toJson_AttachmentProps(resolved),
    };
  }
}

/**
 * Attachment is the Schema for the Attachments API. Provides an Elastic Load Balancer Attachment resource.
 *
 * @schema Attachment
 */
export interface AttachmentProps {
  /**
   * @schema Attachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AttachmentSpec defines the desired state of Attachment
   *
   * @schema Attachment#spec
   */
  readonly spec: AttachmentSpec;

}

/**
 * Converts an object of type 'AttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentProps(obj: AttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AttachmentSpec defines the desired state of Attachment
 *
 * @schema AttachmentSpec
 */
export interface AttachmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema AttachmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: AttachmentSpecDeletionPolicy;

  /**
   * @schema AttachmentSpec#forProvider
   */
  readonly forProvider: AttachmentSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AttachmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: AttachmentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AttachmentSpec#providerRef
   */
  readonly providerRef?: AttachmentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AttachmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AttachmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AttachmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AttachmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpec(obj: AttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AttachmentSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_AttachmentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AttachmentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AttachmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AttachmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema AttachmentSpecDeletionPolicy
 */
export enum AttachmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AttachmentSpecForProvider
 */
export interface AttachmentSpecForProvider {
  /**
   * The name of the ELB.
   *
   * @schema AttachmentSpecForProvider#elb
   */
  readonly elb?: string;

  /**
   * Reference to a ELB to populate elb.
   *
   * @schema AttachmentSpecForProvider#elbRef
   */
  readonly elbRef?: AttachmentSpecForProviderElbRef;

  /**
   * Selector for a ELB to populate elb.
   *
   * @schema AttachmentSpecForProvider#elbSelector
   */
  readonly elbSelector?: AttachmentSpecForProviderElbSelector;

  /**
   * Instance ID to place in the ELB pool.
   *
   * @schema AttachmentSpecForProvider#instance
   */
  readonly instance?: string;

  /**
   * Reference to a Instance in ec2 to populate instance.
   *
   * @schema AttachmentSpecForProvider#instanceRef
   */
  readonly instanceRef?: AttachmentSpecForProviderInstanceRef;

  /**
   * Selector for a Instance in ec2 to populate instance.
   *
   * @schema AttachmentSpecForProvider#instanceSelector
   */
  readonly instanceSelector?: AttachmentSpecForProviderInstanceSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AttachmentSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'AttachmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProvider(obj: AttachmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'elb': obj.elb,
    'elbRef': toJson_AttachmentSpecForProviderElbRef(obj.elbRef),
    'elbSelector': toJson_AttachmentSpecForProviderElbSelector(obj.elbSelector),
    'instance': obj.instance,
    'instanceRef': toJson_AttachmentSpecForProviderInstanceRef(obj.instanceRef),
    'instanceSelector': toJson_AttachmentSpecForProviderInstanceSelector(obj.instanceSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AttachmentSpecProviderConfigRef
 */
export interface AttachmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttachmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttachmentSpecProviderConfigRef#policy
   */
  readonly policy?: AttachmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AttachmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecProviderConfigRef(obj: AttachmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttachmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AttachmentSpecProviderRef
 */
export interface AttachmentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttachmentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttachmentSpecProviderRef#policy
   */
  readonly policy?: AttachmentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AttachmentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecProviderRef(obj: AttachmentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttachmentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AttachmentSpecPublishConnectionDetailsTo
 */
export interface AttachmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AttachmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AttachmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AttachmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AttachmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AttachmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AttachmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecPublishConnectionDetailsTo(obj: AttachmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AttachmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AttachmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AttachmentSpecWriteConnectionSecretToRef
 */
export interface AttachmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AttachmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AttachmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AttachmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecWriteConnectionSecretToRef(obj: AttachmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ELB to populate elb.
 *
 * @schema AttachmentSpecForProviderElbRef
 */
export interface AttachmentSpecForProviderElbRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttachmentSpecForProviderElbRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttachmentSpecForProviderElbRef#policy
   */
  readonly policy?: AttachmentSpecForProviderElbRefPolicy;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderElbRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderElbRef(obj: AttachmentSpecForProviderElbRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttachmentSpecForProviderElbRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ELB to populate elb.
 *
 * @schema AttachmentSpecForProviderElbSelector
 */
export interface AttachmentSpecForProviderElbSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AttachmentSpecForProviderElbSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AttachmentSpecForProviderElbSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AttachmentSpecForProviderElbSelector#policy
   */
  readonly policy?: AttachmentSpecForProviderElbSelectorPolicy;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderElbSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderElbSelector(obj: AttachmentSpecForProviderElbSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AttachmentSpecForProviderElbSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in ec2 to populate instance.
 *
 * @schema AttachmentSpecForProviderInstanceRef
 */
export interface AttachmentSpecForProviderInstanceRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttachmentSpecForProviderInstanceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttachmentSpecForProviderInstanceRef#policy
   */
  readonly policy?: AttachmentSpecForProviderInstanceRefPolicy;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderInstanceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderInstanceRef(obj: AttachmentSpecForProviderInstanceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttachmentSpecForProviderInstanceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in ec2 to populate instance.
 *
 * @schema AttachmentSpecForProviderInstanceSelector
 */
export interface AttachmentSpecForProviderInstanceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AttachmentSpecForProviderInstanceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AttachmentSpecForProviderInstanceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AttachmentSpecForProviderInstanceSelector#policy
   */
  readonly policy?: AttachmentSpecForProviderInstanceSelectorPolicy;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderInstanceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderInstanceSelector(obj: AttachmentSpecForProviderInstanceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AttachmentSpecForProviderInstanceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AttachmentSpecProviderConfigRefPolicy
 */
export interface AttachmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AttachmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AttachmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecProviderConfigRefPolicy(obj: AttachmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AttachmentSpecProviderRefPolicy
 */
export interface AttachmentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AttachmentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AttachmentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecProviderRefPolicy(obj: AttachmentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AttachmentSpecPublishConnectionDetailsToConfigRef
 */
export interface AttachmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttachmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttachmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AttachmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AttachmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecPublishConnectionDetailsToConfigRef(obj: AttachmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AttachmentSpecPublishConnectionDetailsToMetadata
 */
export interface AttachmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AttachmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AttachmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AttachmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AttachmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecPublishConnectionDetailsToMetadata(obj: AttachmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AttachmentSpecForProviderElbRefPolicy
 */
export interface AttachmentSpecForProviderElbRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentSpecForProviderElbRefPolicy#resolution
   */
  readonly resolution?: AttachmentSpecForProviderElbRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentSpecForProviderElbRefPolicy#resolve
   */
  readonly resolve?: AttachmentSpecForProviderElbRefPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderElbRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderElbRefPolicy(obj: AttachmentSpecForProviderElbRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AttachmentSpecForProviderElbSelectorPolicy
 */
export interface AttachmentSpecForProviderElbSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentSpecForProviderElbSelectorPolicy#resolution
   */
  readonly resolution?: AttachmentSpecForProviderElbSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentSpecForProviderElbSelectorPolicy#resolve
   */
  readonly resolve?: AttachmentSpecForProviderElbSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderElbSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderElbSelectorPolicy(obj: AttachmentSpecForProviderElbSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AttachmentSpecForProviderInstanceRefPolicy
 */
export interface AttachmentSpecForProviderInstanceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentSpecForProviderInstanceRefPolicy#resolution
   */
  readonly resolution?: AttachmentSpecForProviderInstanceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentSpecForProviderInstanceRefPolicy#resolve
   */
  readonly resolve?: AttachmentSpecForProviderInstanceRefPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderInstanceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderInstanceRefPolicy(obj: AttachmentSpecForProviderInstanceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AttachmentSpecForProviderInstanceSelectorPolicy
 */
export interface AttachmentSpecForProviderInstanceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentSpecForProviderInstanceSelectorPolicy#resolution
   */
  readonly resolution?: AttachmentSpecForProviderInstanceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentSpecForProviderInstanceSelectorPolicy#resolve
   */
  readonly resolve?: AttachmentSpecForProviderInstanceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderInstanceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderInstanceSelectorPolicy(obj: AttachmentSpecForProviderInstanceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentSpecProviderConfigRefPolicyResolution
 */
export enum AttachmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentSpecProviderConfigRefPolicyResolve
 */
export enum AttachmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentSpecProviderRefPolicyResolution
 */
export enum AttachmentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentSpecProviderRefPolicyResolve
 */
export enum AttachmentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AttachmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AttachmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: AttachmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentSpecForProviderElbRefPolicyResolution
 */
export enum AttachmentSpecForProviderElbRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentSpecForProviderElbRefPolicyResolve
 */
export enum AttachmentSpecForProviderElbRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentSpecForProviderElbSelectorPolicyResolution
 */
export enum AttachmentSpecForProviderElbSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentSpecForProviderElbSelectorPolicyResolve
 */
export enum AttachmentSpecForProviderElbSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentSpecForProviderInstanceRefPolicyResolution
 */
export enum AttachmentSpecForProviderInstanceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentSpecForProviderInstanceRefPolicyResolve
 */
export enum AttachmentSpecForProviderInstanceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentSpecForProviderInstanceSelectorPolicyResolution
 */
export enum AttachmentSpecForProviderInstanceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentSpecForProviderInstanceSelectorPolicyResolve
 */
export enum AttachmentSpecForProviderInstanceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BackendServerPolicy is the Schema for the BackendServerPolicys API. Attaches a load balancer policy to an ELB backend server.
 *
 * @schema BackendServerPolicy
 */
export class BackendServerPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackendServerPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elb.aws.upbound.io/v1beta1',
    kind: 'BackendServerPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "BackendServerPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackendServerPolicyProps): any {
    return {
      ...BackendServerPolicy.GVK,
      ...toJson_BackendServerPolicyProps(props),
    };
  }

  /**
   * Defines a "BackendServerPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackendServerPolicyProps) {
    super(scope, id, {
      ...BackendServerPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackendServerPolicy.GVK,
      ...toJson_BackendServerPolicyProps(resolved),
    };
  }
}

/**
 * BackendServerPolicy is the Schema for the BackendServerPolicys API. Attaches a load balancer policy to an ELB backend server.
 *
 * @schema BackendServerPolicy
 */
export interface BackendServerPolicyProps {
  /**
   * @schema BackendServerPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackendServerPolicySpec defines the desired state of BackendServerPolicy
   *
   * @schema BackendServerPolicy#spec
   */
  readonly spec: BackendServerPolicySpec;

}

/**
 * Converts an object of type 'BackendServerPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendServerPolicyProps(obj: BackendServerPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackendServerPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BackendServerPolicySpec defines the desired state of BackendServerPolicy
 *
 * @schema BackendServerPolicySpec
 */
export interface BackendServerPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BackendServerPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: BackendServerPolicySpecDeletionPolicy;

  /**
   * @schema BackendServerPolicySpec#forProvider
   */
  readonly forProvider: BackendServerPolicySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BackendServerPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: BackendServerPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BackendServerPolicySpec#providerRef
   */
  readonly providerRef?: BackendServerPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BackendServerPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BackendServerPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BackendServerPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BackendServerPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BackendServerPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendServerPolicySpec(obj: BackendServerPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BackendServerPolicySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BackendServerPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BackendServerPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BackendServerPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BackendServerPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BackendServerPolicySpecDeletionPolicy
 */
export enum BackendServerPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BackendServerPolicySpecForProvider
 */
export interface BackendServerPolicySpecForProvider {
  /**
   * The instance port to apply the policy to.
   *
   * @schema BackendServerPolicySpecForProvider#instancePort
   */
  readonly instancePort: number;

  /**
   * The load balancer to attach the policy to.
   *
   * @schema BackendServerPolicySpecForProvider#loadBalancerName
   */
  readonly loadBalancerName?: string;

  /**
   * Reference to a ELB in elb to populate loadBalancerName.
   *
   * @schema BackendServerPolicySpecForProvider#loadBalancerNameRef
   */
  readonly loadBalancerNameRef?: BackendServerPolicySpecForProviderLoadBalancerNameRef;

  /**
   * Selector for a ELB in elb to populate loadBalancerName.
   *
   * @schema BackendServerPolicySpecForProvider#loadBalancerNameSelector
   */
  readonly loadBalancerNameSelector?: BackendServerPolicySpecForProviderLoadBalancerNameSelector;

  /**
   * List of Policy Names to apply to the backend server.
   *
   * @schema BackendServerPolicySpecForProvider#policyNames
   */
  readonly policyNames?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BackendServerPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'BackendServerPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendServerPolicySpecForProvider(obj: BackendServerPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instancePort': obj.instancePort,
    'loadBalancerName': obj.loadBalancerName,
    'loadBalancerNameRef': toJson_BackendServerPolicySpecForProviderLoadBalancerNameRef(obj.loadBalancerNameRef),
    'loadBalancerNameSelector': toJson_BackendServerPolicySpecForProviderLoadBalancerNameSelector(obj.loadBalancerNameSelector),
    'policyNames': obj.policyNames?.map(y => y),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BackendServerPolicySpecProviderConfigRef
 */
export interface BackendServerPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackendServerPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackendServerPolicySpecProviderConfigRef#policy
   */
  readonly policy?: BackendServerPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BackendServerPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendServerPolicySpecProviderConfigRef(obj: BackendServerPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackendServerPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BackendServerPolicySpecProviderRef
 */
export interface BackendServerPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackendServerPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackendServerPolicySpecProviderRef#policy
   */
  readonly policy?: BackendServerPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BackendServerPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendServerPolicySpecProviderRef(obj: BackendServerPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackendServerPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BackendServerPolicySpecPublishConnectionDetailsTo
 */
export interface BackendServerPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BackendServerPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BackendServerPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BackendServerPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BackendServerPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BackendServerPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BackendServerPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendServerPolicySpecPublishConnectionDetailsTo(obj: BackendServerPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BackendServerPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BackendServerPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BackendServerPolicySpecWriteConnectionSecretToRef
 */
export interface BackendServerPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BackendServerPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BackendServerPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BackendServerPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendServerPolicySpecWriteConnectionSecretToRef(obj: BackendServerPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ELB in elb to populate loadBalancerName.
 *
 * @schema BackendServerPolicySpecForProviderLoadBalancerNameRef
 */
export interface BackendServerPolicySpecForProviderLoadBalancerNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackendServerPolicySpecForProviderLoadBalancerNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackendServerPolicySpecForProviderLoadBalancerNameRef#policy
   */
  readonly policy?: BackendServerPolicySpecForProviderLoadBalancerNameRefPolicy;

}

/**
 * Converts an object of type 'BackendServerPolicySpecForProviderLoadBalancerNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendServerPolicySpecForProviderLoadBalancerNameRef(obj: BackendServerPolicySpecForProviderLoadBalancerNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackendServerPolicySpecForProviderLoadBalancerNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ELB in elb to populate loadBalancerName.
 *
 * @schema BackendServerPolicySpecForProviderLoadBalancerNameSelector
 */
export interface BackendServerPolicySpecForProviderLoadBalancerNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BackendServerPolicySpecForProviderLoadBalancerNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BackendServerPolicySpecForProviderLoadBalancerNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BackendServerPolicySpecForProviderLoadBalancerNameSelector#policy
   */
  readonly policy?: BackendServerPolicySpecForProviderLoadBalancerNameSelectorPolicy;

}

/**
 * Converts an object of type 'BackendServerPolicySpecForProviderLoadBalancerNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendServerPolicySpecForProviderLoadBalancerNameSelector(obj: BackendServerPolicySpecForProviderLoadBalancerNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BackendServerPolicySpecForProviderLoadBalancerNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackendServerPolicySpecProviderConfigRefPolicy
 */
export interface BackendServerPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackendServerPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BackendServerPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackendServerPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BackendServerPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BackendServerPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendServerPolicySpecProviderConfigRefPolicy(obj: BackendServerPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackendServerPolicySpecProviderRefPolicy
 */
export interface BackendServerPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackendServerPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: BackendServerPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackendServerPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: BackendServerPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BackendServerPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendServerPolicySpecProviderRefPolicy(obj: BackendServerPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BackendServerPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface BackendServerPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackendServerPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackendServerPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BackendServerPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BackendServerPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendServerPolicySpecPublishConnectionDetailsToConfigRef(obj: BackendServerPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackendServerPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BackendServerPolicySpecPublishConnectionDetailsToMetadata
 */
export interface BackendServerPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BackendServerPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BackendServerPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BackendServerPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BackendServerPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendServerPolicySpecPublishConnectionDetailsToMetadata(obj: BackendServerPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackendServerPolicySpecForProviderLoadBalancerNameRefPolicy
 */
export interface BackendServerPolicySpecForProviderLoadBalancerNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackendServerPolicySpecForProviderLoadBalancerNameRefPolicy#resolution
   */
  readonly resolution?: BackendServerPolicySpecForProviderLoadBalancerNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackendServerPolicySpecForProviderLoadBalancerNameRefPolicy#resolve
   */
  readonly resolve?: BackendServerPolicySpecForProviderLoadBalancerNameRefPolicyResolve;

}

/**
 * Converts an object of type 'BackendServerPolicySpecForProviderLoadBalancerNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendServerPolicySpecForProviderLoadBalancerNameRefPolicy(obj: BackendServerPolicySpecForProviderLoadBalancerNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BackendServerPolicySpecForProviderLoadBalancerNameSelectorPolicy
 */
export interface BackendServerPolicySpecForProviderLoadBalancerNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackendServerPolicySpecForProviderLoadBalancerNameSelectorPolicy#resolution
   */
  readonly resolution?: BackendServerPolicySpecForProviderLoadBalancerNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackendServerPolicySpecForProviderLoadBalancerNameSelectorPolicy#resolve
   */
  readonly resolve?: BackendServerPolicySpecForProviderLoadBalancerNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BackendServerPolicySpecForProviderLoadBalancerNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendServerPolicySpecForProviderLoadBalancerNameSelectorPolicy(obj: BackendServerPolicySpecForProviderLoadBalancerNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackendServerPolicySpecProviderConfigRefPolicyResolution
 */
export enum BackendServerPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackendServerPolicySpecProviderConfigRefPolicyResolve
 */
export enum BackendServerPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackendServerPolicySpecProviderRefPolicyResolution
 */
export enum BackendServerPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackendServerPolicySpecProviderRefPolicyResolve
 */
export enum BackendServerPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BackendServerPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BackendServerPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackendServerPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BackendServerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackendServerPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BackendServerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BackendServerPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackendServerPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: BackendServerPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackendServerPolicySpecForProviderLoadBalancerNameRefPolicyResolution
 */
export enum BackendServerPolicySpecForProviderLoadBalancerNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackendServerPolicySpecForProviderLoadBalancerNameRefPolicyResolve
 */
export enum BackendServerPolicySpecForProviderLoadBalancerNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackendServerPolicySpecForProviderLoadBalancerNameSelectorPolicyResolution
 */
export enum BackendServerPolicySpecForProviderLoadBalancerNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackendServerPolicySpecForProviderLoadBalancerNameSelectorPolicyResolve
 */
export enum BackendServerPolicySpecForProviderLoadBalancerNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackendServerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BackendServerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackendServerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BackendServerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ELB is the Schema for the ELBs API. Provides an Elastic Load Balancer resource.
 *
 * @schema ELB
 */
export class Elb extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ELB"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elb.aws.upbound.io/v1beta1',
    kind: 'ELB',
  }

  /**
   * Renders a Kubernetes manifest for "ELB".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ElbProps): any {
    return {
      ...Elb.GVK,
      ...toJson_ElbProps(props),
    };
  }

  /**
   * Defines a "ELB" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ElbProps) {
    super(scope, id, {
      ...Elb.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Elb.GVK,
      ...toJson_ElbProps(resolved),
    };
  }
}

/**
 * ELB is the Schema for the ELBs API. Provides an Elastic Load Balancer resource.
 *
 * @schema ELB
 */
export interface ElbProps {
  /**
   * @schema ELB#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ELBSpec defines the desired state of ELB
   *
   * @schema ELB#spec
   */
  readonly spec: ElbSpec;

}

/**
 * Converts an object of type 'ElbProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbProps(obj: ElbProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ElbSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ELBSpec defines the desired state of ELB
 *
 * @schema ElbSpec
 */
export interface ElbSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ElbSpec#deletionPolicy
   */
  readonly deletionPolicy?: ElbSpecDeletionPolicy;

  /**
   * @schema ElbSpec#forProvider
   */
  readonly forProvider: ElbSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ElbSpec#providerConfigRef
   */
  readonly providerConfigRef?: ElbSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ElbSpec#providerRef
   */
  readonly providerRef?: ElbSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ElbSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ElbSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ElbSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ElbSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ElbSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpec(obj: ElbSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ElbSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ElbSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ElbSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ElbSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ElbSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ElbSpecDeletionPolicy
 */
export enum ElbSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ElbSpecForProvider
 */
export interface ElbSpecForProvider {
  /**
   * An Access Logs block. Access Logs documented below.
   *
   * @schema ElbSpecForProvider#accessLogs
   */
  readonly accessLogs?: ElbSpecForProviderAccessLogs[];

  /**
   * The AZ's to serve traffic in.
   *
   * @schema ElbSpecForProvider#availabilityZones
   */
  readonly availabilityZones?: string[];

  /**
   * Boolean to enable connection draining. Default: false
   *
   * @schema ElbSpecForProvider#connectionDraining
   */
  readonly connectionDraining?: boolean;

  /**
   * The time in seconds to allow for connections to drain. Default: 300
   *
   * @schema ElbSpecForProvider#connectionDrainingTimeout
   */
  readonly connectionDrainingTimeout?: number;

  /**
   * Enable cross-zone load balancing. Default: true
   *
   * @schema ElbSpecForProvider#crossZoneLoadBalancing
   */
  readonly crossZoneLoadBalancing?: boolean;

  /**
   * Determines how the load balancer handles requests that might pose a security risk to an application due to HTTP desync. Valid values are monitor, defensive (default), strictest.
   *
   * @schema ElbSpecForProvider#desyncMitigationMode
   */
  readonly desyncMitigationMode?: string;

  /**
   * A health_check block. Health Check documented below.
   *
   * @schema ElbSpecForProvider#healthCheck
   */
  readonly healthCheck?: ElbSpecForProviderHealthCheck[];

  /**
   * The time in seconds that the connection is allowed to be idle. Default: 60
   *
   * @schema ElbSpecForProvider#idleTimeout
   */
  readonly idleTimeout?: number;

  /**
   * A list of instance ids to place in the ELB pool.
   *
   * @schema ElbSpecForProvider#instances
   */
  readonly instances?: string[];

  /**
   * References to Instance in ec2 to populate instances.
   *
   * @schema ElbSpecForProvider#instancesRefs
   */
  readonly instancesRefs?: ElbSpecForProviderInstancesRefs[];

  /**
   * Selector for a list of Instance in ec2 to populate instances.
   *
   * @schema ElbSpecForProvider#instancesSelector
   */
  readonly instancesSelector?: ElbSpecForProviderInstancesSelector;

  /**
   * If true, ELB will be an internal ELB.
   *
   * @schema ElbSpecForProvider#internal
   */
  readonly internal?: boolean;

  /**
   * A list of listener blocks. Listeners documented below.
   *
   * @schema ElbSpecForProvider#listener
   */
  readonly listener: ElbSpecForProviderListener[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ElbSpecForProvider#region
   */
  readonly region: string;

  /**
   * A list of security group IDs to assign to the ELB. Only valid if creating an ELB within a VPC
   *
   * @schema ElbSpecForProvider#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * The name of the security group that you can use as part of your inbound rules for your load balancer's back-end application instances. Use this for Classic or Default VPC only.
   *
   * @schema ElbSpecForProvider#sourceSecurityGroup
   */
  readonly sourceSecurityGroup?: string;

  /**
   * A list of subnet IDs to attach to the ELB.
   *
   * @schema ElbSpecForProvider#subnets
   */
  readonly subnets?: string[];

  /**
   * References to Subnet in ec2 to populate subnets.
   *
   * @schema ElbSpecForProvider#subnetsRefs
   */
  readonly subnetsRefs?: ElbSpecForProviderSubnetsRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnets.
   *
   * @schema ElbSpecForProvider#subnetsSelector
   */
  readonly subnetsSelector?: ElbSpecForProviderSubnetsSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema ElbSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ElbSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProvider(obj: ElbSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLogs': obj.accessLogs?.map(y => toJson_ElbSpecForProviderAccessLogs(y)),
    'availabilityZones': obj.availabilityZones?.map(y => y),
    'connectionDraining': obj.connectionDraining,
    'connectionDrainingTimeout': obj.connectionDrainingTimeout,
    'crossZoneLoadBalancing': obj.crossZoneLoadBalancing,
    'desyncMitigationMode': obj.desyncMitigationMode,
    'healthCheck': obj.healthCheck?.map(y => toJson_ElbSpecForProviderHealthCheck(y)),
    'idleTimeout': obj.idleTimeout,
    'instances': obj.instances?.map(y => y),
    'instancesRefs': obj.instancesRefs?.map(y => toJson_ElbSpecForProviderInstancesRefs(y)),
    'instancesSelector': toJson_ElbSpecForProviderInstancesSelector(obj.instancesSelector),
    'internal': obj.internal,
    'listener': obj.listener?.map(y => toJson_ElbSpecForProviderListener(y)),
    'region': obj.region,
    'securityGroups': obj.securityGroups?.map(y => y),
    'sourceSecurityGroup': obj.sourceSecurityGroup,
    'subnets': obj.subnets?.map(y => y),
    'subnetsRefs': obj.subnetsRefs?.map(y => toJson_ElbSpecForProviderSubnetsRefs(y)),
    'subnetsSelector': toJson_ElbSpecForProviderSubnetsSelector(obj.subnetsSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ElbSpecProviderConfigRef
 */
export interface ElbSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ElbSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ElbSpecProviderConfigRef#policy
   */
  readonly policy?: ElbSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ElbSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecProviderConfigRef(obj: ElbSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ElbSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ElbSpecProviderRef
 */
export interface ElbSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ElbSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ElbSpecProviderRef#policy
   */
  readonly policy?: ElbSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ElbSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecProviderRef(obj: ElbSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ElbSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ElbSpecPublishConnectionDetailsTo
 */
export interface ElbSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ElbSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ElbSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ElbSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ElbSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ElbSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ElbSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecPublishConnectionDetailsTo(obj: ElbSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ElbSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ElbSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ElbSpecWriteConnectionSecretToRef
 */
export interface ElbSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ElbSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ElbSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ElbSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecWriteConnectionSecretToRef(obj: ElbSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ElbSpecForProviderAccessLogs
 */
export interface ElbSpecForProviderAccessLogs {
  /**
   * The S3 bucket name to store the logs in.
   *
   * @schema ElbSpecForProviderAccessLogs#bucket
   */
  readonly bucket: string;

  /**
   * The S3 bucket prefix. Logs are stored in the root if not configured.
   *
   * @schema ElbSpecForProviderAccessLogs#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * Boolean to enable / disable access_logs. Default is true
   *
   * @default true
   * @schema ElbSpecForProviderAccessLogs#enabled
   */
  readonly enabled?: boolean;

  /**
   * The publishing interval in minutes. Valid values: 5 and 60. Default: 60
   *
   * @schema ElbSpecForProviderAccessLogs#interval
   */
  readonly interval?: number;

}

/**
 * Converts an object of type 'ElbSpecForProviderAccessLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderAccessLogs(obj: ElbSpecForProviderAccessLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketPrefix': obj.bucketPrefix,
    'enabled': obj.enabled,
    'interval': obj.interval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ElbSpecForProviderHealthCheck
 */
export interface ElbSpecForProviderHealthCheck {
  /**
   * The number of checks before the instance is declared healthy.
   *
   * @schema ElbSpecForProviderHealthCheck#healthyThreshold
   */
  readonly healthyThreshold: number;

  /**
   * The publishing interval in minutes. Valid values: 5 and 60. Default: 60
   *
   * @schema ElbSpecForProviderHealthCheck#interval
   */
  readonly interval: number;

  /**
   * The target of the check. Valid pattern is "${PROTOCOL}:${PORT}${PATH}", where PROTOCOL values are:
   *
   * @schema ElbSpecForProviderHealthCheck#target
   */
  readonly target: string;

  /**
   * The length of time before the check times out.
   *
   * @schema ElbSpecForProviderHealthCheck#timeout
   */
  readonly timeout: number;

  /**
   * The number of checks before the instance is declared unhealthy.
   *
   * @schema ElbSpecForProviderHealthCheck#unhealthyThreshold
   */
  readonly unhealthyThreshold: number;

}

/**
 * Converts an object of type 'ElbSpecForProviderHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderHealthCheck(obj: ElbSpecForProviderHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthyThreshold': obj.healthyThreshold,
    'interval': obj.interval,
    'target': obj.target,
    'timeout': obj.timeout,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ElbSpecForProviderInstancesRefs
 */
export interface ElbSpecForProviderInstancesRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ElbSpecForProviderInstancesRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ElbSpecForProviderInstancesRefs#policy
   */
  readonly policy?: ElbSpecForProviderInstancesRefsPolicy;

}

/**
 * Converts an object of type 'ElbSpecForProviderInstancesRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderInstancesRefs(obj: ElbSpecForProviderInstancesRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ElbSpecForProviderInstancesRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Instance in ec2 to populate instances.
 *
 * @schema ElbSpecForProviderInstancesSelector
 */
export interface ElbSpecForProviderInstancesSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ElbSpecForProviderInstancesSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ElbSpecForProviderInstancesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ElbSpecForProviderInstancesSelector#policy
   */
  readonly policy?: ElbSpecForProviderInstancesSelectorPolicy;

}

/**
 * Converts an object of type 'ElbSpecForProviderInstancesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderInstancesSelector(obj: ElbSpecForProviderInstancesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ElbSpecForProviderInstancesSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ElbSpecForProviderListener
 */
export interface ElbSpecForProviderListener {
  /**
   * The port on the instance to route to
   *
   * @schema ElbSpecForProviderListener#instancePort
   */
  readonly instancePort: number;

  /**
   * The protocol to use to the instance. Valid values are HTTP, HTTPS, TCP, or SSL
   *
   * @schema ElbSpecForProviderListener#instanceProtocol
   */
  readonly instanceProtocol: string;

  /**
   * The port to listen on for the load balancer
   *
   * @schema ElbSpecForProviderListener#lbPort
   */
  readonly lbPort: number;

  /**
   * The protocol to listen on. Valid values are HTTP, HTTPS, TCP, or SSL
   *
   * @schema ElbSpecForProviderListener#lbProtocol
   */
  readonly lbProtocol: string;

  /**
   * The ARN of an SSL certificate you have uploaded to AWS IAM. Note ECDSA-specific restrictions below.  Only valid when
   *
   * @schema ElbSpecForProviderListener#sslCertificateId
   */
  readonly sslCertificateId?: string;

}

/**
 * Converts an object of type 'ElbSpecForProviderListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderListener(obj: ElbSpecForProviderListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instancePort': obj.instancePort,
    'instanceProtocol': obj.instanceProtocol,
    'lbPort': obj.lbPort,
    'lbProtocol': obj.lbProtocol,
    'sslCertificateId': obj.sslCertificateId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ElbSpecForProviderSubnetsRefs
 */
export interface ElbSpecForProviderSubnetsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ElbSpecForProviderSubnetsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ElbSpecForProviderSubnetsRefs#policy
   */
  readonly policy?: ElbSpecForProviderSubnetsRefsPolicy;

}

/**
 * Converts an object of type 'ElbSpecForProviderSubnetsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderSubnetsRefs(obj: ElbSpecForProviderSubnetsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ElbSpecForProviderSubnetsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnets.
 *
 * @schema ElbSpecForProviderSubnetsSelector
 */
export interface ElbSpecForProviderSubnetsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ElbSpecForProviderSubnetsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ElbSpecForProviderSubnetsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ElbSpecForProviderSubnetsSelector#policy
   */
  readonly policy?: ElbSpecForProviderSubnetsSelectorPolicy;

}

/**
 * Converts an object of type 'ElbSpecForProviderSubnetsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderSubnetsSelector(obj: ElbSpecForProviderSubnetsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ElbSpecForProviderSubnetsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ElbSpecProviderConfigRefPolicy
 */
export interface ElbSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ElbSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ElbSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ElbSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ElbSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ElbSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecProviderConfigRefPolicy(obj: ElbSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ElbSpecProviderRefPolicy
 */
export interface ElbSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ElbSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ElbSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ElbSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ElbSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ElbSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecProviderRefPolicy(obj: ElbSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ElbSpecPublishConnectionDetailsToConfigRef
 */
export interface ElbSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ElbSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ElbSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ElbSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ElbSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecPublishConnectionDetailsToConfigRef(obj: ElbSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ElbSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ElbSpecPublishConnectionDetailsToMetadata
 */
export interface ElbSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ElbSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ElbSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ElbSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ElbSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecPublishConnectionDetailsToMetadata(obj: ElbSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ElbSpecForProviderInstancesRefsPolicy
 */
export interface ElbSpecForProviderInstancesRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ElbSpecForProviderInstancesRefsPolicy#resolution
   */
  readonly resolution?: ElbSpecForProviderInstancesRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ElbSpecForProviderInstancesRefsPolicy#resolve
   */
  readonly resolve?: ElbSpecForProviderInstancesRefsPolicyResolve;

}

/**
 * Converts an object of type 'ElbSpecForProviderInstancesRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderInstancesRefsPolicy(obj: ElbSpecForProviderInstancesRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ElbSpecForProviderInstancesSelectorPolicy
 */
export interface ElbSpecForProviderInstancesSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ElbSpecForProviderInstancesSelectorPolicy#resolution
   */
  readonly resolution?: ElbSpecForProviderInstancesSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ElbSpecForProviderInstancesSelectorPolicy#resolve
   */
  readonly resolve?: ElbSpecForProviderInstancesSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ElbSpecForProviderInstancesSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderInstancesSelectorPolicy(obj: ElbSpecForProviderInstancesSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ElbSpecForProviderSubnetsRefsPolicy
 */
export interface ElbSpecForProviderSubnetsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ElbSpecForProviderSubnetsRefsPolicy#resolution
   */
  readonly resolution?: ElbSpecForProviderSubnetsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ElbSpecForProviderSubnetsRefsPolicy#resolve
   */
  readonly resolve?: ElbSpecForProviderSubnetsRefsPolicyResolve;

}

/**
 * Converts an object of type 'ElbSpecForProviderSubnetsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderSubnetsRefsPolicy(obj: ElbSpecForProviderSubnetsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ElbSpecForProviderSubnetsSelectorPolicy
 */
export interface ElbSpecForProviderSubnetsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ElbSpecForProviderSubnetsSelectorPolicy#resolution
   */
  readonly resolution?: ElbSpecForProviderSubnetsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ElbSpecForProviderSubnetsSelectorPolicy#resolve
   */
  readonly resolve?: ElbSpecForProviderSubnetsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ElbSpecForProviderSubnetsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecForProviderSubnetsSelectorPolicy(obj: ElbSpecForProviderSubnetsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ElbSpecProviderConfigRefPolicyResolution
 */
export enum ElbSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ElbSpecProviderConfigRefPolicyResolve
 */
export enum ElbSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ElbSpecProviderRefPolicyResolution
 */
export enum ElbSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ElbSpecProviderRefPolicyResolve
 */
export enum ElbSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ElbSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ElbSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ElbSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ElbSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ElbSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ElbSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ElbSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ElbSpecPublishConnectionDetailsToConfigRefPolicy(obj: ElbSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ElbSpecForProviderInstancesRefsPolicyResolution
 */
export enum ElbSpecForProviderInstancesRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ElbSpecForProviderInstancesRefsPolicyResolve
 */
export enum ElbSpecForProviderInstancesRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ElbSpecForProviderInstancesSelectorPolicyResolution
 */
export enum ElbSpecForProviderInstancesSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ElbSpecForProviderInstancesSelectorPolicyResolve
 */
export enum ElbSpecForProviderInstancesSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ElbSpecForProviderSubnetsRefsPolicyResolution
 */
export enum ElbSpecForProviderSubnetsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ElbSpecForProviderSubnetsRefsPolicyResolve
 */
export enum ElbSpecForProviderSubnetsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ElbSpecForProviderSubnetsSelectorPolicyResolution
 */
export enum ElbSpecForProviderSubnetsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ElbSpecForProviderSubnetsSelectorPolicyResolve
 */
export enum ElbSpecForProviderSubnetsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ElbSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ElbSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ElbSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ElbSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LBCookieStickinessPolicy is the Schema for the LBCookieStickinessPolicys API. Provides a load balancer cookie stickiness policy, which allows an ELB to control the sticky session lifetime of the browser.
 *
 * @schema LBCookieStickinessPolicy
 */
export class LbCookieStickinessPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LBCookieStickinessPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elb.aws.upbound.io/v1beta1',
    kind: 'LBCookieStickinessPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "LBCookieStickinessPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LbCookieStickinessPolicyProps): any {
    return {
      ...LbCookieStickinessPolicy.GVK,
      ...toJson_LbCookieStickinessPolicyProps(props),
    };
  }

  /**
   * Defines a "LBCookieStickinessPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LbCookieStickinessPolicyProps) {
    super(scope, id, {
      ...LbCookieStickinessPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LbCookieStickinessPolicy.GVK,
      ...toJson_LbCookieStickinessPolicyProps(resolved),
    };
  }
}

/**
 * LBCookieStickinessPolicy is the Schema for the LBCookieStickinessPolicys API. Provides a load balancer cookie stickiness policy, which allows an ELB to control the sticky session lifetime of the browser.
 *
 * @schema LBCookieStickinessPolicy
 */
export interface LbCookieStickinessPolicyProps {
  /**
   * @schema LBCookieStickinessPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LBCookieStickinessPolicySpec defines the desired state of LBCookieStickinessPolicy
   *
   * @schema LBCookieStickinessPolicy#spec
   */
  readonly spec: LbCookieStickinessPolicySpec;

}

/**
 * Converts an object of type 'LbCookieStickinessPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbCookieStickinessPolicyProps(obj: LbCookieStickinessPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LbCookieStickinessPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LBCookieStickinessPolicySpec defines the desired state of LBCookieStickinessPolicy
 *
 * @schema LbCookieStickinessPolicySpec
 */
export interface LbCookieStickinessPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema LbCookieStickinessPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: LbCookieStickinessPolicySpecDeletionPolicy;

  /**
   * @schema LbCookieStickinessPolicySpec#forProvider
   */
  readonly forProvider: LbCookieStickinessPolicySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LbCookieStickinessPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: LbCookieStickinessPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LbCookieStickinessPolicySpec#providerRef
   */
  readonly providerRef?: LbCookieStickinessPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LbCookieStickinessPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LbCookieStickinessPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LbCookieStickinessPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LbCookieStickinessPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LbCookieStickinessPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbCookieStickinessPolicySpec(obj: LbCookieStickinessPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LbCookieStickinessPolicySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_LbCookieStickinessPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LbCookieStickinessPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LbCookieStickinessPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LbCookieStickinessPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema LbCookieStickinessPolicySpecDeletionPolicy
 */
export enum LbCookieStickinessPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LbCookieStickinessPolicySpecForProvider
 */
export interface LbCookieStickinessPolicySpecForProvider {
  /**
   * The time period after which the session cookie should be considered stale, expressed in seconds.
   *
   * @schema LbCookieStickinessPolicySpecForProvider#cookieExpirationPeriod
   */
  readonly cookieExpirationPeriod?: number;

  /**
   * The load balancer port to which the policy should be applied. This must be an active listener on the load balancer.
   *
   * @schema LbCookieStickinessPolicySpecForProvider#lbPort
   */
  readonly lbPort: number;

  /**
   * The load balancer to which the policy should be attached.
   *
   * @schema LbCookieStickinessPolicySpecForProvider#loadBalancer
   */
  readonly loadBalancer?: string;

  /**
   * Reference to a ELB in elb to populate loadBalancer.
   *
   * @schema LbCookieStickinessPolicySpecForProvider#loadBalancerRef
   */
  readonly loadBalancerRef?: LbCookieStickinessPolicySpecForProviderLoadBalancerRef;

  /**
   * Selector for a ELB in elb to populate loadBalancer.
   *
   * @schema LbCookieStickinessPolicySpecForProvider#loadBalancerSelector
   */
  readonly loadBalancerSelector?: LbCookieStickinessPolicySpecForProviderLoadBalancerSelector;

  /**
   * The name of the stickiness policy.
   *
   * @schema LbCookieStickinessPolicySpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LbCookieStickinessPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'LbCookieStickinessPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbCookieStickinessPolicySpecForProvider(obj: LbCookieStickinessPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookieExpirationPeriod': obj.cookieExpirationPeriod,
    'lbPort': obj.lbPort,
    'loadBalancer': obj.loadBalancer,
    'loadBalancerRef': toJson_LbCookieStickinessPolicySpecForProviderLoadBalancerRef(obj.loadBalancerRef),
    'loadBalancerSelector': toJson_LbCookieStickinessPolicySpecForProviderLoadBalancerSelector(obj.loadBalancerSelector),
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LbCookieStickinessPolicySpecProviderConfigRef
 */
export interface LbCookieStickinessPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbCookieStickinessPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbCookieStickinessPolicySpecProviderConfigRef#policy
   */
  readonly policy?: LbCookieStickinessPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LbCookieStickinessPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbCookieStickinessPolicySpecProviderConfigRef(obj: LbCookieStickinessPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbCookieStickinessPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LbCookieStickinessPolicySpecProviderRef
 */
export interface LbCookieStickinessPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbCookieStickinessPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbCookieStickinessPolicySpecProviderRef#policy
   */
  readonly policy?: LbCookieStickinessPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LbCookieStickinessPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbCookieStickinessPolicySpecProviderRef(obj: LbCookieStickinessPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbCookieStickinessPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LbCookieStickinessPolicySpecPublishConnectionDetailsTo
 */
export interface LbCookieStickinessPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LbCookieStickinessPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LbCookieStickinessPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LbCookieStickinessPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LbCookieStickinessPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LbCookieStickinessPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbCookieStickinessPolicySpecPublishConnectionDetailsTo(obj: LbCookieStickinessPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LbCookieStickinessPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LbCookieStickinessPolicySpecWriteConnectionSecretToRef
 */
export interface LbCookieStickinessPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LbCookieStickinessPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LbCookieStickinessPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LbCookieStickinessPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbCookieStickinessPolicySpecWriteConnectionSecretToRef(obj: LbCookieStickinessPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ELB in elb to populate loadBalancer.
 *
 * @schema LbCookieStickinessPolicySpecForProviderLoadBalancerRef
 */
export interface LbCookieStickinessPolicySpecForProviderLoadBalancerRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbCookieStickinessPolicySpecForProviderLoadBalancerRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbCookieStickinessPolicySpecForProviderLoadBalancerRef#policy
   */
  readonly policy?: LbCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy;

}

/**
 * Converts an object of type 'LbCookieStickinessPolicySpecForProviderLoadBalancerRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbCookieStickinessPolicySpecForProviderLoadBalancerRef(obj: LbCookieStickinessPolicySpecForProviderLoadBalancerRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ELB in elb to populate loadBalancer.
 *
 * @schema LbCookieStickinessPolicySpecForProviderLoadBalancerSelector
 */
export interface LbCookieStickinessPolicySpecForProviderLoadBalancerSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LbCookieStickinessPolicySpecForProviderLoadBalancerSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LbCookieStickinessPolicySpecForProviderLoadBalancerSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LbCookieStickinessPolicySpecForProviderLoadBalancerSelector#policy
   */
  readonly policy?: LbCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy;

}

/**
 * Converts an object of type 'LbCookieStickinessPolicySpecForProviderLoadBalancerSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbCookieStickinessPolicySpecForProviderLoadBalancerSelector(obj: LbCookieStickinessPolicySpecForProviderLoadBalancerSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LbCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbCookieStickinessPolicySpecProviderConfigRefPolicy
 */
export interface LbCookieStickinessPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbCookieStickinessPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LbCookieStickinessPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbCookieStickinessPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LbCookieStickinessPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LbCookieStickinessPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbCookieStickinessPolicySpecProviderConfigRefPolicy(obj: LbCookieStickinessPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbCookieStickinessPolicySpecProviderRefPolicy
 */
export interface LbCookieStickinessPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbCookieStickinessPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: LbCookieStickinessPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbCookieStickinessPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: LbCookieStickinessPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LbCookieStickinessPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbCookieStickinessPolicySpecProviderRefPolicy(obj: LbCookieStickinessPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef(obj: LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LbCookieStickinessPolicySpecPublishConnectionDetailsToMetadata
 */
export interface LbCookieStickinessPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LbCookieStickinessPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LbCookieStickinessPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LbCookieStickinessPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LbCookieStickinessPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbCookieStickinessPolicySpecPublishConnectionDetailsToMetadata(obj: LbCookieStickinessPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy
 */
export interface LbCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy#resolution
   */
  readonly resolution?: LbCookieStickinessPolicySpecForProviderLoadBalancerRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy#resolve
   */
  readonly resolve?: LbCookieStickinessPolicySpecForProviderLoadBalancerRefPolicyResolve;

}

/**
 * Converts an object of type 'LbCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy(obj: LbCookieStickinessPolicySpecForProviderLoadBalancerRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LbCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy
 */
export interface LbCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy#resolution
   */
  readonly resolution?: LbCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy#resolve
   */
  readonly resolve?: LbCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LbCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy(obj: LbCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbCookieStickinessPolicySpecProviderConfigRefPolicyResolution
 */
export enum LbCookieStickinessPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbCookieStickinessPolicySpecProviderConfigRefPolicyResolve
 */
export enum LbCookieStickinessPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbCookieStickinessPolicySpecProviderRefPolicyResolution
 */
export enum LbCookieStickinessPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbCookieStickinessPolicySpecProviderRefPolicyResolve
 */
export enum LbCookieStickinessPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbCookieStickinessPolicySpecForProviderLoadBalancerRefPolicyResolution
 */
export enum LbCookieStickinessPolicySpecForProviderLoadBalancerRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbCookieStickinessPolicySpecForProviderLoadBalancerRefPolicyResolve
 */
export enum LbCookieStickinessPolicySpecForProviderLoadBalancerRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicyResolution
 */
export enum LbCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicyResolve
 */
export enum LbCookieStickinessPolicySpecForProviderLoadBalancerSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LbCookieStickinessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LBSSLNegotiationPolicy is the Schema for the LBSSLNegotiationPolicys API. Provides a load balancer SSL negotiation policy, which allows an ELB to control which ciphers and protocols are supported during SSL negotiations between a client and a load balancer.
 *
 * @schema LBSSLNegotiationPolicy
 */
export class LbsslNegotiationPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LBSSLNegotiationPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elb.aws.upbound.io/v1beta1',
    kind: 'LBSSLNegotiationPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "LBSSLNegotiationPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LbsslNegotiationPolicyProps): any {
    return {
      ...LbsslNegotiationPolicy.GVK,
      ...toJson_LbsslNegotiationPolicyProps(props),
    };
  }

  /**
   * Defines a "LBSSLNegotiationPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LbsslNegotiationPolicyProps) {
    super(scope, id, {
      ...LbsslNegotiationPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LbsslNegotiationPolicy.GVK,
      ...toJson_LbsslNegotiationPolicyProps(resolved),
    };
  }
}

/**
 * LBSSLNegotiationPolicy is the Schema for the LBSSLNegotiationPolicys API. Provides a load balancer SSL negotiation policy, which allows an ELB to control which ciphers and protocols are supported during SSL negotiations between a client and a load balancer.
 *
 * @schema LBSSLNegotiationPolicy
 */
export interface LbsslNegotiationPolicyProps {
  /**
   * @schema LBSSLNegotiationPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LBSSLNegotiationPolicySpec defines the desired state of LBSSLNegotiationPolicy
   *
   * @schema LBSSLNegotiationPolicy#spec
   */
  readonly spec: LbsslNegotiationPolicySpec;

}

/**
 * Converts an object of type 'LbsslNegotiationPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbsslNegotiationPolicyProps(obj: LbsslNegotiationPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LbsslNegotiationPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LBSSLNegotiationPolicySpec defines the desired state of LBSSLNegotiationPolicy
 *
 * @schema LbsslNegotiationPolicySpec
 */
export interface LbsslNegotiationPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema LbsslNegotiationPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: LbsslNegotiationPolicySpecDeletionPolicy;

  /**
   * @schema LbsslNegotiationPolicySpec#forProvider
   */
  readonly forProvider: LbsslNegotiationPolicySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LbsslNegotiationPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: LbsslNegotiationPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LbsslNegotiationPolicySpec#providerRef
   */
  readonly providerRef?: LbsslNegotiationPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LbsslNegotiationPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LbsslNegotiationPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LbsslNegotiationPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LbsslNegotiationPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LbsslNegotiationPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbsslNegotiationPolicySpec(obj: LbsslNegotiationPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LbsslNegotiationPolicySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_LbsslNegotiationPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LbsslNegotiationPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LbsslNegotiationPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LbsslNegotiationPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema LbsslNegotiationPolicySpecDeletionPolicy
 */
export enum LbsslNegotiationPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LbsslNegotiationPolicySpecForProvider
 */
export interface LbsslNegotiationPolicySpecForProvider {
  /**
   * An SSL Negotiation policy attribute. Each has two properties:
   *
   * @schema LbsslNegotiationPolicySpecForProvider#attribute
   */
  readonly attribute?: LbsslNegotiationPolicySpecForProviderAttribute[];

  /**
   * The load balancer port to which the policy should be applied. This must be an active listener on the load balancer.
   *
   * @schema LbsslNegotiationPolicySpecForProvider#lbPort
   */
  readonly lbPort: number;

  /**
   * The load balancer to which the policy should be attached.
   *
   * @schema LbsslNegotiationPolicySpecForProvider#loadBalancer
   */
  readonly loadBalancer?: string;

  /**
   * Reference to a ELB in elb to populate loadBalancer.
   *
   * @schema LbsslNegotiationPolicySpecForProvider#loadBalancerRef
   */
  readonly loadBalancerRef?: LbsslNegotiationPolicySpecForProviderLoadBalancerRef;

  /**
   * Selector for a ELB in elb to populate loadBalancer.
   *
   * @schema LbsslNegotiationPolicySpecForProvider#loadBalancerSelector
   */
  readonly loadBalancerSelector?: LbsslNegotiationPolicySpecForProviderLoadBalancerSelector;

  /**
   * The name of the SSL negotiation policy.
   *
   * @schema LbsslNegotiationPolicySpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LbsslNegotiationPolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * Map of arbitrary keys and values that, when changed, will trigger a redeployment.
   *
   * @schema LbsslNegotiationPolicySpecForProvider#triggers
   */
  readonly triggers?: { [key: string]: string };

}

/**
 * Converts an object of type 'LbsslNegotiationPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbsslNegotiationPolicySpecForProvider(obj: LbsslNegotiationPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attribute': obj.attribute?.map(y => toJson_LbsslNegotiationPolicySpecForProviderAttribute(y)),
    'lbPort': obj.lbPort,
    'loadBalancer': obj.loadBalancer,
    'loadBalancerRef': toJson_LbsslNegotiationPolicySpecForProviderLoadBalancerRef(obj.loadBalancerRef),
    'loadBalancerSelector': toJson_LbsslNegotiationPolicySpecForProviderLoadBalancerSelector(obj.loadBalancerSelector),
    'name': obj.name,
    'region': obj.region,
    'triggers': ((obj.triggers) === undefined) ? undefined : (Object.entries(obj.triggers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LbsslNegotiationPolicySpecProviderConfigRef
 */
export interface LbsslNegotiationPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbsslNegotiationPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbsslNegotiationPolicySpecProviderConfigRef#policy
   */
  readonly policy?: LbsslNegotiationPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LbsslNegotiationPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbsslNegotiationPolicySpecProviderConfigRef(obj: LbsslNegotiationPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbsslNegotiationPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LbsslNegotiationPolicySpecProviderRef
 */
export interface LbsslNegotiationPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbsslNegotiationPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbsslNegotiationPolicySpecProviderRef#policy
   */
  readonly policy?: LbsslNegotiationPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LbsslNegotiationPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbsslNegotiationPolicySpecProviderRef(obj: LbsslNegotiationPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbsslNegotiationPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LbsslNegotiationPolicySpecPublishConnectionDetailsTo
 */
export interface LbsslNegotiationPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LbsslNegotiationPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LbsslNegotiationPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LbsslNegotiationPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LbsslNegotiationPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LbsslNegotiationPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbsslNegotiationPolicySpecPublishConnectionDetailsTo(obj: LbsslNegotiationPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LbsslNegotiationPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LbsslNegotiationPolicySpecWriteConnectionSecretToRef
 */
export interface LbsslNegotiationPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LbsslNegotiationPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LbsslNegotiationPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LbsslNegotiationPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbsslNegotiationPolicySpecWriteConnectionSecretToRef(obj: LbsslNegotiationPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbsslNegotiationPolicySpecForProviderAttribute
 */
export interface LbsslNegotiationPolicySpecForProviderAttribute {
  /**
   * The name of the SSL negotiation policy.
   *
   * @schema LbsslNegotiationPolicySpecForProviderAttribute#name
   */
  readonly name: string;

  /**
   * The value of the attribute
   *
   * @schema LbsslNegotiationPolicySpecForProviderAttribute#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'LbsslNegotiationPolicySpecForProviderAttribute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbsslNegotiationPolicySpecForProviderAttribute(obj: LbsslNegotiationPolicySpecForProviderAttribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ELB in elb to populate loadBalancer.
 *
 * @schema LbsslNegotiationPolicySpecForProviderLoadBalancerRef
 */
export interface LbsslNegotiationPolicySpecForProviderLoadBalancerRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbsslNegotiationPolicySpecForProviderLoadBalancerRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbsslNegotiationPolicySpecForProviderLoadBalancerRef#policy
   */
  readonly policy?: LbsslNegotiationPolicySpecForProviderLoadBalancerRefPolicy;

}

/**
 * Converts an object of type 'LbsslNegotiationPolicySpecForProviderLoadBalancerRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbsslNegotiationPolicySpecForProviderLoadBalancerRef(obj: LbsslNegotiationPolicySpecForProviderLoadBalancerRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbsslNegotiationPolicySpecForProviderLoadBalancerRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ELB in elb to populate loadBalancer.
 *
 * @schema LbsslNegotiationPolicySpecForProviderLoadBalancerSelector
 */
export interface LbsslNegotiationPolicySpecForProviderLoadBalancerSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LbsslNegotiationPolicySpecForProviderLoadBalancerSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LbsslNegotiationPolicySpecForProviderLoadBalancerSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LbsslNegotiationPolicySpecForProviderLoadBalancerSelector#policy
   */
  readonly policy?: LbsslNegotiationPolicySpecForProviderLoadBalancerSelectorPolicy;

}

/**
 * Converts an object of type 'LbsslNegotiationPolicySpecForProviderLoadBalancerSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbsslNegotiationPolicySpecForProviderLoadBalancerSelector(obj: LbsslNegotiationPolicySpecForProviderLoadBalancerSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LbsslNegotiationPolicySpecForProviderLoadBalancerSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbsslNegotiationPolicySpecProviderConfigRefPolicy
 */
export interface LbsslNegotiationPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbsslNegotiationPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LbsslNegotiationPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbsslNegotiationPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LbsslNegotiationPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LbsslNegotiationPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbsslNegotiationPolicySpecProviderConfigRefPolicy(obj: LbsslNegotiationPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbsslNegotiationPolicySpecProviderRefPolicy
 */
export interface LbsslNegotiationPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbsslNegotiationPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: LbsslNegotiationPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbsslNegotiationPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: LbsslNegotiationPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LbsslNegotiationPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbsslNegotiationPolicySpecProviderRefPolicy(obj: LbsslNegotiationPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRef(obj: LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LbsslNegotiationPolicySpecPublishConnectionDetailsToMetadata
 */
export interface LbsslNegotiationPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LbsslNegotiationPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LbsslNegotiationPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LbsslNegotiationPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LbsslNegotiationPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbsslNegotiationPolicySpecPublishConnectionDetailsToMetadata(obj: LbsslNegotiationPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbsslNegotiationPolicySpecForProviderLoadBalancerRefPolicy
 */
export interface LbsslNegotiationPolicySpecForProviderLoadBalancerRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbsslNegotiationPolicySpecForProviderLoadBalancerRefPolicy#resolution
   */
  readonly resolution?: LbsslNegotiationPolicySpecForProviderLoadBalancerRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbsslNegotiationPolicySpecForProviderLoadBalancerRefPolicy#resolve
   */
  readonly resolve?: LbsslNegotiationPolicySpecForProviderLoadBalancerRefPolicyResolve;

}

/**
 * Converts an object of type 'LbsslNegotiationPolicySpecForProviderLoadBalancerRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbsslNegotiationPolicySpecForProviderLoadBalancerRefPolicy(obj: LbsslNegotiationPolicySpecForProviderLoadBalancerRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LbsslNegotiationPolicySpecForProviderLoadBalancerSelectorPolicy
 */
export interface LbsslNegotiationPolicySpecForProviderLoadBalancerSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbsslNegotiationPolicySpecForProviderLoadBalancerSelectorPolicy#resolution
   */
  readonly resolution?: LbsslNegotiationPolicySpecForProviderLoadBalancerSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbsslNegotiationPolicySpecForProviderLoadBalancerSelectorPolicy#resolve
   */
  readonly resolve?: LbsslNegotiationPolicySpecForProviderLoadBalancerSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LbsslNegotiationPolicySpecForProviderLoadBalancerSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbsslNegotiationPolicySpecForProviderLoadBalancerSelectorPolicy(obj: LbsslNegotiationPolicySpecForProviderLoadBalancerSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbsslNegotiationPolicySpecProviderConfigRefPolicyResolution
 */
export enum LbsslNegotiationPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbsslNegotiationPolicySpecProviderConfigRefPolicyResolve
 */
export enum LbsslNegotiationPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbsslNegotiationPolicySpecProviderRefPolicyResolution
 */
export enum LbsslNegotiationPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbsslNegotiationPolicySpecProviderRefPolicyResolve
 */
export enum LbsslNegotiationPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbsslNegotiationPolicySpecForProviderLoadBalancerRefPolicyResolution
 */
export enum LbsslNegotiationPolicySpecForProviderLoadBalancerRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbsslNegotiationPolicySpecForProviderLoadBalancerRefPolicyResolve
 */
export enum LbsslNegotiationPolicySpecForProviderLoadBalancerRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbsslNegotiationPolicySpecForProviderLoadBalancerSelectorPolicyResolution
 */
export enum LbsslNegotiationPolicySpecForProviderLoadBalancerSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbsslNegotiationPolicySpecForProviderLoadBalancerSelectorPolicyResolve
 */
export enum LbsslNegotiationPolicySpecForProviderLoadBalancerSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LbsslNegotiationPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ListenerPolicy is the Schema for the ListenerPolicys API. Attaches a load balancer policy to an ELB Listener.
 *
 * @schema ListenerPolicy
 */
export class ListenerPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ListenerPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elb.aws.upbound.io/v1beta1',
    kind: 'ListenerPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ListenerPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ListenerPolicyProps): any {
    return {
      ...ListenerPolicy.GVK,
      ...toJson_ListenerPolicyProps(props),
    };
  }

  /**
   * Defines a "ListenerPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ListenerPolicyProps) {
    super(scope, id, {
      ...ListenerPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ListenerPolicy.GVK,
      ...toJson_ListenerPolicyProps(resolved),
    };
  }
}

/**
 * ListenerPolicy is the Schema for the ListenerPolicys API. Attaches a load balancer policy to an ELB Listener.
 *
 * @schema ListenerPolicy
 */
export interface ListenerPolicyProps {
  /**
   * @schema ListenerPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ListenerPolicySpec defines the desired state of ListenerPolicy
   *
   * @schema ListenerPolicy#spec
   */
  readonly spec: ListenerPolicySpec;

}

/**
 * Converts an object of type 'ListenerPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerPolicyProps(obj: ListenerPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ListenerPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ListenerPolicySpec defines the desired state of ListenerPolicy
 *
 * @schema ListenerPolicySpec
 */
export interface ListenerPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ListenerPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: ListenerPolicySpecDeletionPolicy;

  /**
   * @schema ListenerPolicySpec#forProvider
   */
  readonly forProvider: ListenerPolicySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ListenerPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: ListenerPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ListenerPolicySpec#providerRef
   */
  readonly providerRef?: ListenerPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ListenerPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ListenerPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ListenerPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ListenerPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ListenerPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerPolicySpec(obj: ListenerPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ListenerPolicySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ListenerPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ListenerPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ListenerPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ListenerPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ListenerPolicySpecDeletionPolicy
 */
export enum ListenerPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ListenerPolicySpecForProvider
 */
export interface ListenerPolicySpecForProvider {
  /**
   * The load balancer to attach the policy to.
   *
   * @schema ListenerPolicySpecForProvider#loadBalancerName
   */
  readonly loadBalancerName?: string;

  /**
   * Reference to a ELB in elb to populate loadBalancerName.
   *
   * @schema ListenerPolicySpecForProvider#loadBalancerNameRef
   */
  readonly loadBalancerNameRef?: ListenerPolicySpecForProviderLoadBalancerNameRef;

  /**
   * Selector for a ELB in elb to populate loadBalancerName.
   *
   * @schema ListenerPolicySpecForProvider#loadBalancerNameSelector
   */
  readonly loadBalancerNameSelector?: ListenerPolicySpecForProviderLoadBalancerNameSelector;

  /**
   * The load balancer listener port to apply the policy to.
   *
   * @schema ListenerPolicySpecForProvider#loadBalancerPort
   */
  readonly loadBalancerPort: number;

  /**
   * List of Policy Names to apply to the backend server.
   *
   * @schema ListenerPolicySpecForProvider#policyNames
   */
  readonly policyNames?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ListenerPolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * Map of arbitrary keys and values that, when changed, will trigger an update.
   *
   * @schema ListenerPolicySpecForProvider#triggers
   */
  readonly triggers?: { [key: string]: string };

}

/**
 * Converts an object of type 'ListenerPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerPolicySpecForProvider(obj: ListenerPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'loadBalancerName': obj.loadBalancerName,
    'loadBalancerNameRef': toJson_ListenerPolicySpecForProviderLoadBalancerNameRef(obj.loadBalancerNameRef),
    'loadBalancerNameSelector': toJson_ListenerPolicySpecForProviderLoadBalancerNameSelector(obj.loadBalancerNameSelector),
    'loadBalancerPort': obj.loadBalancerPort,
    'policyNames': obj.policyNames?.map(y => y),
    'region': obj.region,
    'triggers': ((obj.triggers) === undefined) ? undefined : (Object.entries(obj.triggers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ListenerPolicySpecProviderConfigRef
 */
export interface ListenerPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ListenerPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ListenerPolicySpecProviderConfigRef#policy
   */
  readonly policy?: ListenerPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ListenerPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerPolicySpecProviderConfigRef(obj: ListenerPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ListenerPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ListenerPolicySpecProviderRef
 */
export interface ListenerPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ListenerPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ListenerPolicySpecProviderRef#policy
   */
  readonly policy?: ListenerPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ListenerPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerPolicySpecProviderRef(obj: ListenerPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ListenerPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ListenerPolicySpecPublishConnectionDetailsTo
 */
export interface ListenerPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ListenerPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ListenerPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ListenerPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ListenerPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ListenerPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ListenerPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerPolicySpecPublishConnectionDetailsTo(obj: ListenerPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ListenerPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ListenerPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ListenerPolicySpecWriteConnectionSecretToRef
 */
export interface ListenerPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ListenerPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ListenerPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ListenerPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerPolicySpecWriteConnectionSecretToRef(obj: ListenerPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ELB in elb to populate loadBalancerName.
 *
 * @schema ListenerPolicySpecForProviderLoadBalancerNameRef
 */
export interface ListenerPolicySpecForProviderLoadBalancerNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ListenerPolicySpecForProviderLoadBalancerNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ListenerPolicySpecForProviderLoadBalancerNameRef#policy
   */
  readonly policy?: ListenerPolicySpecForProviderLoadBalancerNameRefPolicy;

}

/**
 * Converts an object of type 'ListenerPolicySpecForProviderLoadBalancerNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerPolicySpecForProviderLoadBalancerNameRef(obj: ListenerPolicySpecForProviderLoadBalancerNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ListenerPolicySpecForProviderLoadBalancerNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ELB in elb to populate loadBalancerName.
 *
 * @schema ListenerPolicySpecForProviderLoadBalancerNameSelector
 */
export interface ListenerPolicySpecForProviderLoadBalancerNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ListenerPolicySpecForProviderLoadBalancerNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ListenerPolicySpecForProviderLoadBalancerNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ListenerPolicySpecForProviderLoadBalancerNameSelector#policy
   */
  readonly policy?: ListenerPolicySpecForProviderLoadBalancerNameSelectorPolicy;

}

/**
 * Converts an object of type 'ListenerPolicySpecForProviderLoadBalancerNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerPolicySpecForProviderLoadBalancerNameSelector(obj: ListenerPolicySpecForProviderLoadBalancerNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ListenerPolicySpecForProviderLoadBalancerNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ListenerPolicySpecProviderConfigRefPolicy
 */
export interface ListenerPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ListenerPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ListenerPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ListenerPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerPolicySpecProviderConfigRefPolicy(obj: ListenerPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ListenerPolicySpecProviderRefPolicy
 */
export interface ListenerPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: ListenerPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: ListenerPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ListenerPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerPolicySpecProviderRefPolicy(obj: ListenerPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ListenerPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface ListenerPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ListenerPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ListenerPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ListenerPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ListenerPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerPolicySpecPublishConnectionDetailsToConfigRef(obj: ListenerPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ListenerPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ListenerPolicySpecPublishConnectionDetailsToMetadata
 */
export interface ListenerPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ListenerPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ListenerPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ListenerPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ListenerPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerPolicySpecPublishConnectionDetailsToMetadata(obj: ListenerPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ListenerPolicySpecForProviderLoadBalancerNameRefPolicy
 */
export interface ListenerPolicySpecForProviderLoadBalancerNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerPolicySpecForProviderLoadBalancerNameRefPolicy#resolution
   */
  readonly resolution?: ListenerPolicySpecForProviderLoadBalancerNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerPolicySpecForProviderLoadBalancerNameRefPolicy#resolve
   */
  readonly resolve?: ListenerPolicySpecForProviderLoadBalancerNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ListenerPolicySpecForProviderLoadBalancerNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerPolicySpecForProviderLoadBalancerNameRefPolicy(obj: ListenerPolicySpecForProviderLoadBalancerNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ListenerPolicySpecForProviderLoadBalancerNameSelectorPolicy
 */
export interface ListenerPolicySpecForProviderLoadBalancerNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerPolicySpecForProviderLoadBalancerNameSelectorPolicy#resolution
   */
  readonly resolution?: ListenerPolicySpecForProviderLoadBalancerNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerPolicySpecForProviderLoadBalancerNameSelectorPolicy#resolve
   */
  readonly resolve?: ListenerPolicySpecForProviderLoadBalancerNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ListenerPolicySpecForProviderLoadBalancerNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerPolicySpecForProviderLoadBalancerNameSelectorPolicy(obj: ListenerPolicySpecForProviderLoadBalancerNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerPolicySpecProviderConfigRefPolicyResolution
 */
export enum ListenerPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerPolicySpecProviderConfigRefPolicyResolve
 */
export enum ListenerPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerPolicySpecProviderRefPolicyResolution
 */
export enum ListenerPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerPolicySpecProviderRefPolicyResolve
 */
export enum ListenerPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ListenerPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ListenerPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ListenerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ListenerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ListenerPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: ListenerPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerPolicySpecForProviderLoadBalancerNameRefPolicyResolution
 */
export enum ListenerPolicySpecForProviderLoadBalancerNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerPolicySpecForProviderLoadBalancerNameRefPolicyResolve
 */
export enum ListenerPolicySpecForProviderLoadBalancerNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerPolicySpecForProviderLoadBalancerNameSelectorPolicyResolution
 */
export enum ListenerPolicySpecForProviderLoadBalancerNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerPolicySpecForProviderLoadBalancerNameSelectorPolicyResolve
 */
export enum ListenerPolicySpecForProviderLoadBalancerNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ListenerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ListenerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Policy is the Schema for the Policys API. Provides a load balancer policy, which can be attached to an ELB listener or backend server.
 *
 * @schema Policy
 */
export class Policy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Policy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elb.aws.upbound.io/v1beta1',
    kind: 'Policy',
  }

  /**
   * Renders a Kubernetes manifest for "Policy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PolicyProps): any {
    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(props),
    };
  }

  /**
   * Defines a "Policy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PolicyProps) {
    super(scope, id, {
      ...Policy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(resolved),
    };
  }
}

/**
 * Policy is the Schema for the Policys API. Provides a load balancer policy, which can be attached to an ELB listener or backend server.
 *
 * @schema Policy
 */
export interface PolicyProps {
  /**
   * @schema Policy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PolicySpec defines the desired state of Policy
   *
   * @schema Policy#spec
   */
  readonly spec: PolicySpec;

}

/**
 * Converts an object of type 'PolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyProps(obj: PolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicySpec defines the desired state of Policy
 *
 * @schema PolicySpec
 */
export interface PolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema PolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: PolicySpecDeletionPolicy;

  /**
   * @schema PolicySpec#forProvider
   */
  readonly forProvider: PolicySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: PolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PolicySpec#providerRef
   */
  readonly providerRef?: PolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpec(obj: PolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PolicySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_PolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema PolicySpecDeletionPolicy
 */
export enum PolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PolicySpecForProvider
 */
export interface PolicySpecForProvider {
  /**
   * The load balancer on which the policy is defined.
   *
   * @schema PolicySpecForProvider#loadBalancerName
   */
  readonly loadBalancerName?: string;

  /**
   * Reference to a ELB in elb to populate loadBalancerName.
   *
   * @schema PolicySpecForProvider#loadBalancerNameRef
   */
  readonly loadBalancerNameRef?: PolicySpecForProviderLoadBalancerNameRef;

  /**
   * Selector for a ELB in elb to populate loadBalancerName.
   *
   * @schema PolicySpecForProvider#loadBalancerNameSelector
   */
  readonly loadBalancerNameSelector?: PolicySpecForProviderLoadBalancerNameSelector;

  /**
   * Policy attribute to apply to the policy.
   *
   * @schema PolicySpecForProvider#policyAttribute
   */
  readonly policyAttribute?: PolicySpecForProviderPolicyAttribute[];

  /**
   * The name of the load balancer policy.
   *
   * @schema PolicySpecForProvider#policyName
   */
  readonly policyName: string;

  /**
   * The policy type.
   *
   * @schema PolicySpecForProvider#policyTypeName
   */
  readonly policyTypeName: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'PolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProvider(obj: PolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'loadBalancerName': obj.loadBalancerName,
    'loadBalancerNameRef': toJson_PolicySpecForProviderLoadBalancerNameRef(obj.loadBalancerNameRef),
    'loadBalancerNameSelector': toJson_PolicySpecForProviderLoadBalancerNameSelector(obj.loadBalancerNameSelector),
    'policyAttribute': obj.policyAttribute?.map(y => toJson_PolicySpecForProviderPolicyAttribute(y)),
    'policyName': obj.policyName,
    'policyTypeName': obj.policyTypeName,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PolicySpecProviderConfigRef
 */
export interface PolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecProviderConfigRef#policy
   */
  readonly policy?: PolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRef(obj: PolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PolicySpecProviderRef
 */
export interface PolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecProviderRef#policy
   */
  readonly policy?: PolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderRef(obj: PolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PolicySpecPublishConnectionDetailsTo
 */
export interface PolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsTo(obj: PolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PolicySpecWriteConnectionSecretToRef
 */
export interface PolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecWriteConnectionSecretToRef(obj: PolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ELB in elb to populate loadBalancerName.
 *
 * @schema PolicySpecForProviderLoadBalancerNameRef
 */
export interface PolicySpecForProviderLoadBalancerNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecForProviderLoadBalancerNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecForProviderLoadBalancerNameRef#policy
   */
  readonly policy?: PolicySpecForProviderLoadBalancerNameRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderLoadBalancerNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderLoadBalancerNameRef(obj: PolicySpecForProviderLoadBalancerNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecForProviderLoadBalancerNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ELB in elb to populate loadBalancerName.
 *
 * @schema PolicySpecForProviderLoadBalancerNameSelector
 */
export interface PolicySpecForProviderLoadBalancerNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PolicySpecForProviderLoadBalancerNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PolicySpecForProviderLoadBalancerNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PolicySpecForProviderLoadBalancerNameSelector#policy
   */
  readonly policy?: PolicySpecForProviderLoadBalancerNameSelectorPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderLoadBalancerNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderLoadBalancerNameSelector(obj: PolicySpecForProviderLoadBalancerNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PolicySpecForProviderLoadBalancerNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPolicyAttribute
 */
export interface PolicySpecForProviderPolicyAttribute {
  /**
   * @schema PolicySpecForProviderPolicyAttribute#name
   */
  readonly name?: string;

  /**
   * @schema PolicySpecForProviderPolicyAttribute#value
   */
  readonly value?: string;

  /**
   * Reference to a Policy in elb to populate value.
   *
   * @schema PolicySpecForProviderPolicyAttribute#valueRef
   */
  readonly valueRef?: PolicySpecForProviderPolicyAttributeValueRef;

  /**
   * Selector for a Policy in elb to populate value.
   *
   * @schema PolicySpecForProviderPolicyAttribute#valueSelector
   */
  readonly valueSelector?: PolicySpecForProviderPolicyAttributeValueSelector;

}

/**
 * Converts an object of type 'PolicySpecForProviderPolicyAttribute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPolicyAttribute(obj: PolicySpecForProviderPolicyAttribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueRef': toJson_PolicySpecForProviderPolicyAttributeValueRef(obj.valueRef),
    'valueSelector': toJson_PolicySpecForProviderPolicyAttributeValueSelector(obj.valueSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecProviderConfigRefPolicy
 */
export interface PolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRefPolicy(obj: PolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecProviderRefPolicy
 */
export interface PolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: PolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: PolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderRefPolicy(obj: PolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRef
 */
export interface PolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj: PolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PolicySpecPublishConnectionDetailsToMetadata
 */
export interface PolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToMetadata(obj: PolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecForProviderLoadBalancerNameRefPolicy
 */
export interface PolicySpecForProviderLoadBalancerNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderLoadBalancerNameRefPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderLoadBalancerNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderLoadBalancerNameRefPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderLoadBalancerNameRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderLoadBalancerNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderLoadBalancerNameRefPolicy(obj: PolicySpecForProviderLoadBalancerNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PolicySpecForProviderLoadBalancerNameSelectorPolicy
 */
export interface PolicySpecForProviderLoadBalancerNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderLoadBalancerNameSelectorPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderLoadBalancerNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderLoadBalancerNameSelectorPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderLoadBalancerNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderLoadBalancerNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderLoadBalancerNameSelectorPolicy(obj: PolicySpecForProviderLoadBalancerNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Policy in elb to populate value.
 *
 * @schema PolicySpecForProviderPolicyAttributeValueRef
 */
export interface PolicySpecForProviderPolicyAttributeValueRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecForProviderPolicyAttributeValueRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecForProviderPolicyAttributeValueRef#policy
   */
  readonly policy?: PolicySpecForProviderPolicyAttributeValueRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderPolicyAttributeValueRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPolicyAttributeValueRef(obj: PolicySpecForProviderPolicyAttributeValueRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecForProviderPolicyAttributeValueRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Policy in elb to populate value.
 *
 * @schema PolicySpecForProviderPolicyAttributeValueSelector
 */
export interface PolicySpecForProviderPolicyAttributeValueSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PolicySpecForProviderPolicyAttributeValueSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PolicySpecForProviderPolicyAttributeValueSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PolicySpecForProviderPolicyAttributeValueSelector#policy
   */
  readonly policy?: PolicySpecForProviderPolicyAttributeValueSelectorPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderPolicyAttributeValueSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPolicyAttributeValueSelector(obj: PolicySpecForProviderPolicyAttributeValueSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PolicySpecForProviderPolicyAttributeValueSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolution
 */
export enum PolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolve
 */
export enum PolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecProviderRefPolicyResolution
 */
export enum PolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecProviderRefPolicyResolve
 */
export enum PolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: PolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderLoadBalancerNameRefPolicyResolution
 */
export enum PolicySpecForProviderLoadBalancerNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderLoadBalancerNameRefPolicyResolve
 */
export enum PolicySpecForProviderLoadBalancerNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderLoadBalancerNameSelectorPolicyResolution
 */
export enum PolicySpecForProviderLoadBalancerNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderLoadBalancerNameSelectorPolicyResolve
 */
export enum PolicySpecForProviderLoadBalancerNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PolicySpecForProviderPolicyAttributeValueRefPolicy
 */
export interface PolicySpecForProviderPolicyAttributeValueRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderPolicyAttributeValueRefPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderPolicyAttributeValueRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderPolicyAttributeValueRefPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderPolicyAttributeValueRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderPolicyAttributeValueRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPolicyAttributeValueRefPolicy(obj: PolicySpecForProviderPolicyAttributeValueRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PolicySpecForProviderPolicyAttributeValueSelectorPolicy
 */
export interface PolicySpecForProviderPolicyAttributeValueSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderPolicyAttributeValueSelectorPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderPolicyAttributeValueSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderPolicyAttributeValueSelectorPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderPolicyAttributeValueSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderPolicyAttributeValueSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPolicyAttributeValueSelectorPolicy(obj: PolicySpecForProviderPolicyAttributeValueSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderPolicyAttributeValueRefPolicyResolution
 */
export enum PolicySpecForProviderPolicyAttributeValueRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderPolicyAttributeValueRefPolicyResolve
 */
export enum PolicySpecForProviderPolicyAttributeValueRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderPolicyAttributeValueSelectorPolicyResolution
 */
export enum PolicySpecForProviderPolicyAttributeValueSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderPolicyAttributeValueSelectorPolicyResolve
 */
export enum PolicySpecForProviderPolicyAttributeValueSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProxyProtocolPolicy is the Schema for the ProxyProtocolPolicys API. Provides a proxy protocol policy, which allows an ELB to carry a client connection information to a backend.
 *
 * @schema ProxyProtocolPolicy
 */
export class ProxyProtocolPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProxyProtocolPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elb.aws.upbound.io/v1beta1',
    kind: 'ProxyProtocolPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ProxyProtocolPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProxyProtocolPolicyProps): any {
    return {
      ...ProxyProtocolPolicy.GVK,
      ...toJson_ProxyProtocolPolicyProps(props),
    };
  }

  /**
   * Defines a "ProxyProtocolPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProxyProtocolPolicyProps) {
    super(scope, id, {
      ...ProxyProtocolPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProxyProtocolPolicy.GVK,
      ...toJson_ProxyProtocolPolicyProps(resolved),
    };
  }
}

/**
 * ProxyProtocolPolicy is the Schema for the ProxyProtocolPolicys API. Provides a proxy protocol policy, which allows an ELB to carry a client connection information to a backend.
 *
 * @schema ProxyProtocolPolicy
 */
export interface ProxyProtocolPolicyProps {
  /**
   * @schema ProxyProtocolPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProxyProtocolPolicySpec defines the desired state of ProxyProtocolPolicy
   *
   * @schema ProxyProtocolPolicy#spec
   */
  readonly spec: ProxyProtocolPolicySpec;

}

/**
 * Converts an object of type 'ProxyProtocolPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyProtocolPolicyProps(obj: ProxyProtocolPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProxyProtocolPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyProtocolPolicySpec defines the desired state of ProxyProtocolPolicy
 *
 * @schema ProxyProtocolPolicySpec
 */
export interface ProxyProtocolPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ProxyProtocolPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: ProxyProtocolPolicySpecDeletionPolicy;

  /**
   * @schema ProxyProtocolPolicySpec#forProvider
   */
  readonly forProvider: ProxyProtocolPolicySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProxyProtocolPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: ProxyProtocolPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ProxyProtocolPolicySpec#providerRef
   */
  readonly providerRef?: ProxyProtocolPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProxyProtocolPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProxyProtocolPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProxyProtocolPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProxyProtocolPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProxyProtocolPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyProtocolPolicySpec(obj: ProxyProtocolPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProxyProtocolPolicySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ProxyProtocolPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ProxyProtocolPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ProxyProtocolPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProxyProtocolPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ProxyProtocolPolicySpecDeletionPolicy
 */
export enum ProxyProtocolPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProxyProtocolPolicySpecForProvider
 */
export interface ProxyProtocolPolicySpecForProvider {
  /**
   * List of instance ports to which the policy should be applied. This can be specified if the protocol is SSL or TCP.
   *
   * @schema ProxyProtocolPolicySpecForProvider#instancePorts
   */
  readonly instancePorts: string[];

  /**
   * The load balancer to which the policy should be attached.
   *
   * @schema ProxyProtocolPolicySpecForProvider#loadBalancer
   */
  readonly loadBalancer?: string;

  /**
   * Reference to a ELB in elb to populate loadBalancer.
   *
   * @schema ProxyProtocolPolicySpecForProvider#loadBalancerRef
   */
  readonly loadBalancerRef?: ProxyProtocolPolicySpecForProviderLoadBalancerRef;

  /**
   * Selector for a ELB in elb to populate loadBalancer.
   *
   * @schema ProxyProtocolPolicySpecForProvider#loadBalancerSelector
   */
  readonly loadBalancerSelector?: ProxyProtocolPolicySpecForProviderLoadBalancerSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ProxyProtocolPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ProxyProtocolPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyProtocolPolicySpecForProvider(obj: ProxyProtocolPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instancePorts': obj.instancePorts?.map(y => y),
    'loadBalancer': obj.loadBalancer,
    'loadBalancerRef': toJson_ProxyProtocolPolicySpecForProviderLoadBalancerRef(obj.loadBalancerRef),
    'loadBalancerSelector': toJson_ProxyProtocolPolicySpecForProviderLoadBalancerSelector(obj.loadBalancerSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProxyProtocolPolicySpecProviderConfigRef
 */
export interface ProxyProtocolPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxyProtocolPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxyProtocolPolicySpecProviderConfigRef#policy
   */
  readonly policy?: ProxyProtocolPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProxyProtocolPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyProtocolPolicySpecProviderConfigRef(obj: ProxyProtocolPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxyProtocolPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ProxyProtocolPolicySpecProviderRef
 */
export interface ProxyProtocolPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxyProtocolPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxyProtocolPolicySpecProviderRef#policy
   */
  readonly policy?: ProxyProtocolPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ProxyProtocolPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyProtocolPolicySpecProviderRef(obj: ProxyProtocolPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxyProtocolPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProxyProtocolPolicySpecPublishConnectionDetailsTo
 */
export interface ProxyProtocolPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProxyProtocolPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProxyProtocolPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProxyProtocolPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProxyProtocolPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProxyProtocolPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyProtocolPolicySpecPublishConnectionDetailsTo(obj: ProxyProtocolPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProxyProtocolPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProxyProtocolPolicySpecWriteConnectionSecretToRef
 */
export interface ProxyProtocolPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProxyProtocolPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProxyProtocolPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProxyProtocolPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyProtocolPolicySpecWriteConnectionSecretToRef(obj: ProxyProtocolPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ELB in elb to populate loadBalancer.
 *
 * @schema ProxyProtocolPolicySpecForProviderLoadBalancerRef
 */
export interface ProxyProtocolPolicySpecForProviderLoadBalancerRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxyProtocolPolicySpecForProviderLoadBalancerRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxyProtocolPolicySpecForProviderLoadBalancerRef#policy
   */
  readonly policy?: ProxyProtocolPolicySpecForProviderLoadBalancerRefPolicy;

}

/**
 * Converts an object of type 'ProxyProtocolPolicySpecForProviderLoadBalancerRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyProtocolPolicySpecForProviderLoadBalancerRef(obj: ProxyProtocolPolicySpecForProviderLoadBalancerRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxyProtocolPolicySpecForProviderLoadBalancerRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ELB in elb to populate loadBalancer.
 *
 * @schema ProxyProtocolPolicySpecForProviderLoadBalancerSelector
 */
export interface ProxyProtocolPolicySpecForProviderLoadBalancerSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProxyProtocolPolicySpecForProviderLoadBalancerSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProxyProtocolPolicySpecForProviderLoadBalancerSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProxyProtocolPolicySpecForProviderLoadBalancerSelector#policy
   */
  readonly policy?: ProxyProtocolPolicySpecForProviderLoadBalancerSelectorPolicy;

}

/**
 * Converts an object of type 'ProxyProtocolPolicySpecForProviderLoadBalancerSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyProtocolPolicySpecForProviderLoadBalancerSelector(obj: ProxyProtocolPolicySpecForProviderLoadBalancerSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProxyProtocolPolicySpecForProviderLoadBalancerSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProxyProtocolPolicySpecProviderConfigRefPolicy
 */
export interface ProxyProtocolPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyProtocolPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProxyProtocolPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyProtocolPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProxyProtocolPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxyProtocolPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyProtocolPolicySpecProviderConfigRefPolicy(obj: ProxyProtocolPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProxyProtocolPolicySpecProviderRefPolicy
 */
export interface ProxyProtocolPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyProtocolPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: ProxyProtocolPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyProtocolPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: ProxyProtocolPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxyProtocolPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyProtocolPolicySpecProviderRefPolicy(obj: ProxyProtocolPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRef(obj: ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProxyProtocolPolicySpecPublishConnectionDetailsToMetadata
 */
export interface ProxyProtocolPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProxyProtocolPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProxyProtocolPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProxyProtocolPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProxyProtocolPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyProtocolPolicySpecPublishConnectionDetailsToMetadata(obj: ProxyProtocolPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProxyProtocolPolicySpecForProviderLoadBalancerRefPolicy
 */
export interface ProxyProtocolPolicySpecForProviderLoadBalancerRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyProtocolPolicySpecForProviderLoadBalancerRefPolicy#resolution
   */
  readonly resolution?: ProxyProtocolPolicySpecForProviderLoadBalancerRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyProtocolPolicySpecForProviderLoadBalancerRefPolicy#resolve
   */
  readonly resolve?: ProxyProtocolPolicySpecForProviderLoadBalancerRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxyProtocolPolicySpecForProviderLoadBalancerRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyProtocolPolicySpecForProviderLoadBalancerRefPolicy(obj: ProxyProtocolPolicySpecForProviderLoadBalancerRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProxyProtocolPolicySpecForProviderLoadBalancerSelectorPolicy
 */
export interface ProxyProtocolPolicySpecForProviderLoadBalancerSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyProtocolPolicySpecForProviderLoadBalancerSelectorPolicy#resolution
   */
  readonly resolution?: ProxyProtocolPolicySpecForProviderLoadBalancerSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyProtocolPolicySpecForProviderLoadBalancerSelectorPolicy#resolve
   */
  readonly resolve?: ProxyProtocolPolicySpecForProviderLoadBalancerSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProxyProtocolPolicySpecForProviderLoadBalancerSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyProtocolPolicySpecForProviderLoadBalancerSelectorPolicy(obj: ProxyProtocolPolicySpecForProviderLoadBalancerSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyProtocolPolicySpecProviderConfigRefPolicyResolution
 */
export enum ProxyProtocolPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyProtocolPolicySpecProviderConfigRefPolicyResolve
 */
export enum ProxyProtocolPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyProtocolPolicySpecProviderRefPolicyResolution
 */
export enum ProxyProtocolPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyProtocolPolicySpecProviderRefPolicyResolve
 */
export enum ProxyProtocolPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyProtocolPolicySpecForProviderLoadBalancerRefPolicyResolution
 */
export enum ProxyProtocolPolicySpecForProviderLoadBalancerRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyProtocolPolicySpecForProviderLoadBalancerRefPolicyResolve
 */
export enum ProxyProtocolPolicySpecForProviderLoadBalancerRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyProtocolPolicySpecForProviderLoadBalancerSelectorPolicyResolution
 */
export enum ProxyProtocolPolicySpecForProviderLoadBalancerSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyProtocolPolicySpecForProviderLoadBalancerSelectorPolicyResolve
 */
export enum ProxyProtocolPolicySpecForProviderLoadBalancerSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProxyProtocolPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

