// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AuthenticationProfile is the Schema for the AuthenticationProfiles API. Creates a Redshift authentication profile
 *
 * @schema AuthenticationProfile
 */
export class AuthenticationProfile extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AuthenticationProfile"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshift.aws.upbound.io/v1beta1',
    kind: 'AuthenticationProfile',
  }

  /**
   * Renders a Kubernetes manifest for "AuthenticationProfile".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AuthenticationProfileProps): any {
    return {
      ...AuthenticationProfile.GVK,
      ...toJson_AuthenticationProfileProps(props),
    };
  }

  /**
   * Defines a "AuthenticationProfile" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AuthenticationProfileProps) {
    super(scope, id, {
      ...AuthenticationProfile.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AuthenticationProfile.GVK,
      ...toJson_AuthenticationProfileProps(resolved),
    };
  }
}

/**
 * AuthenticationProfile is the Schema for the AuthenticationProfiles API. Creates a Redshift authentication profile
 *
 * @schema AuthenticationProfile
 */
export interface AuthenticationProfileProps {
  /**
   * @schema AuthenticationProfile#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AuthenticationProfileSpec defines the desired state of AuthenticationProfile
   *
   * @schema AuthenticationProfile#spec
   */
  readonly spec: AuthenticationProfileSpec;

}

/**
 * Converts an object of type 'AuthenticationProfileProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthenticationProfileProps(obj: AuthenticationProfileProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AuthenticationProfileSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AuthenticationProfileSpec defines the desired state of AuthenticationProfile
 *
 * @schema AuthenticationProfileSpec
 */
export interface AuthenticationProfileSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AuthenticationProfileSpec#deletionPolicy
   */
  readonly deletionPolicy?: AuthenticationProfileSpecDeletionPolicy;

  /**
   * @schema AuthenticationProfileSpec#forProvider
   */
  readonly forProvider: AuthenticationProfileSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AuthenticationProfileSpec#managementPolicy
   */
  readonly managementPolicy?: AuthenticationProfileSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AuthenticationProfileSpec#providerConfigRef
   */
  readonly providerConfigRef?: AuthenticationProfileSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AuthenticationProfileSpec#providerRef
   */
  readonly providerRef?: AuthenticationProfileSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AuthenticationProfileSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AuthenticationProfileSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AuthenticationProfileSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AuthenticationProfileSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AuthenticationProfileSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthenticationProfileSpec(obj: AuthenticationProfileSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AuthenticationProfileSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AuthenticationProfileSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AuthenticationProfileSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AuthenticationProfileSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AuthenticationProfileSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AuthenticationProfileSpecDeletionPolicy
 */
export enum AuthenticationProfileSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AuthenticationProfileSpecForProvider
 */
export interface AuthenticationProfileSpecForProvider {
  /**
   * The content of the authentication profile in JSON format. The maximum length of the JSON string is determined by a quota for your account.
   *
   * @schema AuthenticationProfileSpecForProvider#authenticationProfileContent
   */
  readonly authenticationProfileContent?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AuthenticationProfileSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'AuthenticationProfileSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthenticationProfileSpecForProvider(obj: AuthenticationProfileSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticationProfileContent': obj.authenticationProfileContent,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AuthenticationProfileSpecManagementPolicy
 */
export enum AuthenticationProfileSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AuthenticationProfileSpecProviderConfigRef
 */
export interface AuthenticationProfileSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthenticationProfileSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthenticationProfileSpecProviderConfigRef#policy
   */
  readonly policy?: AuthenticationProfileSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AuthenticationProfileSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthenticationProfileSpecProviderConfigRef(obj: AuthenticationProfileSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthenticationProfileSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AuthenticationProfileSpecProviderRef
 */
export interface AuthenticationProfileSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthenticationProfileSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthenticationProfileSpecProviderRef#policy
   */
  readonly policy?: AuthenticationProfileSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AuthenticationProfileSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthenticationProfileSpecProviderRef(obj: AuthenticationProfileSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthenticationProfileSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AuthenticationProfileSpecPublishConnectionDetailsTo
 */
export interface AuthenticationProfileSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AuthenticationProfileSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AuthenticationProfileSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AuthenticationProfileSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AuthenticationProfileSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AuthenticationProfileSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AuthenticationProfileSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthenticationProfileSpecPublishConnectionDetailsTo(obj: AuthenticationProfileSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AuthenticationProfileSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AuthenticationProfileSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AuthenticationProfileSpecWriteConnectionSecretToRef
 */
export interface AuthenticationProfileSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AuthenticationProfileSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AuthenticationProfileSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AuthenticationProfileSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthenticationProfileSpecWriteConnectionSecretToRef(obj: AuthenticationProfileSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AuthenticationProfileSpecProviderConfigRefPolicy
 */
export interface AuthenticationProfileSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthenticationProfileSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AuthenticationProfileSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthenticationProfileSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AuthenticationProfileSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthenticationProfileSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthenticationProfileSpecProviderConfigRefPolicy(obj: AuthenticationProfileSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AuthenticationProfileSpecProviderRefPolicy
 */
export interface AuthenticationProfileSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthenticationProfileSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AuthenticationProfileSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthenticationProfileSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AuthenticationProfileSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthenticationProfileSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthenticationProfileSpecProviderRefPolicy(obj: AuthenticationProfileSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AuthenticationProfileSpecPublishConnectionDetailsToConfigRef
 */
export interface AuthenticationProfileSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthenticationProfileSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthenticationProfileSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AuthenticationProfileSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AuthenticationProfileSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthenticationProfileSpecPublishConnectionDetailsToConfigRef(obj: AuthenticationProfileSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthenticationProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AuthenticationProfileSpecPublishConnectionDetailsToMetadata
 */
export interface AuthenticationProfileSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AuthenticationProfileSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AuthenticationProfileSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AuthenticationProfileSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AuthenticationProfileSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthenticationProfileSpecPublishConnectionDetailsToMetadata(obj: AuthenticationProfileSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthenticationProfileSpecProviderConfigRefPolicyResolution
 */
export enum AuthenticationProfileSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthenticationProfileSpecProviderConfigRefPolicyResolve
 */
export enum AuthenticationProfileSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthenticationProfileSpecProviderRefPolicyResolution
 */
export enum AuthenticationProfileSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthenticationProfileSpecProviderRefPolicyResolve
 */
export enum AuthenticationProfileSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AuthenticationProfileSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AuthenticationProfileSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthenticationProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AuthenticationProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthenticationProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AuthenticationProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthenticationProfileSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthenticationProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj: AuthenticationProfileSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthenticationProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AuthenticationProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthenticationProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AuthenticationProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Cluster is the Schema for the Clusters API. Provides a Redshift Cluster resource.
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshift.aws.upbound.io/v1beta1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * Cluster is the Schema for the Clusters API. Provides a Redshift Cluster resource.
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSpec defines the desired state of Cluster
   *
   * @schema Cluster#spec
   */
  readonly spec: ClusterSpec;

}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSpec defines the desired state of Cluster
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSpecDeletionPolicy;

  /**
   * @schema ClusterSpec#forProvider
   */
  readonly forProvider: ClusterSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterSpec#managementPolicy
   */
  readonly managementPolicy?: ClusterSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ClusterSpec#providerRef
   */
  readonly providerRef?: ClusterSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ClusterSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ClusterSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterSpecDeletionPolicy
 */
export enum ClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterSpecForProvider
 */
export interface ClusterSpecForProvider {
  /**
   * If true , major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. Default is true.
   *
   * @default true.
   * @schema ClusterSpecForProvider#allowVersionUpgrade
   */
  readonly allowVersionUpgrade?: boolean;

  /**
   * Specifies whether any cluster modifications are applied immediately, or during the next maintenance window. Default is false.
   *
   * @default false.
   * @schema ClusterSpecForProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * The value represents how the cluster is configured to use AQUA (Advanced Query Accelerator) after the cluster is restored. Possible values are enabled, disabled, and auto. Requires Cluster reboot.
   *
   * @schema ClusterSpecForProvider#aquaConfigurationStatus
   */
  readonly aquaConfigurationStatus?: string;

  /**
   * The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with create-cluster-snapshot. Default is 1.
   *
   * @default 1.
   * @schema ClusterSpecForProvider#automatedSnapshotRetentionPeriod
   */
  readonly automatedSnapshotRetentionPeriod?: number;

  /**
   * The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency. Can only be changed if availability_zone_relocation_enabled is true.
   *
   * @schema ClusterSpecForProvider#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * If true, the cluster can be relocated to another availabity zone, either automatically by AWS or when requested. Default is false. Available for use on clusters from the RA3 instance family.
   *
   * @default false. Available for use on clusters from the RA3 instance family.
   * @schema ClusterSpecForProvider#availabilityZoneRelocationEnabled
   */
  readonly availabilityZoneRelocationEnabled?: boolean;

  /**
   * The name of the parameter group to be associated with this cluster.
   *
   * @schema ClusterSpecForProvider#clusterParameterGroupName
   */
  readonly clusterParameterGroupName?: string;

  /**
   * The public key for the cluster
   *
   * @schema ClusterSpecForProvider#clusterPublicKey
   */
  readonly clusterPublicKey?: string;

  /**
   * The specific revision number of the database in the cluster
   *
   * @schema ClusterSpecForProvider#clusterRevisionNumber
   */
  readonly clusterRevisionNumber?: string;

  /**
   * A list of security groups to be associated with this cluster.
   *
   * @schema ClusterSpecForProvider#clusterSecurityGroups
   */
  readonly clusterSecurityGroups?: string[];

  /**
   * The name of a cluster subnet group to be associated with this cluster. If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).
   *
   * @schema ClusterSpecForProvider#clusterSubnetGroupName
   */
  readonly clusterSubnetGroupName?: string;

  /**
   * The cluster type to use. Either single-node or multi-node.
   *
   * @schema ClusterSpecForProvider#clusterType
   */
  readonly clusterType?: string;

  /**
   * The version of the Amazon Redshift engine software that you want to deploy on the cluster. The version selected runs on all the nodes in the cluster.
   *
   * @schema ClusterSpecForProvider#clusterVersion
   */
  readonly clusterVersion?: string;

  /**
   * The name of the first database to be created when the cluster is created. If you do not provide a name, Amazon Redshift will create a default database called dev.
   *
   * @schema ClusterSpecForProvider#databaseName
   */
  readonly databaseName?: string;

  /**
   * The Amazon Resource Name (ARN) for the IAM role that was set as default for the cluster when the cluster was created.
   *
   * @schema ClusterSpecForProvider#defaultIamRoleArn
   */
  readonly defaultIamRoleArn?: string;

  /**
   * Reference to a Role in iam to populate defaultIamRoleArn.
   *
   * @schema ClusterSpecForProvider#defaultIamRoleArnRef
   */
  readonly defaultIamRoleArnRef?: ClusterSpecForProviderDefaultIamRoleArnRef;

  /**
   * Selector for a Role in iam to populate defaultIamRoleArn.
   *
   * @schema ClusterSpecForProvider#defaultIamRoleArnSelector
   */
  readonly defaultIamRoleArnSelector?: ClusterSpecForProviderDefaultIamRoleArnSelector;

  /**
   * The Elastic IP (EIP) address for the cluster.
   *
   * @schema ClusterSpecForProvider#elasticIp
   */
  readonly elasticIp?: string;

  /**
   * If true , the data in the cluster is encrypted at rest.
   *
   * @schema ClusterSpecForProvider#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * The connection endpoint
   *
   * @schema ClusterSpecForProvider#endpoint
   */
  readonly endpoint?: string;

  /**
   * If true , enhanced VPC routing is enabled.
   *
   * @schema ClusterSpecForProvider#enhancedVpcRouting
   */
  readonly enhancedVpcRouting?: boolean;

  /**
   * The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, skip_final_snapshot must be false.
   *
   * @schema ClusterSpecForProvider#finalSnapshotIdentifier
   */
  readonly finalSnapshotIdentifier?: string;

  /**
   * References to Role in iam to populate iamRoles.
   *
   * @schema ClusterSpecForProvider#iamRoleRefs
   */
  readonly iamRoleRefs?: ClusterSpecForProviderIamRoleRefs[];

  /**
   * Selector for a list of Role in iam to populate iamRoles.
   *
   * @schema ClusterSpecForProvider#iamRoleSelector
   */
  readonly iamRoleSelector?: ClusterSpecForProviderIamRoleSelector;

  /**
   * A list of IAM Role ARNs to associate with the cluster. A Maximum of 10 can be associated to the cluster at any time.
   *
   * @schema ClusterSpecForProvider#iamRoles
   */
  readonly iamRoles?: string[];

  /**
   * The ARN for the KMS encryption key. When specifying kms_key_id, encrypted needs to be set to true.
   *
   * @schema ClusterSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema ClusterSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: ClusterSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema ClusterSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: ClusterSpecForProviderKmsKeyIdSelector;

  /**
   * Logging, documented below.
   *
   * @schema ClusterSpecForProvider#logging
   */
  readonly logging?: ClusterSpecForProviderLogging[];

  /**
   * The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the MaintenanceTrack value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of  a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks. Default value is current.
   *
   * @schema ClusterSpecForProvider#maintenanceTrackName
   */
  readonly maintenanceTrackName?: string;

  /**
   * The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots. Valid values are between -1 and 3653. Default value is -1.
   *
   * @schema ClusterSpecForProvider#manualSnapshotRetentionPeriod
   */
  readonly manualSnapshotRetentionPeriod?: number;

  /**
   * Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. Password must contain at least 8 chars and contain at least one uppercase letter, one lowercase letter, and one number.
   *
   * @schema ClusterSpecForProvider#masterPasswordSecretRef
   */
  readonly masterPasswordSecretRef?: ClusterSpecForProviderMasterPasswordSecretRef;

  /**
   * Username for the master DB user.
   *
   * @schema ClusterSpecForProvider#masterUsername
   */
  readonly masterUsername?: string;

  /**
   * The node type to be provisioned for the cluster.
   *
   * @schema ClusterSpecForProvider#nodeType
   */
  readonly nodeType?: string;

  /**
   * The number of compute nodes in the cluster. This parameter is required when the ClusterType parameter is specified as multi-node. Default is 1.
   *
   * @default 1.
   * @schema ClusterSpecForProvider#numberOfNodes
   */
  readonly numberOfNodes?: number;

  /**
   * The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
   *
   * @schema ClusterSpecForProvider#ownerAccount
   */
  readonly ownerAccount?: string;

  /**
   * The port number on which the cluster accepts incoming connections. Valid values are between 1115 and 65535. The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections. Default port is 5439.
   *
   * @schema ClusterSpecForProvider#port
   */
  readonly port?: number;

  /**
   * The weekly time range (in UTC) during which automated cluster maintenance can occur. Format: ddd:hh24:mi-ddd:hh24:mi
   *
   * @schema ClusterSpecForProvider#preferredMaintenanceWindow
   */
  readonly preferredMaintenanceWindow?: string;

  /**
   * If true, the cluster can be accessed from a public network. Default is true.
   *
   * @default true.
   * @schema ClusterSpecForProvider#publiclyAccessible
   */
  readonly publiclyAccessible?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterSpecForProvider#region
   */
  readonly region: string;

  /**
   * Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If true , a final cluster snapshot is not created. If false , a final cluster snapshot is created before the cluster is deleted. Default is false.
   *
   * @default false.
   * @schema ClusterSpecForProvider#skipFinalSnapshot
   */
  readonly skipFinalSnapshot?: boolean;

  /**
   * The name of the cluster the source snapshot was created from.
   *
   * @schema ClusterSpecForProvider#snapshotClusterIdentifier
   */
  readonly snapshotClusterIdentifier?: string;

  /**
   * Configuration of automatic copy of snapshots from one region to another. Documented below.
   *
   * @schema ClusterSpecForProvider#snapshotCopy
   */
  readonly snapshotCopy?: ClusterSpecForProviderSnapshotCopy[];

  /**
   * The name of the snapshot from which to create the new cluster.
   *
   * @schema ClusterSpecForProvider#snapshotIdentifier
   */
  readonly snapshotIdentifier?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * References to SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema ClusterSpecForProvider#vpcSecurityGroupIdRefs
   */
  readonly vpcSecurityGroupIdRefs?: ClusterSpecForProviderVpcSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema ClusterSpecForProvider#vpcSecurityGroupIdSelector
   */
  readonly vpcSecurityGroupIdSelector?: ClusterSpecForProviderVpcSecurityGroupIdSelector;

  /**
   * A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.
   *
   * @schema ClusterSpecForProvider#vpcSecurityGroupIds
   */
  readonly vpcSecurityGroupIds?: string[];

}

/**
 * Converts an object of type 'ClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProvider(obj: ClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowVersionUpgrade': obj.allowVersionUpgrade,
    'applyImmediately': obj.applyImmediately,
    'aquaConfigurationStatus': obj.aquaConfigurationStatus,
    'automatedSnapshotRetentionPeriod': obj.automatedSnapshotRetentionPeriod,
    'availabilityZone': obj.availabilityZone,
    'availabilityZoneRelocationEnabled': obj.availabilityZoneRelocationEnabled,
    'clusterParameterGroupName': obj.clusterParameterGroupName,
    'clusterPublicKey': obj.clusterPublicKey,
    'clusterRevisionNumber': obj.clusterRevisionNumber,
    'clusterSecurityGroups': obj.clusterSecurityGroups?.map(y => y),
    'clusterSubnetGroupName': obj.clusterSubnetGroupName,
    'clusterType': obj.clusterType,
    'clusterVersion': obj.clusterVersion,
    'databaseName': obj.databaseName,
    'defaultIamRoleArn': obj.defaultIamRoleArn,
    'defaultIamRoleArnRef': toJson_ClusterSpecForProviderDefaultIamRoleArnRef(obj.defaultIamRoleArnRef),
    'defaultIamRoleArnSelector': toJson_ClusterSpecForProviderDefaultIamRoleArnSelector(obj.defaultIamRoleArnSelector),
    'elasticIp': obj.elasticIp,
    'encrypted': obj.encrypted,
    'endpoint': obj.endpoint,
    'enhancedVpcRouting': obj.enhancedVpcRouting,
    'finalSnapshotIdentifier': obj.finalSnapshotIdentifier,
    'iamRoleRefs': obj.iamRoleRefs?.map(y => toJson_ClusterSpecForProviderIamRoleRefs(y)),
    'iamRoleSelector': toJson_ClusterSpecForProviderIamRoleSelector(obj.iamRoleSelector),
    'iamRoles': obj.iamRoles?.map(y => y),
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_ClusterSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_ClusterSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'logging': obj.logging?.map(y => toJson_ClusterSpecForProviderLogging(y)),
    'maintenanceTrackName': obj.maintenanceTrackName,
    'manualSnapshotRetentionPeriod': obj.manualSnapshotRetentionPeriod,
    'masterPasswordSecretRef': toJson_ClusterSpecForProviderMasterPasswordSecretRef(obj.masterPasswordSecretRef),
    'masterUsername': obj.masterUsername,
    'nodeType': obj.nodeType,
    'numberOfNodes': obj.numberOfNodes,
    'ownerAccount': obj.ownerAccount,
    'port': obj.port,
    'preferredMaintenanceWindow': obj.preferredMaintenanceWindow,
    'publiclyAccessible': obj.publiclyAccessible,
    'region': obj.region,
    'skipFinalSnapshot': obj.skipFinalSnapshot,
    'snapshotClusterIdentifier': obj.snapshotClusterIdentifier,
    'snapshotCopy': obj.snapshotCopy?.map(y => toJson_ClusterSpecForProviderSnapshotCopy(y)),
    'snapshotIdentifier': obj.snapshotIdentifier,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcSecurityGroupIdRefs': obj.vpcSecurityGroupIdRefs?.map(y => toJson_ClusterSpecForProviderVpcSecurityGroupIdRefs(y)),
    'vpcSecurityGroupIdSelector': toJson_ClusterSpecForProviderVpcSecurityGroupIdSelector(obj.vpcSecurityGroupIdSelector),
    'vpcSecurityGroupIds': obj.vpcSecurityGroupIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterSpecManagementPolicy
 */
export enum ClusterSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterSpecProviderConfigRef
 */
export interface ClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRef(obj: ClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ClusterSpecProviderRef
 */
export interface ClusterSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderRef#policy
   */
  readonly policy?: ClusterSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderRef(obj: ClusterSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterSpecPublishConnectionDetailsTo
 */
export interface ClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsTo(obj: ClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterSpecWriteConnectionSecretToRef
 */
export interface ClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWriteConnectionSecretToRef(obj: ClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate defaultIamRoleArn.
 *
 * @schema ClusterSpecForProviderDefaultIamRoleArnRef
 */
export interface ClusterSpecForProviderDefaultIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderDefaultIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderDefaultIamRoleArnRef#policy
   */
  readonly policy?: ClusterSpecForProviderDefaultIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderDefaultIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderDefaultIamRoleArnRef(obj: ClusterSpecForProviderDefaultIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderDefaultIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate defaultIamRoleArn.
 *
 * @schema ClusterSpecForProviderDefaultIamRoleArnSelector
 */
export interface ClusterSpecForProviderDefaultIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderDefaultIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderDefaultIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderDefaultIamRoleArnSelector#policy
   */
  readonly policy?: ClusterSpecForProviderDefaultIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderDefaultIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderDefaultIamRoleArnSelector(obj: ClusterSpecForProviderDefaultIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderDefaultIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ClusterSpecForProviderIamRoleRefs
 */
export interface ClusterSpecForProviderIamRoleRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderIamRoleRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderIamRoleRefs#policy
   */
  readonly policy?: ClusterSpecForProviderIamRoleRefsPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderIamRoleRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderIamRoleRefs(obj: ClusterSpecForProviderIamRoleRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderIamRoleRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Role in iam to populate iamRoles.
 *
 * @schema ClusterSpecForProviderIamRoleSelector
 */
export interface ClusterSpecForProviderIamRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderIamRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderIamRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderIamRoleSelector#policy
   */
  readonly policy?: ClusterSpecForProviderIamRoleSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderIamRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderIamRoleSelector(obj: ClusterSpecForProviderIamRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderIamRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema ClusterSpecForProviderKmsKeyIdRef
 */
export interface ClusterSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: ClusterSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKmsKeyIdRef(obj: ClusterSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema ClusterSpecForProviderKmsKeyIdSelector
 */
export interface ClusterSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: ClusterSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKmsKeyIdSelector(obj: ClusterSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderLogging
 */
export interface ClusterSpecForProviderLogging {
  /**
   * The name of an existing S3 bucket where the log files are to be stored. Must be in the same region as the cluster and the cluster must have read bucket and put object permissions. For more information on the permissions required for the bucket, please read the AWS documentation
   *
   * @schema ClusterSpecForProviderLogging#bucketName
   */
  readonly bucketName?: string;

  /**
   * Enables logging information such as queries and connection attempts, for the specified Amazon Redshift cluster.
   *
   * @schema ClusterSpecForProviderLogging#enable
   */
  readonly enable: boolean;

  /**
   * The log destination type. An enum with possible values of s3 and cloudwatch.
   *
   * @schema ClusterSpecForProviderLogging#logDestinationType
   */
  readonly logDestinationType?: string;

  /**
   * The collection of exported log types. Log types include the connection log, user log and user activity log. Required when log_destination_type is cloudwatch. Valid log types are connectionlog, userlog, and useractivitylog.
   *
   * @schema ClusterSpecForProviderLogging#logExports
   */
  readonly logExports?: string[];

  /**
   * The prefix applied to the log file names.
   *
   * @schema ClusterSpecForProviderLogging#s3KeyPrefix
   */
  readonly s3KeyPrefix?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLogging(obj: ClusterSpecForProviderLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'enable': obj.enable,
    'logDestinationType': obj.logDestinationType,
    'logExports': obj.logExports?.map(y => y),
    's3KeyPrefix': obj.s3KeyPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. Password must contain at least 8 chars and contain at least one uppercase letter, one lowercase letter, and one number.
 *
 * @schema ClusterSpecForProviderMasterPasswordSecretRef
 */
export interface ClusterSpecForProviderMasterPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema ClusterSpecForProviderMasterPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ClusterSpecForProviderMasterPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecForProviderMasterPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderMasterPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderMasterPasswordSecretRef(obj: ClusterSpecForProviderMasterPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderSnapshotCopy
 */
export interface ClusterSpecForProviderSnapshotCopy {
  /**
   * The destination region that you want to copy snapshots to.
   *
   * @schema ClusterSpecForProviderSnapshotCopy#destinationRegion
   */
  readonly destinationRegion: string;

  /**
   * The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
   *
   * @schema ClusterSpecForProviderSnapshotCopy#grantName
   */
  readonly grantName?: string;

  /**
   * The number of days to retain automated snapshots in the destination region after they are copied from the source region. Defaults to 7.
   *
   * @default 7.
   * @schema ClusterSpecForProviderSnapshotCopy#retentionPeriod
   */
  readonly retentionPeriod?: number;

}

/**
 * Converts an object of type 'ClusterSpecForProviderSnapshotCopy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderSnapshotCopy(obj: ClusterSpecForProviderSnapshotCopy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationRegion': obj.destinationRegion,
    'grantName': obj.grantName,
    'retentionPeriod': obj.retentionPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefs
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefs#policy
   */
  readonly policy?: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdRefs(obj: ClusterSpecForProviderVpcSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector#policy
   */
  readonly policy?: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdSelector(obj: ClusterSpecForProviderVpcSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderConfigRefPolicy
 */
export interface ClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRefPolicy(obj: ClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderRefPolicy
 */
export interface ClusterSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderRefPolicy(obj: ClusterSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj: ClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj: ClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderDefaultIamRoleArnRefPolicy
 */
export interface ClusterSpecForProviderDefaultIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderDefaultIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderDefaultIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderDefaultIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderDefaultIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderDefaultIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderDefaultIamRoleArnRefPolicy(obj: ClusterSpecForProviderDefaultIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderDefaultIamRoleArnSelectorPolicy
 */
export interface ClusterSpecForProviderDefaultIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderDefaultIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderDefaultIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderDefaultIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderDefaultIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderDefaultIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderDefaultIamRoleArnSelectorPolicy(obj: ClusterSpecForProviderDefaultIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderIamRoleRefsPolicy
 */
export interface ClusterSpecForProviderIamRoleRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderIamRoleRefsPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderIamRoleRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderIamRoleRefsPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderIamRoleRefsPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderIamRoleRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderIamRoleRefsPolicy(obj: ClusterSpecForProviderIamRoleRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderIamRoleSelectorPolicy
 */
export interface ClusterSpecForProviderIamRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderIamRoleSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderIamRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderIamRoleSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderIamRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderIamRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderIamRoleSelectorPolicy(obj: ClusterSpecForProviderIamRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderKmsKeyIdRefPolicy
 */
export interface ClusterSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKmsKeyIdRefPolicy(obj: ClusterSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface ClusterSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKmsKeyIdSelectorPolicy(obj: ClusterSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy(obj: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderRefPolicyResolution
 */
export enum ClusterSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderRefPolicyResolve
 */
export enum ClusterSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderDefaultIamRoleArnRefPolicyResolution
 */
export enum ClusterSpecForProviderDefaultIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderDefaultIamRoleArnRefPolicyResolve
 */
export enum ClusterSpecForProviderDefaultIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderDefaultIamRoleArnSelectorPolicyResolution
 */
export enum ClusterSpecForProviderDefaultIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderDefaultIamRoleArnSelectorPolicyResolve
 */
export enum ClusterSpecForProviderDefaultIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderIamRoleRefsPolicyResolution
 */
export enum ClusterSpecForProviderIamRoleRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderIamRoleRefsPolicyResolve
 */
export enum ClusterSpecForProviderIamRoleRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderIamRoleSelectorPolicyResolution
 */
export enum ClusterSpecForProviderIamRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderIamRoleSelectorPolicyResolve
 */
export enum ClusterSpecForProviderIamRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum ClusterSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum ClusterSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum ClusterSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum ClusterSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EventSubscription is the Schema for the EventSubscriptions API. Provides a Redshift event subscription resource.
 *
 * @schema EventSubscription
 */
export class EventSubscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EventSubscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshift.aws.upbound.io/v1beta1',
    kind: 'EventSubscription',
  }

  /**
   * Renders a Kubernetes manifest for "EventSubscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EventSubscriptionProps): any {
    return {
      ...EventSubscription.GVK,
      ...toJson_EventSubscriptionProps(props),
    };
  }

  /**
   * Defines a "EventSubscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EventSubscriptionProps) {
    super(scope, id, {
      ...EventSubscription.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EventSubscription.GVK,
      ...toJson_EventSubscriptionProps(resolved),
    };
  }
}

/**
 * EventSubscription is the Schema for the EventSubscriptions API. Provides a Redshift event subscription resource.
 *
 * @schema EventSubscription
 */
export interface EventSubscriptionProps {
  /**
   * @schema EventSubscription#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EventSubscriptionSpec defines the desired state of EventSubscription
   *
   * @schema EventSubscription#spec
   */
  readonly spec: EventSubscriptionSpec;

}

/**
 * Converts an object of type 'EventSubscriptionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionProps(obj: EventSubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EventSubscriptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EventSubscriptionSpec defines the desired state of EventSubscription
 *
 * @schema EventSubscriptionSpec
 */
export interface EventSubscriptionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EventSubscriptionSpec#deletionPolicy
   */
  readonly deletionPolicy?: EventSubscriptionSpecDeletionPolicy;

  /**
   * @schema EventSubscriptionSpec#forProvider
   */
  readonly forProvider: EventSubscriptionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EventSubscriptionSpec#managementPolicy
   */
  readonly managementPolicy?: EventSubscriptionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EventSubscriptionSpec#providerConfigRef
   */
  readonly providerConfigRef?: EventSubscriptionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EventSubscriptionSpec#providerRef
   */
  readonly providerRef?: EventSubscriptionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EventSubscriptionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EventSubscriptionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EventSubscriptionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EventSubscriptionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EventSubscriptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpec(obj: EventSubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EventSubscriptionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_EventSubscriptionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EventSubscriptionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EventSubscriptionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EventSubscriptionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EventSubscriptionSpecDeletionPolicy
 */
export enum EventSubscriptionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EventSubscriptionSpecForProvider
 */
export interface EventSubscriptionSpecForProvider {
  /**
   * A boolean flag to enable/disable the subscription. Defaults to true.
   *
   * @default true.
   * @schema EventSubscriptionSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * A list of event categories for a SourceType that you want to subscribe to. See https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html or run aws redshift describe-event-categories.
   *
   * @schema EventSubscriptionSpecForProvider#eventCategories
   */
  readonly eventCategories?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EventSubscriptionSpecForProvider#region
   */
  readonly region: string;

  /**
   * The event severity to be published by the notification subscription. Valid options are INFO or ERROR. Default value of INFO.
   *
   * @schema EventSubscriptionSpecForProvider#severity
   */
  readonly severity?: string;

  /**
   * The ARN of the SNS topic to send events to.
   *
   * @schema EventSubscriptionSpecForProvider#snsTopicArn
   */
  readonly snsTopicArn?: string;

  /**
   * Reference to a Topic in sns to populate snsTopicArn.
   *
   * @schema EventSubscriptionSpecForProvider#snsTopicArnRef
   */
  readonly snsTopicArnRef?: EventSubscriptionSpecForProviderSnsTopicArnRef;

  /**
   * Selector for a Topic in sns to populate snsTopicArn.
   *
   * @schema EventSubscriptionSpecForProvider#snsTopicArnSelector
   */
  readonly snsTopicArnSelector?: EventSubscriptionSpecForProviderSnsTopicArnSelector;

  /**
   * A list of identifiers of the event sources for which events will be returned. If not specified, then all sources are included in the response. If specified, a source_type must also be specified.
   *
   * @schema EventSubscriptionSpecForProvider#sourceIds
   */
  readonly sourceIds?: string[];

  /**
   * The type of source that will be generating the events. Valid options are cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, or scheduled-action. If not set, all sources will be subscribed to.
   *
   * @schema EventSubscriptionSpecForProvider#sourceType
   */
  readonly sourceType?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema EventSubscriptionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProvider(obj: EventSubscriptionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'eventCategories': obj.eventCategories?.map(y => y),
    'region': obj.region,
    'severity': obj.severity,
    'snsTopicArn': obj.snsTopicArn,
    'snsTopicArnRef': toJson_EventSubscriptionSpecForProviderSnsTopicArnRef(obj.snsTopicArnRef),
    'snsTopicArnSelector': toJson_EventSubscriptionSpecForProviderSnsTopicArnSelector(obj.snsTopicArnSelector),
    'sourceIds': obj.sourceIds?.map(y => y),
    'sourceType': obj.sourceType,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EventSubscriptionSpecManagementPolicy
 */
export enum EventSubscriptionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EventSubscriptionSpecProviderConfigRef
 */
export interface EventSubscriptionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecProviderConfigRef#policy
   */
  readonly policy?: EventSubscriptionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderConfigRef(obj: EventSubscriptionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EventSubscriptionSpecProviderRef
 */
export interface EventSubscriptionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecProviderRef#policy
   */
  readonly policy?: EventSubscriptionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderRef(obj: EventSubscriptionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsTo
 */
export interface EventSubscriptionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EventSubscriptionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EventSubscriptionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsTo(obj: EventSubscriptionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EventSubscriptionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EventSubscriptionSpecWriteConnectionSecretToRef
 */
export interface EventSubscriptionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EventSubscriptionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EventSubscriptionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EventSubscriptionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecWriteConnectionSecretToRef(obj: EventSubscriptionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate snsTopicArn.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnRef
 */
export interface EventSubscriptionSpecForProviderSnsTopicArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnRef#policy
   */
  readonly policy?: EventSubscriptionSpecForProviderSnsTopicArnRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicArnRef(obj: EventSubscriptionSpecForProviderSnsTopicArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecForProviderSnsTopicArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate snsTopicArn.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnSelector
 */
export interface EventSubscriptionSpecForProviderSnsTopicArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelector#policy
   */
  readonly policy?: EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicArnSelector(obj: EventSubscriptionSpecForProviderSnsTopicArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecProviderConfigRefPolicy
 */
export interface EventSubscriptionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderConfigRefPolicy(obj: EventSubscriptionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecProviderRefPolicy
 */
export interface EventSubscriptionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderRefPolicy(obj: EventSubscriptionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRef
 */
export interface EventSubscriptionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRef(obj: EventSubscriptionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata
 */
export interface EventSubscriptionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsToMetadata(obj: EventSubscriptionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicy
 */
export interface EventSubscriptionSpecForProviderSnsTopicArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicArnRefPolicy(obj: EventSubscriptionSpecForProviderSnsTopicArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy
 */
export interface EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy(obj: EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecProviderConfigRefPolicyResolution
 */
export enum EventSubscriptionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecProviderConfigRefPolicyResolve
 */
export enum EventSubscriptionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecProviderRefPolicyResolution
 */
export enum EventSubscriptionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecProviderRefPolicyResolve
 */
export enum EventSubscriptionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolution
 */
export enum EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolve
 */
export enum EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolution
 */
export enum EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolve
 */
export enum EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * HSMClientCertificate is the Schema for the HSMClientCertificates API. Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.
 *
 * @schema HSMClientCertificate
 */
export class HsmClientCertificate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HSMClientCertificate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshift.aws.upbound.io/v1beta1',
    kind: 'HSMClientCertificate',
  }

  /**
   * Renders a Kubernetes manifest for "HSMClientCertificate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HsmClientCertificateProps): any {
    return {
      ...HsmClientCertificate.GVK,
      ...toJson_HsmClientCertificateProps(props),
    };
  }

  /**
   * Defines a "HSMClientCertificate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HsmClientCertificateProps) {
    super(scope, id, {
      ...HsmClientCertificate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HsmClientCertificate.GVK,
      ...toJson_HsmClientCertificateProps(resolved),
    };
  }
}

/**
 * HSMClientCertificate is the Schema for the HSMClientCertificates API. Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.
 *
 * @schema HSMClientCertificate
 */
export interface HsmClientCertificateProps {
  /**
   * @schema HSMClientCertificate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HSMClientCertificateSpec defines the desired state of HSMClientCertificate
   *
   * @schema HSMClientCertificate#spec
   */
  readonly spec: HsmClientCertificateSpec;

}

/**
 * Converts an object of type 'HsmClientCertificateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmClientCertificateProps(obj: HsmClientCertificateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HsmClientCertificateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HSMClientCertificateSpec defines the desired state of HSMClientCertificate
 *
 * @schema HsmClientCertificateSpec
 */
export interface HsmClientCertificateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HsmClientCertificateSpec#deletionPolicy
   */
  readonly deletionPolicy?: HsmClientCertificateSpecDeletionPolicy;

  /**
   * @schema HsmClientCertificateSpec#forProvider
   */
  readonly forProvider: HsmClientCertificateSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HsmClientCertificateSpec#managementPolicy
   */
  readonly managementPolicy?: HsmClientCertificateSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema HsmClientCertificateSpec#providerConfigRef
   */
  readonly providerConfigRef?: HsmClientCertificateSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema HsmClientCertificateSpec#providerRef
   */
  readonly providerRef?: HsmClientCertificateSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema HsmClientCertificateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HsmClientCertificateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema HsmClientCertificateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HsmClientCertificateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HsmClientCertificateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmClientCertificateSpec(obj: HsmClientCertificateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HsmClientCertificateSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_HsmClientCertificateSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_HsmClientCertificateSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_HsmClientCertificateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HsmClientCertificateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HsmClientCertificateSpecDeletionPolicy
 */
export enum HsmClientCertificateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema HsmClientCertificateSpecForProvider
 */
export interface HsmClientCertificateSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema HsmClientCertificateSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema HsmClientCertificateSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'HsmClientCertificateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmClientCertificateSpecForProvider(obj: HsmClientCertificateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HsmClientCertificateSpecManagementPolicy
 */
export enum HsmClientCertificateSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema HsmClientCertificateSpecProviderConfigRef
 */
export interface HsmClientCertificateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HsmClientCertificateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HsmClientCertificateSpecProviderConfigRef#policy
   */
  readonly policy?: HsmClientCertificateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HsmClientCertificateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmClientCertificateSpecProviderConfigRef(obj: HsmClientCertificateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HsmClientCertificateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema HsmClientCertificateSpecProviderRef
 */
export interface HsmClientCertificateSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema HsmClientCertificateSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HsmClientCertificateSpecProviderRef#policy
   */
  readonly policy?: HsmClientCertificateSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'HsmClientCertificateSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmClientCertificateSpecProviderRef(obj: HsmClientCertificateSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HsmClientCertificateSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema HsmClientCertificateSpecPublishConnectionDetailsTo
 */
export interface HsmClientCertificateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema HsmClientCertificateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HsmClientCertificateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HsmClientCertificateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HsmClientCertificateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HsmClientCertificateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HsmClientCertificateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmClientCertificateSpecPublishConnectionDetailsTo(obj: HsmClientCertificateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HsmClientCertificateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HsmClientCertificateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema HsmClientCertificateSpecWriteConnectionSecretToRef
 */
export interface HsmClientCertificateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HsmClientCertificateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HsmClientCertificateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HsmClientCertificateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmClientCertificateSpecWriteConnectionSecretToRef(obj: HsmClientCertificateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HsmClientCertificateSpecProviderConfigRefPolicy
 */
export interface HsmClientCertificateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HsmClientCertificateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HsmClientCertificateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HsmClientCertificateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HsmClientCertificateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HsmClientCertificateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmClientCertificateSpecProviderConfigRefPolicy(obj: HsmClientCertificateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HsmClientCertificateSpecProviderRefPolicy
 */
export interface HsmClientCertificateSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HsmClientCertificateSpecProviderRefPolicy#resolution
   */
  readonly resolution?: HsmClientCertificateSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HsmClientCertificateSpecProviderRefPolicy#resolve
   */
  readonly resolve?: HsmClientCertificateSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'HsmClientCertificateSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmClientCertificateSpecProviderRefPolicy(obj: HsmClientCertificateSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema HsmClientCertificateSpecPublishConnectionDetailsToConfigRef
 */
export interface HsmClientCertificateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HsmClientCertificateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HsmClientCertificateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HsmClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HsmClientCertificateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmClientCertificateSpecPublishConnectionDetailsToConfigRef(obj: HsmClientCertificateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HsmClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HsmClientCertificateSpecPublishConnectionDetailsToMetadata
 */
export interface HsmClientCertificateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema HsmClientCertificateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema HsmClientCertificateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema HsmClientCertificateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HsmClientCertificateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmClientCertificateSpecPublishConnectionDetailsToMetadata(obj: HsmClientCertificateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HsmClientCertificateSpecProviderConfigRefPolicyResolution
 */
export enum HsmClientCertificateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HsmClientCertificateSpecProviderConfigRefPolicyResolve
 */
export enum HsmClientCertificateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HsmClientCertificateSpecProviderRefPolicyResolution
 */
export enum HsmClientCertificateSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HsmClientCertificateSpecProviderRefPolicyResolve
 */
export enum HsmClientCertificateSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HsmClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HsmClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HsmClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HsmClientCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HsmClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HsmClientCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HsmClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj: HsmClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HsmClientCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HsmClientCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HsmClientCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HsmClientCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * HSMConfiguration is the Schema for the HSMConfigurations API. Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM).
 *
 * @schema HSMConfiguration
 */
export class HsmConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HSMConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshift.aws.upbound.io/v1beta1',
    kind: 'HSMConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "HSMConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HsmConfigurationProps): any {
    return {
      ...HsmConfiguration.GVK,
      ...toJson_HsmConfigurationProps(props),
    };
  }

  /**
   * Defines a "HSMConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HsmConfigurationProps) {
    super(scope, id, {
      ...HsmConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HsmConfiguration.GVK,
      ...toJson_HsmConfigurationProps(resolved),
    };
  }
}

/**
 * HSMConfiguration is the Schema for the HSMConfigurations API. Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM).
 *
 * @schema HSMConfiguration
 */
export interface HsmConfigurationProps {
  /**
   * @schema HSMConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HSMConfigurationSpec defines the desired state of HSMConfiguration
   *
   * @schema HSMConfiguration#spec
   */
  readonly spec: HsmConfigurationSpec;

}

/**
 * Converts an object of type 'HsmConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmConfigurationProps(obj: HsmConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HsmConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HSMConfigurationSpec defines the desired state of HSMConfiguration
 *
 * @schema HsmConfigurationSpec
 */
export interface HsmConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HsmConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: HsmConfigurationSpecDeletionPolicy;

  /**
   * @schema HsmConfigurationSpec#forProvider
   */
  readonly forProvider: HsmConfigurationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HsmConfigurationSpec#managementPolicy
   */
  readonly managementPolicy?: HsmConfigurationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema HsmConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: HsmConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema HsmConfigurationSpec#providerRef
   */
  readonly providerRef?: HsmConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema HsmConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HsmConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema HsmConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HsmConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HsmConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmConfigurationSpec(obj: HsmConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HsmConfigurationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_HsmConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_HsmConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_HsmConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HsmConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HsmConfigurationSpecDeletionPolicy
 */
export enum HsmConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema HsmConfigurationSpecForProvider
 */
export interface HsmConfigurationSpecForProvider {
  /**
   * A text description of the HSM configuration to be created.
   *
   * @schema HsmConfigurationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The IP address that the Amazon Redshift cluster must use to access the HSM.
   *
   * @schema HsmConfigurationSpecForProvider#hsmIpAddress
   */
  readonly hsmIpAddress?: string;

  /**
   * The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
   *
   * @schema HsmConfigurationSpecForProvider#hsmPartitionName
   */
  readonly hsmPartitionName?: string;

  /**
   * The password required to access the HSM partition.
   *
   * @schema HsmConfigurationSpecForProvider#hsmPartitionPasswordSecretRef
   */
  readonly hsmPartitionPasswordSecretRef?: HsmConfigurationSpecForProviderHsmPartitionPasswordSecretRef;

  /**
   * The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
   *
   * @schema HsmConfigurationSpecForProvider#hsmServerPublicCertificate
   */
  readonly hsmServerPublicCertificate?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema HsmConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema HsmConfigurationSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'HsmConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmConfigurationSpecForProvider(obj: HsmConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'hsmIpAddress': obj.hsmIpAddress,
    'hsmPartitionName': obj.hsmPartitionName,
    'hsmPartitionPasswordSecretRef': toJson_HsmConfigurationSpecForProviderHsmPartitionPasswordSecretRef(obj.hsmPartitionPasswordSecretRef),
    'hsmServerPublicCertificate': obj.hsmServerPublicCertificate,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HsmConfigurationSpecManagementPolicy
 */
export enum HsmConfigurationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema HsmConfigurationSpecProviderConfigRef
 */
export interface HsmConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HsmConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HsmConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: HsmConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HsmConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmConfigurationSpecProviderConfigRef(obj: HsmConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HsmConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema HsmConfigurationSpecProviderRef
 */
export interface HsmConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema HsmConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HsmConfigurationSpecProviderRef#policy
   */
  readonly policy?: HsmConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'HsmConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmConfigurationSpecProviderRef(obj: HsmConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HsmConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema HsmConfigurationSpecPublishConnectionDetailsTo
 */
export interface HsmConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema HsmConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HsmConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HsmConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HsmConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HsmConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HsmConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmConfigurationSpecPublishConnectionDetailsTo(obj: HsmConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HsmConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HsmConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema HsmConfigurationSpecWriteConnectionSecretToRef
 */
export interface HsmConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HsmConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HsmConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HsmConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmConfigurationSpecWriteConnectionSecretToRef(obj: HsmConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The password required to access the HSM partition.
 *
 * @schema HsmConfigurationSpecForProviderHsmPartitionPasswordSecretRef
 */
export interface HsmConfigurationSpecForProviderHsmPartitionPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema HsmConfigurationSpecForProviderHsmPartitionPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema HsmConfigurationSpecForProviderHsmPartitionPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HsmConfigurationSpecForProviderHsmPartitionPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HsmConfigurationSpecForProviderHsmPartitionPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmConfigurationSpecForProviderHsmPartitionPasswordSecretRef(obj: HsmConfigurationSpecForProviderHsmPartitionPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HsmConfigurationSpecProviderConfigRefPolicy
 */
export interface HsmConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HsmConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HsmConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HsmConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HsmConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HsmConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmConfigurationSpecProviderConfigRefPolicy(obj: HsmConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HsmConfigurationSpecProviderRefPolicy
 */
export interface HsmConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HsmConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: HsmConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HsmConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: HsmConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'HsmConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmConfigurationSpecProviderRefPolicy(obj: HsmConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema HsmConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface HsmConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HsmConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HsmConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HsmConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HsmConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmConfigurationSpecPublishConnectionDetailsToConfigRef(obj: HsmConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HsmConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HsmConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface HsmConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema HsmConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema HsmConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema HsmConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HsmConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmConfigurationSpecPublishConnectionDetailsToMetadata(obj: HsmConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HsmConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum HsmConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HsmConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum HsmConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HsmConfigurationSpecProviderRefPolicyResolution
 */
export enum HsmConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HsmConfigurationSpecProviderRefPolicyResolve
 */
export enum HsmConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HsmConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HsmConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HsmConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HsmConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HsmConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HsmConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HsmConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HsmConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: HsmConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HsmConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HsmConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HsmConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HsmConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ParameterGroup is the Schema for the ParameterGroups API. Provides a Redshift Cluster parameter group resource.
 *
 * @schema ParameterGroup
 */
export class ParameterGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ParameterGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshift.aws.upbound.io/v1beta1',
    kind: 'ParameterGroup',
  }

  /**
   * Renders a Kubernetes manifest for "ParameterGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ParameterGroupProps): any {
    return {
      ...ParameterGroup.GVK,
      ...toJson_ParameterGroupProps(props),
    };
  }

  /**
   * Defines a "ParameterGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ParameterGroupProps) {
    super(scope, id, {
      ...ParameterGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ParameterGroup.GVK,
      ...toJson_ParameterGroupProps(resolved),
    };
  }
}

/**
 * ParameterGroup is the Schema for the ParameterGroups API. Provides a Redshift Cluster parameter group resource.
 *
 * @schema ParameterGroup
 */
export interface ParameterGroupProps {
  /**
   * @schema ParameterGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ParameterGroupSpec defines the desired state of ParameterGroup
   *
   * @schema ParameterGroup#spec
   */
  readonly spec: ParameterGroupSpec;

}

/**
 * Converts an object of type 'ParameterGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupProps(obj: ParameterGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ParameterGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ParameterGroupSpec defines the desired state of ParameterGroup
 *
 * @schema ParameterGroupSpec
 */
export interface ParameterGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ParameterGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: ParameterGroupSpecDeletionPolicy;

  /**
   * @schema ParameterGroupSpec#forProvider
   */
  readonly forProvider: ParameterGroupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ParameterGroupSpec#managementPolicy
   */
  readonly managementPolicy?: ParameterGroupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ParameterGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: ParameterGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ParameterGroupSpec#providerRef
   */
  readonly providerRef?: ParameterGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ParameterGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ParameterGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ParameterGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ParameterGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ParameterGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpec(obj: ParameterGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ParameterGroupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ParameterGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ParameterGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ParameterGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ParameterGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ParameterGroupSpecDeletionPolicy
 */
export enum ParameterGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ParameterGroupSpecForProvider
 */
export interface ParameterGroupSpecForProvider {
  /**
   * The description of the Redshift parameter group.
   *
   * @schema ParameterGroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The family of the Redshift parameter group.
   *
   * @schema ParameterGroupSpecForProvider#family
   */
  readonly family?: string;

  /**
   * The name of the Redshift parameter group.
   *
   * @schema ParameterGroupSpecForProvider#name
   */
  readonly name?: string;

  /**
   * A list of Redshift parameters to apply.
   *
   * @schema ParameterGroupSpecForProvider#parameter
   */
  readonly parameter?: ParameterGroupSpecForProviderParameter[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ParameterGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ParameterGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ParameterGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecForProvider(obj: ParameterGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'family': obj.family,
    'name': obj.name,
    'parameter': obj.parameter?.map(y => toJson_ParameterGroupSpecForProviderParameter(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ParameterGroupSpecManagementPolicy
 */
export enum ParameterGroupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ParameterGroupSpecProviderConfigRef
 */
export interface ParameterGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ParameterGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ParameterGroupSpecProviderConfigRef#policy
   */
  readonly policy?: ParameterGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ParameterGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecProviderConfigRef(obj: ParameterGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ParameterGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ParameterGroupSpecProviderRef
 */
export interface ParameterGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ParameterGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ParameterGroupSpecProviderRef#policy
   */
  readonly policy?: ParameterGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ParameterGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecProviderRef(obj: ParameterGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ParameterGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsTo
 */
export interface ParameterGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ParameterGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ParameterGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ParameterGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecPublishConnectionDetailsTo(obj: ParameterGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ParameterGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ParameterGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ParameterGroupSpecWriteConnectionSecretToRef
 */
export interface ParameterGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ParameterGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ParameterGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ParameterGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecWriteConnectionSecretToRef(obj: ParameterGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ParameterGroupSpecForProviderParameter
 */
export interface ParameterGroupSpecForProviderParameter {
  /**
   * The name of the Redshift parameter group.
   *
   * @schema ParameterGroupSpecForProviderParameter#name
   */
  readonly name: string;

  /**
   * The value of the Redshift parameter.
   *
   * @schema ParameterGroupSpecForProviderParameter#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ParameterGroupSpecForProviderParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecForProviderParameter(obj: ParameterGroupSpecForProviderParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ParameterGroupSpecProviderConfigRefPolicy
 */
export interface ParameterGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ParameterGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ParameterGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ParameterGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ParameterGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ParameterGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecProviderConfigRefPolicy(obj: ParameterGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ParameterGroupSpecProviderRefPolicy
 */
export interface ParameterGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ParameterGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ParameterGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ParameterGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ParameterGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ParameterGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecProviderRefPolicy(obj: ParameterGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface ParameterGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ParameterGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecPublishConnectionDetailsToConfigRef(obj: ParameterGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsToMetadata
 */
export interface ParameterGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ParameterGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecPublishConnectionDetailsToMetadata(obj: ParameterGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ParameterGroupSpecProviderConfigRefPolicyResolution
 */
export enum ParameterGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ParameterGroupSpecProviderConfigRefPolicyResolve
 */
export enum ParameterGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ParameterGroupSpecProviderRefPolicyResolution
 */
export enum ParameterGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ParameterGroupSpecProviderRefPolicyResolve
 */
export enum ParameterGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ScheduledAction is the Schema for the ScheduledActions API. Provides a Redshift Scheduled Action resource.
 *
 * @schema ScheduledAction
 */
export class ScheduledAction extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ScheduledAction"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshift.aws.upbound.io/v1beta1',
    kind: 'ScheduledAction',
  }

  /**
   * Renders a Kubernetes manifest for "ScheduledAction".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ScheduledActionProps): any {
    return {
      ...ScheduledAction.GVK,
      ...toJson_ScheduledActionProps(props),
    };
  }

  /**
   * Defines a "ScheduledAction" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ScheduledActionProps) {
    super(scope, id, {
      ...ScheduledAction.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ScheduledAction.GVK,
      ...toJson_ScheduledActionProps(resolved),
    };
  }
}

/**
 * ScheduledAction is the Schema for the ScheduledActions API. Provides a Redshift Scheduled Action resource.
 *
 * @schema ScheduledAction
 */
export interface ScheduledActionProps {
  /**
   * @schema ScheduledAction#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ScheduledActionSpec defines the desired state of ScheduledAction
   *
   * @schema ScheduledAction#spec
   */
  readonly spec: ScheduledActionSpec;

}

/**
 * Converts an object of type 'ScheduledActionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionProps(obj: ScheduledActionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ScheduledActionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScheduledActionSpec defines the desired state of ScheduledAction
 *
 * @schema ScheduledActionSpec
 */
export interface ScheduledActionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ScheduledActionSpec#deletionPolicy
   */
  readonly deletionPolicy?: ScheduledActionSpecDeletionPolicy;

  /**
   * @schema ScheduledActionSpec#forProvider
   */
  readonly forProvider: ScheduledActionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ScheduledActionSpec#managementPolicy
   */
  readonly managementPolicy?: ScheduledActionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ScheduledActionSpec#providerConfigRef
   */
  readonly providerConfigRef?: ScheduledActionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ScheduledActionSpec#providerRef
   */
  readonly providerRef?: ScheduledActionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ScheduledActionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ScheduledActionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ScheduledActionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ScheduledActionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ScheduledActionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpec(obj: ScheduledActionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ScheduledActionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ScheduledActionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ScheduledActionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ScheduledActionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ScheduledActionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ScheduledActionSpecDeletionPolicy
 */
export enum ScheduledActionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ScheduledActionSpecForProvider
 */
export interface ScheduledActionSpecForProvider {
  /**
   * The description of the scheduled action.
   *
   * @schema ScheduledActionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Whether to enable the scheduled action. Default is true .
   *
   * @default true .
   * @schema ScheduledActionSpecForProvider#enable
   */
  readonly enable?: boolean;

  /**
   * The end time in UTC when the schedule is active, in UTC RFC3339 format(for example, YYYY-MM-DDTHH:MM:SSZ).
   *
   * @schema ScheduledActionSpecForProvider#endTime
   */
  readonly endTime?: string;

  /**
   * The IAM role to assume to run the scheduled action.
   *
   * @schema ScheduledActionSpecForProvider#iamRole
   */
  readonly iamRole?: string;

  /**
   * Reference to a Role in iam to populate iamRole.
   *
   * @schema ScheduledActionSpecForProvider#iamRoleRef
   */
  readonly iamRoleRef?: ScheduledActionSpecForProviderIamRoleRef;

  /**
   * Selector for a Role in iam to populate iamRole.
   *
   * @schema ScheduledActionSpecForProvider#iamRoleSelector
   */
  readonly iamRoleSelector?: ScheduledActionSpecForProviderIamRoleSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ScheduledActionSpecForProvider#region
   */
  readonly region: string;

  /**
   * The schedule of action. The schedule is defined format of "at expression" or "cron expression", for example at(2016-03-04T17:27:00) or cron(0 10 ? * MON *). See Scheduled Action for more information.
   *
   * @schema ScheduledActionSpecForProvider#schedule
   */
  readonly schedule?: string;

  /**
   * The start time in UTC when the schedule is active, in UTC RFC3339 format(for example, YYYY-MM-DDTHH:MM:SSZ).
   *
   * @schema ScheduledActionSpecForProvider#startTime
   */
  readonly startTime?: string;

  /**
   * Target action. Documented below.
   *
   * @schema ScheduledActionSpecForProvider#targetAction
   */
  readonly targetAction?: ScheduledActionSpecForProviderTargetAction[];

}

/**
 * Converts an object of type 'ScheduledActionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProvider(obj: ScheduledActionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'enable': obj.enable,
    'endTime': obj.endTime,
    'iamRole': obj.iamRole,
    'iamRoleRef': toJson_ScheduledActionSpecForProviderIamRoleRef(obj.iamRoleRef),
    'iamRoleSelector': toJson_ScheduledActionSpecForProviderIamRoleSelector(obj.iamRoleSelector),
    'region': obj.region,
    'schedule': obj.schedule,
    'startTime': obj.startTime,
    'targetAction': obj.targetAction?.map(y => toJson_ScheduledActionSpecForProviderTargetAction(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ScheduledActionSpecManagementPolicy
 */
export enum ScheduledActionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ScheduledActionSpecProviderConfigRef
 */
export interface ScheduledActionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduledActionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduledActionSpecProviderConfigRef#policy
   */
  readonly policy?: ScheduledActionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecProviderConfigRef(obj: ScheduledActionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduledActionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ScheduledActionSpecProviderRef
 */
export interface ScheduledActionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduledActionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduledActionSpecProviderRef#policy
   */
  readonly policy?: ScheduledActionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecProviderRef(obj: ScheduledActionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduledActionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsTo
 */
export interface ScheduledActionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ScheduledActionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ScheduledActionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ScheduledActionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecPublishConnectionDetailsTo(obj: ScheduledActionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ScheduledActionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ScheduledActionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ScheduledActionSpecWriteConnectionSecretToRef
 */
export interface ScheduledActionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ScheduledActionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ScheduledActionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ScheduledActionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecWriteConnectionSecretToRef(obj: ScheduledActionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate iamRole.
 *
 * @schema ScheduledActionSpecForProviderIamRoleRef
 */
export interface ScheduledActionSpecForProviderIamRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduledActionSpecForProviderIamRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduledActionSpecForProviderIamRoleRef#policy
   */
  readonly policy?: ScheduledActionSpecForProviderIamRoleRefPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderIamRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderIamRoleRef(obj: ScheduledActionSpecForProviderIamRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduledActionSpecForProviderIamRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate iamRole.
 *
 * @schema ScheduledActionSpecForProviderIamRoleSelector
 */
export interface ScheduledActionSpecForProviderIamRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ScheduledActionSpecForProviderIamRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ScheduledActionSpecForProviderIamRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ScheduledActionSpecForProviderIamRoleSelector#policy
   */
  readonly policy?: ScheduledActionSpecForProviderIamRoleSelectorPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderIamRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderIamRoleSelector(obj: ScheduledActionSpecForProviderIamRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ScheduledActionSpecForProviderIamRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduledActionSpecForProviderTargetAction
 */
export interface ScheduledActionSpecForProviderTargetAction {
  /**
   * An action that runs a PauseCluster API operation. Documented below.
   *
   * @schema ScheduledActionSpecForProviderTargetAction#pauseCluster
   */
  readonly pauseCluster?: ScheduledActionSpecForProviderTargetActionPauseCluster[];

  /**
   * An action that runs a ResizeCluster API operation. Documented below.
   *
   * @schema ScheduledActionSpecForProviderTargetAction#resizeCluster
   */
  readonly resizeCluster?: ScheduledActionSpecForProviderTargetActionResizeCluster[];

  /**
   * An action that runs a ResumeCluster API operation. Documented below.
   *
   * @schema ScheduledActionSpecForProviderTargetAction#resumeCluster
   */
  readonly resumeCluster?: ScheduledActionSpecForProviderTargetActionResumeCluster[];

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderTargetAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderTargetAction(obj: ScheduledActionSpecForProviderTargetAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pauseCluster': obj.pauseCluster?.map(y => toJson_ScheduledActionSpecForProviderTargetActionPauseCluster(y)),
    'resizeCluster': obj.resizeCluster?.map(y => toJson_ScheduledActionSpecForProviderTargetActionResizeCluster(y)),
    'resumeCluster': obj.resumeCluster?.map(y => toJson_ScheduledActionSpecForProviderTargetActionResumeCluster(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduledActionSpecProviderConfigRefPolicy
 */
export interface ScheduledActionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecProviderConfigRefPolicy(obj: ScheduledActionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduledActionSpecProviderRefPolicy
 */
export interface ScheduledActionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecProviderRefPolicy(obj: ScheduledActionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRef
 */
export interface ScheduledActionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecPublishConnectionDetailsToConfigRef(obj: ScheduledActionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsToMetadata
 */
export interface ScheduledActionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScheduledActionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecPublishConnectionDetailsToMetadata(obj: ScheduledActionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduledActionSpecForProviderIamRoleRefPolicy
 */
export interface ScheduledActionSpecForProviderIamRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecForProviderIamRoleRefPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecForProviderIamRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecForProviderIamRoleRefPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecForProviderIamRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderIamRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderIamRoleRefPolicy(obj: ScheduledActionSpecForProviderIamRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ScheduledActionSpecForProviderIamRoleSelectorPolicy
 */
export interface ScheduledActionSpecForProviderIamRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecForProviderIamRoleSelectorPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecForProviderIamRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecForProviderIamRoleSelectorPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecForProviderIamRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderIamRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderIamRoleSelectorPolicy(obj: ScheduledActionSpecForProviderIamRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduledActionSpecForProviderTargetActionPauseCluster
 */
export interface ScheduledActionSpecForProviderTargetActionPauseCluster {
  /**
   * The identifier of the cluster to be paused.
   *
   * @schema ScheduledActionSpecForProviderTargetActionPauseCluster#clusterIdentifier
   */
  readonly clusterIdentifier: string;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderTargetActionPauseCluster' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderTargetActionPauseCluster(obj: ScheduledActionSpecForProviderTargetActionPauseCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterIdentifier': obj.clusterIdentifier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduledActionSpecForProviderTargetActionResizeCluster
 */
export interface ScheduledActionSpecForProviderTargetActionResizeCluster {
  /**
   * A boolean value indicating whether the resize operation is using the classic resize process. Default: false.
   *
   * @schema ScheduledActionSpecForProviderTargetActionResizeCluster#classic
   */
  readonly classic?: boolean;

  /**
   * The unique identifier for the cluster to resize.
   *
   * @schema ScheduledActionSpecForProviderTargetActionResizeCluster#clusterIdentifier
   */
  readonly clusterIdentifier: string;

  /**
   * The new cluster type for the specified cluster.
   *
   * @schema ScheduledActionSpecForProviderTargetActionResizeCluster#clusterType
   */
  readonly clusterType?: string;

  /**
   * The new node type for the nodes you are adding.
   *
   * @schema ScheduledActionSpecForProviderTargetActionResizeCluster#nodeType
   */
  readonly nodeType?: string;

  /**
   * The new number of nodes for the cluster.
   *
   * @schema ScheduledActionSpecForProviderTargetActionResizeCluster#numberOfNodes
   */
  readonly numberOfNodes?: number;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderTargetActionResizeCluster' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderTargetActionResizeCluster(obj: ScheduledActionSpecForProviderTargetActionResizeCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'classic': obj.classic,
    'clusterIdentifier': obj.clusterIdentifier,
    'clusterType': obj.clusterType,
    'nodeType': obj.nodeType,
    'numberOfNodes': obj.numberOfNodes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduledActionSpecForProviderTargetActionResumeCluster
 */
export interface ScheduledActionSpecForProviderTargetActionResumeCluster {
  /**
   * The identifier of the cluster to be resumed.
   *
   * @schema ScheduledActionSpecForProviderTargetActionResumeCluster#clusterIdentifier
   */
  readonly clusterIdentifier: string;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderTargetActionResumeCluster' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderTargetActionResumeCluster(obj: ScheduledActionSpecForProviderTargetActionResumeCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterIdentifier': obj.clusterIdentifier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecProviderConfigRefPolicyResolution
 */
export enum ScheduledActionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecProviderConfigRefPolicyResolve
 */
export enum ScheduledActionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecProviderRefPolicyResolution
 */
export enum ScheduledActionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecProviderRefPolicyResolve
 */
export enum ScheduledActionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy(obj: ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecForProviderIamRoleRefPolicyResolution
 */
export enum ScheduledActionSpecForProviderIamRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecForProviderIamRoleRefPolicyResolve
 */
export enum ScheduledActionSpecForProviderIamRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecForProviderIamRoleSelectorPolicyResolution
 */
export enum ScheduledActionSpecForProviderIamRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecForProviderIamRoleSelectorPolicyResolve
 */
export enum ScheduledActionSpecForProviderIamRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SnapshotCopyGrant is the Schema for the SnapshotCopyGrants API. Creates a snapshot copy grant that allows AWS Redshift to encrypt copied snapshots with a customer master key from AWS KMS in a destination region.
 *
 * @schema SnapshotCopyGrant
 */
export class SnapshotCopyGrant extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SnapshotCopyGrant"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshift.aws.upbound.io/v1beta1',
    kind: 'SnapshotCopyGrant',
  }

  /**
   * Renders a Kubernetes manifest for "SnapshotCopyGrant".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SnapshotCopyGrantProps): any {
    return {
      ...SnapshotCopyGrant.GVK,
      ...toJson_SnapshotCopyGrantProps(props),
    };
  }

  /**
   * Defines a "SnapshotCopyGrant" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SnapshotCopyGrantProps) {
    super(scope, id, {
      ...SnapshotCopyGrant.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SnapshotCopyGrant.GVK,
      ...toJson_SnapshotCopyGrantProps(resolved),
    };
  }
}

/**
 * SnapshotCopyGrant is the Schema for the SnapshotCopyGrants API. Creates a snapshot copy grant that allows AWS Redshift to encrypt copied snapshots with a customer master key from AWS KMS in a destination region.
 *
 * @schema SnapshotCopyGrant
 */
export interface SnapshotCopyGrantProps {
  /**
   * @schema SnapshotCopyGrant#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SnapshotCopyGrantSpec defines the desired state of SnapshotCopyGrant
   *
   * @schema SnapshotCopyGrant#spec
   */
  readonly spec: SnapshotCopyGrantSpec;

}

/**
 * Converts an object of type 'SnapshotCopyGrantProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotCopyGrantProps(obj: SnapshotCopyGrantProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SnapshotCopyGrantSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SnapshotCopyGrantSpec defines the desired state of SnapshotCopyGrant
 *
 * @schema SnapshotCopyGrantSpec
 */
export interface SnapshotCopyGrantSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SnapshotCopyGrantSpec#deletionPolicy
   */
  readonly deletionPolicy?: SnapshotCopyGrantSpecDeletionPolicy;

  /**
   * @schema SnapshotCopyGrantSpec#forProvider
   */
  readonly forProvider: SnapshotCopyGrantSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SnapshotCopyGrantSpec#managementPolicy
   */
  readonly managementPolicy?: SnapshotCopyGrantSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SnapshotCopyGrantSpec#providerConfigRef
   */
  readonly providerConfigRef?: SnapshotCopyGrantSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SnapshotCopyGrantSpec#providerRef
   */
  readonly providerRef?: SnapshotCopyGrantSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SnapshotCopyGrantSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SnapshotCopyGrantSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SnapshotCopyGrantSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SnapshotCopyGrantSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SnapshotCopyGrantSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotCopyGrantSpec(obj: SnapshotCopyGrantSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SnapshotCopyGrantSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_SnapshotCopyGrantSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SnapshotCopyGrantSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SnapshotCopyGrantSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SnapshotCopyGrantSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SnapshotCopyGrantSpecDeletionPolicy
 */
export enum SnapshotCopyGrantSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SnapshotCopyGrantSpecForProvider
 */
export interface SnapshotCopyGrantSpecForProvider {
  /**
   * The unique identifier for the customer master key (CMK) that the grant applies to. Specify the key ID or the Amazon Resource Name (ARN) of the CMK. To specify a CMK in a different AWS account, you must use the key ARN. If not specified, the default key is used.
   *
   * @schema SnapshotCopyGrantSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema SnapshotCopyGrantSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: SnapshotCopyGrantSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema SnapshotCopyGrantSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: SnapshotCopyGrantSpecForProviderKmsKeyIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SnapshotCopyGrantSpecForProvider#region
   */
  readonly region: string;

  /**
   * A friendly name for identifying the grant.
   *
   * @schema SnapshotCopyGrantSpecForProvider#snapshotCopyGrantName
   */
  readonly snapshotCopyGrantName?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema SnapshotCopyGrantSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SnapshotCopyGrantSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotCopyGrantSpecForProvider(obj: SnapshotCopyGrantSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_SnapshotCopyGrantSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_SnapshotCopyGrantSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'region': obj.region,
    'snapshotCopyGrantName': obj.snapshotCopyGrantName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SnapshotCopyGrantSpecManagementPolicy
 */
export enum SnapshotCopyGrantSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SnapshotCopyGrantSpecProviderConfigRef
 */
export interface SnapshotCopyGrantSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotCopyGrantSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotCopyGrantSpecProviderConfigRef#policy
   */
  readonly policy?: SnapshotCopyGrantSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SnapshotCopyGrantSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotCopyGrantSpecProviderConfigRef(obj: SnapshotCopyGrantSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotCopyGrantSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SnapshotCopyGrantSpecProviderRef
 */
export interface SnapshotCopyGrantSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotCopyGrantSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotCopyGrantSpecProviderRef#policy
   */
  readonly policy?: SnapshotCopyGrantSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SnapshotCopyGrantSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotCopyGrantSpecProviderRef(obj: SnapshotCopyGrantSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotCopyGrantSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SnapshotCopyGrantSpecPublishConnectionDetailsTo
 */
export interface SnapshotCopyGrantSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SnapshotCopyGrantSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SnapshotCopyGrantSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SnapshotCopyGrantSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SnapshotCopyGrantSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SnapshotCopyGrantSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotCopyGrantSpecPublishConnectionDetailsTo(obj: SnapshotCopyGrantSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SnapshotCopyGrantSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SnapshotCopyGrantSpecWriteConnectionSecretToRef
 */
export interface SnapshotCopyGrantSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SnapshotCopyGrantSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SnapshotCopyGrantSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SnapshotCopyGrantSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotCopyGrantSpecWriteConnectionSecretToRef(obj: SnapshotCopyGrantSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema SnapshotCopyGrantSpecForProviderKmsKeyIdRef
 */
export interface SnapshotCopyGrantSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotCopyGrantSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotCopyGrantSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: SnapshotCopyGrantSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'SnapshotCopyGrantSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotCopyGrantSpecForProviderKmsKeyIdRef(obj: SnapshotCopyGrantSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotCopyGrantSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema SnapshotCopyGrantSpecForProviderKmsKeyIdSelector
 */
export interface SnapshotCopyGrantSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SnapshotCopyGrantSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SnapshotCopyGrantSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SnapshotCopyGrantSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: SnapshotCopyGrantSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'SnapshotCopyGrantSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotCopyGrantSpecForProviderKmsKeyIdSelector(obj: SnapshotCopyGrantSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SnapshotCopyGrantSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SnapshotCopyGrantSpecProviderConfigRefPolicy
 */
export interface SnapshotCopyGrantSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotCopyGrantSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SnapshotCopyGrantSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotCopyGrantSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SnapshotCopyGrantSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotCopyGrantSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotCopyGrantSpecProviderConfigRefPolicy(obj: SnapshotCopyGrantSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SnapshotCopyGrantSpecProviderRefPolicy
 */
export interface SnapshotCopyGrantSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotCopyGrantSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SnapshotCopyGrantSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotCopyGrantSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SnapshotCopyGrantSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotCopyGrantSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotCopyGrantSpecProviderRefPolicy(obj: SnapshotCopyGrantSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRef
 */
export interface SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRef(obj: SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SnapshotCopyGrantSpecPublishConnectionDetailsToMetadata
 */
export interface SnapshotCopyGrantSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SnapshotCopyGrantSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SnapshotCopyGrantSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SnapshotCopyGrantSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SnapshotCopyGrantSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotCopyGrantSpecPublishConnectionDetailsToMetadata(obj: SnapshotCopyGrantSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SnapshotCopyGrantSpecForProviderKmsKeyIdRefPolicy
 */
export interface SnapshotCopyGrantSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotCopyGrantSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: SnapshotCopyGrantSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotCopyGrantSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: SnapshotCopyGrantSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotCopyGrantSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotCopyGrantSpecForProviderKmsKeyIdRefPolicy(obj: SnapshotCopyGrantSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SnapshotCopyGrantSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface SnapshotCopyGrantSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotCopyGrantSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: SnapshotCopyGrantSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotCopyGrantSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: SnapshotCopyGrantSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotCopyGrantSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotCopyGrantSpecForProviderKmsKeyIdSelectorPolicy(obj: SnapshotCopyGrantSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotCopyGrantSpecProviderConfigRefPolicyResolution
 */
export enum SnapshotCopyGrantSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotCopyGrantSpecProviderConfigRefPolicyResolve
 */
export enum SnapshotCopyGrantSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotCopyGrantSpecProviderRefPolicyResolution
 */
export enum SnapshotCopyGrantSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotCopyGrantSpecProviderRefPolicyResolve
 */
export enum SnapshotCopyGrantSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRefPolicy(obj: SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotCopyGrantSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum SnapshotCopyGrantSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotCopyGrantSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum SnapshotCopyGrantSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotCopyGrantSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum SnapshotCopyGrantSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotCopyGrantSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum SnapshotCopyGrantSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SnapshotCopyGrantSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SnapshotSchedule is the Schema for the SnapshotSchedules API. Provides an Redshift Snapshot Schedule resource.
 *
 * @schema SnapshotSchedule
 */
export class SnapshotSchedule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SnapshotSchedule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshift.aws.upbound.io/v1beta1',
    kind: 'SnapshotSchedule',
  }

  /**
   * Renders a Kubernetes manifest for "SnapshotSchedule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SnapshotScheduleProps): any {
    return {
      ...SnapshotSchedule.GVK,
      ...toJson_SnapshotScheduleProps(props),
    };
  }

  /**
   * Defines a "SnapshotSchedule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SnapshotScheduleProps) {
    super(scope, id, {
      ...SnapshotSchedule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SnapshotSchedule.GVK,
      ...toJson_SnapshotScheduleProps(resolved),
    };
  }
}

/**
 * SnapshotSchedule is the Schema for the SnapshotSchedules API. Provides an Redshift Snapshot Schedule resource.
 *
 * @schema SnapshotSchedule
 */
export interface SnapshotScheduleProps {
  /**
   * @schema SnapshotSchedule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SnapshotScheduleSpec defines the desired state of SnapshotSchedule
   *
   * @schema SnapshotSchedule#spec
   */
  readonly spec: SnapshotScheduleSpec;

}

/**
 * Converts an object of type 'SnapshotScheduleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleProps(obj: SnapshotScheduleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SnapshotScheduleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SnapshotScheduleSpec defines the desired state of SnapshotSchedule
 *
 * @schema SnapshotScheduleSpec
 */
export interface SnapshotScheduleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SnapshotScheduleSpec#deletionPolicy
   */
  readonly deletionPolicy?: SnapshotScheduleSpecDeletionPolicy;

  /**
   * @schema SnapshotScheduleSpec#forProvider
   */
  readonly forProvider: SnapshotScheduleSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SnapshotScheduleSpec#managementPolicy
   */
  readonly managementPolicy?: SnapshotScheduleSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SnapshotScheduleSpec#providerConfigRef
   */
  readonly providerConfigRef?: SnapshotScheduleSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SnapshotScheduleSpec#providerRef
   */
  readonly providerRef?: SnapshotScheduleSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SnapshotScheduleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SnapshotScheduleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SnapshotScheduleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SnapshotScheduleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SnapshotScheduleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleSpec(obj: SnapshotScheduleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SnapshotScheduleSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_SnapshotScheduleSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SnapshotScheduleSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SnapshotScheduleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SnapshotScheduleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SnapshotScheduleSpecDeletionPolicy
 */
export enum SnapshotScheduleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SnapshotScheduleSpecForProvider
 */
export interface SnapshotScheduleSpecForProvider {
  /**
   * The definition of the snapshot schedule. The definition is made up of schedule expressions, for example cron(30 12 *) or rate(12 hours).
   *
   * @schema SnapshotScheduleSpecForProvider#definitions
   */
  readonly definitions?: string[];

  /**
   * The description of the snapshot schedule.
   *
   * @schema SnapshotScheduleSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Whether to destroy all associated clusters with this snapshot schedule on deletion. Must be enabled and applied before attempting deletion.
   *
   * @schema SnapshotScheduleSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SnapshotScheduleSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema SnapshotScheduleSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SnapshotScheduleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleSpecForProvider(obj: SnapshotScheduleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'definitions': obj.definitions?.map(y => y),
    'description': obj.description,
    'forceDestroy': obj.forceDestroy,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SnapshotScheduleSpecManagementPolicy
 */
export enum SnapshotScheduleSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SnapshotScheduleSpecProviderConfigRef
 */
export interface SnapshotScheduleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotScheduleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotScheduleSpecProviderConfigRef#policy
   */
  readonly policy?: SnapshotScheduleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SnapshotScheduleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleSpecProviderConfigRef(obj: SnapshotScheduleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotScheduleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SnapshotScheduleSpecProviderRef
 */
export interface SnapshotScheduleSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotScheduleSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotScheduleSpecProviderRef#policy
   */
  readonly policy?: SnapshotScheduleSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SnapshotScheduleSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleSpecProviderRef(obj: SnapshotScheduleSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotScheduleSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SnapshotScheduleSpecPublishConnectionDetailsTo
 */
export interface SnapshotScheduleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SnapshotScheduleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SnapshotScheduleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SnapshotScheduleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SnapshotScheduleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SnapshotScheduleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SnapshotScheduleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleSpecPublishConnectionDetailsTo(obj: SnapshotScheduleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SnapshotScheduleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SnapshotScheduleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SnapshotScheduleSpecWriteConnectionSecretToRef
 */
export interface SnapshotScheduleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SnapshotScheduleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SnapshotScheduleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SnapshotScheduleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleSpecWriteConnectionSecretToRef(obj: SnapshotScheduleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SnapshotScheduleSpecProviderConfigRefPolicy
 */
export interface SnapshotScheduleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotScheduleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SnapshotScheduleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotScheduleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SnapshotScheduleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotScheduleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleSpecProviderConfigRefPolicy(obj: SnapshotScheduleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SnapshotScheduleSpecProviderRefPolicy
 */
export interface SnapshotScheduleSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotScheduleSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SnapshotScheduleSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotScheduleSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SnapshotScheduleSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotScheduleSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleSpecProviderRefPolicy(obj: SnapshotScheduleSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SnapshotScheduleSpecPublishConnectionDetailsToConfigRef
 */
export interface SnapshotScheduleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotScheduleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotScheduleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SnapshotScheduleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SnapshotScheduleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleSpecPublishConnectionDetailsToConfigRef(obj: SnapshotScheduleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotScheduleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SnapshotScheduleSpecPublishConnectionDetailsToMetadata
 */
export interface SnapshotScheduleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SnapshotScheduleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SnapshotScheduleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SnapshotScheduleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SnapshotScheduleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleSpecPublishConnectionDetailsToMetadata(obj: SnapshotScheduleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotScheduleSpecProviderConfigRefPolicyResolution
 */
export enum SnapshotScheduleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotScheduleSpecProviderConfigRefPolicyResolve
 */
export enum SnapshotScheduleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotScheduleSpecProviderRefPolicyResolution
 */
export enum SnapshotScheduleSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotScheduleSpecProviderRefPolicyResolve
 */
export enum SnapshotScheduleSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SnapshotScheduleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SnapshotScheduleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotScheduleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SnapshotScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotScheduleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SnapshotScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotScheduleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleSpecPublishConnectionDetailsToConfigRefPolicy(obj: SnapshotScheduleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SnapshotScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SnapshotScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SnapshotScheduleAssociation is the Schema for the SnapshotScheduleAssociations API. Provides an Association Redshift Cluster and Snapshot Schedule resource.
 *
 * @schema SnapshotScheduleAssociation
 */
export class SnapshotScheduleAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SnapshotScheduleAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshift.aws.upbound.io/v1beta1',
    kind: 'SnapshotScheduleAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "SnapshotScheduleAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SnapshotScheduleAssociationProps): any {
    return {
      ...SnapshotScheduleAssociation.GVK,
      ...toJson_SnapshotScheduleAssociationProps(props),
    };
  }

  /**
   * Defines a "SnapshotScheduleAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SnapshotScheduleAssociationProps) {
    super(scope, id, {
      ...SnapshotScheduleAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SnapshotScheduleAssociation.GVK,
      ...toJson_SnapshotScheduleAssociationProps(resolved),
    };
  }
}

/**
 * SnapshotScheduleAssociation is the Schema for the SnapshotScheduleAssociations API. Provides an Association Redshift Cluster and Snapshot Schedule resource.
 *
 * @schema SnapshotScheduleAssociation
 */
export interface SnapshotScheduleAssociationProps {
  /**
   * @schema SnapshotScheduleAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SnapshotScheduleAssociationSpec defines the desired state of SnapshotScheduleAssociation
   *
   * @schema SnapshotScheduleAssociation#spec
   */
  readonly spec: SnapshotScheduleAssociationSpec;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationProps(obj: SnapshotScheduleAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SnapshotScheduleAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SnapshotScheduleAssociationSpec defines the desired state of SnapshotScheduleAssociation
 *
 * @schema SnapshotScheduleAssociationSpec
 */
export interface SnapshotScheduleAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SnapshotScheduleAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: SnapshotScheduleAssociationSpecDeletionPolicy;

  /**
   * @schema SnapshotScheduleAssociationSpec#forProvider
   */
  readonly forProvider: SnapshotScheduleAssociationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SnapshotScheduleAssociationSpec#managementPolicy
   */
  readonly managementPolicy?: SnapshotScheduleAssociationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SnapshotScheduleAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: SnapshotScheduleAssociationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SnapshotScheduleAssociationSpec#providerRef
   */
  readonly providerRef?: SnapshotScheduleAssociationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SnapshotScheduleAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SnapshotScheduleAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SnapshotScheduleAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SnapshotScheduleAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpec(obj: SnapshotScheduleAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SnapshotScheduleAssociationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_SnapshotScheduleAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SnapshotScheduleAssociationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SnapshotScheduleAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SnapshotScheduleAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SnapshotScheduleAssociationSpecDeletionPolicy
 */
export enum SnapshotScheduleAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SnapshotScheduleAssociationSpecForProvider
 */
export interface SnapshotScheduleAssociationSpecForProvider {
  /**
   * The cluster identifier.
   *
   * @schema SnapshotScheduleAssociationSpecForProvider#clusterIdentifier
   */
  readonly clusterIdentifier?: string;

  /**
   * Reference to a Cluster in redshift to populate clusterIdentifier.
   *
   * @schema SnapshotScheduleAssociationSpecForProvider#clusterIdentifierRef
   */
  readonly clusterIdentifierRef?: SnapshotScheduleAssociationSpecForProviderClusterIdentifierRef;

  /**
   * Selector for a Cluster in redshift to populate clusterIdentifier.
   *
   * @schema SnapshotScheduleAssociationSpecForProvider#clusterIdentifierSelector
   */
  readonly clusterIdentifierSelector?: SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SnapshotScheduleAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The snapshot schedule identifier.
   *
   * @schema SnapshotScheduleAssociationSpecForProvider#scheduleIdentifier
   */
  readonly scheduleIdentifier?: string;

  /**
   * Reference to a SnapshotSchedule in redshift to populate scheduleIdentifier.
   *
   * @schema SnapshotScheduleAssociationSpecForProvider#scheduleIdentifierRef
   */
  readonly scheduleIdentifierRef?: SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRef;

  /**
   * Selector for a SnapshotSchedule in redshift to populate scheduleIdentifier.
   *
   * @schema SnapshotScheduleAssociationSpecForProvider#scheduleIdentifierSelector
   */
  readonly scheduleIdentifierSelector?: SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelector;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecForProvider(obj: SnapshotScheduleAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterIdentifier': obj.clusterIdentifier,
    'clusterIdentifierRef': toJson_SnapshotScheduleAssociationSpecForProviderClusterIdentifierRef(obj.clusterIdentifierRef),
    'clusterIdentifierSelector': toJson_SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelector(obj.clusterIdentifierSelector),
    'region': obj.region,
    'scheduleIdentifier': obj.scheduleIdentifier,
    'scheduleIdentifierRef': toJson_SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRef(obj.scheduleIdentifierRef),
    'scheduleIdentifierSelector': toJson_SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelector(obj.scheduleIdentifierSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SnapshotScheduleAssociationSpecManagementPolicy
 */
export enum SnapshotScheduleAssociationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SnapshotScheduleAssociationSpecProviderConfigRef
 */
export interface SnapshotScheduleAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotScheduleAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotScheduleAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: SnapshotScheduleAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecProviderConfigRef(obj: SnapshotScheduleAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotScheduleAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SnapshotScheduleAssociationSpecProviderRef
 */
export interface SnapshotScheduleAssociationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotScheduleAssociationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotScheduleAssociationSpecProviderRef#policy
   */
  readonly policy?: SnapshotScheduleAssociationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecProviderRef(obj: SnapshotScheduleAssociationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotScheduleAssociationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SnapshotScheduleAssociationSpecPublishConnectionDetailsTo
 */
export interface SnapshotScheduleAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SnapshotScheduleAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SnapshotScheduleAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SnapshotScheduleAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SnapshotScheduleAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecPublishConnectionDetailsTo(obj: SnapshotScheduleAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SnapshotScheduleAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SnapshotScheduleAssociationSpecWriteConnectionSecretToRef
 */
export interface SnapshotScheduleAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SnapshotScheduleAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SnapshotScheduleAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecWriteConnectionSecretToRef(obj: SnapshotScheduleAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in redshift to populate clusterIdentifier.
 *
 * @schema SnapshotScheduleAssociationSpecForProviderClusterIdentifierRef
 */
export interface SnapshotScheduleAssociationSpecForProviderClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderClusterIdentifierRef#policy
   */
  readonly policy?: SnapshotScheduleAssociationSpecForProviderClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecForProviderClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecForProviderClusterIdentifierRef(obj: SnapshotScheduleAssociationSpecForProviderClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotScheduleAssociationSpecForProviderClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in redshift to populate clusterIdentifier.
 *
 * @schema SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelector
 */
export interface SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelector#policy
   */
  readonly policy?: SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelector(obj: SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a SnapshotSchedule in redshift to populate scheduleIdentifier.
 *
 * @schema SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRef
 */
export interface SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRef#policy
   */
  readonly policy?: SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRefPolicy;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRef(obj: SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a SnapshotSchedule in redshift to populate scheduleIdentifier.
 *
 * @schema SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelector
 */
export interface SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelector#policy
   */
  readonly policy?: SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelector(obj: SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SnapshotScheduleAssociationSpecProviderConfigRefPolicy
 */
export interface SnapshotScheduleAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotScheduleAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SnapshotScheduleAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotScheduleAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SnapshotScheduleAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecProviderConfigRefPolicy(obj: SnapshotScheduleAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SnapshotScheduleAssociationSpecProviderRefPolicy
 */
export interface SnapshotScheduleAssociationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotScheduleAssociationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SnapshotScheduleAssociationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotScheduleAssociationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SnapshotScheduleAssociationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecProviderRefPolicy(obj: SnapshotScheduleAssociationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRef(obj: SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SnapshotScheduleAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface SnapshotScheduleAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SnapshotScheduleAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SnapshotScheduleAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SnapshotScheduleAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecPublishConnectionDetailsToMetadata(obj: SnapshotScheduleAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SnapshotScheduleAssociationSpecForProviderClusterIdentifierRefPolicy
 */
export interface SnapshotScheduleAssociationSpecForProviderClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: SnapshotScheduleAssociationSpecForProviderClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: SnapshotScheduleAssociationSpecForProviderClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecForProviderClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecForProviderClusterIdentifierRefPolicy(obj: SnapshotScheduleAssociationSpecForProviderClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelectorPolicy
 */
export interface SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelectorPolicy(obj: SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRefPolicy
 */
export interface SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRefPolicy#resolution
   */
  readonly resolution?: SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRefPolicy#resolve
   */
  readonly resolve?: SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRefPolicy(obj: SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelectorPolicy
 */
export interface SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelectorPolicy(obj: SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotScheduleAssociationSpecProviderConfigRefPolicyResolution
 */
export enum SnapshotScheduleAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotScheduleAssociationSpecProviderConfigRefPolicyResolve
 */
export enum SnapshotScheduleAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotScheduleAssociationSpecProviderRefPolicyResolution
 */
export enum SnapshotScheduleAssociationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotScheduleAssociationSpecProviderRefPolicyResolve
 */
export enum SnapshotScheduleAssociationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotScheduleAssociationSpecForProviderClusterIdentifierRefPolicyResolution
 */
export enum SnapshotScheduleAssociationSpecForProviderClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotScheduleAssociationSpecForProviderClusterIdentifierRefPolicyResolve
 */
export enum SnapshotScheduleAssociationSpecForProviderClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelectorPolicyResolution
 */
export enum SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelectorPolicyResolve
 */
export enum SnapshotScheduleAssociationSpecForProviderClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRefPolicyResolution
 */
export enum SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRefPolicyResolve
 */
export enum SnapshotScheduleAssociationSpecForProviderScheduleIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelectorPolicyResolution
 */
export enum SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelectorPolicyResolve
 */
export enum SnapshotScheduleAssociationSpecForProviderScheduleIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SnapshotScheduleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SubnetGroup is the Schema for the SubnetGroups API. Provides a Redshift Subnet Group resource.
 *
 * @schema SubnetGroup
 */
export class SubnetGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SubnetGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshift.aws.upbound.io/v1beta1',
    kind: 'SubnetGroup',
  }

  /**
   * Renders a Kubernetes manifest for "SubnetGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SubnetGroupProps): any {
    return {
      ...SubnetGroup.GVK,
      ...toJson_SubnetGroupProps(props),
    };
  }

  /**
   * Defines a "SubnetGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SubnetGroupProps) {
    super(scope, id, {
      ...SubnetGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SubnetGroup.GVK,
      ...toJson_SubnetGroupProps(resolved),
    };
  }
}

/**
 * SubnetGroup is the Schema for the SubnetGroups API. Provides a Redshift Subnet Group resource.
 *
 * @schema SubnetGroup
 */
export interface SubnetGroupProps {
  /**
   * @schema SubnetGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SubnetGroupSpec defines the desired state of SubnetGroup
   *
   * @schema SubnetGroup#spec
   */
  readonly spec: SubnetGroupSpec;

}

/**
 * Converts an object of type 'SubnetGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupProps(obj: SubnetGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SubnetGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetGroupSpec defines the desired state of SubnetGroup
 *
 * @schema SubnetGroupSpec
 */
export interface SubnetGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SubnetGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: SubnetGroupSpecDeletionPolicy;

  /**
   * @schema SubnetGroupSpec#forProvider
   */
  readonly forProvider: SubnetGroupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SubnetGroupSpec#managementPolicy
   */
  readonly managementPolicy?: SubnetGroupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SubnetGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: SubnetGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SubnetGroupSpec#providerRef
   */
  readonly providerRef?: SubnetGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SubnetGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SubnetGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SubnetGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SubnetGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SubnetGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpec(obj: SubnetGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SubnetGroupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_SubnetGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SubnetGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SubnetGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SubnetGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SubnetGroupSpecDeletionPolicy
 */
export enum SubnetGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SubnetGroupSpecForProvider
 */
export interface SubnetGroupSpecForProvider {
  /**
   * The description of the Redshift Subnet group.
   *
   * @schema SubnetGroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SubnetGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema SubnetGroupSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: SubnetGroupSpecForProviderSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema SubnetGroupSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: SubnetGroupSpecForProviderSubnetIdSelector;

  /**
   * An array of VPC subnet IDs.
   *
   * @schema SubnetGroupSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema SubnetGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SubnetGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProvider(obj: SubnetGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'region': obj.region,
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_SubnetGroupSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_SubnetGroupSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SubnetGroupSpecManagementPolicy
 */
export enum SubnetGroupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SubnetGroupSpecProviderConfigRef
 */
export interface SubnetGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetGroupSpecProviderConfigRef#policy
   */
  readonly policy?: SubnetGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecProviderConfigRef(obj: SubnetGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SubnetGroupSpecProviderRef
 */
export interface SubnetGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetGroupSpecProviderRef#policy
   */
  readonly policy?: SubnetGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecProviderRef(obj: SubnetGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsTo
 */
export interface SubnetGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SubnetGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SubnetGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SubnetGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecPublishConnectionDetailsTo(obj: SubnetGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SubnetGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SubnetGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SubnetGroupSpecWriteConnectionSecretToRef
 */
export interface SubnetGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SubnetGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SubnetGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SubnetGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecWriteConnectionSecretToRef(obj: SubnetGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdRefs
 */
export interface SubnetGroupSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: SubnetGroupSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProviderSubnetIdRefs(obj: SubnetGroupSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetGroupSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdSelector
 */
export interface SubnetGroupSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: SubnetGroupSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProviderSubnetIdSelector(obj: SubnetGroupSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SubnetGroupSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetGroupSpecProviderConfigRefPolicy
 */
export interface SubnetGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecProviderConfigRefPolicy(obj: SubnetGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetGroupSpecProviderRefPolicy
 */
export interface SubnetGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecProviderRefPolicy(obj: SubnetGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface SubnetGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecPublishConnectionDetailsToConfigRef(obj: SubnetGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToMetadata
 */
export interface SubnetGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SubnetGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecPublishConnectionDetailsToMetadata(obj: SubnetGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdRefsPolicy
 */
export interface SubnetGroupSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProviderSubnetIdRefsPolicy(obj: SubnetGroupSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdSelectorPolicy
 */
export interface SubnetGroupSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProviderSubnetIdSelectorPolicy(obj: SubnetGroupSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecProviderConfigRefPolicyResolution
 */
export enum SubnetGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecProviderConfigRefPolicyResolve
 */
export enum SubnetGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecProviderRefPolicyResolution
 */
export enum SubnetGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecProviderRefPolicyResolve
 */
export enum SubnetGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum SubnetGroupSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum SubnetGroupSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UsageLimit is the Schema for the UsageLimits API. Provides a Redshift Usage Limit resource.
 *
 * @schema UsageLimit
 */
export class UsageLimit extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UsageLimit"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshift.aws.upbound.io/v1beta1',
    kind: 'UsageLimit',
  }

  /**
   * Renders a Kubernetes manifest for "UsageLimit".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UsageLimitProps): any {
    return {
      ...UsageLimit.GVK,
      ...toJson_UsageLimitProps(props),
    };
  }

  /**
   * Defines a "UsageLimit" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UsageLimitProps) {
    super(scope, id, {
      ...UsageLimit.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UsageLimit.GVK,
      ...toJson_UsageLimitProps(resolved),
    };
  }
}

/**
 * UsageLimit is the Schema for the UsageLimits API. Provides a Redshift Usage Limit resource.
 *
 * @schema UsageLimit
 */
export interface UsageLimitProps {
  /**
   * @schema UsageLimit#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UsageLimitSpec defines the desired state of UsageLimit
   *
   * @schema UsageLimit#spec
   */
  readonly spec: UsageLimitSpec;

}

/**
 * Converts an object of type 'UsageLimitProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitProps(obj: UsageLimitProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UsageLimitSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UsageLimitSpec defines the desired state of UsageLimit
 *
 * @schema UsageLimitSpec
 */
export interface UsageLimitSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UsageLimitSpec#deletionPolicy
   */
  readonly deletionPolicy?: UsageLimitSpecDeletionPolicy;

  /**
   * @schema UsageLimitSpec#forProvider
   */
  readonly forProvider: UsageLimitSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UsageLimitSpec#managementPolicy
   */
  readonly managementPolicy?: UsageLimitSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UsageLimitSpec#providerConfigRef
   */
  readonly providerConfigRef?: UsageLimitSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema UsageLimitSpec#providerRef
   */
  readonly providerRef?: UsageLimitSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UsageLimitSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UsageLimitSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UsageLimitSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UsageLimitSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UsageLimitSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpec(obj: UsageLimitSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UsageLimitSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_UsageLimitSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_UsageLimitSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_UsageLimitSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UsageLimitSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UsageLimitSpecDeletionPolicy
 */
export enum UsageLimitSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UsageLimitSpecForProvider
 */
export interface UsageLimitSpecForProvider {
  /**
   * The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB). The value must be a positive number.
   *
   * @schema UsageLimitSpecForProvider#amount
   */
  readonly amount?: number;

  /**
   * The action that Amazon Redshift takes when the limit is reached. The default is log. Valid values are log, emit-metric, and disable.
   *
   * @schema UsageLimitSpecForProvider#breachAction
   */
  readonly breachAction?: string;

  /**
   * The identifier of the cluster that you want to limit usage.
   *
   * @schema UsageLimitSpecForProvider#clusterIdentifier
   */
  readonly clusterIdentifier?: string;

  /**
   * Reference to a Cluster in redshift to populate clusterIdentifier.
   *
   * @schema UsageLimitSpecForProvider#clusterIdentifierRef
   */
  readonly clusterIdentifierRef?: UsageLimitSpecForProviderClusterIdentifierRef;

  /**
   * Selector for a Cluster in redshift to populate clusterIdentifier.
   *
   * @schema UsageLimitSpecForProvider#clusterIdentifierSelector
   */
  readonly clusterIdentifierSelector?: UsageLimitSpecForProviderClusterIdentifierSelector;

  /**
   * The Amazon Redshift feature that you want to limit. Valid values are spectrum, concurrency-scaling, and cross-region-datasharing.
   *
   * @schema UsageLimitSpecForProvider#featureType
   */
  readonly featureType?: string;

  /**
   * The type of limit. Depending on the feature type, this can be based on a time duration or data size. If FeatureType is spectrum, then LimitType must be data-scanned. If FeatureType is concurrency-scaling, then LimitType must be time. If FeatureType is cross-region-datasharing, then LimitType must be data-scanned. Valid values are data-scanned, and time.
   *
   * @schema UsageLimitSpecForProvider#limitType
   */
  readonly limitType?: string;

  /**
   * The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly. Valid values are daily, weekly, and monthly.
   *
   * @schema UsageLimitSpecForProvider#period
   */
  readonly period?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UsageLimitSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema UsageLimitSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'UsageLimitSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecForProvider(obj: UsageLimitSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amount': obj.amount,
    'breachAction': obj.breachAction,
    'clusterIdentifier': obj.clusterIdentifier,
    'clusterIdentifierRef': toJson_UsageLimitSpecForProviderClusterIdentifierRef(obj.clusterIdentifierRef),
    'clusterIdentifierSelector': toJson_UsageLimitSpecForProviderClusterIdentifierSelector(obj.clusterIdentifierSelector),
    'featureType': obj.featureType,
    'limitType': obj.limitType,
    'period': obj.period,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UsageLimitSpecManagementPolicy
 */
export enum UsageLimitSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UsageLimitSpecProviderConfigRef
 */
export interface UsageLimitSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsageLimitSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsageLimitSpecProviderConfigRef#policy
   */
  readonly policy?: UsageLimitSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UsageLimitSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecProviderConfigRef(obj: UsageLimitSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsageLimitSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema UsageLimitSpecProviderRef
 */
export interface UsageLimitSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsageLimitSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsageLimitSpecProviderRef#policy
   */
  readonly policy?: UsageLimitSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'UsageLimitSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecProviderRef(obj: UsageLimitSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsageLimitSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UsageLimitSpecPublishConnectionDetailsTo
 */
export interface UsageLimitSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UsageLimitSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UsageLimitSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UsageLimitSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecPublishConnectionDetailsTo(obj: UsageLimitSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UsageLimitSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UsageLimitSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UsageLimitSpecWriteConnectionSecretToRef
 */
export interface UsageLimitSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UsageLimitSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UsageLimitSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UsageLimitSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecWriteConnectionSecretToRef(obj: UsageLimitSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in redshift to populate clusterIdentifier.
 *
 * @schema UsageLimitSpecForProviderClusterIdentifierRef
 */
export interface UsageLimitSpecForProviderClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsageLimitSpecForProviderClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsageLimitSpecForProviderClusterIdentifierRef#policy
   */
  readonly policy?: UsageLimitSpecForProviderClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'UsageLimitSpecForProviderClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecForProviderClusterIdentifierRef(obj: UsageLimitSpecForProviderClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsageLimitSpecForProviderClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in redshift to populate clusterIdentifier.
 *
 * @schema UsageLimitSpecForProviderClusterIdentifierSelector
 */
export interface UsageLimitSpecForProviderClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UsageLimitSpecForProviderClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UsageLimitSpecForProviderClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UsageLimitSpecForProviderClusterIdentifierSelector#policy
   */
  readonly policy?: UsageLimitSpecForProviderClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'UsageLimitSpecForProviderClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecForProviderClusterIdentifierSelector(obj: UsageLimitSpecForProviderClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UsageLimitSpecForProviderClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UsageLimitSpecProviderConfigRefPolicy
 */
export interface UsageLimitSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsageLimitSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UsageLimitSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsageLimitSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UsageLimitSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UsageLimitSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecProviderConfigRefPolicy(obj: UsageLimitSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UsageLimitSpecProviderRefPolicy
 */
export interface UsageLimitSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsageLimitSpecProviderRefPolicy#resolution
   */
  readonly resolution?: UsageLimitSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsageLimitSpecProviderRefPolicy#resolve
   */
  readonly resolve?: UsageLimitSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'UsageLimitSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecProviderRefPolicy(obj: UsageLimitSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UsageLimitSpecPublishConnectionDetailsToConfigRef
 */
export interface UsageLimitSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UsageLimitSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecPublishConnectionDetailsToConfigRef(obj: UsageLimitSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UsageLimitSpecPublishConnectionDetailsToMetadata
 */
export interface UsageLimitSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UsageLimitSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecPublishConnectionDetailsToMetadata(obj: UsageLimitSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UsageLimitSpecForProviderClusterIdentifierRefPolicy
 */
export interface UsageLimitSpecForProviderClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsageLimitSpecForProviderClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: UsageLimitSpecForProviderClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsageLimitSpecForProviderClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: UsageLimitSpecForProviderClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'UsageLimitSpecForProviderClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecForProviderClusterIdentifierRefPolicy(obj: UsageLimitSpecForProviderClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UsageLimitSpecForProviderClusterIdentifierSelectorPolicy
 */
export interface UsageLimitSpecForProviderClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsageLimitSpecForProviderClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: UsageLimitSpecForProviderClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsageLimitSpecForProviderClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: UsageLimitSpecForProviderClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UsageLimitSpecForProviderClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecForProviderClusterIdentifierSelectorPolicy(obj: UsageLimitSpecForProviderClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsageLimitSpecProviderConfigRefPolicyResolution
 */
export enum UsageLimitSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsageLimitSpecProviderConfigRefPolicyResolve
 */
export enum UsageLimitSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsageLimitSpecProviderRefPolicyResolution
 */
export enum UsageLimitSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsageLimitSpecProviderRefPolicyResolve
 */
export enum UsageLimitSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UsageLimitSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UsageLimitSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy(obj: UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsageLimitSpecForProviderClusterIdentifierRefPolicyResolution
 */
export enum UsageLimitSpecForProviderClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsageLimitSpecForProviderClusterIdentifierRefPolicyResolve
 */
export enum UsageLimitSpecForProviderClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsageLimitSpecForProviderClusterIdentifierSelectorPolicyResolution
 */
export enum UsageLimitSpecForProviderClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsageLimitSpecForProviderClusterIdentifierSelectorPolicyResolve
 */
export enum UsageLimitSpecForProviderClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsageLimitSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UsageLimitSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsageLimitSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UsageLimitSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

