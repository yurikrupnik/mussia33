// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Device is the Schema for the Devices API. A Google Cloud IoT Core device.
 *
 * @schema Device
 */
export class Device extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Device"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudiot.gcp.upbound.io/v1beta1',
    kind: 'Device',
  }

  /**
   * Renders a Kubernetes manifest for "Device".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DeviceProps): any {
    return {
      ...Device.GVK,
      ...toJson_DeviceProps(props),
    };
  }

  /**
   * Defines a "Device" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DeviceProps) {
    super(scope, id, {
      ...Device.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Device.GVK,
      ...toJson_DeviceProps(resolved),
    };
  }
}

/**
 * Device is the Schema for the Devices API. A Google Cloud IoT Core device.
 *
 * @schema Device
 */
export interface DeviceProps {
  /**
   * @schema Device#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeviceSpec defines the desired state of Device
   *
   * @schema Device#spec
   */
  readonly spec: DeviceSpec;

}

/**
 * Converts an object of type 'DeviceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceProps(obj: DeviceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DeviceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeviceSpec defines the desired state of Device
 *
 * @schema DeviceSpec
 */
export interface DeviceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DeviceSpec#deletionPolicy
   */
  readonly deletionPolicy?: DeviceSpecDeletionPolicy;

  /**
   * @schema DeviceSpec#forProvider
   */
  readonly forProvider: DeviceSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DeviceSpec#providerConfigRef
   */
  readonly providerConfigRef?: DeviceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DeviceSpec#providerRef
   */
  readonly providerRef?: DeviceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DeviceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DeviceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DeviceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DeviceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DeviceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpec(obj: DeviceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DeviceSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DeviceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DeviceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DeviceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DeviceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DeviceSpecDeletionPolicy
 */
export enum DeviceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DeviceSpecForProvider
 */
export interface DeviceSpecForProvider {
  /**
   * If a device is blocked, connections or requests from this device will fail.
   *
   * @schema DeviceSpecForProvider#blocked
   */
  readonly blocked?: boolean;

  /**
   * The credentials used to authenticate this device. Structure is documented below.
   *
   * @schema DeviceSpecForProvider#credentials
   */
  readonly credentials?: DeviceSpecForProviderCredentials[];

  /**
   * Gateway-related configuration and state. Structure is documented below.
   *
   * @schema DeviceSpecForProvider#gatewayConfig
   */
  readonly gatewayConfig?: DeviceSpecForProviderGatewayConfig[];

  /**
   * The logging verbosity for device activity. Possible values are NONE, ERROR, INFO, and DEBUG.
   *
   * @schema DeviceSpecForProvider#logLevel
   */
  readonly logLevel?: string;

  /**
   * The metadata key-value pairs assigned to the device.
   *
   * @schema DeviceSpecForProvider#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * The name of the device registry where this device should be created.
   *
   * @schema DeviceSpecForProvider#registry
   */
  readonly registry?: string;

  /**
   * Reference to a Registry in cloudiot to populate registry.
   *
   * @schema DeviceSpecForProvider#registryRef
   */
  readonly registryRef?: DeviceSpecForProviderRegistryRef;

  /**
   * Selector for a Registry in cloudiot to populate registry.
   *
   * @schema DeviceSpecForProvider#registrySelector
   */
  readonly registrySelector?: DeviceSpecForProviderRegistrySelector;

}

/**
 * Converts an object of type 'DeviceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProvider(obj: DeviceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blocked': obj.blocked,
    'credentials': obj.credentials?.map(y => toJson_DeviceSpecForProviderCredentials(y)),
    'gatewayConfig': obj.gatewayConfig?.map(y => toJson_DeviceSpecForProviderGatewayConfig(y)),
    'logLevel': obj.logLevel,
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'registry': obj.registry,
    'registryRef': toJson_DeviceSpecForProviderRegistryRef(obj.registryRef),
    'registrySelector': toJson_DeviceSpecForProviderRegistrySelector(obj.registrySelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DeviceSpecProviderConfigRef
 */
export interface DeviceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeviceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeviceSpecProviderConfigRef#policy
   */
  readonly policy?: DeviceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DeviceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecProviderConfigRef(obj: DeviceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeviceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DeviceSpecProviderRef
 */
export interface DeviceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeviceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeviceSpecProviderRef#policy
   */
  readonly policy?: DeviceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DeviceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecProviderRef(obj: DeviceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeviceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DeviceSpecPublishConnectionDetailsTo
 */
export interface DeviceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DeviceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DeviceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DeviceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DeviceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DeviceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeviceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecPublishConnectionDetailsTo(obj: DeviceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DeviceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DeviceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DeviceSpecWriteConnectionSecretToRef
 */
export interface DeviceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DeviceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeviceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeviceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecWriteConnectionSecretToRef(obj: DeviceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeviceSpecForProviderCredentials
 */
export interface DeviceSpecForProviderCredentials {
  /**
   * The time at which this credential becomes invalid.
   *
   * @schema DeviceSpecForProviderCredentials#expirationTime
   */
  readonly expirationTime?: string;

  /**
   * A public key used to verify the signature of JSON Web Tokens (JWTs). Structure is documented below.
   *
   * @schema DeviceSpecForProviderCredentials#publicKey
   */
  readonly publicKey: DeviceSpecForProviderCredentialsPublicKey[];

}

/**
 * Converts an object of type 'DeviceSpecForProviderCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderCredentials(obj: DeviceSpecForProviderCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expirationTime': obj.expirationTime,
    'publicKey': obj.publicKey?.map(y => toJson_DeviceSpecForProviderCredentialsPublicKey(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeviceSpecForProviderGatewayConfig
 */
export interface DeviceSpecForProviderGatewayConfig {
  /**
   * Indicates whether the device is a gateway. Possible values are ASSOCIATION_ONLY, DEVICE_AUTH_TOKEN_ONLY, and ASSOCIATION_AND_DEVICE_AUTH_TOKEN.
   *
   * @schema DeviceSpecForProviderGatewayConfig#gatewayAuthMethod
   */
  readonly gatewayAuthMethod?: string;

  /**
   * Indicates whether the device is a gateway. Default value is NON_GATEWAY. Possible values are GATEWAY and NON_GATEWAY.
   *
   * @schema DeviceSpecForProviderGatewayConfig#gatewayType
   */
  readonly gatewayType?: string;

}

/**
 * Converts an object of type 'DeviceSpecForProviderGatewayConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderGatewayConfig(obj: DeviceSpecForProviderGatewayConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gatewayAuthMethod': obj.gatewayAuthMethod,
    'gatewayType': obj.gatewayType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Registry in cloudiot to populate registry.
 *
 * @schema DeviceSpecForProviderRegistryRef
 */
export interface DeviceSpecForProviderRegistryRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeviceSpecForProviderRegistryRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeviceSpecForProviderRegistryRef#policy
   */
  readonly policy?: DeviceSpecForProviderRegistryRefPolicy;

}

/**
 * Converts an object of type 'DeviceSpecForProviderRegistryRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderRegistryRef(obj: DeviceSpecForProviderRegistryRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeviceSpecForProviderRegistryRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Registry in cloudiot to populate registry.
 *
 * @schema DeviceSpecForProviderRegistrySelector
 */
export interface DeviceSpecForProviderRegistrySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeviceSpecForProviderRegistrySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeviceSpecForProviderRegistrySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeviceSpecForProviderRegistrySelector#policy
   */
  readonly policy?: DeviceSpecForProviderRegistrySelectorPolicy;

}

/**
 * Converts an object of type 'DeviceSpecForProviderRegistrySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderRegistrySelector(obj: DeviceSpecForProviderRegistrySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeviceSpecForProviderRegistrySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeviceSpecProviderConfigRefPolicy
 */
export interface DeviceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DeviceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DeviceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeviceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecProviderConfigRefPolicy(obj: DeviceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeviceSpecProviderRefPolicy
 */
export interface DeviceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DeviceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DeviceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DeviceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecProviderRefPolicy(obj: DeviceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DeviceSpecPublishConnectionDetailsToConfigRef
 */
export interface DeviceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeviceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeviceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DeviceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DeviceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecPublishConnectionDetailsToConfigRef(obj: DeviceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeviceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DeviceSpecPublishConnectionDetailsToMetadata
 */
export interface DeviceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeviceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeviceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DeviceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeviceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecPublishConnectionDetailsToMetadata(obj: DeviceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeviceSpecForProviderCredentialsPublicKey
 */
export interface DeviceSpecForProviderCredentialsPublicKey {
  /**
   * The format of the key. Possible values are RSA_PEM, RSA_X509_PEM, ES256_PEM, and ES256_X509_PEM.
   *
   * @schema DeviceSpecForProviderCredentialsPublicKey#format
   */
  readonly format: string;

  /**
   * The key data.
   *
   * @schema DeviceSpecForProviderCredentialsPublicKey#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DeviceSpecForProviderCredentialsPublicKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderCredentialsPublicKey(obj: DeviceSpecForProviderCredentialsPublicKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format,
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeviceSpecForProviderRegistryRefPolicy
 */
export interface DeviceSpecForProviderRegistryRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceSpecForProviderRegistryRefPolicy#resolution
   */
  readonly resolution?: DeviceSpecForProviderRegistryRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceSpecForProviderRegistryRefPolicy#resolve
   */
  readonly resolve?: DeviceSpecForProviderRegistryRefPolicyResolve;

}

/**
 * Converts an object of type 'DeviceSpecForProviderRegistryRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderRegistryRefPolicy(obj: DeviceSpecForProviderRegistryRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeviceSpecForProviderRegistrySelectorPolicy
 */
export interface DeviceSpecForProviderRegistrySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceSpecForProviderRegistrySelectorPolicy#resolution
   */
  readonly resolution?: DeviceSpecForProviderRegistrySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceSpecForProviderRegistrySelectorPolicy#resolve
   */
  readonly resolve?: DeviceSpecForProviderRegistrySelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeviceSpecForProviderRegistrySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderRegistrySelectorPolicy(obj: DeviceSpecForProviderRegistrySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceSpecProviderConfigRefPolicyResolution
 */
export enum DeviceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceSpecProviderConfigRefPolicyResolve
 */
export enum DeviceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceSpecProviderRefPolicyResolution
 */
export enum DeviceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceSpecProviderRefPolicyResolve
 */
export enum DeviceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeviceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DeviceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeviceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecPublishConnectionDetailsToConfigRefPolicy(obj: DeviceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceSpecForProviderRegistryRefPolicyResolution
 */
export enum DeviceSpecForProviderRegistryRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceSpecForProviderRegistryRefPolicyResolve
 */
export enum DeviceSpecForProviderRegistryRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceSpecForProviderRegistrySelectorPolicyResolution
 */
export enum DeviceSpecForProviderRegistrySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceSpecForProviderRegistrySelectorPolicyResolve
 */
export enum DeviceSpecForProviderRegistrySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Registry is the Schema for the Registrys API. A Google Cloud IoT Core device registry.
 *
 * @schema Registry
 */
export class Registry extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Registry"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudiot.gcp.upbound.io/v1beta1',
    kind: 'Registry',
  }

  /**
   * Renders a Kubernetes manifest for "Registry".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RegistryProps): any {
    return {
      ...Registry.GVK,
      ...toJson_RegistryProps(props),
    };
  }

  /**
   * Defines a "Registry" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RegistryProps) {
    super(scope, id, {
      ...Registry.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Registry.GVK,
      ...toJson_RegistryProps(resolved),
    };
  }
}

/**
 * Registry is the Schema for the Registrys API. A Google Cloud IoT Core device registry.
 *
 * @schema Registry
 */
export interface RegistryProps {
  /**
   * @schema Registry#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RegistrySpec defines the desired state of Registry
   *
   * @schema Registry#spec
   */
  readonly spec: RegistrySpec;

}

/**
 * Converts an object of type 'RegistryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryProps(obj: RegistryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RegistrySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RegistrySpec defines the desired state of Registry
 *
 * @schema RegistrySpec
 */
export interface RegistrySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema RegistrySpec#deletionPolicy
   */
  readonly deletionPolicy?: RegistrySpecDeletionPolicy;

  /**
   * @schema RegistrySpec#forProvider
   */
  readonly forProvider: RegistrySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RegistrySpec#providerConfigRef
   */
  readonly providerConfigRef?: RegistrySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RegistrySpec#providerRef
   */
  readonly providerRef?: RegistrySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RegistrySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RegistrySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RegistrySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RegistrySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RegistrySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpec(obj: RegistrySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RegistrySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_RegistrySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RegistrySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RegistrySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RegistrySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema RegistrySpecDeletionPolicy
 */
export enum RegistrySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RegistrySpecForProvider
 */
export interface RegistrySpecForProvider {
  /**
   * List of public key certificates to authenticate devices. The structure is documented below.
   *
   * @schema RegistrySpecForProvider#credentials
   */
  readonly credentials?: RegistrySpecForProviderCredentials[];

  /**
   * List of configurations for event notifications, such as PubSub topics to publish device events to. Structure is documented below.
   *
   * @schema RegistrySpecForProvider#eventNotificationConfigs
   */
  readonly eventNotificationConfigs?: RegistrySpecForProviderEventNotificationConfigs[];

  /**
   * Activate or deactivate HTTP. The structure is documented below.
   *
   * @schema RegistrySpecForProvider#httpConfig
   */
  readonly httpConfig?: { [key: string]: string };

  /**
   * The default logging verbosity for activity from devices in this registry. Specifies which events should be written to logs. For example, if the LogLevel is ERROR, only events that terminate in errors will be logged. LogLevel is inclusive; enabling INFO logging will also enable ERROR logging. Default value is NONE. Possible values are NONE, ERROR, INFO, and DEBUG.
   *
   * @schema RegistrySpecForProvider#logLevel
   */
  readonly logLevel?: string;

  /**
   * Activate or deactivate MQTT. The structure is documented below.
   *
   * @schema RegistrySpecForProvider#mqttConfig
   */
  readonly mqttConfig?: { [key: string]: string };

  /**
   * A unique name for the resource, required by device registry.
   *
   * @schema RegistrySpecForProvider#name
   */
  readonly name: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema RegistrySpecForProvider#project
   */
  readonly project?: string;

  /**
   * The region in which the created registry should reside. If it is not provided, the provider region is used.
   *
   * @schema RegistrySpecForProvider#region
   */
  readonly region?: string;

  /**
   * A PubSub topic to publish device state updates. The structure is documented below.
   *
   * @schema RegistrySpecForProvider#stateNotificationConfig
   */
  readonly stateNotificationConfig?: { [key: string]: string };

}

/**
 * Converts an object of type 'RegistrySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecForProvider(obj: RegistrySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': obj.credentials?.map(y => toJson_RegistrySpecForProviderCredentials(y)),
    'eventNotificationConfigs': obj.eventNotificationConfigs?.map(y => toJson_RegistrySpecForProviderEventNotificationConfigs(y)),
    'httpConfig': ((obj.httpConfig) === undefined) ? undefined : (Object.entries(obj.httpConfig).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'logLevel': obj.logLevel,
    'mqttConfig': ((obj.mqttConfig) === undefined) ? undefined : (Object.entries(obj.mqttConfig).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'project': obj.project,
    'region': obj.region,
    'stateNotificationConfig': ((obj.stateNotificationConfig) === undefined) ? undefined : (Object.entries(obj.stateNotificationConfig).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RegistrySpecProviderConfigRef
 */
export interface RegistrySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegistrySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegistrySpecProviderConfigRef#policy
   */
  readonly policy?: RegistrySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RegistrySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecProviderConfigRef(obj: RegistrySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegistrySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RegistrySpecProviderRef
 */
export interface RegistrySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegistrySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegistrySpecProviderRef#policy
   */
  readonly policy?: RegistrySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RegistrySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecProviderRef(obj: RegistrySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegistrySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RegistrySpecPublishConnectionDetailsTo
 */
export interface RegistrySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RegistrySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RegistrySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RegistrySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RegistrySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RegistrySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RegistrySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecPublishConnectionDetailsTo(obj: RegistrySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RegistrySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RegistrySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RegistrySpecWriteConnectionSecretToRef
 */
export interface RegistrySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RegistrySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RegistrySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RegistrySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecWriteConnectionSecretToRef(obj: RegistrySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RegistrySpecForProviderCredentials
 */
export interface RegistrySpecForProviderCredentials {
  /**
   * A public key certificate format and data.
   *
   * @schema RegistrySpecForProviderCredentials#publicKeyCertificate
   */
  readonly publicKeyCertificate: { [key: string]: string };

}

/**
 * Converts an object of type 'RegistrySpecForProviderCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecForProviderCredentials(obj: RegistrySpecForProviderCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publicKeyCertificate': ((obj.publicKeyCertificate) === undefined) ? undefined : (Object.entries(obj.publicKeyCertificate).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RegistrySpecForProviderEventNotificationConfigs
 */
export interface RegistrySpecForProviderEventNotificationConfigs {
  /**
   * PubSub topic name to publish device events.
   *
   * @schema RegistrySpecForProviderEventNotificationConfigs#pubsubTopicName
   */
  readonly pubsubTopicName?: string;

  /**
   * Reference to a Topic in pubsub to populate pubsubTopicName.
   *
   * @schema RegistrySpecForProviderEventNotificationConfigs#pubsubTopicNameRef
   */
  readonly pubsubTopicNameRef?: RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRef;

  /**
   * Selector for a Topic in pubsub to populate pubsubTopicName.
   *
   * @schema RegistrySpecForProviderEventNotificationConfigs#pubsubTopicNameSelector
   */
  readonly pubsubTopicNameSelector?: RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelector;

  /**
   * If the subfolder name matches this string exactly, this configuration will be used. The string must not include the leading '/' character. If empty, all strings are matched. Empty value can only be used for the last event_notification_configs item.
   *
   * @schema RegistrySpecForProviderEventNotificationConfigs#subfolderMatches
   */
  readonly subfolderMatches?: string;

}

/**
 * Converts an object of type 'RegistrySpecForProviderEventNotificationConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecForProviderEventNotificationConfigs(obj: RegistrySpecForProviderEventNotificationConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pubsubTopicName': obj.pubsubTopicName,
    'pubsubTopicNameRef': toJson_RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRef(obj.pubsubTopicNameRef),
    'pubsubTopicNameSelector': toJson_RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelector(obj.pubsubTopicNameSelector),
    'subfolderMatches': obj.subfolderMatches,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RegistrySpecProviderConfigRefPolicy
 */
export interface RegistrySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegistrySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RegistrySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegistrySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RegistrySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RegistrySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecProviderConfigRefPolicy(obj: RegistrySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RegistrySpecProviderRefPolicy
 */
export interface RegistrySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegistrySpecProviderRefPolicy#resolution
   */
  readonly resolution?: RegistrySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegistrySpecProviderRefPolicy#resolve
   */
  readonly resolve?: RegistrySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RegistrySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecProviderRefPolicy(obj: RegistrySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RegistrySpecPublishConnectionDetailsToConfigRef
 */
export interface RegistrySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegistrySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegistrySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RegistrySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RegistrySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecPublishConnectionDetailsToConfigRef(obj: RegistrySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegistrySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RegistrySpecPublishConnectionDetailsToMetadata
 */
export interface RegistrySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RegistrySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RegistrySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RegistrySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RegistrySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecPublishConnectionDetailsToMetadata(obj: RegistrySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in pubsub to populate pubsubTopicName.
 *
 * @schema RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRef
 */
export interface RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRef#policy
   */
  readonly policy?: RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRefPolicy;

}

/**
 * Converts an object of type 'RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRef(obj: RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in pubsub to populate pubsubTopicName.
 *
 * @schema RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelector
 */
export interface RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelector#policy
   */
  readonly policy?: RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelectorPolicy;

}

/**
 * Converts an object of type 'RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelector(obj: RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegistrySpecProviderConfigRefPolicyResolution
 */
export enum RegistrySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegistrySpecProviderConfigRefPolicyResolve
 */
export enum RegistrySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegistrySpecProviderRefPolicyResolution
 */
export enum RegistrySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegistrySpecProviderRefPolicyResolve
 */
export enum RegistrySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RegistrySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RegistrySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegistrySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegistrySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RegistrySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecPublishConnectionDetailsToConfigRefPolicy(obj: RegistrySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRefPolicy
 */
export interface RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRefPolicy#resolution
   */
  readonly resolution?: RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRefPolicy#resolve
   */
  readonly resolve?: RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRefPolicyResolve;

}

/**
 * Converts an object of type 'RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRefPolicy(obj: RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelectorPolicy
 */
export interface RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelectorPolicy#resolution
   */
  readonly resolution?: RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelectorPolicy#resolve
   */
  readonly resolve?: RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelectorPolicy(obj: RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRefPolicyResolution
 */
export enum RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRefPolicyResolve
 */
export enum RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelectorPolicyResolution
 */
export enum RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelectorPolicyResolve
 */
export enum RegistrySpecForProviderEventNotificationConfigsPubsubTopicNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

