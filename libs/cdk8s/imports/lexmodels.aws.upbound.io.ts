// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Bot is the Schema for the Bots API. Provides an Amazon Lex bot resource.
 *
 * @schema Bot
 */
export class Bot extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Bot"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lexmodels.aws.upbound.io/v1beta1',
    kind: 'Bot',
  }

  /**
   * Renders a Kubernetes manifest for "Bot".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BotProps): any {
    return {
      ...Bot.GVK,
      ...toJson_BotProps(props),
    };
  }

  /**
   * Defines a "Bot" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BotProps) {
    super(scope, id, {
      ...Bot.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Bot.GVK,
      ...toJson_BotProps(resolved),
    };
  }
}

/**
 * Bot is the Schema for the Bots API. Provides an Amazon Lex bot resource.
 *
 * @schema Bot
 */
export interface BotProps {
  /**
   * @schema Bot#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BotSpec defines the desired state of Bot
   *
   * @schema Bot#spec
   */
  readonly spec: BotSpec;

}

/**
 * Converts an object of type 'BotProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotProps(obj: BotProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BotSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BotSpec defines the desired state of Bot
 *
 * @schema BotSpec
 */
export interface BotSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BotSpec#deletionPolicy
   */
  readonly deletionPolicy?: BotSpecDeletionPolicy;

  /**
   * @schema BotSpec#forProvider
   */
  readonly forProvider: BotSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BotSpec#managementPolicy
   */
  readonly managementPolicy?: BotSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BotSpec#providerConfigRef
   */
  readonly providerConfigRef?: BotSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BotSpec#providerRef
   */
  readonly providerRef?: BotSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BotSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BotSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BotSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BotSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BotSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotSpec(obj: BotSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BotSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_BotSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BotSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BotSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BotSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BotSpecDeletionPolicy
 */
export enum BotSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BotSpecForProvider
 */
export interface BotSpecForProvider {
  /**
   * The message that Amazon Lex uses to abort a conversation. Attributes are documented under statement.
   *
   * @schema BotSpecForProvider#abortStatement
   */
  readonly abortStatement?: BotSpecForProviderAbortStatement[];

  /**
   * By specifying true, you confirm that your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. For more information see the Amazon Lex FAQ and the Amazon Lex PutBot API Docs.
   *
   * @schema BotSpecForProvider#childDirected
   */
  readonly childDirected?: boolean;

  /**
   * The message that Amazon Lex uses when it doesn't understand the user's request. Attributes are documented under prompt.
   *
   * @schema BotSpecForProvider#clarificationPrompt
   */
  readonly clarificationPrompt?: BotSpecForProviderClarificationPrompt[];

  /**
   * Determines if a new bot version is created when the initial resource is created and on each update. Defaults to false.
   *
   * @default false.
   * @schema BotSpecForProvider#createVersion
   */
  readonly createVersion?: boolean;

  /**
   * A description of the bot. Must be less than or equal to 200 characters in length.
   *
   * @schema BotSpecForProvider#description
   */
  readonly description?: string;

  /**
   * When set to true user utterances are sent to Amazon Comprehend for sentiment analysis. If you don't specify detectSentiment, the default is false.
   *
   * @schema BotSpecForProvider#detectSentiment
   */
  readonly detectSentiment?: boolean;

  /**
   * Set to true to enable access to natural language understanding improvements. When you set the enable_model_improvements parameter to true you can use the nlu_intent_confidence_threshold parameter to configure confidence scores. For more information, see Confidence Scores. You can only set the enable_model_improvements parameter in certain Regions. If you set the parameter to true, your bot has access to accuracy improvements. For more information see the Amazon Lex Bot PutBot API Docs.
   *
   * @schema BotSpecForProvider#enableModelImprovements
   */
  readonly enableModelImprovements?: boolean;

  /**
   * The maximum time in seconds that Amazon Lex retains the data gathered in a conversation. Default is 300. Must be a number between 60 and 86400 (inclusive).
   *
   * @default 300. Must be a number between 60 and 86400 (inclusive).
   * @schema BotSpecForProvider#idleSessionTtlInSeconds
   */
  readonly idleSessionTtlInSeconds?: number;

  /**
   * A set of Intent objects. Each intent represents a command that a user can express. Attributes are documented under intent. Can have up to 250 Intent objects.
   *
   * @schema BotSpecForProvider#intent
   */
  readonly intent?: BotSpecForProviderIntent[];

  /**
   * Specifies the target locale for the bot. Any intent used in the bot must be compatible with the locale of the bot. For available locales, see Amazon Lex Bot PutBot API Docs. Default is en-US.
   *
   * @default en-US.
   * @schema BotSpecForProvider#locale
   */
  readonly locale?: string;

  /**
   * Determines the threshold where Amazon Lex will insert the AMAZON.FallbackIntent, AMAZON.KendraSearchIntent, or both when returning alternative intents in a PostContent or PostText response. AMAZON.FallbackIntent and AMAZON.KendraSearchIntent are only inserted if they are configured for the bot. For more information see Amazon Lex Bot PutBot API Docs This value requires enable_model_improvements to be set to true and the default is 0. Must be a float between 0 and 1.
   *
   * @schema BotSpecForProvider#nluIntentConfidenceThreshold
   */
  readonly nluIntentConfidenceThreshold?: number;

  /**
   * If you set the process_behavior element to BUILD, Amazon Lex builds the bot so that it can be run. If you set the element to SAVE Amazon Lex saves the bot, but doesn't build it. Default is SAVE.
   *
   * @default SAVE.
   * @schema BotSpecForProvider#processBehavior
   */
  readonly processBehavior?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BotSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Polly voice ID that you want Amazon Lex to use for voice interactions with the user. The locale configured for the voice must match the locale of the bot. For more information, see Available Voices in the Amazon Polly Developer Guide.
   *
   * @schema BotSpecForProvider#voiceId
   */
  readonly voiceId?: string;

}

/**
 * Converts an object of type 'BotSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotSpecForProvider(obj: BotSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'abortStatement': obj.abortStatement?.map(y => toJson_BotSpecForProviderAbortStatement(y)),
    'childDirected': obj.childDirected,
    'clarificationPrompt': obj.clarificationPrompt?.map(y => toJson_BotSpecForProviderClarificationPrompt(y)),
    'createVersion': obj.createVersion,
    'description': obj.description,
    'detectSentiment': obj.detectSentiment,
    'enableModelImprovements': obj.enableModelImprovements,
    'idleSessionTtlInSeconds': obj.idleSessionTtlInSeconds,
    'intent': obj.intent?.map(y => toJson_BotSpecForProviderIntent(y)),
    'locale': obj.locale,
    'nluIntentConfidenceThreshold': obj.nluIntentConfidenceThreshold,
    'processBehavior': obj.processBehavior,
    'region': obj.region,
    'voiceId': obj.voiceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BotSpecManagementPolicy
 */
export enum BotSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BotSpecProviderConfigRef
 */
export interface BotSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BotSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BotSpecProviderConfigRef#policy
   */
  readonly policy?: BotSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BotSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotSpecProviderConfigRef(obj: BotSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BotSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BotSpecProviderRef
 */
export interface BotSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BotSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BotSpecProviderRef#policy
   */
  readonly policy?: BotSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BotSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotSpecProviderRef(obj: BotSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BotSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BotSpecPublishConnectionDetailsTo
 */
export interface BotSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BotSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BotSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BotSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BotSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BotSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BotSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotSpecPublishConnectionDetailsTo(obj: BotSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BotSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BotSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BotSpecWriteConnectionSecretToRef
 */
export interface BotSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BotSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BotSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BotSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotSpecWriteConnectionSecretToRef(obj: BotSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BotSpecForProviderAbortStatement
 */
export interface BotSpecForProviderAbortStatement {
  /**
   * A set of messages, each of which provides a message string and its type. You can specify the message string in plain text or in Speech Synthesis Markup Language (SSML). Attributes are documented under message.
   *
   * @schema BotSpecForProviderAbortStatement#message
   */
  readonly message: BotSpecForProviderAbortStatementMessage[];

  /**
   * The response card. Amazon Lex will substitute session attributes and slot values into the response card. For more information, see Example: Using a Response Card.
   *
   * @schema BotSpecForProviderAbortStatement#responseCard
   */
  readonly responseCard?: string;

}

/**
 * Converts an object of type 'BotSpecForProviderAbortStatement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotSpecForProviderAbortStatement(obj: BotSpecForProviderAbortStatement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'message': obj.message?.map(y => toJson_BotSpecForProviderAbortStatementMessage(y)),
    'responseCard': obj.responseCard,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BotSpecForProviderClarificationPrompt
 */
export interface BotSpecForProviderClarificationPrompt {
  /**
   * The number of times to prompt the user for information.
   *
   * @schema BotSpecForProviderClarificationPrompt#maxAttempts
   */
  readonly maxAttempts: number;

  /**
   * A set of messages, each of which provides a message string and its type. You can specify the message string in plain text or in Speech Synthesis Markup Language (SSML). Attributes are documented under message.
   *
   * @schema BotSpecForProviderClarificationPrompt#message
   */
  readonly message: BotSpecForProviderClarificationPromptMessage[];

  /**
   * The response card. Amazon Lex will substitute session attributes and slot values into the response card. For more information, see Example: Using a Response Card.
   *
   * @schema BotSpecForProviderClarificationPrompt#responseCard
   */
  readonly responseCard?: string;

}

/**
 * Converts an object of type 'BotSpecForProviderClarificationPrompt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotSpecForProviderClarificationPrompt(obj: BotSpecForProviderClarificationPrompt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxAttempts': obj.maxAttempts,
    'message': obj.message?.map(y => toJson_BotSpecForProviderClarificationPromptMessage(y)),
    'responseCard': obj.responseCard,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BotSpecForProviderIntent
 */
export interface BotSpecForProviderIntent {
  /**
   * The name of the intent. Must be less than or equal to 100 characters in length.
   *
   * @schema BotSpecForProviderIntent#intentName
   */
  readonly intentName: string;

  /**
   * The version of the intent. Must be less than or equal to 64 characters in length.
   *
   * @schema BotSpecForProviderIntent#intentVersion
   */
  readonly intentVersion: string;

}

/**
 * Converts an object of type 'BotSpecForProviderIntent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotSpecForProviderIntent(obj: BotSpecForProviderIntent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'intentName': obj.intentName,
    'intentVersion': obj.intentVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BotSpecProviderConfigRefPolicy
 */
export interface BotSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BotSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BotSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BotSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BotSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BotSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotSpecProviderConfigRefPolicy(obj: BotSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BotSpecProviderRefPolicy
 */
export interface BotSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BotSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BotSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BotSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BotSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BotSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotSpecProviderRefPolicy(obj: BotSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BotSpecPublishConnectionDetailsToConfigRef
 */
export interface BotSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BotSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BotSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BotSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BotSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotSpecPublishConnectionDetailsToConfigRef(obj: BotSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BotSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BotSpecPublishConnectionDetailsToMetadata
 */
export interface BotSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BotSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BotSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BotSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BotSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotSpecPublishConnectionDetailsToMetadata(obj: BotSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BotSpecForProviderAbortStatementMessage
 */
export interface BotSpecForProviderAbortStatementMessage {
  /**
   * The text of the message.
   *
   * @schema BotSpecForProviderAbortStatementMessage#content
   */
  readonly content: string;

  /**
   * The content type of the message string.
   *
   * @schema BotSpecForProviderAbortStatementMessage#contentType
   */
  readonly contentType: string;

  /**
   * Identifies the message group that the message belongs to. When a group is assigned to a message, Amazon Lex returns one message from each group in the response.
   *
   * @schema BotSpecForProviderAbortStatementMessage#groupNumber
   */
  readonly groupNumber?: number;

}

/**
 * Converts an object of type 'BotSpecForProviderAbortStatementMessage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotSpecForProviderAbortStatementMessage(obj: BotSpecForProviderAbortStatementMessage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'contentType': obj.contentType,
    'groupNumber': obj.groupNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BotSpecForProviderClarificationPromptMessage
 */
export interface BotSpecForProviderClarificationPromptMessage {
  /**
   * The text of the message.
   *
   * @schema BotSpecForProviderClarificationPromptMessage#content
   */
  readonly content: string;

  /**
   * The content type of the message string.
   *
   * @schema BotSpecForProviderClarificationPromptMessage#contentType
   */
  readonly contentType: string;

  /**
   * Identifies the message group that the message belongs to. When a group is assigned to a message, Amazon Lex returns one message from each group in the response.
   *
   * @schema BotSpecForProviderClarificationPromptMessage#groupNumber
   */
  readonly groupNumber?: number;

}

/**
 * Converts an object of type 'BotSpecForProviderClarificationPromptMessage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotSpecForProviderClarificationPromptMessage(obj: BotSpecForProviderClarificationPromptMessage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'contentType': obj.contentType,
    'groupNumber': obj.groupNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BotSpecProviderConfigRefPolicyResolution
 */
export enum BotSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BotSpecProviderConfigRefPolicyResolve
 */
export enum BotSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BotSpecProviderRefPolicyResolution
 */
export enum BotSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BotSpecProviderRefPolicyResolve
 */
export enum BotSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BotSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BotSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BotSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BotSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BotSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BotSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BotSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotSpecPublishConnectionDetailsToConfigRefPolicy(obj: BotSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BotSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BotSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BotSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BotSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BotAlias is the Schema for the BotAliass API. Provides an Amazon Lex Bot Alias resource.
 *
 * @schema BotAlias
 */
export class BotAlias extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BotAlias"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lexmodels.aws.upbound.io/v1beta1',
    kind: 'BotAlias',
  }

  /**
   * Renders a Kubernetes manifest for "BotAlias".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BotAliasProps): any {
    return {
      ...BotAlias.GVK,
      ...toJson_BotAliasProps(props),
    };
  }

  /**
   * Defines a "BotAlias" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BotAliasProps) {
    super(scope, id, {
      ...BotAlias.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BotAlias.GVK,
      ...toJson_BotAliasProps(resolved),
    };
  }
}

/**
 * BotAlias is the Schema for the BotAliass API. Provides an Amazon Lex Bot Alias resource.
 *
 * @schema BotAlias
 */
export interface BotAliasProps {
  /**
   * @schema BotAlias#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BotAliasSpec defines the desired state of BotAlias
   *
   * @schema BotAlias#spec
   */
  readonly spec: BotAliasSpec;

}

/**
 * Converts an object of type 'BotAliasProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAliasProps(obj: BotAliasProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BotAliasSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BotAliasSpec defines the desired state of BotAlias
 *
 * @schema BotAliasSpec
 */
export interface BotAliasSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BotAliasSpec#deletionPolicy
   */
  readonly deletionPolicy?: BotAliasSpecDeletionPolicy;

  /**
   * @schema BotAliasSpec#forProvider
   */
  readonly forProvider: BotAliasSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BotAliasSpec#managementPolicy
   */
  readonly managementPolicy?: BotAliasSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BotAliasSpec#providerConfigRef
   */
  readonly providerConfigRef?: BotAliasSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BotAliasSpec#providerRef
   */
  readonly providerRef?: BotAliasSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BotAliasSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BotAliasSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BotAliasSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BotAliasSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BotAliasSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAliasSpec(obj: BotAliasSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BotAliasSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_BotAliasSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BotAliasSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BotAliasSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BotAliasSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BotAliasSpecDeletionPolicy
 */
export enum BotAliasSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BotAliasSpecForProvider
 */
export interface BotAliasSpecForProvider {
  /**
   * The name of the bot.
   *
   * @schema BotAliasSpecForProvider#botName
   */
  readonly botName?: string;

  /**
   * The name of the bot.
   *
   * @schema BotAliasSpecForProvider#botVersion
   */
  readonly botVersion?: string;

  /**
   * The settings that determine how Amazon Lex uses conversation logs for the alias. Attributes are documented under conversation_logs.
   *
   * @schema BotAliasSpecForProvider#conversationLogs
   */
  readonly conversationLogs?: BotAliasSpecForProviderConversationLogs[];

  /**
   * A description of the alias. Must be less than or equal to 200 characters in length.
   *
   * @schema BotAliasSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BotAliasSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'BotAliasSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAliasSpecForProvider(obj: BotAliasSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'botName': obj.botName,
    'botVersion': obj.botVersion,
    'conversationLogs': obj.conversationLogs?.map(y => toJson_BotAliasSpecForProviderConversationLogs(y)),
    'description': obj.description,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BotAliasSpecManagementPolicy
 */
export enum BotAliasSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BotAliasSpecProviderConfigRef
 */
export interface BotAliasSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BotAliasSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BotAliasSpecProviderConfigRef#policy
   */
  readonly policy?: BotAliasSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BotAliasSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAliasSpecProviderConfigRef(obj: BotAliasSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BotAliasSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BotAliasSpecProviderRef
 */
export interface BotAliasSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BotAliasSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BotAliasSpecProviderRef#policy
   */
  readonly policy?: BotAliasSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BotAliasSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAliasSpecProviderRef(obj: BotAliasSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BotAliasSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BotAliasSpecPublishConnectionDetailsTo
 */
export interface BotAliasSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BotAliasSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BotAliasSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BotAliasSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BotAliasSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BotAliasSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BotAliasSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAliasSpecPublishConnectionDetailsTo(obj: BotAliasSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BotAliasSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BotAliasSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BotAliasSpecWriteConnectionSecretToRef
 */
export interface BotAliasSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BotAliasSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BotAliasSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BotAliasSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAliasSpecWriteConnectionSecretToRef(obj: BotAliasSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BotAliasSpecForProviderConversationLogs
 */
export interface BotAliasSpecForProviderConversationLogs {
  /**
   * The Amazon Resource Name (ARN) of the IAM role used to write your logs to CloudWatch Logs or an S3 bucket. Must be between 20 and 2048 characters in length.
   *
   * @schema BotAliasSpecForProviderConversationLogs#iamRoleArn
   */
  readonly iamRoleArn: string;

  /**
   * The settings for your conversation logs. You can log text, audio, or both. Attributes are documented under log_settings.
   *
   * @schema BotAliasSpecForProviderConversationLogs#logSettings
   */
  readonly logSettings?: BotAliasSpecForProviderConversationLogsLogSettings[];

}

/**
 * Converts an object of type 'BotAliasSpecForProviderConversationLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAliasSpecForProviderConversationLogs(obj: BotAliasSpecForProviderConversationLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iamRoleArn': obj.iamRoleArn,
    'logSettings': obj.logSettings?.map(y => toJson_BotAliasSpecForProviderConversationLogsLogSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BotAliasSpecProviderConfigRefPolicy
 */
export interface BotAliasSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BotAliasSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BotAliasSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BotAliasSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BotAliasSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BotAliasSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAliasSpecProviderConfigRefPolicy(obj: BotAliasSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BotAliasSpecProviderRefPolicy
 */
export interface BotAliasSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BotAliasSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BotAliasSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BotAliasSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BotAliasSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BotAliasSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAliasSpecProviderRefPolicy(obj: BotAliasSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BotAliasSpecPublishConnectionDetailsToConfigRef
 */
export interface BotAliasSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BotAliasSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BotAliasSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BotAliasSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BotAliasSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAliasSpecPublishConnectionDetailsToConfigRef(obj: BotAliasSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BotAliasSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BotAliasSpecPublishConnectionDetailsToMetadata
 */
export interface BotAliasSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BotAliasSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BotAliasSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BotAliasSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BotAliasSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAliasSpecPublishConnectionDetailsToMetadata(obj: BotAliasSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BotAliasSpecForProviderConversationLogsLogSettings
 */
export interface BotAliasSpecForProviderConversationLogsLogSettings {
  /**
   * The destination where logs are delivered. Options are CLOUDWATCH_LOGS or S3.
   *
   * @schema BotAliasSpecForProviderConversationLogsLogSettings#destination
   */
  readonly destination: string;

  /**
   * The Amazon Resource Name (ARN) of the key used to encrypt audio logs in an S3 bucket. This can only be specified when destination is set to S3. Must be between 20 and 2048 characters in length.
   *
   * @schema BotAliasSpecForProviderConversationLogsLogSettings#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * The type of logging that is enabled. Options are AUDIO or TEXT.
   *
   * @schema BotAliasSpecForProviderConversationLogsLogSettings#logType
   */
  readonly logType: string;

  /**
   * The Amazon Resource Name (ARN) of the CloudWatch Logs log group or S3 bucket where the logs are delivered. Must be less than or equal to 2048 characters in length.
   *
   * @schema BotAliasSpecForProviderConversationLogsLogSettings#resourceArn
   */
  readonly resourceArn: string;

}

/**
 * Converts an object of type 'BotAliasSpecForProviderConversationLogsLogSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAliasSpecForProviderConversationLogsLogSettings(obj: BotAliasSpecForProviderConversationLogsLogSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination,
    'kmsKeyArn': obj.kmsKeyArn,
    'logType': obj.logType,
    'resourceArn': obj.resourceArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BotAliasSpecProviderConfigRefPolicyResolution
 */
export enum BotAliasSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BotAliasSpecProviderConfigRefPolicyResolve
 */
export enum BotAliasSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BotAliasSpecProviderRefPolicyResolution
 */
export enum BotAliasSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BotAliasSpecProviderRefPolicyResolve
 */
export enum BotAliasSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BotAliasSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BotAliasSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BotAliasSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BotAliasSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BotAliasSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BotAliasSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BotAliasSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAliasSpecPublishConnectionDetailsToConfigRefPolicy(obj: BotAliasSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BotAliasSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BotAliasSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BotAliasSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BotAliasSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Intent is the Schema for the Intents API. Provides an Amazon Lex intent resource.
 *
 * @schema Intent
 */
export class Intent extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Intent"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lexmodels.aws.upbound.io/v1beta1',
    kind: 'Intent',
  }

  /**
   * Renders a Kubernetes manifest for "Intent".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IntentProps): any {
    return {
      ...Intent.GVK,
      ...toJson_IntentProps(props),
    };
  }

  /**
   * Defines a "Intent" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IntentProps) {
    super(scope, id, {
      ...Intent.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Intent.GVK,
      ...toJson_IntentProps(resolved),
    };
  }
}

/**
 * Intent is the Schema for the Intents API. Provides an Amazon Lex intent resource.
 *
 * @schema Intent
 */
export interface IntentProps {
  /**
   * @schema Intent#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IntentSpec defines the desired state of Intent
   *
   * @schema Intent#spec
   */
  readonly spec: IntentSpec;

}

/**
 * Converts an object of type 'IntentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentProps(obj: IntentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IntentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IntentSpec defines the desired state of Intent
 *
 * @schema IntentSpec
 */
export interface IntentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IntentSpec#deletionPolicy
   */
  readonly deletionPolicy?: IntentSpecDeletionPolicy;

  /**
   * @schema IntentSpec#forProvider
   */
  readonly forProvider: IntentSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IntentSpec#managementPolicy
   */
  readonly managementPolicy?: IntentSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IntentSpec#providerConfigRef
   */
  readonly providerConfigRef?: IntentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema IntentSpec#providerRef
   */
  readonly providerRef?: IntentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IntentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IntentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IntentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IntentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IntentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpec(obj: IntentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IntentSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_IntentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_IntentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_IntentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IntentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IntentSpecDeletionPolicy
 */
export enum IntentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema IntentSpecForProvider
 */
export interface IntentSpecForProvider {
  /**
   * The statement that you want Amazon Lex to convey to the user after the intent is successfully fulfilled by the Lambda function. This element is relevant only if you provide a Lambda function in the fulfillment_activity. If you return the intent to the client application, you can't specify this element. The follow_up_prompt and conclusion_statement are mutually exclusive. You can specify only one. Attributes are documented under statement.
   *
   * @schema IntentSpecForProvider#conclusionStatement
   */
  readonly conclusionStatement?: IntentSpecForProviderConclusionStatement[];

  /**
   * Prompts the user to confirm the intent. This question should have a yes or no answer. You you must provide both the rejection_statement and confirmation_prompt, or neither. Attributes are documented under prompt.
   *
   * @schema IntentSpecForProvider#confirmationPrompt
   */
  readonly confirmationPrompt?: IntentSpecForProviderConfirmationPrompt[];

  /**
   * Determines if a new slot type version is created when the initial resource is created and on each update. Defaults to false.
   *
   * @default false.
   * @schema IntentSpecForProvider#createVersion
   */
  readonly createVersion?: boolean;

  /**
   * A description of the intent. Must be less than or equal to 200 characters in length.
   *
   * @schema IntentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies a Lambda function to invoke for each user input. You can invoke this Lambda function to personalize user interaction. Attributes are documented under code_hook.
   *
   * @schema IntentSpecForProvider#dialogCodeHook
   */
  readonly dialogCodeHook?: IntentSpecForProviderDialogCodeHook[];

  /**
   * Amazon Lex uses this prompt to solicit additional activity after fulfilling an intent. For example, after the OrderPizza intent is fulfilled, you might prompt the user to order a drink. The follow_up_prompt field and the conclusion_statement field are mutually exclusive. You can specify only one. Attributes are documented under follow_up_prompt.
   *
   * @schema IntentSpecForProvider#followUpPrompt
   */
  readonly followUpPrompt?: IntentSpecForProviderFollowUpPrompt[];

  /**
   * Describes how the intent is fulfilled. For example, after a user provides all of the information for a pizza order, fulfillment_activity defines how the bot places an order with a local pizza store. Attributes are documented under fulfillment_activity.
   *
   * @schema IntentSpecForProvider#fulfillmentActivity
   */
  readonly fulfillmentActivity?: IntentSpecForProviderFulfillmentActivity[];

  /**
   * A unique identifier for the built-in intent to base this intent on. To find the signature for an intent, see Standard Built-in Intents in the Alexa Skills Kit.
   *
   * @schema IntentSpecForProvider#parentIntentSignature
   */
  readonly parentIntentSignature?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema IntentSpecForProvider#region
   */
  readonly region: string;

  /**
   * When the user answers "no" to the question defined in confirmation_prompt, Amazon Lex responds with this statement to acknowledge that the intent was canceled. You must provide both the rejection_statement and the confirmation_prompt, or neither. Attributes are documented under statement.
   *
   * @schema IntentSpecForProvider#rejectionStatement
   */
  readonly rejectionStatement?: IntentSpecForProviderRejectionStatement[];

  /**
   * An array of utterances (strings) that a user might say to signal the intent. For example, "I want {PizzaSize} pizza", "Order {Quantity} {PizzaSize} pizzas". In each utterance, a slot name is enclosed in curly braces. Must have between 1 and 10 items in the list, and each item must be less than or equal to 200 characters in length.
   *
   * @schema IntentSpecForProvider#sampleUtterances
   */
  readonly sampleUtterances?: string[];

  /**
   * An list of intent slots. At runtime, Amazon Lex elicits required slot values from the user using prompts defined in the slots. Attributes are documented under slot.
   *
   * @schema IntentSpecForProvider#slot
   */
  readonly slot?: IntentSpecForProviderSlot[];

}

/**
 * Converts an object of type 'IntentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProvider(obj: IntentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conclusionStatement': obj.conclusionStatement?.map(y => toJson_IntentSpecForProviderConclusionStatement(y)),
    'confirmationPrompt': obj.confirmationPrompt?.map(y => toJson_IntentSpecForProviderConfirmationPrompt(y)),
    'createVersion': obj.createVersion,
    'description': obj.description,
    'dialogCodeHook': obj.dialogCodeHook?.map(y => toJson_IntentSpecForProviderDialogCodeHook(y)),
    'followUpPrompt': obj.followUpPrompt?.map(y => toJson_IntentSpecForProviderFollowUpPrompt(y)),
    'fulfillmentActivity': obj.fulfillmentActivity?.map(y => toJson_IntentSpecForProviderFulfillmentActivity(y)),
    'parentIntentSignature': obj.parentIntentSignature,
    'region': obj.region,
    'rejectionStatement': obj.rejectionStatement?.map(y => toJson_IntentSpecForProviderRejectionStatement(y)),
    'sampleUtterances': obj.sampleUtterances?.map(y => y),
    'slot': obj.slot?.map(y => toJson_IntentSpecForProviderSlot(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IntentSpecManagementPolicy
 */
export enum IntentSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IntentSpecProviderConfigRef
 */
export interface IntentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntentSpecProviderConfigRef#policy
   */
  readonly policy?: IntentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IntentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecProviderConfigRef(obj: IntentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema IntentSpecProviderRef
 */
export interface IntentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntentSpecProviderRef#policy
   */
  readonly policy?: IntentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'IntentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecProviderRef(obj: IntentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IntentSpecPublishConnectionDetailsTo
 */
export interface IntentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IntentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IntentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IntentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IntentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IntentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IntentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecPublishConnectionDetailsTo(obj: IntentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IntentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IntentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IntentSpecWriteConnectionSecretToRef
 */
export interface IntentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IntentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IntentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IntentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecWriteConnectionSecretToRef(obj: IntentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderConclusionStatement
 */
export interface IntentSpecForProviderConclusionStatement {
  /**
   * A set of messages, each of which provides a message string and its type. You can specify the message string in plain text or in Speech Synthesis Markup Language (SSML). Attributes are documented under message. Must contain between 1 and 15 messages.
   *
   * @schema IntentSpecForProviderConclusionStatement#message
   */
  readonly message: IntentSpecForProviderConclusionStatementMessage[];

  /**
   * The response card. Amazon Lex will substitute session attributes and slot values into the response card. For more information, see Example: Using a Response Card. Must be less than or equal to 50000 characters in length.
   *
   * @schema IntentSpecForProviderConclusionStatement#responseCard
   */
  readonly responseCard?: string;

}

/**
 * Converts an object of type 'IntentSpecForProviderConclusionStatement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderConclusionStatement(obj: IntentSpecForProviderConclusionStatement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'message': obj.message?.map(y => toJson_IntentSpecForProviderConclusionStatementMessage(y)),
    'responseCard': obj.responseCard,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderConfirmationPrompt
 */
export interface IntentSpecForProviderConfirmationPrompt {
  /**
   * The number of times to prompt the user for information. Must be a number between 1 and 5 (inclusive).
   *
   * @schema IntentSpecForProviderConfirmationPrompt#maxAttempts
   */
  readonly maxAttempts: number;

  /**
   * A set of messages, each of which provides a message string and its type. You can specify the message string in plain text or in Speech Synthesis Markup Language (SSML). Attributes are documented under message. Must contain between 1 and 15 messages.
   *
   * @schema IntentSpecForProviderConfirmationPrompt#message
   */
  readonly message: IntentSpecForProviderConfirmationPromptMessage[];

  /**
   * The response card. Amazon Lex will substitute session attributes and slot values into the response card. For more information, see Example: Using a Response Card. Must be less than or equal to 50000 characters in length.
   *
   * @schema IntentSpecForProviderConfirmationPrompt#responseCard
   */
  readonly responseCard?: string;

}

/**
 * Converts an object of type 'IntentSpecForProviderConfirmationPrompt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderConfirmationPrompt(obj: IntentSpecForProviderConfirmationPrompt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxAttempts': obj.maxAttempts,
    'message': obj.message?.map(y => toJson_IntentSpecForProviderConfirmationPromptMessage(y)),
    'responseCard': obj.responseCard,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderDialogCodeHook
 */
export interface IntentSpecForProviderDialogCodeHook {
  /**
   * The version of the request-response that you want Amazon Lex to use to invoke your Lambda function. For more information, see Using Lambda Functions. Must be less than or equal to 5 characters in length.
   *
   * @schema IntentSpecForProviderDialogCodeHook#messageVersion
   */
  readonly messageVersion: string;

  /**
   * The Amazon Resource Name (ARN) of the Lambda function.
   *
   * @schema IntentSpecForProviderDialogCodeHook#uri
   */
  readonly uri: string;

}

/**
 * Converts an object of type 'IntentSpecForProviderDialogCodeHook' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderDialogCodeHook(obj: IntentSpecForProviderDialogCodeHook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'messageVersion': obj.messageVersion,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderFollowUpPrompt
 */
export interface IntentSpecForProviderFollowUpPrompt {
  /**
   * Prompts for information from the user. Attributes are documented under prompt.
   *
   * @schema IntentSpecForProviderFollowUpPrompt#prompt
   */
  readonly prompt: IntentSpecForProviderFollowUpPromptPrompt[];

  /**
   * If the user answers "no" to the question defined in the prompt field, Amazon Lex responds with this statement to acknowledge that the intent was canceled. Attributes are documented below under statement.
   *
   * @schema IntentSpecForProviderFollowUpPrompt#rejectionStatement
   */
  readonly rejectionStatement: IntentSpecForProviderFollowUpPromptRejectionStatement[];

}

/**
 * Converts an object of type 'IntentSpecForProviderFollowUpPrompt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderFollowUpPrompt(obj: IntentSpecForProviderFollowUpPrompt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prompt': obj.prompt?.map(y => toJson_IntentSpecForProviderFollowUpPromptPrompt(y)),
    'rejectionStatement': obj.rejectionStatement?.map(y => toJson_IntentSpecForProviderFollowUpPromptRejectionStatement(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderFulfillmentActivity
 */
export interface IntentSpecForProviderFulfillmentActivity {
  /**
   * A description of the Lambda function that is run to fulfill the intent. Required if type is CodeHook. Attributes are documented under code_hook.
   *
   * @schema IntentSpecForProviderFulfillmentActivity#codeHook
   */
  readonly codeHook?: IntentSpecForProviderFulfillmentActivityCodeHook[];

  /**
   * How the intent should be fulfilled, either by running a Lambda function or by returning the slot data to the client application. Type can be either ReturnIntent or CodeHook, as documented here.
   *
   * @schema IntentSpecForProviderFulfillmentActivity#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'IntentSpecForProviderFulfillmentActivity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderFulfillmentActivity(obj: IntentSpecForProviderFulfillmentActivity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codeHook': obj.codeHook?.map(y => toJson_IntentSpecForProviderFulfillmentActivityCodeHook(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderRejectionStatement
 */
export interface IntentSpecForProviderRejectionStatement {
  /**
   * A set of messages, each of which provides a message string and its type. You can specify the message string in plain text or in Speech Synthesis Markup Language (SSML). Attributes are documented under message. Must contain between 1 and 15 messages.
   *
   * @schema IntentSpecForProviderRejectionStatement#message
   */
  readonly message: IntentSpecForProviderRejectionStatementMessage[];

  /**
   * The response card. Amazon Lex will substitute session attributes and slot values into the response card. For more information, see Example: Using a Response Card. Must be less than or equal to 50000 characters in length.
   *
   * @schema IntentSpecForProviderRejectionStatement#responseCard
   */
  readonly responseCard?: string;

}

/**
 * Converts an object of type 'IntentSpecForProviderRejectionStatement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderRejectionStatement(obj: IntentSpecForProviderRejectionStatement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'message': obj.message?.map(y => toJson_IntentSpecForProviderRejectionStatementMessage(y)),
    'responseCard': obj.responseCard,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderSlot
 */
export interface IntentSpecForProviderSlot {
  /**
   * A description of the bot. Must be less than or equal to 200 characters in length.
   *
   * @schema IntentSpecForProviderSlot#description
   */
  readonly description?: string;

  /**
   * The name of the intent slot that you want to create. The name is case sensitive. Must be less than or equal to 100 characters in length.
   *
   * @schema IntentSpecForProviderSlot#name
   */
  readonly name: string;

  /**
   * Directs Lex the order in which to elicit this slot value from the user. For example, if the intent has two slots with priorities 1 and 2, AWS Lex first elicits a value for the slot with priority 1. If multiple slots share the same priority, the order in which Lex elicits values is arbitrary. Must be between 1 and 100.
   *
   * @schema IntentSpecForProviderSlot#priority
   */
  readonly priority?: number;

  /**
   * The response card. Amazon Lex will substitute session attributes and slot values into the response card. For more information, see Example: Using a Response Card. Must be less than or equal to 50000 characters in length.
   *
   * @schema IntentSpecForProviderSlot#responseCard
   */
  readonly responseCard?: string;

  /**
   * If you know a specific pattern with which users might respond to an Amazon Lex request for a slot value, you can provide those utterances to improve accuracy. This is optional. In most cases, Amazon Lex is capable of understanding user utterances. Must have between 1 and 10 items in the list, and each item must be less than or equal to 200 characters in length.
   *
   * @schema IntentSpecForProviderSlot#sampleUtterances
   */
  readonly sampleUtterances?: string[];

  /**
   * Specifies whether the slot is required or optional.
   *
   * @schema IntentSpecForProviderSlot#slotConstraint
   */
  readonly slotConstraint: string;

  /**
   * The type of the slot, either a custom slot type that you defined or one of the built-in slot types. Must be less than or equal to 100 characters in length.
   *
   * @schema IntentSpecForProviderSlot#slotType
   */
  readonly slotType: string;

  /**
   * The version of the slot type. Must be less than or equal to 64 characters in length.
   *
   * @schema IntentSpecForProviderSlot#slotTypeVersion
   */
  readonly slotTypeVersion?: string;

  /**
   * The prompt that Amazon Lex uses to elicit the slot value from the user. Attributes are documented under prompt.
   *
   * @schema IntentSpecForProviderSlot#valueElicitationPrompt
   */
  readonly valueElicitationPrompt?: IntentSpecForProviderSlotValueElicitationPrompt[];

}

/**
 * Converts an object of type 'IntentSpecForProviderSlot' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderSlot(obj: IntentSpecForProviderSlot | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'priority': obj.priority,
    'responseCard': obj.responseCard,
    'sampleUtterances': obj.sampleUtterances?.map(y => y),
    'slotConstraint': obj.slotConstraint,
    'slotType': obj.slotType,
    'slotTypeVersion': obj.slotTypeVersion,
    'valueElicitationPrompt': obj.valueElicitationPrompt?.map(y => toJson_IntentSpecForProviderSlotValueElicitationPrompt(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntentSpecProviderConfigRefPolicy
 */
export interface IntentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IntentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IntentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecProviderConfigRefPolicy(obj: IntentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntentSpecProviderRefPolicy
 */
export interface IntentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: IntentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: IntentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'IntentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecProviderRefPolicy(obj: IntentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IntentSpecPublishConnectionDetailsToConfigRef
 */
export interface IntentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IntentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IntentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecPublishConnectionDetailsToConfigRef(obj: IntentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IntentSpecPublishConnectionDetailsToMetadata
 */
export interface IntentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IntentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IntentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecPublishConnectionDetailsToMetadata(obj: IntentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderConclusionStatementMessage
 */
export interface IntentSpecForProviderConclusionStatementMessage {
  /**
   * The text of the message. Must be less than or equal to 1000 characters in length.
   *
   * @schema IntentSpecForProviderConclusionStatementMessage#content
   */
  readonly content: string;

  /**
   * The content type of the message string.
   *
   * @schema IntentSpecForProviderConclusionStatementMessage#contentType
   */
  readonly contentType: string;

  /**
   * Identifies the message group that the message belongs to. When a group is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
   *
   * @schema IntentSpecForProviderConclusionStatementMessage#groupNumber
   */
  readonly groupNumber?: number;

}

/**
 * Converts an object of type 'IntentSpecForProviderConclusionStatementMessage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderConclusionStatementMessage(obj: IntentSpecForProviderConclusionStatementMessage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'contentType': obj.contentType,
    'groupNumber': obj.groupNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderConfirmationPromptMessage
 */
export interface IntentSpecForProviderConfirmationPromptMessage {
  /**
   * The text of the message. Must be less than or equal to 1000 characters in length.
   *
   * @schema IntentSpecForProviderConfirmationPromptMessage#content
   */
  readonly content: string;

  /**
   * The content type of the message string.
   *
   * @schema IntentSpecForProviderConfirmationPromptMessage#contentType
   */
  readonly contentType: string;

  /**
   * Identifies the message group that the message belongs to. When a group is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
   *
   * @schema IntentSpecForProviderConfirmationPromptMessage#groupNumber
   */
  readonly groupNumber?: number;

}

/**
 * Converts an object of type 'IntentSpecForProviderConfirmationPromptMessage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderConfirmationPromptMessage(obj: IntentSpecForProviderConfirmationPromptMessage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'contentType': obj.contentType,
    'groupNumber': obj.groupNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderFollowUpPromptPrompt
 */
export interface IntentSpecForProviderFollowUpPromptPrompt {
  /**
   * The number of times to prompt the user for information. Must be a number between 1 and 5 (inclusive).
   *
   * @schema IntentSpecForProviderFollowUpPromptPrompt#maxAttempts
   */
  readonly maxAttempts: number;

  /**
   * A set of messages, each of which provides a message string and its type. You can specify the message string in plain text or in Speech Synthesis Markup Language (SSML). Attributes are documented under message. Must contain between 1 and 15 messages.
   *
   * @schema IntentSpecForProviderFollowUpPromptPrompt#message
   */
  readonly message: IntentSpecForProviderFollowUpPromptPromptMessage[];

  /**
   * The response card. Amazon Lex will substitute session attributes and slot values into the response card. For more information, see Example: Using a Response Card. Must be less than or equal to 50000 characters in length.
   *
   * @schema IntentSpecForProviderFollowUpPromptPrompt#responseCard
   */
  readonly responseCard?: string;

}

/**
 * Converts an object of type 'IntentSpecForProviderFollowUpPromptPrompt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderFollowUpPromptPrompt(obj: IntentSpecForProviderFollowUpPromptPrompt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxAttempts': obj.maxAttempts,
    'message': obj.message?.map(y => toJson_IntentSpecForProviderFollowUpPromptPromptMessage(y)),
    'responseCard': obj.responseCard,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderFollowUpPromptRejectionStatement
 */
export interface IntentSpecForProviderFollowUpPromptRejectionStatement {
  /**
   * A set of messages, each of which provides a message string and its type. You can specify the message string in plain text or in Speech Synthesis Markup Language (SSML). Attributes are documented under message. Must contain between 1 and 15 messages.
   *
   * @schema IntentSpecForProviderFollowUpPromptRejectionStatement#message
   */
  readonly message: IntentSpecForProviderFollowUpPromptRejectionStatementMessage[];

  /**
   * The response card. Amazon Lex will substitute session attributes and slot values into the response card. For more information, see Example: Using a Response Card. Must be less than or equal to 50000 characters in length.
   *
   * @schema IntentSpecForProviderFollowUpPromptRejectionStatement#responseCard
   */
  readonly responseCard?: string;

}

/**
 * Converts an object of type 'IntentSpecForProviderFollowUpPromptRejectionStatement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderFollowUpPromptRejectionStatement(obj: IntentSpecForProviderFollowUpPromptRejectionStatement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'message': obj.message?.map(y => toJson_IntentSpecForProviderFollowUpPromptRejectionStatementMessage(y)),
    'responseCard': obj.responseCard,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderFulfillmentActivityCodeHook
 */
export interface IntentSpecForProviderFulfillmentActivityCodeHook {
  /**
   * The version of the request-response that you want Amazon Lex to use to invoke your Lambda function. For more information, see Using Lambda Functions. Must be less than or equal to 5 characters in length.
   *
   * @schema IntentSpecForProviderFulfillmentActivityCodeHook#messageVersion
   */
  readonly messageVersion: string;

  /**
   * The Amazon Resource Name (ARN) of the Lambda function.
   *
   * @schema IntentSpecForProviderFulfillmentActivityCodeHook#uri
   */
  readonly uri: string;

}

/**
 * Converts an object of type 'IntentSpecForProviderFulfillmentActivityCodeHook' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderFulfillmentActivityCodeHook(obj: IntentSpecForProviderFulfillmentActivityCodeHook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'messageVersion': obj.messageVersion,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderRejectionStatementMessage
 */
export interface IntentSpecForProviderRejectionStatementMessage {
  /**
   * The text of the message. Must be less than or equal to 1000 characters in length.
   *
   * @schema IntentSpecForProviderRejectionStatementMessage#content
   */
  readonly content: string;

  /**
   * The content type of the message string.
   *
   * @schema IntentSpecForProviderRejectionStatementMessage#contentType
   */
  readonly contentType: string;

  /**
   * Identifies the message group that the message belongs to. When a group is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
   *
   * @schema IntentSpecForProviderRejectionStatementMessage#groupNumber
   */
  readonly groupNumber?: number;

}

/**
 * Converts an object of type 'IntentSpecForProviderRejectionStatementMessage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderRejectionStatementMessage(obj: IntentSpecForProviderRejectionStatementMessage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'contentType': obj.contentType,
    'groupNumber': obj.groupNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderSlotValueElicitationPrompt
 */
export interface IntentSpecForProviderSlotValueElicitationPrompt {
  /**
   * The number of times to prompt the user for information. Must be a number between 1 and 5 (inclusive).
   *
   * @schema IntentSpecForProviderSlotValueElicitationPrompt#maxAttempts
   */
  readonly maxAttempts: number;

  /**
   * A set of messages, each of which provides a message string and its type. You can specify the message string in plain text or in Speech Synthesis Markup Language (SSML). Attributes are documented under message. Must contain between 1 and 15 messages.
   *
   * @schema IntentSpecForProviderSlotValueElicitationPrompt#message
   */
  readonly message: IntentSpecForProviderSlotValueElicitationPromptMessage[];

  /**
   * The response card. Amazon Lex will substitute session attributes and slot values into the response card. For more information, see Example: Using a Response Card. Must be less than or equal to 50000 characters in length.
   *
   * @schema IntentSpecForProviderSlotValueElicitationPrompt#responseCard
   */
  readonly responseCard?: string;

}

/**
 * Converts an object of type 'IntentSpecForProviderSlotValueElicitationPrompt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderSlotValueElicitationPrompt(obj: IntentSpecForProviderSlotValueElicitationPrompt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxAttempts': obj.maxAttempts,
    'message': obj.message?.map(y => toJson_IntentSpecForProviderSlotValueElicitationPromptMessage(y)),
    'responseCard': obj.responseCard,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntentSpecProviderConfigRefPolicyResolution
 */
export enum IntentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntentSpecProviderConfigRefPolicyResolve
 */
export enum IntentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntentSpecProviderRefPolicyResolution
 */
export enum IntentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntentSpecProviderRefPolicyResolve
 */
export enum IntentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IntentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IntentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IntentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IntentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecPublishConnectionDetailsToConfigRefPolicy(obj: IntentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderFollowUpPromptPromptMessage
 */
export interface IntentSpecForProviderFollowUpPromptPromptMessage {
  /**
   * The text of the message. Must be less than or equal to 1000 characters in length.
   *
   * @schema IntentSpecForProviderFollowUpPromptPromptMessage#content
   */
  readonly content: string;

  /**
   * The content type of the message string.
   *
   * @schema IntentSpecForProviderFollowUpPromptPromptMessage#contentType
   */
  readonly contentType: string;

  /**
   * Identifies the message group that the message belongs to. When a group is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
   *
   * @schema IntentSpecForProviderFollowUpPromptPromptMessage#groupNumber
   */
  readonly groupNumber?: number;

}

/**
 * Converts an object of type 'IntentSpecForProviderFollowUpPromptPromptMessage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderFollowUpPromptPromptMessage(obj: IntentSpecForProviderFollowUpPromptPromptMessage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'contentType': obj.contentType,
    'groupNumber': obj.groupNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderFollowUpPromptRejectionStatementMessage
 */
export interface IntentSpecForProviderFollowUpPromptRejectionStatementMessage {
  /**
   * The text of the message. Must be less than or equal to 1000 characters in length.
   *
   * @schema IntentSpecForProviderFollowUpPromptRejectionStatementMessage#content
   */
  readonly content: string;

  /**
   * The content type of the message string.
   *
   * @schema IntentSpecForProviderFollowUpPromptRejectionStatementMessage#contentType
   */
  readonly contentType: string;

  /**
   * Identifies the message group that the message belongs to. When a group is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
   *
   * @schema IntentSpecForProviderFollowUpPromptRejectionStatementMessage#groupNumber
   */
  readonly groupNumber?: number;

}

/**
 * Converts an object of type 'IntentSpecForProviderFollowUpPromptRejectionStatementMessage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderFollowUpPromptRejectionStatementMessage(obj: IntentSpecForProviderFollowUpPromptRejectionStatementMessage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'contentType': obj.contentType,
    'groupNumber': obj.groupNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderSlotValueElicitationPromptMessage
 */
export interface IntentSpecForProviderSlotValueElicitationPromptMessage {
  /**
   * The text of the message. Must be less than or equal to 1000 characters in length.
   *
   * @schema IntentSpecForProviderSlotValueElicitationPromptMessage#content
   */
  readonly content: string;

  /**
   * The content type of the message string.
   *
   * @schema IntentSpecForProviderSlotValueElicitationPromptMessage#contentType
   */
  readonly contentType: string;

  /**
   * Identifies the message group that the message belongs to. When a group is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
   *
   * @schema IntentSpecForProviderSlotValueElicitationPromptMessage#groupNumber
   */
  readonly groupNumber?: number;

}

/**
 * Converts an object of type 'IntentSpecForProviderSlotValueElicitationPromptMessage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderSlotValueElicitationPromptMessage(obj: IntentSpecForProviderSlotValueElicitationPromptMessage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'contentType': obj.contentType,
    'groupNumber': obj.groupNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IntentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IntentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SlotType is the Schema for the SlotTypes API. Provides details about a specific Amazon Lex Slot Type
 *
 * @schema SlotType
 */
export class SlotType extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SlotType"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lexmodels.aws.upbound.io/v1beta1',
    kind: 'SlotType',
  }

  /**
   * Renders a Kubernetes manifest for "SlotType".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SlotTypeProps): any {
    return {
      ...SlotType.GVK,
      ...toJson_SlotTypeProps(props),
    };
  }

  /**
   * Defines a "SlotType" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SlotTypeProps) {
    super(scope, id, {
      ...SlotType.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SlotType.GVK,
      ...toJson_SlotTypeProps(resolved),
    };
  }
}

/**
 * SlotType is the Schema for the SlotTypes API. Provides details about a specific Amazon Lex Slot Type
 *
 * @schema SlotType
 */
export interface SlotTypeProps {
  /**
   * @schema SlotType#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SlotTypeSpec defines the desired state of SlotType
   *
   * @schema SlotType#spec
   */
  readonly spec: SlotTypeSpec;

}

/**
 * Converts an object of type 'SlotTypeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SlotTypeProps(obj: SlotTypeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SlotTypeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SlotTypeSpec defines the desired state of SlotType
 *
 * @schema SlotTypeSpec
 */
export interface SlotTypeSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SlotTypeSpec#deletionPolicy
   */
  readonly deletionPolicy?: SlotTypeSpecDeletionPolicy;

  /**
   * @schema SlotTypeSpec#forProvider
   */
  readonly forProvider: SlotTypeSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SlotTypeSpec#managementPolicy
   */
  readonly managementPolicy?: SlotTypeSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SlotTypeSpec#providerConfigRef
   */
  readonly providerConfigRef?: SlotTypeSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SlotTypeSpec#providerRef
   */
  readonly providerRef?: SlotTypeSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SlotTypeSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SlotTypeSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SlotTypeSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SlotTypeSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SlotTypeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SlotTypeSpec(obj: SlotTypeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SlotTypeSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_SlotTypeSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SlotTypeSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SlotTypeSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SlotTypeSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SlotTypeSpecDeletionPolicy
 */
export enum SlotTypeSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SlotTypeSpecForProvider
 */
export interface SlotTypeSpecForProvider {
  /**
   * Determines if a new slot type version is created when the initial resource is created and on each update. Defaults to false.
   *
   * @default false.
   * @schema SlotTypeSpecForProvider#createVersion
   */
  readonly createVersion?: boolean;

  /**
   * A description of the slot type. Must be less than or equal to 200 characters in length.
   *
   * @schema SlotTypeSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A list of EnumerationValue objects that defines the values that the slot type can take. Each value can have a list of synonyms, which are additional values that help train the machine learning model about the values that it resolves for a slot. Attributes are documented under enumeration_value.
   *
   * @schema SlotTypeSpecForProvider#enumerationValue
   */
  readonly enumerationValue?: SlotTypeSpecForProviderEnumerationValue[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SlotTypeSpecForProvider#region
   */
  readonly region: string;

  /**
   * Determines the slot resolution strategy that Amazon Lex uses to return slot type values. ORIGINAL_VALUE returns the value entered by the user if the user value is similar to the slot value. TOP_RESOLUTION returns the first value in the resolution list if there is a resolution list for the slot, otherwise null is returned. Defaults to ORIGINAL_VALUE.
   *
   * @default ORIGINAL_VALUE.
   * @schema SlotTypeSpecForProvider#valueSelectionStrategy
   */
  readonly valueSelectionStrategy?: string;

}

/**
 * Converts an object of type 'SlotTypeSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SlotTypeSpecForProvider(obj: SlotTypeSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'createVersion': obj.createVersion,
    'description': obj.description,
    'enumerationValue': obj.enumerationValue?.map(y => toJson_SlotTypeSpecForProviderEnumerationValue(y)),
    'region': obj.region,
    'valueSelectionStrategy': obj.valueSelectionStrategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SlotTypeSpecManagementPolicy
 */
export enum SlotTypeSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SlotTypeSpecProviderConfigRef
 */
export interface SlotTypeSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SlotTypeSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SlotTypeSpecProviderConfigRef#policy
   */
  readonly policy?: SlotTypeSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SlotTypeSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SlotTypeSpecProviderConfigRef(obj: SlotTypeSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SlotTypeSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SlotTypeSpecProviderRef
 */
export interface SlotTypeSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SlotTypeSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SlotTypeSpecProviderRef#policy
   */
  readonly policy?: SlotTypeSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SlotTypeSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SlotTypeSpecProviderRef(obj: SlotTypeSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SlotTypeSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SlotTypeSpecPublishConnectionDetailsTo
 */
export interface SlotTypeSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SlotTypeSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SlotTypeSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SlotTypeSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SlotTypeSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SlotTypeSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SlotTypeSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SlotTypeSpecPublishConnectionDetailsTo(obj: SlotTypeSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SlotTypeSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SlotTypeSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SlotTypeSpecWriteConnectionSecretToRef
 */
export interface SlotTypeSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SlotTypeSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SlotTypeSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SlotTypeSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SlotTypeSpecWriteConnectionSecretToRef(obj: SlotTypeSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SlotTypeSpecForProviderEnumerationValue
 */
export interface SlotTypeSpecForProviderEnumerationValue {
  /**
   * Additional values related to the slot type value. Each item must be less than or equal to 140 characters in length.
   *
   * @schema SlotTypeSpecForProviderEnumerationValue#synonyms
   */
  readonly synonyms?: string[];

  /**
   * The value of the slot type. Must be less than or equal to 140 characters in length.
   *
   * @schema SlotTypeSpecForProviderEnumerationValue#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'SlotTypeSpecForProviderEnumerationValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SlotTypeSpecForProviderEnumerationValue(obj: SlotTypeSpecForProviderEnumerationValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'synonyms': obj.synonyms?.map(y => y),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SlotTypeSpecProviderConfigRefPolicy
 */
export interface SlotTypeSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SlotTypeSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SlotTypeSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SlotTypeSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SlotTypeSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SlotTypeSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SlotTypeSpecProviderConfigRefPolicy(obj: SlotTypeSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SlotTypeSpecProviderRefPolicy
 */
export interface SlotTypeSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SlotTypeSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SlotTypeSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SlotTypeSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SlotTypeSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SlotTypeSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SlotTypeSpecProviderRefPolicy(obj: SlotTypeSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SlotTypeSpecPublishConnectionDetailsToConfigRef
 */
export interface SlotTypeSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SlotTypeSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SlotTypeSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SlotTypeSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SlotTypeSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SlotTypeSpecPublishConnectionDetailsToConfigRef(obj: SlotTypeSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SlotTypeSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SlotTypeSpecPublishConnectionDetailsToMetadata
 */
export interface SlotTypeSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SlotTypeSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SlotTypeSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SlotTypeSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SlotTypeSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SlotTypeSpecPublishConnectionDetailsToMetadata(obj: SlotTypeSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SlotTypeSpecProviderConfigRefPolicyResolution
 */
export enum SlotTypeSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SlotTypeSpecProviderConfigRefPolicyResolve
 */
export enum SlotTypeSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SlotTypeSpecProviderRefPolicyResolution
 */
export enum SlotTypeSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SlotTypeSpecProviderRefPolicyResolve
 */
export enum SlotTypeSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SlotTypeSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SlotTypeSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SlotTypeSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SlotTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SlotTypeSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SlotTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SlotTypeSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SlotTypeSpecPublishConnectionDetailsToConfigRefPolicy(obj: SlotTypeSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SlotTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SlotTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SlotTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SlotTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

