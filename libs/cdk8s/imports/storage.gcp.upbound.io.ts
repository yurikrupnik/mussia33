// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Bucket is the Schema for the Buckets API. Creates a new bucket in Google Cloud Storage.
 *
 * @schema Bucket
 */
export class Bucket extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Bucket"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'Bucket',
  }

  /**
   * Renders a Kubernetes manifest for "Bucket".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketProps): any {
    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(props),
    };
  }

  /**
   * Defines a "Bucket" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketProps) {
    super(scope, id, {
      ...Bucket.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(resolved),
    };
  }
}

/**
 * Bucket is the Schema for the Buckets API. Creates a new bucket in Google Cloud Storage.
 *
 * @schema Bucket
 */
export interface BucketProps {
  /**
   * @schema Bucket#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketSpec defines the desired state of Bucket
   *
   * @schema Bucket#spec
   */
  readonly spec: BucketSpec;

}

/**
 * Converts an object of type 'BucketProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketProps(obj: BucketProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketSpec defines the desired state of Bucket
 *
 * @schema BucketSpec
 */
export interface BucketSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketSpecDeletionPolicy;

  /**
   * @schema BucketSpec#forProvider
   */
  readonly forProvider: BucketSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketSpec#providerRef
   */
  readonly providerRef?: BucketSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpec(obj: BucketSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketSpecDeletionPolicy
 */
export enum BucketSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketSpecForProvider
 */
export interface BucketSpecForProvider {
  /**
   * The bucket's Autoclass configuration.  Structure is documented below.
   *
   * @schema BucketSpecForProvider#autoclass
   */
  readonly autoclass?: BucketSpecForProviderAutoclass[];

  /**
   * The bucket's Cross-Origin Resource Sharing (CORS) configuration. Multiple blocks of this type are permitted. Structure is documented below.
   *
   * @schema BucketSpecForProvider#cors
   */
  readonly cors?: BucketSpecForProviderCors[];

  /**
   * The bucket's custom location configuration, which specifies the individual regions that comprise a dual-region bucket. If the bucket is designated a single or multi-region, the parameters are empty. Structure is documented below.
   *
   * @schema BucketSpecForProvider#customPlacementConfig
   */
  readonly customPlacementConfig?: BucketSpecForProviderCustomPlacementConfig[];

  /**
   * Whether or not to automatically apply an eventBasedHold to new objects added to the bucket.
   *
   * @schema BucketSpecForProvider#defaultEventBasedHold
   */
  readonly defaultEventBasedHold?: boolean;

  /**
   * The bucket's encryption configuration. Structure is documented below.
   *
   * @schema BucketSpecForProvider#encryption
   */
  readonly encryption?: BucketSpecForProviderEncryption[];

  /**
   * When deleting a bucket, this boolean option will delete all contained objects.
   *
   * @schema BucketSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * A map of key/value label pairs to assign to the bucket.
   *
   * @schema BucketSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The bucket's Lifecycle Rules configuration. Multiple blocks of this type are permitted. Structure is documented below.
   *
   * @schema BucketSpecForProvider#lifecycleRule
   */
  readonly lifecycleRule?: BucketSpecForProviderLifecycleRule[];

  /**
   * The GCS location.
   *
   * @schema BucketSpecForProvider#location
   */
  readonly location: string;

  /**
   * The bucket's Access & Storage Logs configuration. Structure is documented below.
   *
   * @schema BucketSpecForProvider#logging
   */
  readonly logging?: BucketSpecForProviderLogging[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema BucketSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Prevents public access to a bucket. Acceptable values are "inherited" or "enforced". If "inherited", the bucket uses public access prevention. only if the bucket is subject to the public access prevention organization policy constraint. Defaults to "inherited".
   *
   * @default inherited".
   * @schema BucketSpecForProvider#publicAccessPrevention
   */
  readonly publicAccessPrevention?: string;

  /**
   * Enables Requester Pays on a storage bucket.
   *
   * @schema BucketSpecForProvider#requesterPays
   */
  readonly requesterPays?: boolean;

  /**
   * Configuration of the bucket's data retention policy for how long objects in the bucket should be retained. Structure is documented below.
   *
   * @schema BucketSpecForProvider#retentionPolicy
   */
  readonly retentionPolicy?: BucketSpecForProviderRetentionPolicy[];

  /**
   * The Storage Class of the new bucket. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE.
   *
   * @schema BucketSpecForProvider#storageClass
   */
  readonly storageClass?: string;

  /**
   * Enables Uniform bucket-level access access to a bucket.
   *
   * @schema BucketSpecForProvider#uniformBucketLevelAccess
   */
  readonly uniformBucketLevelAccess?: boolean;

  /**
   * The bucket's Versioning configuration.  Structure is documented below.
   *
   * @schema BucketSpecForProvider#versioning
   */
  readonly versioning?: BucketSpecForProviderVersioning[];

  /**
   * Configuration if the bucket acts as a website. Structure is documented below.
   *
   * @schema BucketSpecForProvider#website
   */
  readonly website?: BucketSpecForProviderWebsite[];

}

/**
 * Converts an object of type 'BucketSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProvider(obj: BucketSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoclass': obj.autoclass?.map(y => toJson_BucketSpecForProviderAutoclass(y)),
    'cors': obj.cors?.map(y => toJson_BucketSpecForProviderCors(y)),
    'customPlacementConfig': obj.customPlacementConfig?.map(y => toJson_BucketSpecForProviderCustomPlacementConfig(y)),
    'defaultEventBasedHold': obj.defaultEventBasedHold,
    'encryption': obj.encryption?.map(y => toJson_BucketSpecForProviderEncryption(y)),
    'forceDestroy': obj.forceDestroy,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'lifecycleRule': obj.lifecycleRule?.map(y => toJson_BucketSpecForProviderLifecycleRule(y)),
    'location': obj.location,
    'logging': obj.logging?.map(y => toJson_BucketSpecForProviderLogging(y)),
    'project': obj.project,
    'publicAccessPrevention': obj.publicAccessPrevention,
    'requesterPays': obj.requesterPays,
    'retentionPolicy': obj.retentionPolicy?.map(y => toJson_BucketSpecForProviderRetentionPolicy(y)),
    'storageClass': obj.storageClass,
    'uniformBucketLevelAccess': obj.uniformBucketLevelAccess,
    'versioning': obj.versioning?.map(y => toJson_BucketSpecForProviderVersioning(y)),
    'website': obj.website?.map(y => toJson_BucketSpecForProviderWebsite(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketSpecProviderConfigRef
 */
export interface BucketSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecProviderConfigRef#policy
   */
  readonly policy?: BucketSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecProviderConfigRef(obj: BucketSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketSpecProviderRef
 */
export interface BucketSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecProviderRef#policy
   */
  readonly policy?: BucketSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecProviderRef(obj: BucketSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketSpecPublishConnectionDetailsTo
 */
export interface BucketSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecPublishConnectionDetailsTo(obj: BucketSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketSpecWriteConnectionSecretToRef
 */
export interface BucketSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecWriteConnectionSecretToRef(obj: BucketSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderAutoclass
 */
export interface BucketSpecForProviderAutoclass {
  /**
   * While set to true, autoclass automatically transitions objects in your bucket to appropriate storage classes based on each object's access pattern.
   *
   * @schema BucketSpecForProviderAutoclass#enabled
   */
  readonly enabled: boolean;

}

/**
 * Converts an object of type 'BucketSpecForProviderAutoclass' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderAutoclass(obj: BucketSpecForProviderAutoclass | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderCors
 */
export interface BucketSpecForProviderCors {
  /**
   * The value, in seconds, to return in the Access-Control-Max-Age header used in preflight responses.
   *
   * @schema BucketSpecForProviderCors#maxAgeSeconds
   */
  readonly maxAgeSeconds?: number;

  /**
   * The list of HTTP methods on which to include CORS response headers, (GET, OPTIONS, POST, etc) Note: "*" is permitted in the list of methods, and means "any method".
   *
   * @schema BucketSpecForProviderCors#method
   */
  readonly method?: string[];

  /**
   * The list of Origins eligible to receive CORS response headers. Note: "*" is permitted in the list of origins, and means "any Origin".
   *
   * @schema BucketSpecForProviderCors#origin
   */
  readonly origin?: string[];

  /**
   * The list of HTTP headers other than the simple response headers to give permission for the user-agent to share across domains.
   *
   * @schema BucketSpecForProviderCors#responseHeader
   */
  readonly responseHeader?: string[];

}

/**
 * Converts an object of type 'BucketSpecForProviderCors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderCors(obj: BucketSpecForProviderCors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxAgeSeconds': obj.maxAgeSeconds,
    'method': obj.method?.map(y => y),
    'origin': obj.origin?.map(y => y),
    'responseHeader': obj.responseHeader?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderCustomPlacementConfig
 */
export interface BucketSpecForProviderCustomPlacementConfig {
  /**
   * The list of individual regions that comprise a dual-region bucket. See Cloud Storage bucket locations for a list of acceptable regions. Note: If any of the data_locations changes, it will recreate the bucket.
   *
   * @schema BucketSpecForProviderCustomPlacementConfig#dataLocations
   */
  readonly dataLocations: string[];

}

/**
 * Converts an object of type 'BucketSpecForProviderCustomPlacementConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderCustomPlacementConfig(obj: BucketSpecForProviderCustomPlacementConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataLocations': obj.dataLocations?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderEncryption
 */
export interface BucketSpecForProviderEncryption {
  /**
   * : The id of a Cloud KMS key that will be used to encrypt objects inserted into this bucket, if no encryption method is specified. You must pay attention to whether the crypto key is available in the location that this bucket is created in. See the docs for more details.
   *
   * @schema BucketSpecForProviderEncryption#defaultKmsKeyName
   */
  readonly defaultKmsKeyName: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderEncryption(obj: BucketSpecForProviderEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultKmsKeyName': obj.defaultKmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderLifecycleRule
 */
export interface BucketSpecForProviderLifecycleRule {
  /**
   * The Lifecycle Rule's action configuration. A single block of this type is supported. Structure is documented below.
   *
   * @schema BucketSpecForProviderLifecycleRule#action
   */
  readonly action: BucketSpecForProviderLifecycleRuleAction[];

  /**
   * The Lifecycle Rule's condition configuration. A single block of this type is supported. Structure is documented below.
   *
   * @schema BucketSpecForProviderLifecycleRule#condition
   */
  readonly condition: BucketSpecForProviderLifecycleRuleCondition[];

}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLifecycleRule(obj: BucketSpecForProviderLifecycleRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_BucketSpecForProviderLifecycleRuleAction(y)),
    'condition': obj.condition?.map(y => toJson_BucketSpecForProviderLifecycleRuleCondition(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderLogging
 */
export interface BucketSpecForProviderLogging {
  /**
   * The bucket that will receive log objects.
   *
   * @schema BucketSpecForProviderLogging#logBucket
   */
  readonly logBucket: string;

  /**
   * The object prefix for log objects. If it's not provided, by default GCS sets this to this bucket's name.
   *
   * @schema BucketSpecForProviderLogging#logObjectPrefix
   */
  readonly logObjectPrefix?: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLogging(obj: BucketSpecForProviderLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logBucket': obj.logBucket,
    'logObjectPrefix': obj.logObjectPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderRetentionPolicy
 */
export interface BucketSpecForProviderRetentionPolicy {
  /**
   * If set to true, the bucket will be locked and permanently restrict edits to the bucket's retention policy.  Caution: Locking a bucket is an irreversible action.
   *
   * @schema BucketSpecForProviderRetentionPolicy#isLocked
   */
  readonly isLocked?: boolean;

  /**
   * The period of time, in seconds, that objects in the bucket must be retained and cannot be deleted, overwritten, or archived. The value must be less than 2,147,483,647 seconds.
   *
   * @schema BucketSpecForProviderRetentionPolicy#retentionPeriod
   */
  readonly retentionPeriod: number;

}

/**
 * Converts an object of type 'BucketSpecForProviderRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderRetentionPolicy(obj: BucketSpecForProviderRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isLocked': obj.isLocked,
    'retentionPeriod': obj.retentionPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderVersioning
 */
export interface BucketSpecForProviderVersioning {
  /**
   * While set to true, versioning is fully enabled for this bucket.
   *
   * @schema BucketSpecForProviderVersioning#enabled
   */
  readonly enabled: boolean;

}

/**
 * Converts an object of type 'BucketSpecForProviderVersioning' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderVersioning(obj: BucketSpecForProviderVersioning | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderWebsite
 */
export interface BucketSpecForProviderWebsite {
  /**
   * Behaves as the bucket's directory index where missing objects are treated as potential directories.
   *
   * @schema BucketSpecForProviderWebsite#mainPageSuffix
   */
  readonly mainPageSuffix?: string;

  /**
   * The custom object to return when a requested resource is not found.
   *
   * @schema BucketSpecForProviderWebsite#notFoundPage
   */
  readonly notFoundPage?: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderWebsite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderWebsite(obj: BucketSpecForProviderWebsite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mainPageSuffix': obj.mainPageSuffix,
    'notFoundPage': obj.notFoundPage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketSpecProviderConfigRefPolicy
 */
export interface BucketSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecProviderConfigRefPolicy(obj: BucketSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketSpecProviderRefPolicy
 */
export interface BucketSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecProviderRefPolicy(obj: BucketSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecPublishConnectionDetailsToConfigRef(obj: BucketSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketSpecPublishConnectionDetailsToMetadata
 */
export interface BucketSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecPublishConnectionDetailsToMetadata(obj: BucketSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderLifecycleRuleAction
 */
export interface BucketSpecForProviderLifecycleRuleAction {
  /**
   * The Storage Class of the new bucket. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE.
   *
   * @schema BucketSpecForProviderLifecycleRuleAction#storageClass
   */
  readonly storageClass?: string;

  /**
   * The type of the action of this Lifecycle Rule. Supported values include: Delete, SetStorageClass and AbortIncompleteMultipartUpload.
   *
   * @schema BucketSpecForProviderLifecycleRuleAction#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleRuleAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLifecycleRuleAction(obj: BucketSpecForProviderLifecycleRuleAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'storageClass': obj.storageClass,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderLifecycleRuleCondition
 */
export interface BucketSpecForProviderLifecycleRuleCondition {
  /**
   * Minimum age of an object in days to satisfy this condition.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#age
   */
  readonly age?: number;

  /**
   * A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when an object is created before midnight of the specified date in UTC.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#createdBefore
   */
  readonly createdBefore?: string;

  /**
   * A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when the customTime metadata for the object is set to an earlier date than the date used in this lifecycle condition.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#customTimeBefore
   */
  readonly customTimeBefore?: string;

  /**
   * Days since the date set in the customTime metadata for the object. This condition is satisfied when the current date and time is at least the specified number of days after the customTime.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#daysSinceCustomTime
   */
  readonly daysSinceCustomTime?: number;

  /**
   * Relevant only for versioned objects. Number of days elapsed since the noncurrent timestamp of an object.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#daysSinceNoncurrentTime
   */
  readonly daysSinceNoncurrentTime?: number;

  /**
   * One or more matching name prefixes to satisfy this condition.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#matchesPrefix
   */
  readonly matchesPrefix?: string[];

  /**
   * Storage Class of objects to satisfy this condition. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE, DURABLE_REDUCED_AVAILABILITY.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#matchesStorageClass
   */
  readonly matchesStorageClass?: string[];

  /**
   * One or more matching name suffixes to satisfy this condition.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#matchesSuffix
   */
  readonly matchesSuffix?: string[];

  /**
   * Relevant only for versioned objects. The date in RFC 3339 (e.g. 2017-06-13) when the object became nonconcurrent.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#noncurrentTimeBefore
   */
  readonly noncurrentTimeBefore?: string;

  /**
   * Relevant only for versioned objects. The number of newer versions of an object to satisfy this condition.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#numNewerVersions
   */
  readonly numNewerVersions?: number;

  /**
   * Match to live and/or archived objects. Unversioned buckets have only live objects. Supported values include: "LIVE", "ARCHIVED", "ANY".
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#withState
   */
  readonly withState?: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleRuleCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLifecycleRuleCondition(obj: BucketSpecForProviderLifecycleRuleCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'age': obj.age,
    'createdBefore': obj.createdBefore,
    'customTimeBefore': obj.customTimeBefore,
    'daysSinceCustomTime': obj.daysSinceCustomTime,
    'daysSinceNoncurrentTime': obj.daysSinceNoncurrentTime,
    'matchesPrefix': obj.matchesPrefix?.map(y => y),
    'matchesStorageClass': obj.matchesStorageClass?.map(y => y),
    'matchesSuffix': obj.matchesSuffix?.map(y => y),
    'noncurrentTimeBefore': obj.noncurrentTimeBefore,
    'numNewerVersions': obj.numNewerVersions,
    'withState': obj.withState,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecProviderConfigRefPolicyResolution
 */
export enum BucketSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecProviderConfigRefPolicyResolve
 */
export enum BucketSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecProviderRefPolicyResolution
 */
export enum BucketSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecProviderRefPolicyResolve
 */
export enum BucketSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketAccessControl is the Schema for the BucketAccessControls API. Bucket ACLs can be managed authoritatively using the [
 *
 * @schema BucketAccessControl
 */
export class BucketAccessControl extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketAccessControl"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'BucketAccessControl',
  }

  /**
   * Renders a Kubernetes manifest for "BucketAccessControl".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketAccessControlProps): any {
    return {
      ...BucketAccessControl.GVK,
      ...toJson_BucketAccessControlProps(props),
    };
  }

  /**
   * Defines a "BucketAccessControl" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketAccessControlProps) {
    super(scope, id, {
      ...BucketAccessControl.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketAccessControl.GVK,
      ...toJson_BucketAccessControlProps(resolved),
    };
  }
}

/**
 * BucketAccessControl is the Schema for the BucketAccessControls API. Bucket ACLs can be managed authoritatively using the [
 *
 * @schema BucketAccessControl
 */
export interface BucketAccessControlProps {
  /**
   * @schema BucketAccessControl#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketAccessControlSpec defines the desired state of BucketAccessControl
   *
   * @schema BucketAccessControl#spec
   */
  readonly spec: BucketAccessControlSpec;

}

/**
 * Converts an object of type 'BucketAccessControlProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlProps(obj: BucketAccessControlProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketAccessControlSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketAccessControlSpec defines the desired state of BucketAccessControl
 *
 * @schema BucketAccessControlSpec
 */
export interface BucketAccessControlSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketAccessControlSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketAccessControlSpecDeletionPolicy;

  /**
   * @schema BucketAccessControlSpec#forProvider
   */
  readonly forProvider: BucketAccessControlSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketAccessControlSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketAccessControlSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketAccessControlSpec#providerRef
   */
  readonly providerRef?: BucketAccessControlSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketAccessControlSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketAccessControlSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketAccessControlSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketAccessControlSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketAccessControlSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpec(obj: BucketAccessControlSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketAccessControlSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketAccessControlSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketAccessControlSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketAccessControlSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketAccessControlSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketAccessControlSpecDeletionPolicy
 */
export enum BucketAccessControlSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketAccessControlSpecForProvider
 */
export interface BucketAccessControlSpecForProvider {
  /**
   * The name of the bucket.
   *
   * @schema BucketAccessControlSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema BucketAccessControlSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketAccessControlSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema BucketAccessControlSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketAccessControlSpecForProviderBucketSelector;

  /**
   * The entity holding the permission, in one of the following forms: user-userId user-email group-groupId group-email domain-domain project-team-projectId allUsers allAuthenticatedUsers Examples: The user liz@example.com would be user-liz@example.com. The group example@googlegroups.com would be group-example@googlegroups.com. To refer to all members of the Google Apps for Business domain example.com, the entity would be domain-example.com.
   *
   * @schema BucketAccessControlSpecForProvider#entity
   */
  readonly entity: string;

  /**
   * The access permission for the entity. Possible values are OWNER, READER, and WRITER.
   *
   * @schema BucketAccessControlSpecForProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'BucketAccessControlSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecForProvider(obj: BucketAccessControlSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketAccessControlSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketAccessControlSpecForProviderBucketSelector(obj.bucketSelector),
    'entity': obj.entity,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketAccessControlSpecProviderConfigRef
 */
export interface BucketAccessControlSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAccessControlSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAccessControlSpecProviderConfigRef#policy
   */
  readonly policy?: BucketAccessControlSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketAccessControlSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecProviderConfigRef(obj: BucketAccessControlSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAccessControlSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketAccessControlSpecProviderRef
 */
export interface BucketAccessControlSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAccessControlSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAccessControlSpecProviderRef#policy
   */
  readonly policy?: BucketAccessControlSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketAccessControlSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecProviderRef(obj: BucketAccessControlSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAccessControlSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketAccessControlSpecPublishConnectionDetailsTo
 */
export interface BucketAccessControlSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketAccessControlSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketAccessControlSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketAccessControlSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecPublishConnectionDetailsTo(obj: BucketAccessControlSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketAccessControlSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketAccessControlSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketAccessControlSpecWriteConnectionSecretToRef
 */
export interface BucketAccessControlSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketAccessControlSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketAccessControlSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketAccessControlSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecWriteConnectionSecretToRef(obj: BucketAccessControlSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema BucketAccessControlSpecForProviderBucketRef
 */
export interface BucketAccessControlSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAccessControlSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAccessControlSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketAccessControlSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketAccessControlSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecForProviderBucketRef(obj: BucketAccessControlSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAccessControlSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema BucketAccessControlSpecForProviderBucketSelector
 */
export interface BucketAccessControlSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketAccessControlSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketAccessControlSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketAccessControlSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketAccessControlSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketAccessControlSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecForProviderBucketSelector(obj: BucketAccessControlSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketAccessControlSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAccessControlSpecProviderConfigRefPolicy
 */
export interface BucketAccessControlSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAccessControlSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketAccessControlSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAccessControlSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketAccessControlSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAccessControlSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecProviderConfigRefPolicy(obj: BucketAccessControlSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAccessControlSpecProviderRefPolicy
 */
export interface BucketAccessControlSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAccessControlSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketAccessControlSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAccessControlSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketAccessControlSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAccessControlSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecProviderRefPolicy(obj: BucketAccessControlSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketAccessControlSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketAccessControlSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketAccessControlSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecPublishConnectionDetailsToConfigRef(obj: BucketAccessControlSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketAccessControlSpecPublishConnectionDetailsToMetadata
 */
export interface BucketAccessControlSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketAccessControlSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecPublishConnectionDetailsToMetadata(obj: BucketAccessControlSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAccessControlSpecForProviderBucketRefPolicy
 */
export interface BucketAccessControlSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAccessControlSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketAccessControlSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAccessControlSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketAccessControlSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAccessControlSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecForProviderBucketRefPolicy(obj: BucketAccessControlSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketAccessControlSpecForProviderBucketSelectorPolicy
 */
export interface BucketAccessControlSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAccessControlSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketAccessControlSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAccessControlSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketAccessControlSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketAccessControlSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecForProviderBucketSelectorPolicy(obj: BucketAccessControlSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAccessControlSpecProviderConfigRefPolicyResolution
 */
export enum BucketAccessControlSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAccessControlSpecProviderConfigRefPolicyResolve
 */
export enum BucketAccessControlSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAccessControlSpecProviderRefPolicyResolution
 */
export enum BucketAccessControlSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAccessControlSpecProviderRefPolicyResolve
 */
export enum BucketAccessControlSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAccessControlSpecForProviderBucketRefPolicyResolution
 */
export enum BucketAccessControlSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAccessControlSpecForProviderBucketRefPolicyResolve
 */
export enum BucketAccessControlSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAccessControlSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketAccessControlSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAccessControlSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketAccessControlSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketACL is the Schema for the BucketACLs API. Creates a new bucket ACL in Google Cloud Storage.
 *
 * @schema BucketACL
 */
export class BucketAcl extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketACL"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'BucketACL',
  }

  /**
   * Renders a Kubernetes manifest for "BucketACL".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketAclProps): any {
    return {
      ...BucketAcl.GVK,
      ...toJson_BucketAclProps(props),
    };
  }

  /**
   * Defines a "BucketACL" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketAclProps) {
    super(scope, id, {
      ...BucketAcl.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketAcl.GVK,
      ...toJson_BucketAclProps(resolved),
    };
  }
}

/**
 * BucketACL is the Schema for the BucketACLs API. Creates a new bucket ACL in Google Cloud Storage.
 *
 * @schema BucketACL
 */
export interface BucketAclProps {
  /**
   * @schema BucketACL#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketACLSpec defines the desired state of BucketACL
   *
   * @schema BucketACL#spec
   */
  readonly spec: BucketAclSpec;

}

/**
 * Converts an object of type 'BucketAclProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclProps(obj: BucketAclProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketAclSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketACLSpec defines the desired state of BucketACL
 *
 * @schema BucketAclSpec
 */
export interface BucketAclSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketAclSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketAclSpecDeletionPolicy;

  /**
   * @schema BucketAclSpec#forProvider
   */
  readonly forProvider: BucketAclSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketAclSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketAclSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketAclSpec#providerRef
   */
  readonly providerRef?: BucketAclSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketAclSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketAclSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketAclSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketAclSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketAclSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpec(obj: BucketAclSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketAclSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketAclSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketAclSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketAclSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketAclSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketAclSpecDeletionPolicy
 */
export enum BucketAclSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketAclSpecForProvider
 */
export interface BucketAclSpecForProvider {
  /**
   * The name of the bucket it applies to.
   *
   * @schema BucketAclSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema BucketAclSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketAclSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema BucketAclSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketAclSpecForProviderBucketSelector;

  /**
   * Configure this ACL to be the default ACL.
   *
   * @schema BucketAclSpecForProvider#defaultAcl
   */
  readonly defaultAcl?: string;

  /**
   * The canned GCS ACL to apply. Must be set if role_entity is not.
   *
   * @schema BucketAclSpecForProvider#predefinedAcl
   */
  readonly predefinedAcl?: string;

  /**
   * List of role/entity pairs in the form ROLE:entity. See GCS Bucket ACL documentation  for more details. Must be set if predefined_acl is not.
   *
   * @schema BucketAclSpecForProvider#roleEntity
   */
  readonly roleEntity?: string[];

}

/**
 * Converts an object of type 'BucketAclSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProvider(obj: BucketAclSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketAclSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketAclSpecForProviderBucketSelector(obj.bucketSelector),
    'defaultAcl': obj.defaultAcl,
    'predefinedAcl': obj.predefinedAcl,
    'roleEntity': obj.roleEntity?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketAclSpecProviderConfigRef
 */
export interface BucketAclSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAclSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAclSpecProviderConfigRef#policy
   */
  readonly policy?: BucketAclSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketAclSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecProviderConfigRef(obj: BucketAclSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAclSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketAclSpecProviderRef
 */
export interface BucketAclSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAclSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAclSpecProviderRef#policy
   */
  readonly policy?: BucketAclSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketAclSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecProviderRef(obj: BucketAclSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAclSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketAclSpecPublishConnectionDetailsTo
 */
export interface BucketAclSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketAclSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketAclSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketAclSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketAclSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketAclSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketAclSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecPublishConnectionDetailsTo(obj: BucketAclSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketAclSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketAclSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketAclSpecWriteConnectionSecretToRef
 */
export interface BucketAclSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketAclSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketAclSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketAclSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecWriteConnectionSecretToRef(obj: BucketAclSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema BucketAclSpecForProviderBucketRef
 */
export interface BucketAclSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAclSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAclSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketAclSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketAclSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProviderBucketRef(obj: BucketAclSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAclSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema BucketAclSpecForProviderBucketSelector
 */
export interface BucketAclSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketAclSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketAclSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketAclSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketAclSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketAclSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProviderBucketSelector(obj: BucketAclSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketAclSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAclSpecProviderConfigRefPolicy
 */
export interface BucketAclSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAclSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketAclSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAclSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketAclSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAclSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecProviderConfigRefPolicy(obj: BucketAclSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAclSpecProviderRefPolicy
 */
export interface BucketAclSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAclSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketAclSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAclSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketAclSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAclSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecProviderRefPolicy(obj: BucketAclSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketAclSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketAclSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketAclSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketAclSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecPublishConnectionDetailsToConfigRef(obj: BucketAclSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAclSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketAclSpecPublishConnectionDetailsToMetadata
 */
export interface BucketAclSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketAclSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecPublishConnectionDetailsToMetadata(obj: BucketAclSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAclSpecForProviderBucketRefPolicy
 */
export interface BucketAclSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAclSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketAclSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAclSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketAclSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAclSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProviderBucketRefPolicy(obj: BucketAclSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketAclSpecForProviderBucketSelectorPolicy
 */
export interface BucketAclSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAclSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketAclSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAclSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketAclSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketAclSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProviderBucketSelectorPolicy(obj: BucketAclSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAclSpecProviderConfigRefPolicyResolution
 */
export enum BucketAclSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAclSpecProviderConfigRefPolicyResolve
 */
export enum BucketAclSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAclSpecProviderRefPolicyResolution
 */
export enum BucketAclSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAclSpecProviderRefPolicyResolve
 */
export enum BucketAclSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketAclSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketAclSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAclSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketAclSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAclSpecForProviderBucketRefPolicyResolution
 */
export enum BucketAclSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAclSpecForProviderBucketRefPolicyResolve
 */
export enum BucketAclSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAclSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketAclSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAclSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketAclSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketIAMMember is the Schema for the BucketIAMMembers API. <no value>
 *
 * @schema BucketIAMMember
 */
export class BucketIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'BucketIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "BucketIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketIamMemberProps): any {
    return {
      ...BucketIamMember.GVK,
      ...toJson_BucketIamMemberProps(props),
    };
  }

  /**
   * Defines a "BucketIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketIamMemberProps) {
    super(scope, id, {
      ...BucketIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketIamMember.GVK,
      ...toJson_BucketIamMemberProps(resolved),
    };
  }
}

/**
 * BucketIAMMember is the Schema for the BucketIAMMembers API. <no value>
 *
 * @schema BucketIAMMember
 */
export interface BucketIamMemberProps {
  /**
   * @schema BucketIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketIAMMemberSpec defines the desired state of BucketIAMMember
   *
   * @schema BucketIAMMember#spec
   */
  readonly spec: BucketIamMemberSpec;

}

/**
 * Converts an object of type 'BucketIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberProps(obj: BucketIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketIAMMemberSpec defines the desired state of BucketIAMMember
 *
 * @schema BucketIamMemberSpec
 */
export interface BucketIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketIamMemberSpecDeletionPolicy;

  /**
   * @schema BucketIamMemberSpec#forProvider
   */
  readonly forProvider: BucketIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketIamMemberSpec#providerRef
   */
  readonly providerRef?: BucketIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpec(obj: BucketIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketIamMemberSpecDeletionPolicy
 */
export enum BucketIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketIamMemberSpecForProvider
 */
export interface BucketIamMemberSpecForProvider {
  /**
   * @schema BucketIamMemberSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket to populate bucket.
   *
   * @schema BucketIamMemberSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketIamMemberSpecForProviderBucketRef;

  /**
   * Selector for a Bucket to populate bucket.
   *
   * @schema BucketIamMemberSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketIamMemberSpecForProviderBucketSelector;

  /**
   * @schema BucketIamMemberSpecForProvider#condition
   */
  readonly condition?: BucketIamMemberSpecForProviderCondition[];

  /**
   * @schema BucketIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema BucketIamMemberSpecForProvider#role
   */
  readonly role: string;

}

/**
 * Converts an object of type 'BucketIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecForProvider(obj: BucketIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketIamMemberSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketIamMemberSpecForProviderBucketSelector(obj.bucketSelector),
    'condition': obj.condition?.map(y => toJson_BucketIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketIamMemberSpecProviderConfigRef
 */
export interface BucketIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: BucketIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecProviderConfigRef(obj: BucketIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketIamMemberSpecProviderRef
 */
export interface BucketIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketIamMemberSpecProviderRef#policy
   */
  readonly policy?: BucketIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecProviderRef(obj: BucketIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketIamMemberSpecPublishConnectionDetailsTo
 */
export interface BucketIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecPublishConnectionDetailsTo(obj: BucketIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketIamMemberSpecWriteConnectionSecretToRef
 */
export interface BucketIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecWriteConnectionSecretToRef(obj: BucketIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket to populate bucket.
 *
 * @schema BucketIamMemberSpecForProviderBucketRef
 */
export interface BucketIamMemberSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketIamMemberSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketIamMemberSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketIamMemberSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketIamMemberSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecForProviderBucketRef(obj: BucketIamMemberSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketIamMemberSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket to populate bucket.
 *
 * @schema BucketIamMemberSpecForProviderBucketSelector
 */
export interface BucketIamMemberSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketIamMemberSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketIamMemberSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketIamMemberSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketIamMemberSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketIamMemberSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecForProviderBucketSelector(obj: BucketIamMemberSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketIamMemberSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketIamMemberSpecForProviderCondition
 */
export interface BucketIamMemberSpecForProviderCondition {
  /**
   * @schema BucketIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema BucketIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema BucketIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'BucketIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecForProviderCondition(obj: BucketIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketIamMemberSpecProviderConfigRefPolicy
 */
export interface BucketIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecProviderConfigRefPolicy(obj: BucketIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketIamMemberSpecProviderRefPolicy
 */
export interface BucketIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecProviderRefPolicy(obj: BucketIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecPublishConnectionDetailsToConfigRef(obj: BucketIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface BucketIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecPublishConnectionDetailsToMetadata(obj: BucketIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketIamMemberSpecForProviderBucketRefPolicy
 */
export interface BucketIamMemberSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketIamMemberSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketIamMemberSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketIamMemberSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketIamMemberSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecForProviderBucketRefPolicy(obj: BucketIamMemberSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketIamMemberSpecForProviderBucketSelectorPolicy
 */
export interface BucketIamMemberSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketIamMemberSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketIamMemberSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketIamMemberSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketIamMemberSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecForProviderBucketSelectorPolicy(obj: BucketIamMemberSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum BucketIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum BucketIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberSpecProviderRefPolicyResolution
 */
export enum BucketIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketIamMemberSpecProviderRefPolicyResolve
 */
export enum BucketIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberSpecForProviderBucketRefPolicyResolution
 */
export enum BucketIamMemberSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketIamMemberSpecForProviderBucketRefPolicyResolve
 */
export enum BucketIamMemberSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketIamMemberSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketIamMemberSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketIamMemberSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketObject is the Schema for the BucketObjects API. Creates a new object inside a specified bucket
 *
 * @schema BucketObject
 */
export class BucketObject extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketObject"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'BucketObject',
  }

  /**
   * Renders a Kubernetes manifest for "BucketObject".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketObjectProps): any {
    return {
      ...BucketObject.GVK,
      ...toJson_BucketObjectProps(props),
    };
  }

  /**
   * Defines a "BucketObject" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketObjectProps) {
    super(scope, id, {
      ...BucketObject.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketObject.GVK,
      ...toJson_BucketObjectProps(resolved),
    };
  }
}

/**
 * BucketObject is the Schema for the BucketObjects API. Creates a new object inside a specified bucket
 *
 * @schema BucketObject
 */
export interface BucketObjectProps {
  /**
   * @schema BucketObject#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketObjectSpec defines the desired state of BucketObject
   *
   * @schema BucketObject#spec
   */
  readonly spec: BucketObjectSpec;

}

/**
 * Converts an object of type 'BucketObjectProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectProps(obj: BucketObjectProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketObjectSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketObjectSpec defines the desired state of BucketObject
 *
 * @schema BucketObjectSpec
 */
export interface BucketObjectSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketObjectSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketObjectSpecDeletionPolicy;

  /**
   * @schema BucketObjectSpec#forProvider
   */
  readonly forProvider: BucketObjectSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketObjectSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketObjectSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketObjectSpec#providerRef
   */
  readonly providerRef?: BucketObjectSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketObjectSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketObjectSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketObjectSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketObjectSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketObjectSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpec(obj: BucketObjectSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketObjectSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketObjectSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketObjectSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketObjectSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketObjectSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketObjectSpecDeletionPolicy
 */
export enum BucketObjectSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketObjectSpecForProvider
 */
export interface BucketObjectSpecForProvider {
  /**
   * The name of the containing bucket.
   *
   * @schema BucketObjectSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket to populate bucket.
   *
   * @schema BucketObjectSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketObjectSpecForProviderBucketRef;

  /**
   * Selector for a Bucket to populate bucket.
   *
   * @schema BucketObjectSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketObjectSpecForProviderBucketSelector;

  /**
   * Cache-Control directive to specify caching behavior of object data. If omitted and object is accessible to all anonymous users, the default will be public, max-age=3600
   *
   * @schema BucketObjectSpecForProvider#cacheControl
   */
  readonly cacheControl?: string;

  /**
   * Data as string to be uploaded. Must be defined if source is not. Note: The content field is marked as sensitive. To view the raw contents of the object, please define an output.
   *
   * @schema BucketObjectSpecForProvider#content
   */
  readonly content?: string;

  /**
   * Content-Disposition of the object data.
   *
   * @schema BucketObjectSpecForProvider#contentDisposition
   */
  readonly contentDisposition?: string;

  /**
   * Content-Encoding of the object data.
   *
   * @schema BucketObjectSpecForProvider#contentEncoding
   */
  readonly contentEncoding?: string;

  /**
   * Content-Language of the object data.
   *
   * @schema BucketObjectSpecForProvider#contentLanguage
   */
  readonly contentLanguage?: string;

  /**
   * Content-Type of the object data. Defaults to "application/octet-stream" or "text/plain; charset=utf-8".
   *
   * @default application/octet-stream" or "text/plain; charset=utf-8".
   * @schema BucketObjectSpecForProvider#contentType
   */
  readonly contentType?: string;

  /**
   * Enables object encryption with Customer-Supplied Encryption Key (CSEK). [Google documentation about CSEK.](https://cloud.google.com/storage/docs/encryption/customer-supplied-keys) Structure is documented below.
   *
   * @schema BucketObjectSpecForProvider#customerEncryption
   */
  readonly customerEncryption?: BucketObjectSpecForProviderCustomerEncryption[];

  /**
   * MD5 hash of the data, encoded using base64. This field is not present for composite objects. For more information about using the MD5 hash, see Hashes and ETags: Best Practices.
   *
   * @schema BucketObjectSpecForProvider#detectMd5Hash
   */
  readonly detectMd5Hash?: string;

  /**
   * Whether an object is under event-based hold. Event-based hold is a way to retain objects until an event occurs, which is signified by the hold's release (i.e. this value is set to false). After being released (set to false), such objects will be subject to bucket-level retention (if any).
   *
   * @schema BucketObjectSpecForProvider#eventBasedHold
   */
  readonly eventBasedHold?: boolean;

  /**
   * The resource name of the Cloud KMS key that will be used to encrypt the object.
   *
   * @schema BucketObjectSpecForProvider#kmsKeyName
   */
  readonly kmsKeyName?: string;

  /**
   * User-provided metadata, in key/value pairs.
   *
   * @schema BucketObjectSpecForProvider#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * The name of the object. If you're interpolating the name of this object, see output_name instead.
   *
   * @schema BucketObjectSpecForProvider#name
   */
  readonly name: string;

  /**
   * A path to the data you want to upload. Must be defined if content is not.
   *
   * @schema BucketObjectSpecForProvider#source
   */
  readonly source?: string;

  /**
   * The StorageClass of the new bucket object. Supported values include: MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE. If not provided, this defaults to the bucket's default storage class or to a standard class.
   *
   * @schema BucketObjectSpecForProvider#storageClass
   */
  readonly storageClass?: string;

  /**
   * Whether an object is under temporary hold. While this flag is set to true, the object is protected against deletion and overwrites.
   *
   * @schema BucketObjectSpecForProvider#temporaryHold
   */
  readonly temporaryHold?: boolean;

}

/**
 * Converts an object of type 'BucketObjectSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProvider(obj: BucketObjectSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketObjectSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketObjectSpecForProviderBucketSelector(obj.bucketSelector),
    'cacheControl': obj.cacheControl,
    'content': obj.content,
    'contentDisposition': obj.contentDisposition,
    'contentEncoding': obj.contentEncoding,
    'contentLanguage': obj.contentLanguage,
    'contentType': obj.contentType,
    'customerEncryption': obj.customerEncryption?.map(y => toJson_BucketObjectSpecForProviderCustomerEncryption(y)),
    'detectMd5Hash': obj.detectMd5Hash,
    'eventBasedHold': obj.eventBasedHold,
    'kmsKeyName': obj.kmsKeyName,
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'source': obj.source,
    'storageClass': obj.storageClass,
    'temporaryHold': obj.temporaryHold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketObjectSpecProviderConfigRef
 */
export interface BucketObjectSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketObjectSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketObjectSpecProviderConfigRef#policy
   */
  readonly policy?: BucketObjectSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketObjectSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecProviderConfigRef(obj: BucketObjectSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketObjectSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketObjectSpecProviderRef
 */
export interface BucketObjectSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketObjectSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketObjectSpecProviderRef#policy
   */
  readonly policy?: BucketObjectSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketObjectSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecProviderRef(obj: BucketObjectSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketObjectSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsTo
 */
export interface BucketObjectSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketObjectSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketObjectSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketObjectSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecPublishConnectionDetailsTo(obj: BucketObjectSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketObjectSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketObjectSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketObjectSpecWriteConnectionSecretToRef
 */
export interface BucketObjectSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketObjectSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketObjectSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketObjectSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecWriteConnectionSecretToRef(obj: BucketObjectSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket to populate bucket.
 *
 * @schema BucketObjectSpecForProviderBucketRef
 */
export interface BucketObjectSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketObjectSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketObjectSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketObjectSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderBucketRef(obj: BucketObjectSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketObjectSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket to populate bucket.
 *
 * @schema BucketObjectSpecForProviderBucketSelector
 */
export interface BucketObjectSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketObjectSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketObjectSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketObjectSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketObjectSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderBucketSelector(obj: BucketObjectSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketObjectSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketObjectSpecForProviderCustomerEncryption
 */
export interface BucketObjectSpecForProviderCustomerEncryption {
  /**
   * Encryption algorithm. Default: AES256
   *
   * @schema BucketObjectSpecForProviderCustomerEncryption#encryptionAlgorithm
   */
  readonly encryptionAlgorithm?: string;

  /**
   * Base64 encoded Customer-Supplied Encryption Key.
   *
   * @schema BucketObjectSpecForProviderCustomerEncryption#encryptionKeySecretRef
   */
  readonly encryptionKeySecretRef: BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderCustomerEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderCustomerEncryption(obj: BucketObjectSpecForProviderCustomerEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionAlgorithm': obj.encryptionAlgorithm,
    'encryptionKeySecretRef': toJson_BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef(obj.encryptionKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketObjectSpecProviderConfigRefPolicy
 */
export interface BucketObjectSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketObjectSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketObjectSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecProviderConfigRefPolicy(obj: BucketObjectSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketObjectSpecProviderRefPolicy
 */
export interface BucketObjectSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketObjectSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketObjectSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecProviderRefPolicy(obj: BucketObjectSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketObjectSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketObjectSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecPublishConnectionDetailsToConfigRef(obj: BucketObjectSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsToMetadata
 */
export interface BucketObjectSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketObjectSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecPublishConnectionDetailsToMetadata(obj: BucketObjectSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketObjectSpecForProviderBucketRefPolicy
 */
export interface BucketObjectSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketObjectSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketObjectSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderBucketRefPolicy(obj: BucketObjectSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketObjectSpecForProviderBucketSelectorPolicy
 */
export interface BucketObjectSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketObjectSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketObjectSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderBucketSelectorPolicy(obj: BucketObjectSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Base64 encoded Customer-Supplied Encryption Key.
 *
 * @schema BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef
 */
export interface BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef {
  /**
   * The key to select.
   *
   * @schema BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef(obj: BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectSpecProviderConfigRefPolicyResolution
 */
export enum BucketObjectSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectSpecProviderConfigRefPolicyResolve
 */
export enum BucketObjectSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectSpecProviderRefPolicyResolution
 */
export enum BucketObjectSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectSpecProviderRefPolicyResolve
 */
export enum BucketObjectSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectSpecForProviderBucketRefPolicyResolution
 */
export enum BucketObjectSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectSpecForProviderBucketRefPolicyResolve
 */
export enum BucketObjectSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketObjectSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketObjectSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DefaultObjectAccessControl is the Schema for the DefaultObjectAccessControls API. The DefaultObjectAccessControls resources represent the Access Control Lists (ACLs) applied to a new object within a Google Cloud Storage bucket when no ACL was provided for that object.
 *
 * @schema DefaultObjectAccessControl
 */
export class DefaultObjectAccessControl extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DefaultObjectAccessControl"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'DefaultObjectAccessControl',
  }

  /**
   * Renders a Kubernetes manifest for "DefaultObjectAccessControl".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DefaultObjectAccessControlProps): any {
    return {
      ...DefaultObjectAccessControl.GVK,
      ...toJson_DefaultObjectAccessControlProps(props),
    };
  }

  /**
   * Defines a "DefaultObjectAccessControl" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DefaultObjectAccessControlProps) {
    super(scope, id, {
      ...DefaultObjectAccessControl.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DefaultObjectAccessControl.GVK,
      ...toJson_DefaultObjectAccessControlProps(resolved),
    };
  }
}

/**
 * DefaultObjectAccessControl is the Schema for the DefaultObjectAccessControls API. The DefaultObjectAccessControls resources represent the Access Control Lists (ACLs) applied to a new object within a Google Cloud Storage bucket when no ACL was provided for that object.
 *
 * @schema DefaultObjectAccessControl
 */
export interface DefaultObjectAccessControlProps {
  /**
   * @schema DefaultObjectAccessControl#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DefaultObjectAccessControlSpec defines the desired state of DefaultObjectAccessControl
   *
   * @schema DefaultObjectAccessControl#spec
   */
  readonly spec: DefaultObjectAccessControlSpec;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlProps(obj: DefaultObjectAccessControlProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DefaultObjectAccessControlSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DefaultObjectAccessControlSpec defines the desired state of DefaultObjectAccessControl
 *
 * @schema DefaultObjectAccessControlSpec
 */
export interface DefaultObjectAccessControlSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DefaultObjectAccessControlSpec#deletionPolicy
   */
  readonly deletionPolicy?: DefaultObjectAccessControlSpecDeletionPolicy;

  /**
   * @schema DefaultObjectAccessControlSpec#forProvider
   */
  readonly forProvider: DefaultObjectAccessControlSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DefaultObjectAccessControlSpec#providerConfigRef
   */
  readonly providerConfigRef?: DefaultObjectAccessControlSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DefaultObjectAccessControlSpec#providerRef
   */
  readonly providerRef?: DefaultObjectAccessControlSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DefaultObjectAccessControlSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DefaultObjectAccessControlSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DefaultObjectAccessControlSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DefaultObjectAccessControlSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpec(obj: DefaultObjectAccessControlSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DefaultObjectAccessControlSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DefaultObjectAccessControlSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DefaultObjectAccessControlSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DefaultObjectAccessControlSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DefaultObjectAccessControlSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DefaultObjectAccessControlSpecDeletionPolicy
 */
export enum DefaultObjectAccessControlSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DefaultObjectAccessControlSpecForProvider
 */
export interface DefaultObjectAccessControlSpecForProvider {
  /**
   * The name of the bucket.
   *
   * @schema DefaultObjectAccessControlSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema DefaultObjectAccessControlSpecForProvider#bucketRef
   */
  readonly bucketRef?: DefaultObjectAccessControlSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema DefaultObjectAccessControlSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: DefaultObjectAccessControlSpecForProviderBucketSelector;

  /**
   * The entity holding the permission, in one of the following forms:
   *
   * @schema DefaultObjectAccessControlSpecForProvider#entity
   */
  readonly entity: string;

  /**
   * The name of the object, if applied to an object.
   *
   * @schema DefaultObjectAccessControlSpecForProvider#object
   */
  readonly object?: string;

  /**
   * The access permission for the entity. Possible values are OWNER and READER.
   *
   * @schema DefaultObjectAccessControlSpecForProvider#role
   */
  readonly role: string;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecForProvider(obj: DefaultObjectAccessControlSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_DefaultObjectAccessControlSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_DefaultObjectAccessControlSpecForProviderBucketSelector(obj.bucketSelector),
    'entity': obj.entity,
    'object': obj.object,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DefaultObjectAccessControlSpecProviderConfigRef
 */
export interface DefaultObjectAccessControlSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultObjectAccessControlSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultObjectAccessControlSpecProviderConfigRef#policy
   */
  readonly policy?: DefaultObjectAccessControlSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecProviderConfigRef(obj: DefaultObjectAccessControlSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultObjectAccessControlSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DefaultObjectAccessControlSpecProviderRef
 */
export interface DefaultObjectAccessControlSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultObjectAccessControlSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultObjectAccessControlSpecProviderRef#policy
   */
  readonly policy?: DefaultObjectAccessControlSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecProviderRef(obj: DefaultObjectAccessControlSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultObjectAccessControlSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsTo
 */
export interface DefaultObjectAccessControlSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecPublishConnectionDetailsTo(obj: DefaultObjectAccessControlSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DefaultObjectAccessControlSpecWriteConnectionSecretToRef
 */
export interface DefaultObjectAccessControlSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DefaultObjectAccessControlSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DefaultObjectAccessControlSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecWriteConnectionSecretToRef(obj: DefaultObjectAccessControlSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema DefaultObjectAccessControlSpecForProviderBucketRef
 */
export interface DefaultObjectAccessControlSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketRef#policy
   */
  readonly policy?: DefaultObjectAccessControlSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecForProviderBucketRef(obj: DefaultObjectAccessControlSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultObjectAccessControlSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema DefaultObjectAccessControlSpecForProviderBucketSelector
 */
export interface DefaultObjectAccessControlSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketSelector#policy
   */
  readonly policy?: DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecForProviderBucketSelector(obj: DefaultObjectAccessControlSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DefaultObjectAccessControlSpecProviderConfigRefPolicy
 */
export interface DefaultObjectAccessControlSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAccessControlSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DefaultObjectAccessControlSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAccessControlSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DefaultObjectAccessControlSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecProviderConfigRefPolicy(obj: DefaultObjectAccessControlSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DefaultObjectAccessControlSpecProviderRefPolicy
 */
export interface DefaultObjectAccessControlSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAccessControlSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DefaultObjectAccessControlSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAccessControlSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DefaultObjectAccessControlSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecProviderRefPolicy(obj: DefaultObjectAccessControlSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef
 */
export interface DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef(obj: DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata
 */
export interface DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata(obj: DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DefaultObjectAccessControlSpecForProviderBucketRefPolicy
 */
export interface DefaultObjectAccessControlSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: DefaultObjectAccessControlSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: DefaultObjectAccessControlSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecForProviderBucketRefPolicy(obj: DefaultObjectAccessControlSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy
 */
export interface DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: DefaultObjectAccessControlSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: DefaultObjectAccessControlSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy(obj: DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAccessControlSpecProviderConfigRefPolicyResolution
 */
export enum DefaultObjectAccessControlSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAccessControlSpecProviderConfigRefPolicyResolve
 */
export enum DefaultObjectAccessControlSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAccessControlSpecProviderRefPolicyResolution
 */
export enum DefaultObjectAccessControlSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAccessControlSpecProviderRefPolicyResolve
 */
export enum DefaultObjectAccessControlSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy(obj: DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAccessControlSpecForProviderBucketRefPolicyResolution
 */
export enum DefaultObjectAccessControlSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAccessControlSpecForProviderBucketRefPolicyResolve
 */
export enum DefaultObjectAccessControlSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAccessControlSpecForProviderBucketSelectorPolicyResolution
 */
export enum DefaultObjectAccessControlSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAccessControlSpecForProviderBucketSelectorPolicyResolve
 */
export enum DefaultObjectAccessControlSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DefaultObjectACL is the Schema for the DefaultObjectACLs API. Authoritatively manages the default object ACLs for a Google Cloud Storage bucket
 *
 * @schema DefaultObjectACL
 */
export class DefaultObjectAcl extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DefaultObjectACL"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'DefaultObjectACL',
  }

  /**
   * Renders a Kubernetes manifest for "DefaultObjectACL".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DefaultObjectAclProps): any {
    return {
      ...DefaultObjectAcl.GVK,
      ...toJson_DefaultObjectAclProps(props),
    };
  }

  /**
   * Defines a "DefaultObjectACL" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DefaultObjectAclProps) {
    super(scope, id, {
      ...DefaultObjectAcl.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DefaultObjectAcl.GVK,
      ...toJson_DefaultObjectAclProps(resolved),
    };
  }
}

/**
 * DefaultObjectACL is the Schema for the DefaultObjectACLs API. Authoritatively manages the default object ACLs for a Google Cloud Storage bucket
 *
 * @schema DefaultObjectACL
 */
export interface DefaultObjectAclProps {
  /**
   * @schema DefaultObjectACL#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DefaultObjectACLSpec defines the desired state of DefaultObjectACL
   *
   * @schema DefaultObjectACL#spec
   */
  readonly spec: DefaultObjectAclSpec;

}

/**
 * Converts an object of type 'DefaultObjectAclProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclProps(obj: DefaultObjectAclProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DefaultObjectAclSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DefaultObjectACLSpec defines the desired state of DefaultObjectACL
 *
 * @schema DefaultObjectAclSpec
 */
export interface DefaultObjectAclSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DefaultObjectAclSpec#deletionPolicy
   */
  readonly deletionPolicy?: DefaultObjectAclSpecDeletionPolicy;

  /**
   * @schema DefaultObjectAclSpec#forProvider
   */
  readonly forProvider: DefaultObjectAclSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DefaultObjectAclSpec#providerConfigRef
   */
  readonly providerConfigRef?: DefaultObjectAclSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DefaultObjectAclSpec#providerRef
   */
  readonly providerRef?: DefaultObjectAclSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DefaultObjectAclSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DefaultObjectAclSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DefaultObjectAclSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DefaultObjectAclSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DefaultObjectAclSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpec(obj: DefaultObjectAclSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DefaultObjectAclSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DefaultObjectAclSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DefaultObjectAclSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DefaultObjectAclSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DefaultObjectAclSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DefaultObjectAclSpecDeletionPolicy
 */
export enum DefaultObjectAclSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DefaultObjectAclSpecForProvider
 */
export interface DefaultObjectAclSpecForProvider {
  /**
   * The name of the bucket it applies to.
   *
   * @schema DefaultObjectAclSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema DefaultObjectAclSpecForProvider#bucketRef
   */
  readonly bucketRef?: DefaultObjectAclSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema DefaultObjectAclSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: DefaultObjectAclSpecForProviderBucketSelector;

  /**
   * List of role/entity pairs in the form ROLE:entity. See GCS Object ACL documentation for more details. Omitting the field is the same as providing an empty list.
   *
   * @schema DefaultObjectAclSpecForProvider#roleEntity
   */
  readonly roleEntity?: string[];

}

/**
 * Converts an object of type 'DefaultObjectAclSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecForProvider(obj: DefaultObjectAclSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_DefaultObjectAclSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_DefaultObjectAclSpecForProviderBucketSelector(obj.bucketSelector),
    'roleEntity': obj.roleEntity?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DefaultObjectAclSpecProviderConfigRef
 */
export interface DefaultObjectAclSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultObjectAclSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultObjectAclSpecProviderConfigRef#policy
   */
  readonly policy?: DefaultObjectAclSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecProviderConfigRef(obj: DefaultObjectAclSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultObjectAclSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DefaultObjectAclSpecProviderRef
 */
export interface DefaultObjectAclSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultObjectAclSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultObjectAclSpecProviderRef#policy
   */
  readonly policy?: DefaultObjectAclSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecProviderRef(obj: DefaultObjectAclSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultObjectAclSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DefaultObjectAclSpecPublishConnectionDetailsTo
 */
export interface DefaultObjectAclSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DefaultObjectAclSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DefaultObjectAclSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecPublishConnectionDetailsTo(obj: DefaultObjectAclSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DefaultObjectAclSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DefaultObjectAclSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DefaultObjectAclSpecWriteConnectionSecretToRef
 */
export interface DefaultObjectAclSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DefaultObjectAclSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DefaultObjectAclSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecWriteConnectionSecretToRef(obj: DefaultObjectAclSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema DefaultObjectAclSpecForProviderBucketRef
 */
export interface DefaultObjectAclSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultObjectAclSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultObjectAclSpecForProviderBucketRef#policy
   */
  readonly policy?: DefaultObjectAclSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecForProviderBucketRef(obj: DefaultObjectAclSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultObjectAclSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema DefaultObjectAclSpecForProviderBucketSelector
 */
export interface DefaultObjectAclSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DefaultObjectAclSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DefaultObjectAclSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DefaultObjectAclSpecForProviderBucketSelector#policy
   */
  readonly policy?: DefaultObjectAclSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecForProviderBucketSelector(obj: DefaultObjectAclSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DefaultObjectAclSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DefaultObjectAclSpecProviderConfigRefPolicy
 */
export interface DefaultObjectAclSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAclSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DefaultObjectAclSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAclSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DefaultObjectAclSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecProviderConfigRefPolicy(obj: DefaultObjectAclSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DefaultObjectAclSpecProviderRefPolicy
 */
export interface DefaultObjectAclSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAclSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DefaultObjectAclSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAclSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DefaultObjectAclSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecProviderRefPolicy(obj: DefaultObjectAclSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DefaultObjectAclSpecPublishConnectionDetailsToConfigRef
 */
export interface DefaultObjectAclSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecPublishConnectionDetailsToConfigRef(obj: DefaultObjectAclSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DefaultObjectAclSpecPublishConnectionDetailsToMetadata
 */
export interface DefaultObjectAclSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecPublishConnectionDetailsToMetadata(obj: DefaultObjectAclSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DefaultObjectAclSpecForProviderBucketRefPolicy
 */
export interface DefaultObjectAclSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAclSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: DefaultObjectAclSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAclSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: DefaultObjectAclSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecForProviderBucketRefPolicy(obj: DefaultObjectAclSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DefaultObjectAclSpecForProviderBucketSelectorPolicy
 */
export interface DefaultObjectAclSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAclSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: DefaultObjectAclSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAclSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: DefaultObjectAclSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecForProviderBucketSelectorPolicy(obj: DefaultObjectAclSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAclSpecProviderConfigRefPolicyResolution
 */
export enum DefaultObjectAclSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAclSpecProviderConfigRefPolicyResolve
 */
export enum DefaultObjectAclSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAclSpecProviderRefPolicyResolution
 */
export enum DefaultObjectAclSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAclSpecProviderRefPolicyResolve
 */
export enum DefaultObjectAclSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy(obj: DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAclSpecForProviderBucketRefPolicyResolution
 */
export enum DefaultObjectAclSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAclSpecForProviderBucketRefPolicyResolve
 */
export enum DefaultObjectAclSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAclSpecForProviderBucketSelectorPolicyResolution
 */
export enum DefaultObjectAclSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAclSpecForProviderBucketSelectorPolicyResolve
 */
export enum DefaultObjectAclSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ObjectAccessControl is the Schema for the ObjectAccessControls API. The ObjectAccessControls resources represent the Access Control Lists (ACLs) for objects within Google Cloud Storage.
 *
 * @schema ObjectAccessControl
 */
export class ObjectAccessControl extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ObjectAccessControl"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'ObjectAccessControl',
  }

  /**
   * Renders a Kubernetes manifest for "ObjectAccessControl".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ObjectAccessControlProps): any {
    return {
      ...ObjectAccessControl.GVK,
      ...toJson_ObjectAccessControlProps(props),
    };
  }

  /**
   * Defines a "ObjectAccessControl" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ObjectAccessControlProps) {
    super(scope, id, {
      ...ObjectAccessControl.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ObjectAccessControl.GVK,
      ...toJson_ObjectAccessControlProps(resolved),
    };
  }
}

/**
 * ObjectAccessControl is the Schema for the ObjectAccessControls API. The ObjectAccessControls resources represent the Access Control Lists (ACLs) for objects within Google Cloud Storage.
 *
 * @schema ObjectAccessControl
 */
export interface ObjectAccessControlProps {
  /**
   * @schema ObjectAccessControl#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ObjectAccessControlSpec defines the desired state of ObjectAccessControl
   *
   * @schema ObjectAccessControl#spec
   */
  readonly spec: ObjectAccessControlSpec;

}

/**
 * Converts an object of type 'ObjectAccessControlProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlProps(obj: ObjectAccessControlProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ObjectAccessControlSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectAccessControlSpec defines the desired state of ObjectAccessControl
 *
 * @schema ObjectAccessControlSpec
 */
export interface ObjectAccessControlSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ObjectAccessControlSpec#deletionPolicy
   */
  readonly deletionPolicy?: ObjectAccessControlSpecDeletionPolicy;

  /**
   * @schema ObjectAccessControlSpec#forProvider
   */
  readonly forProvider: ObjectAccessControlSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ObjectAccessControlSpec#providerConfigRef
   */
  readonly providerConfigRef?: ObjectAccessControlSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ObjectAccessControlSpec#providerRef
   */
  readonly providerRef?: ObjectAccessControlSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ObjectAccessControlSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ObjectAccessControlSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ObjectAccessControlSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ObjectAccessControlSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ObjectAccessControlSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpec(obj: ObjectAccessControlSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ObjectAccessControlSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ObjectAccessControlSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ObjectAccessControlSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ObjectAccessControlSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ObjectAccessControlSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ObjectAccessControlSpecDeletionPolicy
 */
export enum ObjectAccessControlSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ObjectAccessControlSpecForProvider
 */
export interface ObjectAccessControlSpecForProvider {
  /**
   * The name of the bucket.
   *
   * @schema ObjectAccessControlSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema ObjectAccessControlSpecForProvider#bucketRef
   */
  readonly bucketRef?: ObjectAccessControlSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema ObjectAccessControlSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: ObjectAccessControlSpecForProviderBucketSelector;

  /**
   * The entity holding the permission, in one of the following forms:
   *
   * @schema ObjectAccessControlSpecForProvider#entity
   */
  readonly entity: string;

  /**
   * The name of the object to apply the access control to.
   *
   * @schema ObjectAccessControlSpecForProvider#object
   */
  readonly object?: string;

  /**
   * Reference to a BucketObject in storage to populate object.
   *
   * @schema ObjectAccessControlSpecForProvider#objectRef
   */
  readonly objectRef?: ObjectAccessControlSpecForProviderObjectRef;

  /**
   * Selector for a BucketObject in storage to populate object.
   *
   * @schema ObjectAccessControlSpecForProvider#objectSelector
   */
  readonly objectSelector?: ObjectAccessControlSpecForProviderObjectSelector;

  /**
   * The access permission for the entity. Possible values are OWNER and READER.
   *
   * @schema ObjectAccessControlSpecForProvider#role
   */
  readonly role: string;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProvider(obj: ObjectAccessControlSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_ObjectAccessControlSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_ObjectAccessControlSpecForProviderBucketSelector(obj.bucketSelector),
    'entity': obj.entity,
    'object': obj.object,
    'objectRef': toJson_ObjectAccessControlSpecForProviderObjectRef(obj.objectRef),
    'objectSelector': toJson_ObjectAccessControlSpecForProviderObjectSelector(obj.objectSelector),
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ObjectAccessControlSpecProviderConfigRef
 */
export interface ObjectAccessControlSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAccessControlSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAccessControlSpecProviderConfigRef#policy
   */
  readonly policy?: ObjectAccessControlSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecProviderConfigRef(obj: ObjectAccessControlSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAccessControlSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ObjectAccessControlSpecProviderRef
 */
export interface ObjectAccessControlSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAccessControlSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAccessControlSpecProviderRef#policy
   */
  readonly policy?: ObjectAccessControlSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecProviderRef(obj: ObjectAccessControlSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAccessControlSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ObjectAccessControlSpecPublishConnectionDetailsTo
 */
export interface ObjectAccessControlSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ObjectAccessControlSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ObjectAccessControlSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecPublishConnectionDetailsTo(obj: ObjectAccessControlSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ObjectAccessControlSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ObjectAccessControlSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ObjectAccessControlSpecWriteConnectionSecretToRef
 */
export interface ObjectAccessControlSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ObjectAccessControlSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ObjectAccessControlSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecWriteConnectionSecretToRef(obj: ObjectAccessControlSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema ObjectAccessControlSpecForProviderBucketRef
 */
export interface ObjectAccessControlSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAccessControlSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAccessControlSpecForProviderBucketRef#policy
   */
  readonly policy?: ObjectAccessControlSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProviderBucketRef(obj: ObjectAccessControlSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAccessControlSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema ObjectAccessControlSpecForProviderBucketSelector
 */
export interface ObjectAccessControlSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ObjectAccessControlSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ObjectAccessControlSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ObjectAccessControlSpecForProviderBucketSelector#policy
   */
  readonly policy?: ObjectAccessControlSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProviderBucketSelector(obj: ObjectAccessControlSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ObjectAccessControlSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a BucketObject in storage to populate object.
 *
 * @schema ObjectAccessControlSpecForProviderObjectRef
 */
export interface ObjectAccessControlSpecForProviderObjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAccessControlSpecForProviderObjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAccessControlSpecForProviderObjectRef#policy
   */
  readonly policy?: ObjectAccessControlSpecForProviderObjectRefPolicy;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProviderObjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProviderObjectRef(obj: ObjectAccessControlSpecForProviderObjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAccessControlSpecForProviderObjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a BucketObject in storage to populate object.
 *
 * @schema ObjectAccessControlSpecForProviderObjectSelector
 */
export interface ObjectAccessControlSpecForProviderObjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ObjectAccessControlSpecForProviderObjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ObjectAccessControlSpecForProviderObjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ObjectAccessControlSpecForProviderObjectSelector#policy
   */
  readonly policy?: ObjectAccessControlSpecForProviderObjectSelectorPolicy;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProviderObjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProviderObjectSelector(obj: ObjectAccessControlSpecForProviderObjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ObjectAccessControlSpecForProviderObjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectAccessControlSpecProviderConfigRefPolicy
 */
export interface ObjectAccessControlSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAccessControlSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectAccessControlSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAccessControlSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectAccessControlSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecProviderConfigRefPolicy(obj: ObjectAccessControlSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectAccessControlSpecProviderRefPolicy
 */
export interface ObjectAccessControlSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAccessControlSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ObjectAccessControlSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAccessControlSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ObjectAccessControlSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecProviderRefPolicy(obj: ObjectAccessControlSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ObjectAccessControlSpecPublishConnectionDetailsToConfigRef
 */
export interface ObjectAccessControlSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecPublishConnectionDetailsToConfigRef(obj: ObjectAccessControlSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ObjectAccessControlSpecPublishConnectionDetailsToMetadata
 */
export interface ObjectAccessControlSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecPublishConnectionDetailsToMetadata(obj: ObjectAccessControlSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectAccessControlSpecForProviderBucketRefPolicy
 */
export interface ObjectAccessControlSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAccessControlSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: ObjectAccessControlSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAccessControlSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: ObjectAccessControlSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProviderBucketRefPolicy(obj: ObjectAccessControlSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ObjectAccessControlSpecForProviderBucketSelectorPolicy
 */
export interface ObjectAccessControlSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAccessControlSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: ObjectAccessControlSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAccessControlSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: ObjectAccessControlSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProviderBucketSelectorPolicy(obj: ObjectAccessControlSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectAccessControlSpecForProviderObjectRefPolicy
 */
export interface ObjectAccessControlSpecForProviderObjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAccessControlSpecForProviderObjectRefPolicy#resolution
   */
  readonly resolution?: ObjectAccessControlSpecForProviderObjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAccessControlSpecForProviderObjectRefPolicy#resolve
   */
  readonly resolve?: ObjectAccessControlSpecForProviderObjectRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProviderObjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProviderObjectRefPolicy(obj: ObjectAccessControlSpecForProviderObjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ObjectAccessControlSpecForProviderObjectSelectorPolicy
 */
export interface ObjectAccessControlSpecForProviderObjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAccessControlSpecForProviderObjectSelectorPolicy#resolution
   */
  readonly resolution?: ObjectAccessControlSpecForProviderObjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAccessControlSpecForProviderObjectSelectorPolicy#resolve
   */
  readonly resolve?: ObjectAccessControlSpecForProviderObjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProviderObjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProviderObjectSelectorPolicy(obj: ObjectAccessControlSpecForProviderObjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAccessControlSpecProviderConfigRefPolicyResolution
 */
export enum ObjectAccessControlSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAccessControlSpecProviderConfigRefPolicyResolve
 */
export enum ObjectAccessControlSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAccessControlSpecProviderRefPolicyResolution
 */
export enum ObjectAccessControlSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAccessControlSpecProviderRefPolicyResolve
 */
export enum ObjectAccessControlSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy(obj: ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAccessControlSpecForProviderBucketRefPolicyResolution
 */
export enum ObjectAccessControlSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAccessControlSpecForProviderBucketRefPolicyResolve
 */
export enum ObjectAccessControlSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAccessControlSpecForProviderBucketSelectorPolicyResolution
 */
export enum ObjectAccessControlSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAccessControlSpecForProviderBucketSelectorPolicyResolve
 */
export enum ObjectAccessControlSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAccessControlSpecForProviderObjectRefPolicyResolution
 */
export enum ObjectAccessControlSpecForProviderObjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAccessControlSpecForProviderObjectRefPolicyResolve
 */
export enum ObjectAccessControlSpecForProviderObjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAccessControlSpecForProviderObjectSelectorPolicyResolution
 */
export enum ObjectAccessControlSpecForProviderObjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAccessControlSpecForProviderObjectSelectorPolicyResolve
 */
export enum ObjectAccessControlSpecForProviderObjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ObjectACL is the Schema for the ObjectACLs API. Creates a new object ACL in Google Cloud Storage.
 *
 * @schema ObjectACL
 */
export class ObjectAcl extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ObjectACL"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'ObjectACL',
  }

  /**
   * Renders a Kubernetes manifest for "ObjectACL".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ObjectAclProps): any {
    return {
      ...ObjectAcl.GVK,
      ...toJson_ObjectAclProps(props),
    };
  }

  /**
   * Defines a "ObjectACL" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ObjectAclProps) {
    super(scope, id, {
      ...ObjectAcl.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ObjectAcl.GVK,
      ...toJson_ObjectAclProps(resolved),
    };
  }
}

/**
 * ObjectACL is the Schema for the ObjectACLs API. Creates a new object ACL in Google Cloud Storage.
 *
 * @schema ObjectACL
 */
export interface ObjectAclProps {
  /**
   * @schema ObjectACL#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ObjectACLSpec defines the desired state of ObjectACL
   *
   * @schema ObjectACL#spec
   */
  readonly spec: ObjectAclSpec;

}

/**
 * Converts an object of type 'ObjectAclProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclProps(obj: ObjectAclProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ObjectAclSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectACLSpec defines the desired state of ObjectACL
 *
 * @schema ObjectAclSpec
 */
export interface ObjectAclSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ObjectAclSpec#deletionPolicy
   */
  readonly deletionPolicy?: ObjectAclSpecDeletionPolicy;

  /**
   * @schema ObjectAclSpec#forProvider
   */
  readonly forProvider: ObjectAclSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ObjectAclSpec#providerConfigRef
   */
  readonly providerConfigRef?: ObjectAclSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ObjectAclSpec#providerRef
   */
  readonly providerRef?: ObjectAclSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ObjectAclSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ObjectAclSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ObjectAclSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ObjectAclSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ObjectAclSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpec(obj: ObjectAclSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ObjectAclSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ObjectAclSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ObjectAclSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ObjectAclSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ObjectAclSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ObjectAclSpecDeletionPolicy
 */
export enum ObjectAclSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ObjectAclSpecForProvider
 */
export interface ObjectAclSpecForProvider {
  /**
   * The name of the bucket the object is stored in.
   *
   * @schema ObjectAclSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema ObjectAclSpecForProvider#bucketRef
   */
  readonly bucketRef?: ObjectAclSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema ObjectAclSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: ObjectAclSpecForProviderBucketSelector;

  /**
   * The name of the object to apply the acl to.
   *
   * @schema ObjectAclSpecForProvider#object
   */
  readonly object?: string;

  /**
   * Reference to a BucketObject in storage to populate object.
   *
   * @schema ObjectAclSpecForProvider#objectRef
   */
  readonly objectRef?: ObjectAclSpecForProviderObjectRef;

  /**
   * Selector for a BucketObject in storage to populate object.
   *
   * @schema ObjectAclSpecForProvider#objectSelector
   */
  readonly objectSelector?: ObjectAclSpecForProviderObjectSelector;

  /**
   * The "canned" predefined ACL to apply. Must be set if role_entity is not.
   *
   * @schema ObjectAclSpecForProvider#predefinedAcl
   */
  readonly predefinedAcl?: string;

  /**
   * List of role/entity pairs in the form ROLE:entity. See GCS Object ACL documentation for more details. Must be set if predefined_acl is not.
   *
   * @schema ObjectAclSpecForProvider#roleEntity
   */
  readonly roleEntity?: string[];

}

/**
 * Converts an object of type 'ObjectAclSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProvider(obj: ObjectAclSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_ObjectAclSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_ObjectAclSpecForProviderBucketSelector(obj.bucketSelector),
    'object': obj.object,
    'objectRef': toJson_ObjectAclSpecForProviderObjectRef(obj.objectRef),
    'objectSelector': toJson_ObjectAclSpecForProviderObjectSelector(obj.objectSelector),
    'predefinedAcl': obj.predefinedAcl,
    'roleEntity': obj.roleEntity?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ObjectAclSpecProviderConfigRef
 */
export interface ObjectAclSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAclSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAclSpecProviderConfigRef#policy
   */
  readonly policy?: ObjectAclSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ObjectAclSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecProviderConfigRef(obj: ObjectAclSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAclSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ObjectAclSpecProviderRef
 */
export interface ObjectAclSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAclSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAclSpecProviderRef#policy
   */
  readonly policy?: ObjectAclSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ObjectAclSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecProviderRef(obj: ObjectAclSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAclSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ObjectAclSpecPublishConnectionDetailsTo
 */
export interface ObjectAclSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ObjectAclSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ObjectAclSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ObjectAclSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecPublishConnectionDetailsTo(obj: ObjectAclSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ObjectAclSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ObjectAclSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ObjectAclSpecWriteConnectionSecretToRef
 */
export interface ObjectAclSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ObjectAclSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ObjectAclSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ObjectAclSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecWriteConnectionSecretToRef(obj: ObjectAclSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema ObjectAclSpecForProviderBucketRef
 */
export interface ObjectAclSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAclSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAclSpecForProviderBucketRef#policy
   */
  readonly policy?: ObjectAclSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'ObjectAclSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProviderBucketRef(obj: ObjectAclSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAclSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema ObjectAclSpecForProviderBucketSelector
 */
export interface ObjectAclSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ObjectAclSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ObjectAclSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ObjectAclSpecForProviderBucketSelector#policy
   */
  readonly policy?: ObjectAclSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'ObjectAclSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProviderBucketSelector(obj: ObjectAclSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ObjectAclSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a BucketObject in storage to populate object.
 *
 * @schema ObjectAclSpecForProviderObjectRef
 */
export interface ObjectAclSpecForProviderObjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAclSpecForProviderObjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAclSpecForProviderObjectRef#policy
   */
  readonly policy?: ObjectAclSpecForProviderObjectRefPolicy;

}

/**
 * Converts an object of type 'ObjectAclSpecForProviderObjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProviderObjectRef(obj: ObjectAclSpecForProviderObjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAclSpecForProviderObjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a BucketObject in storage to populate object.
 *
 * @schema ObjectAclSpecForProviderObjectSelector
 */
export interface ObjectAclSpecForProviderObjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ObjectAclSpecForProviderObjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ObjectAclSpecForProviderObjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ObjectAclSpecForProviderObjectSelector#policy
   */
  readonly policy?: ObjectAclSpecForProviderObjectSelectorPolicy;

}

/**
 * Converts an object of type 'ObjectAclSpecForProviderObjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProviderObjectSelector(obj: ObjectAclSpecForProviderObjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ObjectAclSpecForProviderObjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectAclSpecProviderConfigRefPolicy
 */
export interface ObjectAclSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAclSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectAclSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAclSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectAclSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAclSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecProviderConfigRefPolicy(obj: ObjectAclSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectAclSpecProviderRefPolicy
 */
export interface ObjectAclSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAclSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ObjectAclSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAclSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ObjectAclSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAclSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecProviderRefPolicy(obj: ObjectAclSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ObjectAclSpecPublishConnectionDetailsToConfigRef
 */
export interface ObjectAclSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ObjectAclSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecPublishConnectionDetailsToConfigRef(obj: ObjectAclSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ObjectAclSpecPublishConnectionDetailsToMetadata
 */
export interface ObjectAclSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ObjectAclSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecPublishConnectionDetailsToMetadata(obj: ObjectAclSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectAclSpecForProviderBucketRefPolicy
 */
export interface ObjectAclSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAclSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: ObjectAclSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAclSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: ObjectAclSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAclSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProviderBucketRefPolicy(obj: ObjectAclSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ObjectAclSpecForProviderBucketSelectorPolicy
 */
export interface ObjectAclSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAclSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: ObjectAclSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAclSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: ObjectAclSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAclSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProviderBucketSelectorPolicy(obj: ObjectAclSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectAclSpecForProviderObjectRefPolicy
 */
export interface ObjectAclSpecForProviderObjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAclSpecForProviderObjectRefPolicy#resolution
   */
  readonly resolution?: ObjectAclSpecForProviderObjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAclSpecForProviderObjectRefPolicy#resolve
   */
  readonly resolve?: ObjectAclSpecForProviderObjectRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAclSpecForProviderObjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProviderObjectRefPolicy(obj: ObjectAclSpecForProviderObjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ObjectAclSpecForProviderObjectSelectorPolicy
 */
export interface ObjectAclSpecForProviderObjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAclSpecForProviderObjectSelectorPolicy#resolution
   */
  readonly resolution?: ObjectAclSpecForProviderObjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAclSpecForProviderObjectSelectorPolicy#resolve
   */
  readonly resolve?: ObjectAclSpecForProviderObjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAclSpecForProviderObjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProviderObjectSelectorPolicy(obj: ObjectAclSpecForProviderObjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAclSpecProviderConfigRefPolicyResolution
 */
export enum ObjectAclSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAclSpecProviderConfigRefPolicyResolve
 */
export enum ObjectAclSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAclSpecProviderRefPolicyResolution
 */
export enum ObjectAclSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAclSpecProviderRefPolicyResolve
 */
export enum ObjectAclSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy(obj: ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAclSpecForProviderBucketRefPolicyResolution
 */
export enum ObjectAclSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAclSpecForProviderBucketRefPolicyResolve
 */
export enum ObjectAclSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAclSpecForProviderBucketSelectorPolicyResolution
 */
export enum ObjectAclSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAclSpecForProviderBucketSelectorPolicyResolve
 */
export enum ObjectAclSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAclSpecForProviderObjectRefPolicyResolution
 */
export enum ObjectAclSpecForProviderObjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAclSpecForProviderObjectRefPolicyResolve
 */
export enum ObjectAclSpecForProviderObjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAclSpecForProviderObjectSelectorPolicyResolution
 */
export enum ObjectAclSpecForProviderObjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAclSpecForProviderObjectSelectorPolicyResolve
 */
export enum ObjectAclSpecForProviderObjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

