// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Bucket is the Schema for the Buckets API. Creates a new bucket in Google Cloud Storage.
 *
 * @schema Bucket
 */
export class Bucket extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Bucket"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'Bucket',
  }

  /**
   * Renders a Kubernetes manifest for "Bucket".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketProps): any {
    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(props),
    };
  }

  /**
   * Defines a "Bucket" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketProps) {
    super(scope, id, {
      ...Bucket.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(resolved),
    };
  }
}

/**
 * Bucket is the Schema for the Buckets API. Creates a new bucket in Google Cloud Storage.
 *
 * @schema Bucket
 */
export interface BucketProps {
  /**
   * @schema Bucket#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketSpec defines the desired state of Bucket
   *
   * @schema Bucket#spec
   */
  readonly spec: BucketSpec;

}

/**
 * Converts an object of type 'BucketProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketProps(obj: BucketProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketSpec defines the desired state of Bucket
 *
 * @schema BucketSpec
 */
export interface BucketSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BucketSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketSpecDeletionPolicy;

  /**
   * @schema BucketSpec#forProvider
   */
  readonly forProvider: BucketSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema BucketSpec#initProvider
   */
  readonly initProvider?: BucketSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BucketSpec#managementPolicies
   */
  readonly managementPolicies?: BucketSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpec(obj: BucketSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketSpecForProvider(obj.forProvider),
    'initProvider': toJson_BucketSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BucketSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_BucketSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BucketSpecDeletionPolicy
 */
export enum BucketSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketSpecForProvider
 */
export interface BucketSpecForProvider {
  /**
   * The bucket's Autoclass configuration.  Structure is documented below.
   *
   * @schema BucketSpecForProvider#autoclass
   */
  readonly autoclass?: BucketSpecForProviderAutoclass[];

  /**
   * The bucket's Cross-Origin Resource Sharing (CORS) configuration. Multiple blocks of this type are permitted. Structure is documented below.
   *
   * @schema BucketSpecForProvider#cors
   */
  readonly cors?: BucketSpecForProviderCors[];

  /**
   * The bucket's custom location configuration, which specifies the individual regions that comprise a dual-region bucket. If the bucket is designated a single or multi-region, the parameters are empty. Structure is documented below.
   *
   * @schema BucketSpecForProvider#customPlacementConfig
   */
  readonly customPlacementConfig?: BucketSpecForProviderCustomPlacementConfig[];

  /**
   * Whether or not to automatically apply an eventBasedHold to new objects added to the bucket.
   *
   * @schema BucketSpecForProvider#defaultEventBasedHold
   */
  readonly defaultEventBasedHold?: boolean;

  /**
   * The bucket's encryption configuration. Structure is documented below.
   *
   * @schema BucketSpecForProvider#encryption
   */
  readonly encryption?: BucketSpecForProviderEncryption[];

  /**
   * When deleting a bucket, this boolean option will delete all contained objects.
   *
   * @schema BucketSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * A map of key/value label pairs to assign to the bucket.
   *
   * @schema BucketSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The bucket's Lifecycle Rules configuration. Multiple blocks of this type are permitted. Structure is documented below.
   *
   * @schema BucketSpecForProvider#lifecycleRule
   */
  readonly lifecycleRule?: BucketSpecForProviderLifecycleRule[];

  /**
   * The GCS location.
   *
   * @schema BucketSpecForProvider#location
   */
  readonly location?: string;

  /**
   * The bucket's Access & Storage Logs configuration. Structure is documented below.
   *
   * @schema BucketSpecForProvider#logging
   */
  readonly logging?: BucketSpecForProviderLogging[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema BucketSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Prevents public access to a bucket. Acceptable values are "inherited" or "enforced". If "inherited", the bucket uses public access prevention. only if the bucket is subject to the public access prevention organization policy constraint. Defaults to "inherited".
   *
   * @default inherited".
   * @schema BucketSpecForProvider#publicAccessPrevention
   */
  readonly publicAccessPrevention?: string;

  /**
   * Enables Requester Pays on a storage bucket.
   *
   * @schema BucketSpecForProvider#requesterPays
   */
  readonly requesterPays?: boolean;

  /**
   * Configuration of the bucket's data retention policy for how long objects in the bucket should be retained. Structure is documented below.
   *
   * @schema BucketSpecForProvider#retentionPolicy
   */
  readonly retentionPolicy?: BucketSpecForProviderRetentionPolicy[];

  /**
   * The Storage Class of the new bucket. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE.
   *
   * @schema BucketSpecForProvider#storageClass
   */
  readonly storageClass?: string;

  /**
   * Enables Uniform bucket-level access access to a bucket.
   *
   * @schema BucketSpecForProvider#uniformBucketLevelAccess
   */
  readonly uniformBucketLevelAccess?: boolean;

  /**
   * The bucket's Versioning configuration.  Structure is documented below.
   *
   * @schema BucketSpecForProvider#versioning
   */
  readonly versioning?: BucketSpecForProviderVersioning[];

  /**
   * Configuration if the bucket acts as a website. Structure is documented below.
   *
   * @schema BucketSpecForProvider#website
   */
  readonly website?: BucketSpecForProviderWebsite[];

}

/**
 * Converts an object of type 'BucketSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProvider(obj: BucketSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoclass': obj.autoclass?.map(y => toJson_BucketSpecForProviderAutoclass(y)),
    'cors': obj.cors?.map(y => toJson_BucketSpecForProviderCors(y)),
    'customPlacementConfig': obj.customPlacementConfig?.map(y => toJson_BucketSpecForProviderCustomPlacementConfig(y)),
    'defaultEventBasedHold': obj.defaultEventBasedHold,
    'encryption': obj.encryption?.map(y => toJson_BucketSpecForProviderEncryption(y)),
    'forceDestroy': obj.forceDestroy,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'lifecycleRule': obj.lifecycleRule?.map(y => toJson_BucketSpecForProviderLifecycleRule(y)),
    'location': obj.location,
    'logging': obj.logging?.map(y => toJson_BucketSpecForProviderLogging(y)),
    'project': obj.project,
    'publicAccessPrevention': obj.publicAccessPrevention,
    'requesterPays': obj.requesterPays,
    'retentionPolicy': obj.retentionPolicy?.map(y => toJson_BucketSpecForProviderRetentionPolicy(y)),
    'storageClass': obj.storageClass,
    'uniformBucketLevelAccess': obj.uniformBucketLevelAccess,
    'versioning': obj.versioning?.map(y => toJson_BucketSpecForProviderVersioning(y)),
    'website': obj.website?.map(y => toJson_BucketSpecForProviderWebsite(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema BucketSpecInitProvider
 */
export interface BucketSpecInitProvider {
  /**
   * The bucket's Autoclass configuration.  Structure is documented below.
   *
   * @schema BucketSpecInitProvider#autoclass
   */
  readonly autoclass?: BucketSpecInitProviderAutoclass[];

  /**
   * The bucket's Cross-Origin Resource Sharing (CORS) configuration. Multiple blocks of this type are permitted. Structure is documented below.
   *
   * @schema BucketSpecInitProvider#cors
   */
  readonly cors?: BucketSpecInitProviderCors[];

  /**
   * The bucket's custom location configuration, which specifies the individual regions that comprise a dual-region bucket. If the bucket is designated a single or multi-region, the parameters are empty. Structure is documented below.
   *
   * @schema BucketSpecInitProvider#customPlacementConfig
   */
  readonly customPlacementConfig?: BucketSpecInitProviderCustomPlacementConfig[];

  /**
   * Whether or not to automatically apply an eventBasedHold to new objects added to the bucket.
   *
   * @schema BucketSpecInitProvider#defaultEventBasedHold
   */
  readonly defaultEventBasedHold?: boolean;

  /**
   * The bucket's encryption configuration. Structure is documented below.
   *
   * @schema BucketSpecInitProvider#encryption
   */
  readonly encryption?: BucketSpecInitProviderEncryption[];

  /**
   * When deleting a bucket, this boolean option will delete all contained objects.
   *
   * @schema BucketSpecInitProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * A map of key/value label pairs to assign to the bucket.
   *
   * @schema BucketSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The bucket's Lifecycle Rules configuration. Multiple blocks of this type are permitted. Structure is documented below.
   *
   * @schema BucketSpecInitProvider#lifecycleRule
   */
  readonly lifecycleRule?: BucketSpecInitProviderLifecycleRule[];

  /**
   * The GCS location.
   *
   * @schema BucketSpecInitProvider#location
   */
  readonly location?: string;

  /**
   * The bucket's Access & Storage Logs configuration. Structure is documented below.
   *
   * @schema BucketSpecInitProvider#logging
   */
  readonly logging?: BucketSpecInitProviderLogging[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema BucketSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * Prevents public access to a bucket. Acceptable values are "inherited" or "enforced". If "inherited", the bucket uses public access prevention. only if the bucket is subject to the public access prevention organization policy constraint. Defaults to "inherited".
   *
   * @default inherited".
   * @schema BucketSpecInitProvider#publicAccessPrevention
   */
  readonly publicAccessPrevention?: string;

  /**
   * Enables Requester Pays on a storage bucket.
   *
   * @schema BucketSpecInitProvider#requesterPays
   */
  readonly requesterPays?: boolean;

  /**
   * Configuration of the bucket's data retention policy for how long objects in the bucket should be retained. Structure is documented below.
   *
   * @schema BucketSpecInitProvider#retentionPolicy
   */
  readonly retentionPolicy?: BucketSpecInitProviderRetentionPolicy[];

  /**
   * The Storage Class of the new bucket. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE.
   *
   * @schema BucketSpecInitProvider#storageClass
   */
  readonly storageClass?: string;

  /**
   * Enables Uniform bucket-level access access to a bucket.
   *
   * @schema BucketSpecInitProvider#uniformBucketLevelAccess
   */
  readonly uniformBucketLevelAccess?: boolean;

  /**
   * The bucket's Versioning configuration.  Structure is documented below.
   *
   * @schema BucketSpecInitProvider#versioning
   */
  readonly versioning?: BucketSpecInitProviderVersioning[];

  /**
   * Configuration if the bucket acts as a website. Structure is documented below.
   *
   * @schema BucketSpecInitProvider#website
   */
  readonly website?: BucketSpecInitProviderWebsite[];

}

/**
 * Converts an object of type 'BucketSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInitProvider(obj: BucketSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoclass': obj.autoclass?.map(y => toJson_BucketSpecInitProviderAutoclass(y)),
    'cors': obj.cors?.map(y => toJson_BucketSpecInitProviderCors(y)),
    'customPlacementConfig': obj.customPlacementConfig?.map(y => toJson_BucketSpecInitProviderCustomPlacementConfig(y)),
    'defaultEventBasedHold': obj.defaultEventBasedHold,
    'encryption': obj.encryption?.map(y => toJson_BucketSpecInitProviderEncryption(y)),
    'forceDestroy': obj.forceDestroy,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'lifecycleRule': obj.lifecycleRule?.map(y => toJson_BucketSpecInitProviderLifecycleRule(y)),
    'location': obj.location,
    'logging': obj.logging?.map(y => toJson_BucketSpecInitProviderLogging(y)),
    'project': obj.project,
    'publicAccessPrevention': obj.publicAccessPrevention,
    'requesterPays': obj.requesterPays,
    'retentionPolicy': obj.retentionPolicy?.map(y => toJson_BucketSpecInitProviderRetentionPolicy(y)),
    'storageClass': obj.storageClass,
    'uniformBucketLevelAccess': obj.uniformBucketLevelAccess,
    'versioning': obj.versioning?.map(y => toJson_BucketSpecInitProviderVersioning(y)),
    'website': obj.website?.map(y => toJson_BucketSpecInitProviderWebsite(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema BucketSpecManagementPolicies
 */
export enum BucketSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketSpecProviderConfigRef
 */
export interface BucketSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecProviderConfigRef#policy
   */
  readonly policy?: BucketSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecProviderConfigRef(obj: BucketSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketSpecPublishConnectionDetailsTo
 */
export interface BucketSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecPublishConnectionDetailsTo(obj: BucketSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketSpecWriteConnectionSecretToRef
 */
export interface BucketSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecWriteConnectionSecretToRef(obj: BucketSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderAutoclass
 */
export interface BucketSpecForProviderAutoclass {
  /**
   * While set to true, autoclass automatically transitions objects in your bucket to appropriate storage classes based on each object's access pattern.
   *
   * @schema BucketSpecForProviderAutoclass#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'BucketSpecForProviderAutoclass' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderAutoclass(obj: BucketSpecForProviderAutoclass | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderCors
 */
export interface BucketSpecForProviderCors {
  /**
   * The value, in seconds, to return in the Access-Control-Max-Age header used in preflight responses.
   *
   * @schema BucketSpecForProviderCors#maxAgeSeconds
   */
  readonly maxAgeSeconds?: number;

  /**
   * The list of HTTP methods on which to include CORS response headers, (GET, OPTIONS, POST, etc) Note: "*" is permitted in the list of methods, and means "any method".
   *
   * @schema BucketSpecForProviderCors#method
   */
  readonly method?: string[];

  /**
   * The list of Origins eligible to receive CORS response headers. Note: "*" is permitted in the list of origins, and means "any Origin".
   *
   * @schema BucketSpecForProviderCors#origin
   */
  readonly origin?: string[];

  /**
   * The list of HTTP headers other than the simple response headers to give permission for the user-agent to share across domains.
   *
   * @schema BucketSpecForProviderCors#responseHeader
   */
  readonly responseHeader?: string[];

}

/**
 * Converts an object of type 'BucketSpecForProviderCors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderCors(obj: BucketSpecForProviderCors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxAgeSeconds': obj.maxAgeSeconds,
    'method': obj.method?.map(y => y),
    'origin': obj.origin?.map(y => y),
    'responseHeader': obj.responseHeader?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderCustomPlacementConfig
 */
export interface BucketSpecForProviderCustomPlacementConfig {
  /**
   * The list of individual regions that comprise a dual-region bucket. See Cloud Storage bucket locations for a list of acceptable regions. Note: If any of the data_locations changes, it will recreate the bucket.
   *
   * @schema BucketSpecForProviderCustomPlacementConfig#dataLocations
   */
  readonly dataLocations?: string[];

}

/**
 * Converts an object of type 'BucketSpecForProviderCustomPlacementConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderCustomPlacementConfig(obj: BucketSpecForProviderCustomPlacementConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataLocations': obj.dataLocations?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderEncryption
 */
export interface BucketSpecForProviderEncryption {
  /**
   * : The id of a Cloud KMS key that will be used to encrypt objects inserted into this bucket, if no encryption method is specified. You must pay attention to whether the crypto key is available in the location that this bucket is created in. See the docs for more details.
   *
   * @schema BucketSpecForProviderEncryption#defaultKmsKeyName
   */
  readonly defaultKmsKeyName?: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderEncryption(obj: BucketSpecForProviderEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultKmsKeyName': obj.defaultKmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderLifecycleRule
 */
export interface BucketSpecForProviderLifecycleRule {
  /**
   * The Lifecycle Rule's action configuration. A single block of this type is supported. Structure is documented below.
   *
   * @schema BucketSpecForProviderLifecycleRule#action
   */
  readonly action?: BucketSpecForProviderLifecycleRuleAction[];

  /**
   * The Lifecycle Rule's condition configuration. A single block of this type is supported. Structure is documented below.
   *
   * @schema BucketSpecForProviderLifecycleRule#condition
   */
  readonly condition?: BucketSpecForProviderLifecycleRuleCondition[];

}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLifecycleRule(obj: BucketSpecForProviderLifecycleRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_BucketSpecForProviderLifecycleRuleAction(y)),
    'condition': obj.condition?.map(y => toJson_BucketSpecForProviderLifecycleRuleCondition(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderLogging
 */
export interface BucketSpecForProviderLogging {
  /**
   * The bucket that will receive log objects.
   *
   * @schema BucketSpecForProviderLogging#logBucket
   */
  readonly logBucket?: string;

  /**
   * The object prefix for log objects. If it's not provided, by default GCS sets this to this bucket's name.
   *
   * @schema BucketSpecForProviderLogging#logObjectPrefix
   */
  readonly logObjectPrefix?: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLogging(obj: BucketSpecForProviderLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logBucket': obj.logBucket,
    'logObjectPrefix': obj.logObjectPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderRetentionPolicy
 */
export interface BucketSpecForProviderRetentionPolicy {
  /**
   * If set to true, the bucket will be locked and permanently restrict edits to the bucket's retention policy.  Caution: Locking a bucket is an irreversible action.
   *
   * @schema BucketSpecForProviderRetentionPolicy#isLocked
   */
  readonly isLocked?: boolean;

  /**
   * The period of time, in seconds, that objects in the bucket must be retained and cannot be deleted, overwritten, or archived. The value must be less than 2,147,483,647 seconds.
   *
   * @schema BucketSpecForProviderRetentionPolicy#retentionPeriod
   */
  readonly retentionPeriod?: number;

}

/**
 * Converts an object of type 'BucketSpecForProviderRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderRetentionPolicy(obj: BucketSpecForProviderRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isLocked': obj.isLocked,
    'retentionPeriod': obj.retentionPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderVersioning
 */
export interface BucketSpecForProviderVersioning {
  /**
   * While set to true, versioning is fully enabled for this bucket.
   *
   * @schema BucketSpecForProviderVersioning#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'BucketSpecForProviderVersioning' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderVersioning(obj: BucketSpecForProviderVersioning | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderWebsite
 */
export interface BucketSpecForProviderWebsite {
  /**
   * Behaves as the bucket's directory index where missing objects are treated as potential directories.
   *
   * @schema BucketSpecForProviderWebsite#mainPageSuffix
   */
  readonly mainPageSuffix?: string;

  /**
   * The custom object to return when a requested resource is not found.
   *
   * @schema BucketSpecForProviderWebsite#notFoundPage
   */
  readonly notFoundPage?: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderWebsite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderWebsite(obj: BucketSpecForProviderWebsite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mainPageSuffix': obj.mainPageSuffix,
    'notFoundPage': obj.notFoundPage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecInitProviderAutoclass
 */
export interface BucketSpecInitProviderAutoclass {
  /**
   * While set to true, autoclass automatically transitions objects in your bucket to appropriate storage classes based on each object's access pattern.
   *
   * @schema BucketSpecInitProviderAutoclass#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'BucketSpecInitProviderAutoclass' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInitProviderAutoclass(obj: BucketSpecInitProviderAutoclass | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecInitProviderCors
 */
export interface BucketSpecInitProviderCors {
  /**
   * The value, in seconds, to return in the Access-Control-Max-Age header used in preflight responses.
   *
   * @schema BucketSpecInitProviderCors#maxAgeSeconds
   */
  readonly maxAgeSeconds?: number;

  /**
   * The list of HTTP methods on which to include CORS response headers, (GET, OPTIONS, POST, etc) Note: "*" is permitted in the list of methods, and means "any method".
   *
   * @schema BucketSpecInitProviderCors#method
   */
  readonly method?: string[];

  /**
   * The list of Origins eligible to receive CORS response headers. Note: "*" is permitted in the list of origins, and means "any Origin".
   *
   * @schema BucketSpecInitProviderCors#origin
   */
  readonly origin?: string[];

  /**
   * The list of HTTP headers other than the simple response headers to give permission for the user-agent to share across domains.
   *
   * @schema BucketSpecInitProviderCors#responseHeader
   */
  readonly responseHeader?: string[];

}

/**
 * Converts an object of type 'BucketSpecInitProviderCors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInitProviderCors(obj: BucketSpecInitProviderCors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxAgeSeconds': obj.maxAgeSeconds,
    'method': obj.method?.map(y => y),
    'origin': obj.origin?.map(y => y),
    'responseHeader': obj.responseHeader?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecInitProviderCustomPlacementConfig
 */
export interface BucketSpecInitProviderCustomPlacementConfig {
  /**
   * The list of individual regions that comprise a dual-region bucket. See Cloud Storage bucket locations for a list of acceptable regions. Note: If any of the data_locations changes, it will recreate the bucket.
   *
   * @schema BucketSpecInitProviderCustomPlacementConfig#dataLocations
   */
  readonly dataLocations?: string[];

}

/**
 * Converts an object of type 'BucketSpecInitProviderCustomPlacementConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInitProviderCustomPlacementConfig(obj: BucketSpecInitProviderCustomPlacementConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataLocations': obj.dataLocations?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecInitProviderEncryption
 */
export interface BucketSpecInitProviderEncryption {
  /**
   * : The id of a Cloud KMS key that will be used to encrypt objects inserted into this bucket, if no encryption method is specified. You must pay attention to whether the crypto key is available in the location that this bucket is created in. See the docs for more details.
   *
   * @schema BucketSpecInitProviderEncryption#defaultKmsKeyName
   */
  readonly defaultKmsKeyName?: string;

}

/**
 * Converts an object of type 'BucketSpecInitProviderEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInitProviderEncryption(obj: BucketSpecInitProviderEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultKmsKeyName': obj.defaultKmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecInitProviderLifecycleRule
 */
export interface BucketSpecInitProviderLifecycleRule {
  /**
   * The Lifecycle Rule's action configuration. A single block of this type is supported. Structure is documented below.
   *
   * @schema BucketSpecInitProviderLifecycleRule#action
   */
  readonly action?: BucketSpecInitProviderLifecycleRuleAction[];

  /**
   * The Lifecycle Rule's condition configuration. A single block of this type is supported. Structure is documented below.
   *
   * @schema BucketSpecInitProviderLifecycleRule#condition
   */
  readonly condition?: BucketSpecInitProviderLifecycleRuleCondition[];

}

/**
 * Converts an object of type 'BucketSpecInitProviderLifecycleRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInitProviderLifecycleRule(obj: BucketSpecInitProviderLifecycleRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_BucketSpecInitProviderLifecycleRuleAction(y)),
    'condition': obj.condition?.map(y => toJson_BucketSpecInitProviderLifecycleRuleCondition(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecInitProviderLogging
 */
export interface BucketSpecInitProviderLogging {
  /**
   * The bucket that will receive log objects.
   *
   * @schema BucketSpecInitProviderLogging#logBucket
   */
  readonly logBucket?: string;

  /**
   * The object prefix for log objects. If it's not provided, by default GCS sets this to this bucket's name.
   *
   * @schema BucketSpecInitProviderLogging#logObjectPrefix
   */
  readonly logObjectPrefix?: string;

}

/**
 * Converts an object of type 'BucketSpecInitProviderLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInitProviderLogging(obj: BucketSpecInitProviderLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logBucket': obj.logBucket,
    'logObjectPrefix': obj.logObjectPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecInitProviderRetentionPolicy
 */
export interface BucketSpecInitProviderRetentionPolicy {
  /**
   * If set to true, the bucket will be locked and permanently restrict edits to the bucket's retention policy.  Caution: Locking a bucket is an irreversible action.
   *
   * @schema BucketSpecInitProviderRetentionPolicy#isLocked
   */
  readonly isLocked?: boolean;

  /**
   * The period of time, in seconds, that objects in the bucket must be retained and cannot be deleted, overwritten, or archived. The value must be less than 2,147,483,647 seconds.
   *
   * @schema BucketSpecInitProviderRetentionPolicy#retentionPeriod
   */
  readonly retentionPeriod?: number;

}

/**
 * Converts an object of type 'BucketSpecInitProviderRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInitProviderRetentionPolicy(obj: BucketSpecInitProviderRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isLocked': obj.isLocked,
    'retentionPeriod': obj.retentionPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecInitProviderVersioning
 */
export interface BucketSpecInitProviderVersioning {
  /**
   * While set to true, versioning is fully enabled for this bucket.
   *
   * @schema BucketSpecInitProviderVersioning#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'BucketSpecInitProviderVersioning' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInitProviderVersioning(obj: BucketSpecInitProviderVersioning | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecInitProviderWebsite
 */
export interface BucketSpecInitProviderWebsite {
  /**
   * Behaves as the bucket's directory index where missing objects are treated as potential directories.
   *
   * @schema BucketSpecInitProviderWebsite#mainPageSuffix
   */
  readonly mainPageSuffix?: string;

  /**
   * The custom object to return when a requested resource is not found.
   *
   * @schema BucketSpecInitProviderWebsite#notFoundPage
   */
  readonly notFoundPage?: string;

}

/**
 * Converts an object of type 'BucketSpecInitProviderWebsite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInitProviderWebsite(obj: BucketSpecInitProviderWebsite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mainPageSuffix': obj.mainPageSuffix,
    'notFoundPage': obj.notFoundPage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketSpecProviderConfigRefPolicy
 */
export interface BucketSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecProviderConfigRefPolicy(obj: BucketSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecPublishConnectionDetailsToConfigRef(obj: BucketSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketSpecPublishConnectionDetailsToMetadata
 */
export interface BucketSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecPublishConnectionDetailsToMetadata(obj: BucketSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderLifecycleRuleAction
 */
export interface BucketSpecForProviderLifecycleRuleAction {
  /**
   * The Storage Class of the new bucket. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE.
   *
   * @schema BucketSpecForProviderLifecycleRuleAction#storageClass
   */
  readonly storageClass?: string;

  /**
   * The type of the action of this Lifecycle Rule. Supported values include: Delete, SetStorageClass and AbortIncompleteMultipartUpload.
   *
   * @schema BucketSpecForProviderLifecycleRuleAction#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleRuleAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLifecycleRuleAction(obj: BucketSpecForProviderLifecycleRuleAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'storageClass': obj.storageClass,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecForProviderLifecycleRuleCondition
 */
export interface BucketSpecForProviderLifecycleRuleCondition {
  /**
   * Minimum age of an object in days to satisfy this condition.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#age
   */
  readonly age?: number;

  /**
   * A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when an object is created before midnight of the specified date in UTC.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#createdBefore
   */
  readonly createdBefore?: string;

  /**
   * A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when the customTime metadata for the object is set to an earlier date than the date used in this lifecycle condition.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#customTimeBefore
   */
  readonly customTimeBefore?: string;

  /**
   * Days since the date set in the customTime metadata for the object. This condition is satisfied when the current date and time is at least the specified number of days after the customTime.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#daysSinceCustomTime
   */
  readonly daysSinceCustomTime?: number;

  /**
   * Relevant only for versioned objects. Number of days elapsed since the noncurrent timestamp of an object.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#daysSinceNoncurrentTime
   */
  readonly daysSinceNoncurrentTime?: number;

  /**
   * One or more matching name prefixes to satisfy this condition.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#matchesPrefix
   */
  readonly matchesPrefix?: string[];

  /**
   * Storage Class of objects to satisfy this condition. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE, DURABLE_REDUCED_AVAILABILITY.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#matchesStorageClass
   */
  readonly matchesStorageClass?: string[];

  /**
   * One or more matching name suffixes to satisfy this condition.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#matchesSuffix
   */
  readonly matchesSuffix?: string[];

  /**
   * Relevant only for versioned objects. The date in RFC 3339 (e.g. 2017-06-13) when the object became nonconcurrent.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#noncurrentTimeBefore
   */
  readonly noncurrentTimeBefore?: string;

  /**
   * Relevant only for versioned objects. The number of newer versions of an object to satisfy this condition.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#numNewerVersions
   */
  readonly numNewerVersions?: number;

  /**
   * Match to live and/or archived objects. Unversioned buckets have only live objects. Supported values include: "LIVE", "ARCHIVED", "ANY".
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#withState
   */
  readonly withState?: string;

}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleRuleCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProviderLifecycleRuleCondition(obj: BucketSpecForProviderLifecycleRuleCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'age': obj.age,
    'createdBefore': obj.createdBefore,
    'customTimeBefore': obj.customTimeBefore,
    'daysSinceCustomTime': obj.daysSinceCustomTime,
    'daysSinceNoncurrentTime': obj.daysSinceNoncurrentTime,
    'matchesPrefix': obj.matchesPrefix?.map(y => y),
    'matchesStorageClass': obj.matchesStorageClass?.map(y => y),
    'matchesSuffix': obj.matchesSuffix?.map(y => y),
    'noncurrentTimeBefore': obj.noncurrentTimeBefore,
    'numNewerVersions': obj.numNewerVersions,
    'withState': obj.withState,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecInitProviderLifecycleRuleAction
 */
export interface BucketSpecInitProviderLifecycleRuleAction {
  /**
   * The Storage Class of the new bucket. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE.
   *
   * @schema BucketSpecInitProviderLifecycleRuleAction#storageClass
   */
  readonly storageClass?: string;

  /**
   * The type of the action of this Lifecycle Rule. Supported values include: Delete, SetStorageClass and AbortIncompleteMultipartUpload.
   *
   * @schema BucketSpecInitProviderLifecycleRuleAction#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketSpecInitProviderLifecycleRuleAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInitProviderLifecycleRuleAction(obj: BucketSpecInitProviderLifecycleRuleAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'storageClass': obj.storageClass,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketSpecInitProviderLifecycleRuleCondition
 */
export interface BucketSpecInitProviderLifecycleRuleCondition {
  /**
   * Minimum age of an object in days to satisfy this condition.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#age
   */
  readonly age?: number;

  /**
   * A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when an object is created before midnight of the specified date in UTC.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#createdBefore
   */
  readonly createdBefore?: string;

  /**
   * A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when the customTime metadata for the object is set to an earlier date than the date used in this lifecycle condition.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#customTimeBefore
   */
  readonly customTimeBefore?: string;

  /**
   * Days since the date set in the customTime metadata for the object. This condition is satisfied when the current date and time is at least the specified number of days after the customTime.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#daysSinceCustomTime
   */
  readonly daysSinceCustomTime?: number;

  /**
   * Relevant only for versioned objects. Number of days elapsed since the noncurrent timestamp of an object.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#daysSinceNoncurrentTime
   */
  readonly daysSinceNoncurrentTime?: number;

  /**
   * One or more matching name prefixes to satisfy this condition.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#matchesPrefix
   */
  readonly matchesPrefix?: string[];

  /**
   * Storage Class of objects to satisfy this condition. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE, DURABLE_REDUCED_AVAILABILITY.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#matchesStorageClass
   */
  readonly matchesStorageClass?: string[];

  /**
   * One or more matching name suffixes to satisfy this condition.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#matchesSuffix
   */
  readonly matchesSuffix?: string[];

  /**
   * Relevant only for versioned objects. The date in RFC 3339 (e.g. 2017-06-13) when the object became nonconcurrent.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#noncurrentTimeBefore
   */
  readonly noncurrentTimeBefore?: string;

  /**
   * Relevant only for versioned objects. The number of newer versions of an object to satisfy this condition.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#numNewerVersions
   */
  readonly numNewerVersions?: number;

  /**
   * Match to live and/or archived objects. Unversioned buckets have only live objects. Supported values include: "LIVE", "ARCHIVED", "ANY".
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#withState
   */
  readonly withState?: string;

}

/**
 * Converts an object of type 'BucketSpecInitProviderLifecycleRuleCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInitProviderLifecycleRuleCondition(obj: BucketSpecInitProviderLifecycleRuleCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'age': obj.age,
    'createdBefore': obj.createdBefore,
    'customTimeBefore': obj.customTimeBefore,
    'daysSinceCustomTime': obj.daysSinceCustomTime,
    'daysSinceNoncurrentTime': obj.daysSinceNoncurrentTime,
    'matchesPrefix': obj.matchesPrefix?.map(y => y),
    'matchesStorageClass': obj.matchesStorageClass?.map(y => y),
    'matchesSuffix': obj.matchesSuffix?.map(y => y),
    'noncurrentTimeBefore': obj.noncurrentTimeBefore,
    'numNewerVersions': obj.numNewerVersions,
    'withState': obj.withState,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecProviderConfigRefPolicyResolution
 */
export enum BucketSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecProviderConfigRefPolicyResolve
 */
export enum BucketSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketAccessControl is the Schema for the BucketAccessControls API. Bucket ACLs can be managed authoritatively using the [
 *
 * @schema BucketAccessControl
 */
export class BucketAccessControl extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketAccessControl"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'BucketAccessControl',
  }

  /**
   * Renders a Kubernetes manifest for "BucketAccessControl".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketAccessControlProps): any {
    return {
      ...BucketAccessControl.GVK,
      ...toJson_BucketAccessControlProps(props),
    };
  }

  /**
   * Defines a "BucketAccessControl" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketAccessControlProps) {
    super(scope, id, {
      ...BucketAccessControl.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketAccessControl.GVK,
      ...toJson_BucketAccessControlProps(resolved),
    };
  }
}

/**
 * BucketAccessControl is the Schema for the BucketAccessControls API. Bucket ACLs can be managed authoritatively using the [
 *
 * @schema BucketAccessControl
 */
export interface BucketAccessControlProps {
  /**
   * @schema BucketAccessControl#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketAccessControlSpec defines the desired state of BucketAccessControl
   *
   * @schema BucketAccessControl#spec
   */
  readonly spec: BucketAccessControlSpec;

}

/**
 * Converts an object of type 'BucketAccessControlProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlProps(obj: BucketAccessControlProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketAccessControlSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketAccessControlSpec defines the desired state of BucketAccessControl
 *
 * @schema BucketAccessControlSpec
 */
export interface BucketAccessControlSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BucketAccessControlSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketAccessControlSpecDeletionPolicy;

  /**
   * @schema BucketAccessControlSpec#forProvider
   */
  readonly forProvider: BucketAccessControlSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema BucketAccessControlSpec#initProvider
   */
  readonly initProvider?: BucketAccessControlSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BucketAccessControlSpec#managementPolicies
   */
  readonly managementPolicies?: BucketAccessControlSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketAccessControlSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketAccessControlSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketAccessControlSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketAccessControlSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketAccessControlSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketAccessControlSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketAccessControlSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpec(obj: BucketAccessControlSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketAccessControlSpecForProvider(obj.forProvider),
    'initProvider': toJson_BucketAccessControlSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BucketAccessControlSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_BucketAccessControlSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketAccessControlSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BucketAccessControlSpecDeletionPolicy
 */
export enum BucketAccessControlSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketAccessControlSpecForProvider
 */
export interface BucketAccessControlSpecForProvider {
  /**
   * The name of the bucket.
   *
   * @schema BucketAccessControlSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema BucketAccessControlSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketAccessControlSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema BucketAccessControlSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketAccessControlSpecForProviderBucketSelector;

  /**
   * The entity holding the permission, in one of the following forms: user-userId user-email group-groupId group-email domain-domain project-team-projectId allUsers allAuthenticatedUsers Examples: The user liz@example.com would be user-liz@example.com. The group example@googlegroups.com would be group-example@googlegroups.com. To refer to all members of the Google Apps for Business domain example.com, the entity would be domain-example.com.
   *
   * @schema BucketAccessControlSpecForProvider#entity
   */
  readonly entity?: string;

  /**
   * The access permission for the entity. Possible values are: OWNER, READER, WRITER.
   *
   * @schema BucketAccessControlSpecForProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'BucketAccessControlSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecForProvider(obj: BucketAccessControlSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketAccessControlSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketAccessControlSpecForProviderBucketSelector(obj.bucketSelector),
    'entity': obj.entity,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema BucketAccessControlSpecInitProvider
 */
export interface BucketAccessControlSpecInitProvider {
  /**
   * The entity holding the permission, in one of the following forms: user-userId user-email group-groupId group-email domain-domain project-team-projectId allUsers allAuthenticatedUsers Examples: The user liz@example.com would be user-liz@example.com. The group example@googlegroups.com would be group-example@googlegroups.com. To refer to all members of the Google Apps for Business domain example.com, the entity would be domain-example.com.
   *
   * @schema BucketAccessControlSpecInitProvider#entity
   */
  readonly entity?: string;

  /**
   * The access permission for the entity. Possible values are: OWNER, READER, WRITER.
   *
   * @schema BucketAccessControlSpecInitProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'BucketAccessControlSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecInitProvider(obj: BucketAccessControlSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entity': obj.entity,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema BucketAccessControlSpecManagementPolicies
 */
export enum BucketAccessControlSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketAccessControlSpecProviderConfigRef
 */
export interface BucketAccessControlSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAccessControlSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAccessControlSpecProviderConfigRef#policy
   */
  readonly policy?: BucketAccessControlSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketAccessControlSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecProviderConfigRef(obj: BucketAccessControlSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAccessControlSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketAccessControlSpecPublishConnectionDetailsTo
 */
export interface BucketAccessControlSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketAccessControlSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketAccessControlSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketAccessControlSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecPublishConnectionDetailsTo(obj: BucketAccessControlSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketAccessControlSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketAccessControlSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketAccessControlSpecWriteConnectionSecretToRef
 */
export interface BucketAccessControlSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketAccessControlSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketAccessControlSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketAccessControlSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecWriteConnectionSecretToRef(obj: BucketAccessControlSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema BucketAccessControlSpecForProviderBucketRef
 */
export interface BucketAccessControlSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAccessControlSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAccessControlSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketAccessControlSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketAccessControlSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecForProviderBucketRef(obj: BucketAccessControlSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAccessControlSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema BucketAccessControlSpecForProviderBucketSelector
 */
export interface BucketAccessControlSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketAccessControlSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketAccessControlSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketAccessControlSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketAccessControlSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketAccessControlSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecForProviderBucketSelector(obj: BucketAccessControlSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketAccessControlSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAccessControlSpecProviderConfigRefPolicy
 */
export interface BucketAccessControlSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAccessControlSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketAccessControlSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAccessControlSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketAccessControlSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAccessControlSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecProviderConfigRefPolicy(obj: BucketAccessControlSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketAccessControlSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketAccessControlSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketAccessControlSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecPublishConnectionDetailsToConfigRef(obj: BucketAccessControlSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketAccessControlSpecPublishConnectionDetailsToMetadata
 */
export interface BucketAccessControlSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketAccessControlSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecPublishConnectionDetailsToMetadata(obj: BucketAccessControlSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAccessControlSpecForProviderBucketRefPolicy
 */
export interface BucketAccessControlSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAccessControlSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketAccessControlSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAccessControlSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketAccessControlSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAccessControlSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecForProviderBucketRefPolicy(obj: BucketAccessControlSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketAccessControlSpecForProviderBucketSelectorPolicy
 */
export interface BucketAccessControlSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAccessControlSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketAccessControlSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAccessControlSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketAccessControlSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketAccessControlSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecForProviderBucketSelectorPolicy(obj: BucketAccessControlSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAccessControlSpecProviderConfigRefPolicyResolution
 */
export enum BucketAccessControlSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAccessControlSpecProviderConfigRefPolicyResolve
 */
export enum BucketAccessControlSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAccessControlSpecForProviderBucketRefPolicyResolution
 */
export enum BucketAccessControlSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAccessControlSpecForProviderBucketRefPolicyResolve
 */
export enum BucketAccessControlSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAccessControlSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketAccessControlSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAccessControlSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketAccessControlSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketACL is the Schema for the BucketACLs API. Creates a new bucket ACL in Google Cloud Storage.
 *
 * @schema BucketACL
 */
export class BucketAcl extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketACL"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'BucketACL',
  }

  /**
   * Renders a Kubernetes manifest for "BucketACL".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketAclProps): any {
    return {
      ...BucketAcl.GVK,
      ...toJson_BucketAclProps(props),
    };
  }

  /**
   * Defines a "BucketACL" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketAclProps) {
    super(scope, id, {
      ...BucketAcl.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketAcl.GVK,
      ...toJson_BucketAclProps(resolved),
    };
  }
}

/**
 * BucketACL is the Schema for the BucketACLs API. Creates a new bucket ACL in Google Cloud Storage.
 *
 * @schema BucketACL
 */
export interface BucketAclProps {
  /**
   * @schema BucketACL#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketACLSpec defines the desired state of BucketACL
   *
   * @schema BucketACL#spec
   */
  readonly spec: BucketAclSpec;

}

/**
 * Converts an object of type 'BucketAclProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclProps(obj: BucketAclProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketAclSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketACLSpec defines the desired state of BucketACL
 *
 * @schema BucketAclSpec
 */
export interface BucketAclSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BucketAclSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketAclSpecDeletionPolicy;

  /**
   * @schema BucketAclSpec#forProvider
   */
  readonly forProvider: BucketAclSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema BucketAclSpec#initProvider
   */
  readonly initProvider?: BucketAclSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BucketAclSpec#managementPolicies
   */
  readonly managementPolicies?: BucketAclSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketAclSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketAclSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketAclSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketAclSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketAclSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketAclSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketAclSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpec(obj: BucketAclSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketAclSpecForProvider(obj.forProvider),
    'initProvider': toJson_BucketAclSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BucketAclSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_BucketAclSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketAclSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BucketAclSpecDeletionPolicy
 */
export enum BucketAclSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketAclSpecForProvider
 */
export interface BucketAclSpecForProvider {
  /**
   * The name of the bucket it applies to.
   *
   * @schema BucketAclSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema BucketAclSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketAclSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema BucketAclSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketAclSpecForProviderBucketSelector;

  /**
   * Configure this ACL to be the default ACL.
   *
   * @schema BucketAclSpecForProvider#defaultAcl
   */
  readonly defaultAcl?: string;

  /**
   * The canned GCS ACL to apply. Must be set if role_entity is not.
   *
   * @schema BucketAclSpecForProvider#predefinedAcl
   */
  readonly predefinedAcl?: string;

  /**
   * List of role/entity pairs in the form ROLE:entity. See GCS Bucket ACL documentation  for more details. Must be set if predefined_acl is not.
   *
   * @schema BucketAclSpecForProvider#roleEntity
   */
  readonly roleEntity?: string[];

}

/**
 * Converts an object of type 'BucketAclSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProvider(obj: BucketAclSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketAclSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketAclSpecForProviderBucketSelector(obj.bucketSelector),
    'defaultAcl': obj.defaultAcl,
    'predefinedAcl': obj.predefinedAcl,
    'roleEntity': obj.roleEntity?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema BucketAclSpecInitProvider
 */
export interface BucketAclSpecInitProvider {
  /**
   * Configure this ACL to be the default ACL.
   *
   * @schema BucketAclSpecInitProvider#defaultAcl
   */
  readonly defaultAcl?: string;

  /**
   * The canned GCS ACL to apply. Must be set if role_entity is not.
   *
   * @schema BucketAclSpecInitProvider#predefinedAcl
   */
  readonly predefinedAcl?: string;

  /**
   * List of role/entity pairs in the form ROLE:entity. See GCS Bucket ACL documentation  for more details. Must be set if predefined_acl is not.
   *
   * @schema BucketAclSpecInitProvider#roleEntity
   */
  readonly roleEntity?: string[];

}

/**
 * Converts an object of type 'BucketAclSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecInitProvider(obj: BucketAclSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultAcl': obj.defaultAcl,
    'predefinedAcl': obj.predefinedAcl,
    'roleEntity': obj.roleEntity?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema BucketAclSpecManagementPolicies
 */
export enum BucketAclSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketAclSpecProviderConfigRef
 */
export interface BucketAclSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAclSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAclSpecProviderConfigRef#policy
   */
  readonly policy?: BucketAclSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketAclSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecProviderConfigRef(obj: BucketAclSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAclSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketAclSpecPublishConnectionDetailsTo
 */
export interface BucketAclSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketAclSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketAclSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketAclSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketAclSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketAclSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketAclSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecPublishConnectionDetailsTo(obj: BucketAclSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketAclSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketAclSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketAclSpecWriteConnectionSecretToRef
 */
export interface BucketAclSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketAclSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketAclSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketAclSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecWriteConnectionSecretToRef(obj: BucketAclSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema BucketAclSpecForProviderBucketRef
 */
export interface BucketAclSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAclSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAclSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketAclSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketAclSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProviderBucketRef(obj: BucketAclSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAclSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema BucketAclSpecForProviderBucketSelector
 */
export interface BucketAclSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketAclSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketAclSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketAclSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketAclSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketAclSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProviderBucketSelector(obj: BucketAclSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketAclSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAclSpecProviderConfigRefPolicy
 */
export interface BucketAclSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAclSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketAclSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAclSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketAclSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAclSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecProviderConfigRefPolicy(obj: BucketAclSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketAclSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketAclSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketAclSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketAclSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecPublishConnectionDetailsToConfigRef(obj: BucketAclSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAclSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketAclSpecPublishConnectionDetailsToMetadata
 */
export interface BucketAclSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketAclSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecPublishConnectionDetailsToMetadata(obj: BucketAclSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAclSpecForProviderBucketRefPolicy
 */
export interface BucketAclSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAclSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketAclSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAclSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketAclSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAclSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProviderBucketRefPolicy(obj: BucketAclSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketAclSpecForProviderBucketSelectorPolicy
 */
export interface BucketAclSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAclSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketAclSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAclSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketAclSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketAclSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProviderBucketSelectorPolicy(obj: BucketAclSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAclSpecProviderConfigRefPolicyResolution
 */
export enum BucketAclSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAclSpecProviderConfigRefPolicyResolve
 */
export enum BucketAclSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketAclSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketAclSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAclSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketAclSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAclSpecForProviderBucketRefPolicyResolution
 */
export enum BucketAclSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAclSpecForProviderBucketRefPolicyResolve
 */
export enum BucketAclSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAclSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketAclSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAclSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketAclSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketIAMMember is the Schema for the BucketIAMMembers API. <no value>
 *
 * @schema BucketIAMMember
 */
export class BucketIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'BucketIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "BucketIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketIamMemberProps): any {
    return {
      ...BucketIamMember.GVK,
      ...toJson_BucketIamMemberProps(props),
    };
  }

  /**
   * Defines a "BucketIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketIamMemberProps) {
    super(scope, id, {
      ...BucketIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketIamMember.GVK,
      ...toJson_BucketIamMemberProps(resolved),
    };
  }
}

/**
 * BucketIAMMember is the Schema for the BucketIAMMembers API. <no value>
 *
 * @schema BucketIAMMember
 */
export interface BucketIamMemberProps {
  /**
   * @schema BucketIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketIAMMemberSpec defines the desired state of BucketIAMMember
   *
   * @schema BucketIAMMember#spec
   */
  readonly spec: BucketIamMemberSpec;

}

/**
 * Converts an object of type 'BucketIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberProps(obj: BucketIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketIAMMemberSpec defines the desired state of BucketIAMMember
 *
 * @schema BucketIamMemberSpec
 */
export interface BucketIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BucketIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketIamMemberSpecDeletionPolicy;

  /**
   * @schema BucketIamMemberSpec#forProvider
   */
  readonly forProvider: BucketIamMemberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema BucketIamMemberSpec#initProvider
   */
  readonly initProvider?: BucketIamMemberSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BucketIamMemberSpec#managementPolicies
   */
  readonly managementPolicies?: BucketIamMemberSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketIamMemberSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpec(obj: BucketIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketIamMemberSpecForProvider(obj.forProvider),
    'initProvider': toJson_BucketIamMemberSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BucketIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_BucketIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BucketIamMemberSpecDeletionPolicy
 */
export enum BucketIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketIamMemberSpecForProvider
 */
export interface BucketIamMemberSpecForProvider {
  /**
   * @schema BucketIamMemberSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket to populate bucket.
   *
   * @schema BucketIamMemberSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketIamMemberSpecForProviderBucketRef;

  /**
   * Selector for a Bucket to populate bucket.
   *
   * @schema BucketIamMemberSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketIamMemberSpecForProviderBucketSelector;

  /**
   * @schema BucketIamMemberSpecForProvider#condition
   */
  readonly condition?: BucketIamMemberSpecForProviderCondition[];

  /**
   * @schema BucketIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema BucketIamMemberSpecForProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'BucketIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecForProvider(obj: BucketIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketIamMemberSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketIamMemberSpecForProviderBucketSelector(obj.bucketSelector),
    'condition': obj.condition?.map(y => toJson_BucketIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema BucketIamMemberSpecInitProvider
 */
export interface BucketIamMemberSpecInitProvider {
  /**
   * @schema BucketIamMemberSpecInitProvider#condition
   */
  readonly condition?: BucketIamMemberSpecInitProviderCondition[];

  /**
   * @schema BucketIamMemberSpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema BucketIamMemberSpecInitProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'BucketIamMemberSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecInitProvider(obj: BucketIamMemberSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_BucketIamMemberSpecInitProviderCondition(y)),
    'member': obj.member,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema BucketIamMemberSpecManagementPolicies
 */
export enum BucketIamMemberSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketIamMemberSpecProviderConfigRef
 */
export interface BucketIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: BucketIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecProviderConfigRef(obj: BucketIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketIamMemberSpecPublishConnectionDetailsTo
 */
export interface BucketIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecPublishConnectionDetailsTo(obj: BucketIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketIamMemberSpecWriteConnectionSecretToRef
 */
export interface BucketIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecWriteConnectionSecretToRef(obj: BucketIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket to populate bucket.
 *
 * @schema BucketIamMemberSpecForProviderBucketRef
 */
export interface BucketIamMemberSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketIamMemberSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketIamMemberSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketIamMemberSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketIamMemberSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecForProviderBucketRef(obj: BucketIamMemberSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketIamMemberSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket to populate bucket.
 *
 * @schema BucketIamMemberSpecForProviderBucketSelector
 */
export interface BucketIamMemberSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketIamMemberSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketIamMemberSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketIamMemberSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketIamMemberSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketIamMemberSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecForProviderBucketSelector(obj: BucketIamMemberSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketIamMemberSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketIamMemberSpecForProviderCondition
 */
export interface BucketIamMemberSpecForProviderCondition {
  /**
   * @schema BucketIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema BucketIamMemberSpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema BucketIamMemberSpecForProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'BucketIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecForProviderCondition(obj: BucketIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketIamMemberSpecInitProviderCondition
 */
export interface BucketIamMemberSpecInitProviderCondition {
  /**
   * @schema BucketIamMemberSpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema BucketIamMemberSpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema BucketIamMemberSpecInitProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'BucketIamMemberSpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecInitProviderCondition(obj: BucketIamMemberSpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketIamMemberSpecProviderConfigRefPolicy
 */
export interface BucketIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecProviderConfigRefPolicy(obj: BucketIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecPublishConnectionDetailsToConfigRef(obj: BucketIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface BucketIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecPublishConnectionDetailsToMetadata(obj: BucketIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketIamMemberSpecForProviderBucketRefPolicy
 */
export interface BucketIamMemberSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketIamMemberSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketIamMemberSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketIamMemberSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketIamMemberSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecForProviderBucketRefPolicy(obj: BucketIamMemberSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketIamMemberSpecForProviderBucketSelectorPolicy
 */
export interface BucketIamMemberSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketIamMemberSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketIamMemberSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketIamMemberSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketIamMemberSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecForProviderBucketSelectorPolicy(obj: BucketIamMemberSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum BucketIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum BucketIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberSpecForProviderBucketRefPolicyResolution
 */
export enum BucketIamMemberSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketIamMemberSpecForProviderBucketRefPolicyResolve
 */
export enum BucketIamMemberSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketIamMemberSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketIamMemberSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketIamMemberSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketObject is the Schema for the BucketObjects API. Creates a new object inside a specified bucket
 *
 * @schema BucketObject
 */
export class BucketObject extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketObject"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'BucketObject',
  }

  /**
   * Renders a Kubernetes manifest for "BucketObject".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketObjectProps): any {
    return {
      ...BucketObject.GVK,
      ...toJson_BucketObjectProps(props),
    };
  }

  /**
   * Defines a "BucketObject" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketObjectProps) {
    super(scope, id, {
      ...BucketObject.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketObject.GVK,
      ...toJson_BucketObjectProps(resolved),
    };
  }
}

/**
 * BucketObject is the Schema for the BucketObjects API. Creates a new object inside a specified bucket
 *
 * @schema BucketObject
 */
export interface BucketObjectProps {
  /**
   * @schema BucketObject#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketObjectSpec defines the desired state of BucketObject
   *
   * @schema BucketObject#spec
   */
  readonly spec: BucketObjectSpec;

}

/**
 * Converts an object of type 'BucketObjectProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectProps(obj: BucketObjectProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketObjectSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketObjectSpec defines the desired state of BucketObject
 *
 * @schema BucketObjectSpec
 */
export interface BucketObjectSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BucketObjectSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketObjectSpecDeletionPolicy;

  /**
   * @schema BucketObjectSpec#forProvider
   */
  readonly forProvider: BucketObjectSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema BucketObjectSpec#initProvider
   */
  readonly initProvider?: BucketObjectSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BucketObjectSpec#managementPolicies
   */
  readonly managementPolicies?: BucketObjectSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketObjectSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketObjectSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketObjectSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketObjectSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketObjectSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketObjectSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketObjectSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpec(obj: BucketObjectSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketObjectSpecForProvider(obj.forProvider),
    'initProvider': toJson_BucketObjectSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BucketObjectSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_BucketObjectSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketObjectSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BucketObjectSpecDeletionPolicy
 */
export enum BucketObjectSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketObjectSpecForProvider
 */
export interface BucketObjectSpecForProvider {
  /**
   * The name of the containing bucket.
   *
   * @schema BucketObjectSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket to populate bucket.
   *
   * @schema BucketObjectSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketObjectSpecForProviderBucketRef;

  /**
   * Selector for a Bucket to populate bucket.
   *
   * @schema BucketObjectSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketObjectSpecForProviderBucketSelector;

  /**
   * Cache-Control directive to specify caching behavior of object data. If omitted and object is accessible to all anonymous users, the default will be public, max-age=3600
   *
   * @schema BucketObjectSpecForProvider#cacheControl
   */
  readonly cacheControl?: string;

  /**
   * Data as string to be uploaded. Must be defined if source is not. Note: The content field is marked as sensitive. To view the raw contents of the object, please define an output.
   *
   * @schema BucketObjectSpecForProvider#content
   */
  readonly content?: string;

  /**
   * Content-Disposition of the object data.
   *
   * @schema BucketObjectSpecForProvider#contentDisposition
   */
  readonly contentDisposition?: string;

  /**
   * Content-Encoding of the object data.
   *
   * @schema BucketObjectSpecForProvider#contentEncoding
   */
  readonly contentEncoding?: string;

  /**
   * Content-Language of the object data.
   *
   * @schema BucketObjectSpecForProvider#contentLanguage
   */
  readonly contentLanguage?: string;

  /**
   * Content-Type of the object data. Defaults to "application/octet-stream" or "text/plain; charset=utf-8".
   *
   * @default application/octet-stream" or "text/plain; charset=utf-8".
   * @schema BucketObjectSpecForProvider#contentType
   */
  readonly contentType?: string;

  /**
   * Enables object encryption with Customer-Supplied Encryption Key (CSEK). [Google documentation about CSEK.](https://cloud.google.com/storage/docs/encryption/customer-supplied-keys) Structure is documented below.
   *
   * @schema BucketObjectSpecForProvider#customerEncryption
   */
  readonly customerEncryption?: BucketObjectSpecForProviderCustomerEncryption[];

  /**
   * MD5 hash of the data, encoded using base64. This field is not present for composite objects. For more information about using the MD5 hash, see Hashes and ETags: Best Practices.
   *
   * @schema BucketObjectSpecForProvider#detectMd5Hash
   */
  readonly detectMd5Hash?: string;

  /**
   * Whether an object is under event-based hold. Event-based hold is a way to retain objects until an event occurs, which is signified by the hold's release (i.e. this value is set to false). After being released (set to false), such objects will be subject to bucket-level retention (if any).
   *
   * @schema BucketObjectSpecForProvider#eventBasedHold
   */
  readonly eventBasedHold?: boolean;

  /**
   * The resource name of the Cloud KMS key that will be used to encrypt the object.
   *
   * @schema BucketObjectSpecForProvider#kmsKeyName
   */
  readonly kmsKeyName?: string;

  /**
   * User-provided metadata, in key/value pairs.
   *
   * @schema BucketObjectSpecForProvider#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * The name of the object. If you're interpolating the name of this object, see output_name instead.
   *
   * @schema BucketObjectSpecForProvider#name
   */
  readonly name?: string;

  /**
   * A path to the data you want to upload. Must be defined if content is not.
   *
   * @schema BucketObjectSpecForProvider#source
   */
  readonly source?: string;

  /**
   * The StorageClass of the new bucket object. Supported values include: MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE. If not provided, this defaults to the bucket's default storage class or to a standard class.
   *
   * @schema BucketObjectSpecForProvider#storageClass
   */
  readonly storageClass?: string;

  /**
   * Whether an object is under temporary hold. While this flag is set to true, the object is protected against deletion and overwrites.
   *
   * @schema BucketObjectSpecForProvider#temporaryHold
   */
  readonly temporaryHold?: boolean;

}

/**
 * Converts an object of type 'BucketObjectSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProvider(obj: BucketObjectSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketObjectSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketObjectSpecForProviderBucketSelector(obj.bucketSelector),
    'cacheControl': obj.cacheControl,
    'content': obj.content,
    'contentDisposition': obj.contentDisposition,
    'contentEncoding': obj.contentEncoding,
    'contentLanguage': obj.contentLanguage,
    'contentType': obj.contentType,
    'customerEncryption': obj.customerEncryption?.map(y => toJson_BucketObjectSpecForProviderCustomerEncryption(y)),
    'detectMd5Hash': obj.detectMd5Hash,
    'eventBasedHold': obj.eventBasedHold,
    'kmsKeyName': obj.kmsKeyName,
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'source': obj.source,
    'storageClass': obj.storageClass,
    'temporaryHold': obj.temporaryHold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema BucketObjectSpecInitProvider
 */
export interface BucketObjectSpecInitProvider {
  /**
   * Cache-Control directive to specify caching behavior of object data. If omitted and object is accessible to all anonymous users, the default will be public, max-age=3600
   *
   * @schema BucketObjectSpecInitProvider#cacheControl
   */
  readonly cacheControl?: string;

  /**
   * Data as string to be uploaded. Must be defined if source is not. Note: The content field is marked as sensitive. To view the raw contents of the object, please define an output.
   *
   * @schema BucketObjectSpecInitProvider#content
   */
  readonly content?: string;

  /**
   * Content-Disposition of the object data.
   *
   * @schema BucketObjectSpecInitProvider#contentDisposition
   */
  readonly contentDisposition?: string;

  /**
   * Content-Encoding of the object data.
   *
   * @schema BucketObjectSpecInitProvider#contentEncoding
   */
  readonly contentEncoding?: string;

  /**
   * Content-Language of the object data.
   *
   * @schema BucketObjectSpecInitProvider#contentLanguage
   */
  readonly contentLanguage?: string;

  /**
   * Content-Type of the object data. Defaults to "application/octet-stream" or "text/plain; charset=utf-8".
   *
   * @default application/octet-stream" or "text/plain; charset=utf-8".
   * @schema BucketObjectSpecInitProvider#contentType
   */
  readonly contentType?: string;

  /**
   * Enables object encryption with Customer-Supplied Encryption Key (CSEK). [Google documentation about CSEK.](https://cloud.google.com/storage/docs/encryption/customer-supplied-keys) Structure is documented below.
   *
   * @schema BucketObjectSpecInitProvider#customerEncryption
   */
  readonly customerEncryption?: BucketObjectSpecInitProviderCustomerEncryption[];

  /**
   * MD5 hash of the data, encoded using base64. This field is not present for composite objects. For more information about using the MD5 hash, see Hashes and ETags: Best Practices.
   *
   * @schema BucketObjectSpecInitProvider#detectMd5Hash
   */
  readonly detectMd5Hash?: string;

  /**
   * Whether an object is under event-based hold. Event-based hold is a way to retain objects until an event occurs, which is signified by the hold's release (i.e. this value is set to false). After being released (set to false), such objects will be subject to bucket-level retention (if any).
   *
   * @schema BucketObjectSpecInitProvider#eventBasedHold
   */
  readonly eventBasedHold?: boolean;

  /**
   * The resource name of the Cloud KMS key that will be used to encrypt the object.
   *
   * @schema BucketObjectSpecInitProvider#kmsKeyName
   */
  readonly kmsKeyName?: string;

  /**
   * User-provided metadata, in key/value pairs.
   *
   * @schema BucketObjectSpecInitProvider#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * The name of the object. If you're interpolating the name of this object, see output_name instead.
   *
   * @schema BucketObjectSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * A path to the data you want to upload. Must be defined if content is not.
   *
   * @schema BucketObjectSpecInitProvider#source
   */
  readonly source?: string;

  /**
   * The StorageClass of the new bucket object. Supported values include: MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE. If not provided, this defaults to the bucket's default storage class or to a standard class.
   *
   * @schema BucketObjectSpecInitProvider#storageClass
   */
  readonly storageClass?: string;

  /**
   * Whether an object is under temporary hold. While this flag is set to true, the object is protected against deletion and overwrites.
   *
   * @schema BucketObjectSpecInitProvider#temporaryHold
   */
  readonly temporaryHold?: boolean;

}

/**
 * Converts an object of type 'BucketObjectSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecInitProvider(obj: BucketObjectSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cacheControl': obj.cacheControl,
    'content': obj.content,
    'contentDisposition': obj.contentDisposition,
    'contentEncoding': obj.contentEncoding,
    'contentLanguage': obj.contentLanguage,
    'contentType': obj.contentType,
    'customerEncryption': obj.customerEncryption?.map(y => toJson_BucketObjectSpecInitProviderCustomerEncryption(y)),
    'detectMd5Hash': obj.detectMd5Hash,
    'eventBasedHold': obj.eventBasedHold,
    'kmsKeyName': obj.kmsKeyName,
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'source': obj.source,
    'storageClass': obj.storageClass,
    'temporaryHold': obj.temporaryHold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema BucketObjectSpecManagementPolicies
 */
export enum BucketObjectSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketObjectSpecProviderConfigRef
 */
export interface BucketObjectSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketObjectSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketObjectSpecProviderConfigRef#policy
   */
  readonly policy?: BucketObjectSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketObjectSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecProviderConfigRef(obj: BucketObjectSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketObjectSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsTo
 */
export interface BucketObjectSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketObjectSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketObjectSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketObjectSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecPublishConnectionDetailsTo(obj: BucketObjectSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketObjectSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketObjectSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketObjectSpecWriteConnectionSecretToRef
 */
export interface BucketObjectSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketObjectSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketObjectSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketObjectSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecWriteConnectionSecretToRef(obj: BucketObjectSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket to populate bucket.
 *
 * @schema BucketObjectSpecForProviderBucketRef
 */
export interface BucketObjectSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketObjectSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketObjectSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketObjectSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderBucketRef(obj: BucketObjectSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketObjectSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket to populate bucket.
 *
 * @schema BucketObjectSpecForProviderBucketSelector
 */
export interface BucketObjectSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketObjectSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketObjectSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketObjectSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketObjectSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderBucketSelector(obj: BucketObjectSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketObjectSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketObjectSpecForProviderCustomerEncryption
 */
export interface BucketObjectSpecForProviderCustomerEncryption {
  /**
   * Encryption algorithm. Default: AES256
   *
   * @schema BucketObjectSpecForProviderCustomerEncryption#encryptionAlgorithm
   */
  readonly encryptionAlgorithm?: string;

  /**
   * Base64 encoded Customer-Supplied Encryption Key.
   *
   * @schema BucketObjectSpecForProviderCustomerEncryption#encryptionKeySecretRef
   */
  readonly encryptionKeySecretRef: BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderCustomerEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderCustomerEncryption(obj: BucketObjectSpecForProviderCustomerEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionAlgorithm': obj.encryptionAlgorithm,
    'encryptionKeySecretRef': toJson_BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef(obj.encryptionKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketObjectSpecInitProviderCustomerEncryption
 */
export interface BucketObjectSpecInitProviderCustomerEncryption {
  /**
   * Encryption algorithm. Default: AES256
   *
   * @schema BucketObjectSpecInitProviderCustomerEncryption#encryptionAlgorithm
   */
  readonly encryptionAlgorithm?: string;

}

/**
 * Converts an object of type 'BucketObjectSpecInitProviderCustomerEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecInitProviderCustomerEncryption(obj: BucketObjectSpecInitProviderCustomerEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionAlgorithm': obj.encryptionAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketObjectSpecProviderConfigRefPolicy
 */
export interface BucketObjectSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketObjectSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketObjectSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecProviderConfigRefPolicy(obj: BucketObjectSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketObjectSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketObjectSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecPublishConnectionDetailsToConfigRef(obj: BucketObjectSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsToMetadata
 */
export interface BucketObjectSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketObjectSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecPublishConnectionDetailsToMetadata(obj: BucketObjectSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketObjectSpecForProviderBucketRefPolicy
 */
export interface BucketObjectSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketObjectSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketObjectSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderBucketRefPolicy(obj: BucketObjectSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketObjectSpecForProviderBucketSelectorPolicy
 */
export interface BucketObjectSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketObjectSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketObjectSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderBucketSelectorPolicy(obj: BucketObjectSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Base64 encoded Customer-Supplied Encryption Key.
 *
 * @schema BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef
 */
export interface BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef {
  /**
   * The key to select.
   *
   * @schema BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef(obj: BucketObjectSpecForProviderCustomerEncryptionEncryptionKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectSpecProviderConfigRefPolicyResolution
 */
export enum BucketObjectSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectSpecProviderConfigRefPolicyResolve
 */
export enum BucketObjectSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectSpecForProviderBucketRefPolicyResolution
 */
export enum BucketObjectSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectSpecForProviderBucketRefPolicyResolve
 */
export enum BucketObjectSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketObjectSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketObjectSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DefaultObjectAccessControl is the Schema for the DefaultObjectAccessControls API. The DefaultObjectAccessControls resources represent the Access Control Lists (ACLs) applied to a new object within a Google Cloud Storage bucket when no ACL was provided for that object.
 *
 * @schema DefaultObjectAccessControl
 */
export class DefaultObjectAccessControl extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DefaultObjectAccessControl"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'DefaultObjectAccessControl',
  }

  /**
   * Renders a Kubernetes manifest for "DefaultObjectAccessControl".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DefaultObjectAccessControlProps): any {
    return {
      ...DefaultObjectAccessControl.GVK,
      ...toJson_DefaultObjectAccessControlProps(props),
    };
  }

  /**
   * Defines a "DefaultObjectAccessControl" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DefaultObjectAccessControlProps) {
    super(scope, id, {
      ...DefaultObjectAccessControl.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DefaultObjectAccessControl.GVK,
      ...toJson_DefaultObjectAccessControlProps(resolved),
    };
  }
}

/**
 * DefaultObjectAccessControl is the Schema for the DefaultObjectAccessControls API. The DefaultObjectAccessControls resources represent the Access Control Lists (ACLs) applied to a new object within a Google Cloud Storage bucket when no ACL was provided for that object.
 *
 * @schema DefaultObjectAccessControl
 */
export interface DefaultObjectAccessControlProps {
  /**
   * @schema DefaultObjectAccessControl#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DefaultObjectAccessControlSpec defines the desired state of DefaultObjectAccessControl
   *
   * @schema DefaultObjectAccessControl#spec
   */
  readonly spec: DefaultObjectAccessControlSpec;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlProps(obj: DefaultObjectAccessControlProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DefaultObjectAccessControlSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DefaultObjectAccessControlSpec defines the desired state of DefaultObjectAccessControl
 *
 * @schema DefaultObjectAccessControlSpec
 */
export interface DefaultObjectAccessControlSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DefaultObjectAccessControlSpec#deletionPolicy
   */
  readonly deletionPolicy?: DefaultObjectAccessControlSpecDeletionPolicy;

  /**
   * @schema DefaultObjectAccessControlSpec#forProvider
   */
  readonly forProvider: DefaultObjectAccessControlSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DefaultObjectAccessControlSpec#initProvider
   */
  readonly initProvider?: DefaultObjectAccessControlSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DefaultObjectAccessControlSpec#managementPolicies
   */
  readonly managementPolicies?: DefaultObjectAccessControlSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DefaultObjectAccessControlSpec#providerConfigRef
   */
  readonly providerConfigRef?: DefaultObjectAccessControlSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DefaultObjectAccessControlSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DefaultObjectAccessControlSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DefaultObjectAccessControlSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DefaultObjectAccessControlSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpec(obj: DefaultObjectAccessControlSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DefaultObjectAccessControlSpecForProvider(obj.forProvider),
    'initProvider': toJson_DefaultObjectAccessControlSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DefaultObjectAccessControlSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DefaultObjectAccessControlSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DefaultObjectAccessControlSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DefaultObjectAccessControlSpecDeletionPolicy
 */
export enum DefaultObjectAccessControlSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DefaultObjectAccessControlSpecForProvider
 */
export interface DefaultObjectAccessControlSpecForProvider {
  /**
   * The name of the bucket.
   *
   * @schema DefaultObjectAccessControlSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema DefaultObjectAccessControlSpecForProvider#bucketRef
   */
  readonly bucketRef?: DefaultObjectAccessControlSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema DefaultObjectAccessControlSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: DefaultObjectAccessControlSpecForProviderBucketSelector;

  /**
   * The entity holding the permission, in one of the following forms:
   *
   * @schema DefaultObjectAccessControlSpecForProvider#entity
   */
  readonly entity?: string;

  /**
   * The name of the object, if applied to an object.
   *
   * @schema DefaultObjectAccessControlSpecForProvider#object
   */
  readonly object?: string;

  /**
   * The access permission for the entity. Possible values are: OWNER, READER.
   *
   * @schema DefaultObjectAccessControlSpecForProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecForProvider(obj: DefaultObjectAccessControlSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_DefaultObjectAccessControlSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_DefaultObjectAccessControlSpecForProviderBucketSelector(obj.bucketSelector),
    'entity': obj.entity,
    'object': obj.object,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DefaultObjectAccessControlSpecInitProvider
 */
export interface DefaultObjectAccessControlSpecInitProvider {
  /**
   * The entity holding the permission, in one of the following forms:
   *
   * @schema DefaultObjectAccessControlSpecInitProvider#entity
   */
  readonly entity?: string;

  /**
   * The name of the object, if applied to an object.
   *
   * @schema DefaultObjectAccessControlSpecInitProvider#object
   */
  readonly object?: string;

  /**
   * The access permission for the entity. Possible values are: OWNER, READER.
   *
   * @schema DefaultObjectAccessControlSpecInitProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecInitProvider(obj: DefaultObjectAccessControlSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entity': obj.entity,
    'object': obj.object,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DefaultObjectAccessControlSpecManagementPolicies
 */
export enum DefaultObjectAccessControlSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DefaultObjectAccessControlSpecProviderConfigRef
 */
export interface DefaultObjectAccessControlSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultObjectAccessControlSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultObjectAccessControlSpecProviderConfigRef#policy
   */
  readonly policy?: DefaultObjectAccessControlSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecProviderConfigRef(obj: DefaultObjectAccessControlSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultObjectAccessControlSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsTo
 */
export interface DefaultObjectAccessControlSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecPublishConnectionDetailsTo(obj: DefaultObjectAccessControlSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DefaultObjectAccessControlSpecWriteConnectionSecretToRef
 */
export interface DefaultObjectAccessControlSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DefaultObjectAccessControlSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DefaultObjectAccessControlSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecWriteConnectionSecretToRef(obj: DefaultObjectAccessControlSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema DefaultObjectAccessControlSpecForProviderBucketRef
 */
export interface DefaultObjectAccessControlSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketRef#policy
   */
  readonly policy?: DefaultObjectAccessControlSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecForProviderBucketRef(obj: DefaultObjectAccessControlSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultObjectAccessControlSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema DefaultObjectAccessControlSpecForProviderBucketSelector
 */
export interface DefaultObjectAccessControlSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketSelector#policy
   */
  readonly policy?: DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecForProviderBucketSelector(obj: DefaultObjectAccessControlSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DefaultObjectAccessControlSpecProviderConfigRefPolicy
 */
export interface DefaultObjectAccessControlSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAccessControlSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DefaultObjectAccessControlSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAccessControlSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DefaultObjectAccessControlSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecProviderConfigRefPolicy(obj: DefaultObjectAccessControlSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef
 */
export interface DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef(obj: DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata
 */
export interface DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata(obj: DefaultObjectAccessControlSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DefaultObjectAccessControlSpecForProviderBucketRefPolicy
 */
export interface DefaultObjectAccessControlSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: DefaultObjectAccessControlSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: DefaultObjectAccessControlSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecForProviderBucketRefPolicy(obj: DefaultObjectAccessControlSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy
 */
export interface DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: DefaultObjectAccessControlSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: DefaultObjectAccessControlSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy(obj: DefaultObjectAccessControlSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAccessControlSpecProviderConfigRefPolicyResolution
 */
export enum DefaultObjectAccessControlSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAccessControlSpecProviderConfigRefPolicyResolve
 */
export enum DefaultObjectAccessControlSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy(obj: DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAccessControlSpecForProviderBucketRefPolicyResolution
 */
export enum DefaultObjectAccessControlSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAccessControlSpecForProviderBucketRefPolicyResolve
 */
export enum DefaultObjectAccessControlSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAccessControlSpecForProviderBucketSelectorPolicyResolution
 */
export enum DefaultObjectAccessControlSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAccessControlSpecForProviderBucketSelectorPolicyResolve
 */
export enum DefaultObjectAccessControlSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DefaultObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DefaultObjectACL is the Schema for the DefaultObjectACLs API. Authoritatively manages the default object ACLs for a Google Cloud Storage bucket
 *
 * @schema DefaultObjectACL
 */
export class DefaultObjectAcl extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DefaultObjectACL"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'DefaultObjectACL',
  }

  /**
   * Renders a Kubernetes manifest for "DefaultObjectACL".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DefaultObjectAclProps): any {
    return {
      ...DefaultObjectAcl.GVK,
      ...toJson_DefaultObjectAclProps(props),
    };
  }

  /**
   * Defines a "DefaultObjectACL" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DefaultObjectAclProps) {
    super(scope, id, {
      ...DefaultObjectAcl.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DefaultObjectAcl.GVK,
      ...toJson_DefaultObjectAclProps(resolved),
    };
  }
}

/**
 * DefaultObjectACL is the Schema for the DefaultObjectACLs API. Authoritatively manages the default object ACLs for a Google Cloud Storage bucket
 *
 * @schema DefaultObjectACL
 */
export interface DefaultObjectAclProps {
  /**
   * @schema DefaultObjectACL#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DefaultObjectACLSpec defines the desired state of DefaultObjectACL
   *
   * @schema DefaultObjectACL#spec
   */
  readonly spec: DefaultObjectAclSpec;

}

/**
 * Converts an object of type 'DefaultObjectAclProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclProps(obj: DefaultObjectAclProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DefaultObjectAclSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DefaultObjectACLSpec defines the desired state of DefaultObjectACL
 *
 * @schema DefaultObjectAclSpec
 */
export interface DefaultObjectAclSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DefaultObjectAclSpec#deletionPolicy
   */
  readonly deletionPolicy?: DefaultObjectAclSpecDeletionPolicy;

  /**
   * @schema DefaultObjectAclSpec#forProvider
   */
  readonly forProvider: DefaultObjectAclSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DefaultObjectAclSpec#initProvider
   */
  readonly initProvider?: DefaultObjectAclSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DefaultObjectAclSpec#managementPolicies
   */
  readonly managementPolicies?: DefaultObjectAclSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DefaultObjectAclSpec#providerConfigRef
   */
  readonly providerConfigRef?: DefaultObjectAclSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DefaultObjectAclSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DefaultObjectAclSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DefaultObjectAclSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DefaultObjectAclSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DefaultObjectAclSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpec(obj: DefaultObjectAclSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DefaultObjectAclSpecForProvider(obj.forProvider),
    'initProvider': toJson_DefaultObjectAclSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DefaultObjectAclSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DefaultObjectAclSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DefaultObjectAclSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DefaultObjectAclSpecDeletionPolicy
 */
export enum DefaultObjectAclSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DefaultObjectAclSpecForProvider
 */
export interface DefaultObjectAclSpecForProvider {
  /**
   * The name of the bucket it applies to.
   *
   * @schema DefaultObjectAclSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema DefaultObjectAclSpecForProvider#bucketRef
   */
  readonly bucketRef?: DefaultObjectAclSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema DefaultObjectAclSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: DefaultObjectAclSpecForProviderBucketSelector;

  /**
   * List of role/entity pairs in the form ROLE:entity. See GCS Object ACL documentation for more details. Omitting the field is the same as providing an empty list.
   *
   * @schema DefaultObjectAclSpecForProvider#roleEntity
   */
  readonly roleEntity?: string[];

}

/**
 * Converts an object of type 'DefaultObjectAclSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecForProvider(obj: DefaultObjectAclSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_DefaultObjectAclSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_DefaultObjectAclSpecForProviderBucketSelector(obj.bucketSelector),
    'roleEntity': obj.roleEntity?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DefaultObjectAclSpecInitProvider
 */
export interface DefaultObjectAclSpecInitProvider {
  /**
   * List of role/entity pairs in the form ROLE:entity. See GCS Object ACL documentation for more details. Omitting the field is the same as providing an empty list.
   *
   * @schema DefaultObjectAclSpecInitProvider#roleEntity
   */
  readonly roleEntity?: string[];

}

/**
 * Converts an object of type 'DefaultObjectAclSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecInitProvider(obj: DefaultObjectAclSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'roleEntity': obj.roleEntity?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DefaultObjectAclSpecManagementPolicies
 */
export enum DefaultObjectAclSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DefaultObjectAclSpecProviderConfigRef
 */
export interface DefaultObjectAclSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultObjectAclSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultObjectAclSpecProviderConfigRef#policy
   */
  readonly policy?: DefaultObjectAclSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecProviderConfigRef(obj: DefaultObjectAclSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultObjectAclSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DefaultObjectAclSpecPublishConnectionDetailsTo
 */
export interface DefaultObjectAclSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DefaultObjectAclSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DefaultObjectAclSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecPublishConnectionDetailsTo(obj: DefaultObjectAclSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DefaultObjectAclSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DefaultObjectAclSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DefaultObjectAclSpecWriteConnectionSecretToRef
 */
export interface DefaultObjectAclSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DefaultObjectAclSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DefaultObjectAclSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecWriteConnectionSecretToRef(obj: DefaultObjectAclSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema DefaultObjectAclSpecForProviderBucketRef
 */
export interface DefaultObjectAclSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultObjectAclSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultObjectAclSpecForProviderBucketRef#policy
   */
  readonly policy?: DefaultObjectAclSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecForProviderBucketRef(obj: DefaultObjectAclSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultObjectAclSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema DefaultObjectAclSpecForProviderBucketSelector
 */
export interface DefaultObjectAclSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DefaultObjectAclSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DefaultObjectAclSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DefaultObjectAclSpecForProviderBucketSelector#policy
   */
  readonly policy?: DefaultObjectAclSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecForProviderBucketSelector(obj: DefaultObjectAclSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DefaultObjectAclSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DefaultObjectAclSpecProviderConfigRefPolicy
 */
export interface DefaultObjectAclSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAclSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DefaultObjectAclSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAclSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DefaultObjectAclSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecProviderConfigRefPolicy(obj: DefaultObjectAclSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DefaultObjectAclSpecPublishConnectionDetailsToConfigRef
 */
export interface DefaultObjectAclSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecPublishConnectionDetailsToConfigRef(obj: DefaultObjectAclSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DefaultObjectAclSpecPublishConnectionDetailsToMetadata
 */
export interface DefaultObjectAclSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecPublishConnectionDetailsToMetadata(obj: DefaultObjectAclSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DefaultObjectAclSpecForProviderBucketRefPolicy
 */
export interface DefaultObjectAclSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAclSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: DefaultObjectAclSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAclSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: DefaultObjectAclSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecForProviderBucketRefPolicy(obj: DefaultObjectAclSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DefaultObjectAclSpecForProviderBucketSelectorPolicy
 */
export interface DefaultObjectAclSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAclSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: DefaultObjectAclSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAclSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: DefaultObjectAclSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecForProviderBucketSelectorPolicy(obj: DefaultObjectAclSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAclSpecProviderConfigRefPolicyResolution
 */
export enum DefaultObjectAclSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAclSpecProviderConfigRefPolicyResolve
 */
export enum DefaultObjectAclSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy(obj: DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAclSpecForProviderBucketRefPolicyResolution
 */
export enum DefaultObjectAclSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAclSpecForProviderBucketRefPolicyResolve
 */
export enum DefaultObjectAclSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAclSpecForProviderBucketSelectorPolicyResolution
 */
export enum DefaultObjectAclSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAclSpecForProviderBucketSelectorPolicyResolve
 */
export enum DefaultObjectAclSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DefaultObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Notification is the Schema for the Notifications API. Creates a new notification configuration on a specified bucket.
 *
 * @schema Notification
 */
export class Notification extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Notification"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'Notification',
  }

  /**
   * Renders a Kubernetes manifest for "Notification".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NotificationProps): any {
    return {
      ...Notification.GVK,
      ...toJson_NotificationProps(props),
    };
  }

  /**
   * Defines a "Notification" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NotificationProps) {
    super(scope, id, {
      ...Notification.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Notification.GVK,
      ...toJson_NotificationProps(resolved),
    };
  }
}

/**
 * Notification is the Schema for the Notifications API. Creates a new notification configuration on a specified bucket.
 *
 * @schema Notification
 */
export interface NotificationProps {
  /**
   * @schema Notification#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NotificationSpec defines the desired state of Notification
   *
   * @schema Notification#spec
   */
  readonly spec: NotificationSpec;

}

/**
 * Converts an object of type 'NotificationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationProps(obj: NotificationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NotificationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NotificationSpec defines the desired state of Notification
 *
 * @schema NotificationSpec
 */
export interface NotificationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NotificationSpec#deletionPolicy
   */
  readonly deletionPolicy?: NotificationSpecDeletionPolicy;

  /**
   * @schema NotificationSpec#forProvider
   */
  readonly forProvider: NotificationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema NotificationSpec#initProvider
   */
  readonly initProvider?: NotificationSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema NotificationSpec#managementPolicies
   */
  readonly managementPolicies?: NotificationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema NotificationSpec#providerConfigRef
   */
  readonly providerConfigRef?: NotificationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema NotificationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: NotificationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema NotificationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NotificationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'NotificationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpec(obj: NotificationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NotificationSpecForProvider(obj.forProvider),
    'initProvider': toJson_NotificationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_NotificationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_NotificationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_NotificationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NotificationSpecDeletionPolicy
 */
export enum NotificationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema NotificationSpecForProvider
 */
export interface NotificationSpecForProvider {
  /**
   * The name of the bucket.
   *
   * @schema NotificationSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema NotificationSpecForProvider#bucketRef
   */
  readonly bucketRef?: NotificationSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema NotificationSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: NotificationSpecForProviderBucketSelector;

  /**
   * A set of key/value attribute pairs to attach to each Cloud PubSub message published for this notification subscription
   *
   * @schema NotificationSpecForProvider#customAttributes
   */
  readonly customAttributes?: { [key: string]: string };

  /**
   * List of event type filters for this notification config. If not specified, Cloud Storage will send notifications for all event types. The valid types are: "OBJECT_FINALIZE", "OBJECT_METADATA_UPDATE", "OBJECT_DELETE", "OBJECT_ARCHIVE"
   *
   * @schema NotificationSpecForProvider#eventTypes
   */
  readonly eventTypes?: string[];

  /**
   * Specifies a prefix path filter for this notification config. Cloud Storage will only send notifications for objects in this bucket whose names begin with the specified prefix.
   *
   * @schema NotificationSpecForProvider#objectNamePrefix
   */
  readonly objectNamePrefix?: string;

  /**
   * The desired content of the Payload. One of "JSON_API_V1" or "NONE".
   *
   * @schema NotificationSpecForProvider#payloadFormat
   */
  readonly payloadFormat?: string;

  /**
   * The Cloud PubSub topic to which this subscription publishes. Expects either the topic name, assumed to belong to the default GCP provider project, or the project-level name, i.e. projects/my-gcp-project/topics/my-topic or my-topic. If the project is not set in the provider, you will need to use the project-level name.
   *
   * @schema NotificationSpecForProvider#topic
   */
  readonly topic?: string;

  /**
   * Reference to a Topic in pubsub to populate topic.
   *
   * @schema NotificationSpecForProvider#topicRef
   */
  readonly topicRef?: NotificationSpecForProviderTopicRef;

  /**
   * Selector for a Topic in pubsub to populate topic.
   *
   * @schema NotificationSpecForProvider#topicSelector
   */
  readonly topicSelector?: NotificationSpecForProviderTopicSelector;

}

/**
 * Converts an object of type 'NotificationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecForProvider(obj: NotificationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_NotificationSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_NotificationSpecForProviderBucketSelector(obj.bucketSelector),
    'customAttributes': ((obj.customAttributes) === undefined) ? undefined : (Object.entries(obj.customAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'eventTypes': obj.eventTypes?.map(y => y),
    'objectNamePrefix': obj.objectNamePrefix,
    'payloadFormat': obj.payloadFormat,
    'topic': obj.topic,
    'topicRef': toJson_NotificationSpecForProviderTopicRef(obj.topicRef),
    'topicSelector': toJson_NotificationSpecForProviderTopicSelector(obj.topicSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema NotificationSpecInitProvider
 */
export interface NotificationSpecInitProvider {
  /**
   * A set of key/value attribute pairs to attach to each Cloud PubSub message published for this notification subscription
   *
   * @schema NotificationSpecInitProvider#customAttributes
   */
  readonly customAttributes?: { [key: string]: string };

  /**
   * List of event type filters for this notification config. If not specified, Cloud Storage will send notifications for all event types. The valid types are: "OBJECT_FINALIZE", "OBJECT_METADATA_UPDATE", "OBJECT_DELETE", "OBJECT_ARCHIVE"
   *
   * @schema NotificationSpecInitProvider#eventTypes
   */
  readonly eventTypes?: string[];

  /**
   * Specifies a prefix path filter for this notification config. Cloud Storage will only send notifications for objects in this bucket whose names begin with the specified prefix.
   *
   * @schema NotificationSpecInitProvider#objectNamePrefix
   */
  readonly objectNamePrefix?: string;

  /**
   * The desired content of the Payload. One of "JSON_API_V1" or "NONE".
   *
   * @schema NotificationSpecInitProvider#payloadFormat
   */
  readonly payloadFormat?: string;

}

/**
 * Converts an object of type 'NotificationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecInitProvider(obj: NotificationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customAttributes': ((obj.customAttributes) === undefined) ? undefined : (Object.entries(obj.customAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'eventTypes': obj.eventTypes?.map(y => y),
    'objectNamePrefix': obj.objectNamePrefix,
    'payloadFormat': obj.payloadFormat,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema NotificationSpecManagementPolicies
 */
export enum NotificationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema NotificationSpecProviderConfigRef
 */
export interface NotificationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotificationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotificationSpecProviderConfigRef#policy
   */
  readonly policy?: NotificationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'NotificationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecProviderConfigRef(obj: NotificationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotificationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema NotificationSpecPublishConnectionDetailsTo
 */
export interface NotificationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema NotificationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: NotificationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema NotificationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: NotificationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema NotificationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'NotificationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecPublishConnectionDetailsTo(obj: NotificationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_NotificationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_NotificationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema NotificationSpecWriteConnectionSecretToRef
 */
export interface NotificationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NotificationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NotificationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NotificationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecWriteConnectionSecretToRef(obj: NotificationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema NotificationSpecForProviderBucketRef
 */
export interface NotificationSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotificationSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotificationSpecForProviderBucketRef#policy
   */
  readonly policy?: NotificationSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'NotificationSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecForProviderBucketRef(obj: NotificationSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotificationSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema NotificationSpecForProviderBucketSelector
 */
export interface NotificationSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NotificationSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NotificationSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NotificationSpecForProviderBucketSelector#policy
   */
  readonly policy?: NotificationSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'NotificationSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecForProviderBucketSelector(obj: NotificationSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NotificationSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in pubsub to populate topic.
 *
 * @schema NotificationSpecForProviderTopicRef
 */
export interface NotificationSpecForProviderTopicRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotificationSpecForProviderTopicRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotificationSpecForProviderTopicRef#policy
   */
  readonly policy?: NotificationSpecForProviderTopicRefPolicy;

}

/**
 * Converts an object of type 'NotificationSpecForProviderTopicRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecForProviderTopicRef(obj: NotificationSpecForProviderTopicRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotificationSpecForProviderTopicRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in pubsub to populate topic.
 *
 * @schema NotificationSpecForProviderTopicSelector
 */
export interface NotificationSpecForProviderTopicSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NotificationSpecForProviderTopicSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NotificationSpecForProviderTopicSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NotificationSpecForProviderTopicSelector#policy
   */
  readonly policy?: NotificationSpecForProviderTopicSelectorPolicy;

}

/**
 * Converts an object of type 'NotificationSpecForProviderTopicSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecForProviderTopicSelector(obj: NotificationSpecForProviderTopicSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NotificationSpecForProviderTopicSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NotificationSpecProviderConfigRefPolicy
 */
export interface NotificationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NotificationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NotificationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NotificationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecProviderConfigRefPolicy(obj: NotificationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema NotificationSpecPublishConnectionDetailsToConfigRef
 */
export interface NotificationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotificationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotificationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: NotificationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'NotificationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecPublishConnectionDetailsToConfigRef(obj: NotificationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotificationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema NotificationSpecPublishConnectionDetailsToMetadata
 */
export interface NotificationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema NotificationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema NotificationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema NotificationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NotificationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecPublishConnectionDetailsToMetadata(obj: NotificationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NotificationSpecForProviderBucketRefPolicy
 */
export interface NotificationSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: NotificationSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: NotificationSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'NotificationSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecForProviderBucketRefPolicy(obj: NotificationSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NotificationSpecForProviderBucketSelectorPolicy
 */
export interface NotificationSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: NotificationSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: NotificationSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NotificationSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecForProviderBucketSelectorPolicy(obj: NotificationSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NotificationSpecForProviderTopicRefPolicy
 */
export interface NotificationSpecForProviderTopicRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationSpecForProviderTopicRefPolicy#resolution
   */
  readonly resolution?: NotificationSpecForProviderTopicRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationSpecForProviderTopicRefPolicy#resolve
   */
  readonly resolve?: NotificationSpecForProviderTopicRefPolicyResolve;

}

/**
 * Converts an object of type 'NotificationSpecForProviderTopicRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecForProviderTopicRefPolicy(obj: NotificationSpecForProviderTopicRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NotificationSpecForProviderTopicSelectorPolicy
 */
export interface NotificationSpecForProviderTopicSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationSpecForProviderTopicSelectorPolicy#resolution
   */
  readonly resolution?: NotificationSpecForProviderTopicSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationSpecForProviderTopicSelectorPolicy#resolve
   */
  readonly resolve?: NotificationSpecForProviderTopicSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NotificationSpecForProviderTopicSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecForProviderTopicSelectorPolicy(obj: NotificationSpecForProviderTopicSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationSpecProviderConfigRefPolicyResolution
 */
export enum NotificationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationSpecProviderConfigRefPolicyResolve
 */
export enum NotificationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NotificationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface NotificationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: NotificationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: NotificationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NotificationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecPublishConnectionDetailsToConfigRefPolicy(obj: NotificationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationSpecForProviderBucketRefPolicyResolution
 */
export enum NotificationSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationSpecForProviderBucketRefPolicyResolve
 */
export enum NotificationSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationSpecForProviderBucketSelectorPolicyResolution
 */
export enum NotificationSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationSpecForProviderBucketSelectorPolicyResolve
 */
export enum NotificationSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationSpecForProviderTopicRefPolicyResolution
 */
export enum NotificationSpecForProviderTopicRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationSpecForProviderTopicRefPolicyResolve
 */
export enum NotificationSpecForProviderTopicRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationSpecForProviderTopicSelectorPolicyResolution
 */
export enum NotificationSpecForProviderTopicSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationSpecForProviderTopicSelectorPolicyResolve
 */
export enum NotificationSpecForProviderTopicSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum NotificationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum NotificationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ObjectAccessControl is the Schema for the ObjectAccessControls API. The ObjectAccessControls resources represent the Access Control Lists (ACLs) for objects within Google Cloud Storage.
 *
 * @schema ObjectAccessControl
 */
export class ObjectAccessControl extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ObjectAccessControl"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'ObjectAccessControl',
  }

  /**
   * Renders a Kubernetes manifest for "ObjectAccessControl".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ObjectAccessControlProps): any {
    return {
      ...ObjectAccessControl.GVK,
      ...toJson_ObjectAccessControlProps(props),
    };
  }

  /**
   * Defines a "ObjectAccessControl" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ObjectAccessControlProps) {
    super(scope, id, {
      ...ObjectAccessControl.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ObjectAccessControl.GVK,
      ...toJson_ObjectAccessControlProps(resolved),
    };
  }
}

/**
 * ObjectAccessControl is the Schema for the ObjectAccessControls API. The ObjectAccessControls resources represent the Access Control Lists (ACLs) for objects within Google Cloud Storage.
 *
 * @schema ObjectAccessControl
 */
export interface ObjectAccessControlProps {
  /**
   * @schema ObjectAccessControl#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ObjectAccessControlSpec defines the desired state of ObjectAccessControl
   *
   * @schema ObjectAccessControl#spec
   */
  readonly spec: ObjectAccessControlSpec;

}

/**
 * Converts an object of type 'ObjectAccessControlProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlProps(obj: ObjectAccessControlProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ObjectAccessControlSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectAccessControlSpec defines the desired state of ObjectAccessControl
 *
 * @schema ObjectAccessControlSpec
 */
export interface ObjectAccessControlSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ObjectAccessControlSpec#deletionPolicy
   */
  readonly deletionPolicy?: ObjectAccessControlSpecDeletionPolicy;

  /**
   * @schema ObjectAccessControlSpec#forProvider
   */
  readonly forProvider: ObjectAccessControlSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ObjectAccessControlSpec#initProvider
   */
  readonly initProvider?: ObjectAccessControlSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ObjectAccessControlSpec#managementPolicies
   */
  readonly managementPolicies?: ObjectAccessControlSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ObjectAccessControlSpec#providerConfigRef
   */
  readonly providerConfigRef?: ObjectAccessControlSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ObjectAccessControlSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ObjectAccessControlSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ObjectAccessControlSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ObjectAccessControlSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ObjectAccessControlSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpec(obj: ObjectAccessControlSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ObjectAccessControlSpecForProvider(obj.forProvider),
    'initProvider': toJson_ObjectAccessControlSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ObjectAccessControlSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ObjectAccessControlSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ObjectAccessControlSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ObjectAccessControlSpecDeletionPolicy
 */
export enum ObjectAccessControlSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ObjectAccessControlSpecForProvider
 */
export interface ObjectAccessControlSpecForProvider {
  /**
   * The name of the bucket.
   *
   * @schema ObjectAccessControlSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema ObjectAccessControlSpecForProvider#bucketRef
   */
  readonly bucketRef?: ObjectAccessControlSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema ObjectAccessControlSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: ObjectAccessControlSpecForProviderBucketSelector;

  /**
   * The entity holding the permission, in one of the following forms:
   *
   * @schema ObjectAccessControlSpecForProvider#entity
   */
  readonly entity?: string;

  /**
   * The name of the object to apply the access control to.
   *
   * @schema ObjectAccessControlSpecForProvider#object
   */
  readonly object?: string;

  /**
   * Reference to a BucketObject in storage to populate object.
   *
   * @schema ObjectAccessControlSpecForProvider#objectRef
   */
  readonly objectRef?: ObjectAccessControlSpecForProviderObjectRef;

  /**
   * Selector for a BucketObject in storage to populate object.
   *
   * @schema ObjectAccessControlSpecForProvider#objectSelector
   */
  readonly objectSelector?: ObjectAccessControlSpecForProviderObjectSelector;

  /**
   * The access permission for the entity. Possible values are: OWNER, READER.
   *
   * @schema ObjectAccessControlSpecForProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProvider(obj: ObjectAccessControlSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_ObjectAccessControlSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_ObjectAccessControlSpecForProviderBucketSelector(obj.bucketSelector),
    'entity': obj.entity,
    'object': obj.object,
    'objectRef': toJson_ObjectAccessControlSpecForProviderObjectRef(obj.objectRef),
    'objectSelector': toJson_ObjectAccessControlSpecForProviderObjectSelector(obj.objectSelector),
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ObjectAccessControlSpecInitProvider
 */
export interface ObjectAccessControlSpecInitProvider {
  /**
   * The entity holding the permission, in one of the following forms:
   *
   * @schema ObjectAccessControlSpecInitProvider#entity
   */
  readonly entity?: string;

  /**
   * The access permission for the entity. Possible values are: OWNER, READER.
   *
   * @schema ObjectAccessControlSpecInitProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecInitProvider(obj: ObjectAccessControlSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entity': obj.entity,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ObjectAccessControlSpecManagementPolicies
 */
export enum ObjectAccessControlSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ObjectAccessControlSpecProviderConfigRef
 */
export interface ObjectAccessControlSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAccessControlSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAccessControlSpecProviderConfigRef#policy
   */
  readonly policy?: ObjectAccessControlSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecProviderConfigRef(obj: ObjectAccessControlSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAccessControlSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ObjectAccessControlSpecPublishConnectionDetailsTo
 */
export interface ObjectAccessControlSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ObjectAccessControlSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ObjectAccessControlSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecPublishConnectionDetailsTo(obj: ObjectAccessControlSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ObjectAccessControlSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ObjectAccessControlSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ObjectAccessControlSpecWriteConnectionSecretToRef
 */
export interface ObjectAccessControlSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ObjectAccessControlSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ObjectAccessControlSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecWriteConnectionSecretToRef(obj: ObjectAccessControlSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema ObjectAccessControlSpecForProviderBucketRef
 */
export interface ObjectAccessControlSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAccessControlSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAccessControlSpecForProviderBucketRef#policy
   */
  readonly policy?: ObjectAccessControlSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProviderBucketRef(obj: ObjectAccessControlSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAccessControlSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema ObjectAccessControlSpecForProviderBucketSelector
 */
export interface ObjectAccessControlSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ObjectAccessControlSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ObjectAccessControlSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ObjectAccessControlSpecForProviderBucketSelector#policy
   */
  readonly policy?: ObjectAccessControlSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProviderBucketSelector(obj: ObjectAccessControlSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ObjectAccessControlSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a BucketObject in storage to populate object.
 *
 * @schema ObjectAccessControlSpecForProviderObjectRef
 */
export interface ObjectAccessControlSpecForProviderObjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAccessControlSpecForProviderObjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAccessControlSpecForProviderObjectRef#policy
   */
  readonly policy?: ObjectAccessControlSpecForProviderObjectRefPolicy;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProviderObjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProviderObjectRef(obj: ObjectAccessControlSpecForProviderObjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAccessControlSpecForProviderObjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a BucketObject in storage to populate object.
 *
 * @schema ObjectAccessControlSpecForProviderObjectSelector
 */
export interface ObjectAccessControlSpecForProviderObjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ObjectAccessControlSpecForProviderObjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ObjectAccessControlSpecForProviderObjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ObjectAccessControlSpecForProviderObjectSelector#policy
   */
  readonly policy?: ObjectAccessControlSpecForProviderObjectSelectorPolicy;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProviderObjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProviderObjectSelector(obj: ObjectAccessControlSpecForProviderObjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ObjectAccessControlSpecForProviderObjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectAccessControlSpecProviderConfigRefPolicy
 */
export interface ObjectAccessControlSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAccessControlSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectAccessControlSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAccessControlSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectAccessControlSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecProviderConfigRefPolicy(obj: ObjectAccessControlSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ObjectAccessControlSpecPublishConnectionDetailsToConfigRef
 */
export interface ObjectAccessControlSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecPublishConnectionDetailsToConfigRef(obj: ObjectAccessControlSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ObjectAccessControlSpecPublishConnectionDetailsToMetadata
 */
export interface ObjectAccessControlSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecPublishConnectionDetailsToMetadata(obj: ObjectAccessControlSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectAccessControlSpecForProviderBucketRefPolicy
 */
export interface ObjectAccessControlSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAccessControlSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: ObjectAccessControlSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAccessControlSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: ObjectAccessControlSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProviderBucketRefPolicy(obj: ObjectAccessControlSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ObjectAccessControlSpecForProviderBucketSelectorPolicy
 */
export interface ObjectAccessControlSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAccessControlSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: ObjectAccessControlSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAccessControlSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: ObjectAccessControlSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProviderBucketSelectorPolicy(obj: ObjectAccessControlSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectAccessControlSpecForProviderObjectRefPolicy
 */
export interface ObjectAccessControlSpecForProviderObjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAccessControlSpecForProviderObjectRefPolicy#resolution
   */
  readonly resolution?: ObjectAccessControlSpecForProviderObjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAccessControlSpecForProviderObjectRefPolicy#resolve
   */
  readonly resolve?: ObjectAccessControlSpecForProviderObjectRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProviderObjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProviderObjectRefPolicy(obj: ObjectAccessControlSpecForProviderObjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ObjectAccessControlSpecForProviderObjectSelectorPolicy
 */
export interface ObjectAccessControlSpecForProviderObjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAccessControlSpecForProviderObjectSelectorPolicy#resolution
   */
  readonly resolution?: ObjectAccessControlSpecForProviderObjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAccessControlSpecForProviderObjectSelectorPolicy#resolve
   */
  readonly resolve?: ObjectAccessControlSpecForProviderObjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecForProviderObjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecForProviderObjectSelectorPolicy(obj: ObjectAccessControlSpecForProviderObjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAccessControlSpecProviderConfigRefPolicyResolution
 */
export enum ObjectAccessControlSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAccessControlSpecProviderConfigRefPolicyResolve
 */
export enum ObjectAccessControlSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy(obj: ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAccessControlSpecForProviderBucketRefPolicyResolution
 */
export enum ObjectAccessControlSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAccessControlSpecForProviderBucketRefPolicyResolve
 */
export enum ObjectAccessControlSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAccessControlSpecForProviderBucketSelectorPolicyResolution
 */
export enum ObjectAccessControlSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAccessControlSpecForProviderBucketSelectorPolicyResolve
 */
export enum ObjectAccessControlSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAccessControlSpecForProviderObjectRefPolicyResolution
 */
export enum ObjectAccessControlSpecForProviderObjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAccessControlSpecForProviderObjectRefPolicyResolve
 */
export enum ObjectAccessControlSpecForProviderObjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAccessControlSpecForProviderObjectSelectorPolicyResolution
 */
export enum ObjectAccessControlSpecForProviderObjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAccessControlSpecForProviderObjectSelectorPolicyResolve
 */
export enum ObjectAccessControlSpecForProviderObjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ObjectAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ObjectACL is the Schema for the ObjectACLs API. Creates a new object ACL in Google Cloud Storage.
 *
 * @schema ObjectACL
 */
export class ObjectAcl extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ObjectACL"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'ObjectACL',
  }

  /**
   * Renders a Kubernetes manifest for "ObjectACL".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ObjectAclProps): any {
    return {
      ...ObjectAcl.GVK,
      ...toJson_ObjectAclProps(props),
    };
  }

  /**
   * Defines a "ObjectACL" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ObjectAclProps) {
    super(scope, id, {
      ...ObjectAcl.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ObjectAcl.GVK,
      ...toJson_ObjectAclProps(resolved),
    };
  }
}

/**
 * ObjectACL is the Schema for the ObjectACLs API. Creates a new object ACL in Google Cloud Storage.
 *
 * @schema ObjectACL
 */
export interface ObjectAclProps {
  /**
   * @schema ObjectACL#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ObjectACLSpec defines the desired state of ObjectACL
   *
   * @schema ObjectACL#spec
   */
  readonly spec: ObjectAclSpec;

}

/**
 * Converts an object of type 'ObjectAclProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclProps(obj: ObjectAclProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ObjectAclSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectACLSpec defines the desired state of ObjectACL
 *
 * @schema ObjectAclSpec
 */
export interface ObjectAclSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ObjectAclSpec#deletionPolicy
   */
  readonly deletionPolicy?: ObjectAclSpecDeletionPolicy;

  /**
   * @schema ObjectAclSpec#forProvider
   */
  readonly forProvider: ObjectAclSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ObjectAclSpec#initProvider
   */
  readonly initProvider?: ObjectAclSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ObjectAclSpec#managementPolicies
   */
  readonly managementPolicies?: ObjectAclSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ObjectAclSpec#providerConfigRef
   */
  readonly providerConfigRef?: ObjectAclSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ObjectAclSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ObjectAclSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ObjectAclSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ObjectAclSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ObjectAclSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpec(obj: ObjectAclSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ObjectAclSpecForProvider(obj.forProvider),
    'initProvider': toJson_ObjectAclSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ObjectAclSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ObjectAclSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ObjectAclSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ObjectAclSpecDeletionPolicy
 */
export enum ObjectAclSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ObjectAclSpecForProvider
 */
export interface ObjectAclSpecForProvider {
  /**
   * The name of the bucket the object is stored in.
   *
   * @schema ObjectAclSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema ObjectAclSpecForProvider#bucketRef
   */
  readonly bucketRef?: ObjectAclSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema ObjectAclSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: ObjectAclSpecForProviderBucketSelector;

  /**
   * The name of the object to apply the acl to.
   *
   * @schema ObjectAclSpecForProvider#object
   */
  readonly object?: string;

  /**
   * Reference to a BucketObject in storage to populate object.
   *
   * @schema ObjectAclSpecForProvider#objectRef
   */
  readonly objectRef?: ObjectAclSpecForProviderObjectRef;

  /**
   * Selector for a BucketObject in storage to populate object.
   *
   * @schema ObjectAclSpecForProvider#objectSelector
   */
  readonly objectSelector?: ObjectAclSpecForProviderObjectSelector;

  /**
   * The "canned" predefined ACL to apply. Must be set if role_entity is not.
   *
   * @schema ObjectAclSpecForProvider#predefinedAcl
   */
  readonly predefinedAcl?: string;

  /**
   * List of role/entity pairs in the form ROLE:entity. See GCS Object ACL documentation for more details. Must be set if predefined_acl is not.
   *
   * @schema ObjectAclSpecForProvider#roleEntity
   */
  readonly roleEntity?: string[];

}

/**
 * Converts an object of type 'ObjectAclSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProvider(obj: ObjectAclSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_ObjectAclSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_ObjectAclSpecForProviderBucketSelector(obj.bucketSelector),
    'object': obj.object,
    'objectRef': toJson_ObjectAclSpecForProviderObjectRef(obj.objectRef),
    'objectSelector': toJson_ObjectAclSpecForProviderObjectSelector(obj.objectSelector),
    'predefinedAcl': obj.predefinedAcl,
    'roleEntity': obj.roleEntity?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ObjectAclSpecInitProvider
 */
export interface ObjectAclSpecInitProvider {
  /**
   * The "canned" predefined ACL to apply. Must be set if role_entity is not.
   *
   * @schema ObjectAclSpecInitProvider#predefinedAcl
   */
  readonly predefinedAcl?: string;

  /**
   * List of role/entity pairs in the form ROLE:entity. See GCS Object ACL documentation for more details. Must be set if predefined_acl is not.
   *
   * @schema ObjectAclSpecInitProvider#roleEntity
   */
  readonly roleEntity?: string[];

}

/**
 * Converts an object of type 'ObjectAclSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecInitProvider(obj: ObjectAclSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'predefinedAcl': obj.predefinedAcl,
    'roleEntity': obj.roleEntity?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ObjectAclSpecManagementPolicies
 */
export enum ObjectAclSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ObjectAclSpecProviderConfigRef
 */
export interface ObjectAclSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAclSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAclSpecProviderConfigRef#policy
   */
  readonly policy?: ObjectAclSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ObjectAclSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecProviderConfigRef(obj: ObjectAclSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAclSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ObjectAclSpecPublishConnectionDetailsTo
 */
export interface ObjectAclSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ObjectAclSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ObjectAclSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ObjectAclSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecPublishConnectionDetailsTo(obj: ObjectAclSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ObjectAclSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ObjectAclSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ObjectAclSpecWriteConnectionSecretToRef
 */
export interface ObjectAclSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ObjectAclSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ObjectAclSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ObjectAclSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecWriteConnectionSecretToRef(obj: ObjectAclSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema ObjectAclSpecForProviderBucketRef
 */
export interface ObjectAclSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAclSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAclSpecForProviderBucketRef#policy
   */
  readonly policy?: ObjectAclSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'ObjectAclSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProviderBucketRef(obj: ObjectAclSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAclSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema ObjectAclSpecForProviderBucketSelector
 */
export interface ObjectAclSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ObjectAclSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ObjectAclSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ObjectAclSpecForProviderBucketSelector#policy
   */
  readonly policy?: ObjectAclSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'ObjectAclSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProviderBucketSelector(obj: ObjectAclSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ObjectAclSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a BucketObject in storage to populate object.
 *
 * @schema ObjectAclSpecForProviderObjectRef
 */
export interface ObjectAclSpecForProviderObjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAclSpecForProviderObjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAclSpecForProviderObjectRef#policy
   */
  readonly policy?: ObjectAclSpecForProviderObjectRefPolicy;

}

/**
 * Converts an object of type 'ObjectAclSpecForProviderObjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProviderObjectRef(obj: ObjectAclSpecForProviderObjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAclSpecForProviderObjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a BucketObject in storage to populate object.
 *
 * @schema ObjectAclSpecForProviderObjectSelector
 */
export interface ObjectAclSpecForProviderObjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ObjectAclSpecForProviderObjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ObjectAclSpecForProviderObjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ObjectAclSpecForProviderObjectSelector#policy
   */
  readonly policy?: ObjectAclSpecForProviderObjectSelectorPolicy;

}

/**
 * Converts an object of type 'ObjectAclSpecForProviderObjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProviderObjectSelector(obj: ObjectAclSpecForProviderObjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ObjectAclSpecForProviderObjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectAclSpecProviderConfigRefPolicy
 */
export interface ObjectAclSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAclSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectAclSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAclSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectAclSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAclSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecProviderConfigRefPolicy(obj: ObjectAclSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ObjectAclSpecPublishConnectionDetailsToConfigRef
 */
export interface ObjectAclSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ObjectAclSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecPublishConnectionDetailsToConfigRef(obj: ObjectAclSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ObjectAclSpecPublishConnectionDetailsToMetadata
 */
export interface ObjectAclSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ObjectAclSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecPublishConnectionDetailsToMetadata(obj: ObjectAclSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectAclSpecForProviderBucketRefPolicy
 */
export interface ObjectAclSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAclSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: ObjectAclSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAclSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: ObjectAclSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAclSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProviderBucketRefPolicy(obj: ObjectAclSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ObjectAclSpecForProviderBucketSelectorPolicy
 */
export interface ObjectAclSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAclSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: ObjectAclSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAclSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: ObjectAclSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAclSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProviderBucketSelectorPolicy(obj: ObjectAclSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectAclSpecForProviderObjectRefPolicy
 */
export interface ObjectAclSpecForProviderObjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAclSpecForProviderObjectRefPolicy#resolution
   */
  readonly resolution?: ObjectAclSpecForProviderObjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAclSpecForProviderObjectRefPolicy#resolve
   */
  readonly resolve?: ObjectAclSpecForProviderObjectRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAclSpecForProviderObjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProviderObjectRefPolicy(obj: ObjectAclSpecForProviderObjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ObjectAclSpecForProviderObjectSelectorPolicy
 */
export interface ObjectAclSpecForProviderObjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAclSpecForProviderObjectSelectorPolicy#resolution
   */
  readonly resolution?: ObjectAclSpecForProviderObjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAclSpecForProviderObjectSelectorPolicy#resolve
   */
  readonly resolve?: ObjectAclSpecForProviderObjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAclSpecForProviderObjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecForProviderObjectSelectorPolicy(obj: ObjectAclSpecForProviderObjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAclSpecProviderConfigRefPolicyResolution
 */
export enum ObjectAclSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAclSpecProviderConfigRefPolicyResolve
 */
export enum ObjectAclSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy(obj: ObjectAclSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAclSpecForProviderBucketRefPolicyResolution
 */
export enum ObjectAclSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAclSpecForProviderBucketRefPolicyResolve
 */
export enum ObjectAclSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAclSpecForProviderBucketSelectorPolicyResolution
 */
export enum ObjectAclSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAclSpecForProviderBucketSelectorPolicyResolve
 */
export enum ObjectAclSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAclSpecForProviderObjectRefPolicyResolution
 */
export enum ObjectAclSpecForProviderObjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAclSpecForProviderObjectRefPolicyResolve
 */
export enum ObjectAclSpecForProviderObjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAclSpecForProviderObjectSelectorPolicyResolution
 */
export enum ObjectAclSpecForProviderObjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAclSpecForProviderObjectSelectorPolicyResolve
 */
export enum ObjectAclSpecForProviderObjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ObjectAclSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

