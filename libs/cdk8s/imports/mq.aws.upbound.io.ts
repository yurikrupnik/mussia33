// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Broker is the Schema for the Brokers API. Provides an MQ Broker Resource
 *
 * @schema Broker
 */
export class Broker extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Broker"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'mq.aws.upbound.io/v1beta1',
    kind: 'Broker',
  }

  /**
   * Renders a Kubernetes manifest for "Broker".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BrokerProps): any {
    return {
      ...Broker.GVK,
      ...toJson_BrokerProps(props),
    };
  }

  /**
   * Defines a "Broker" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BrokerProps) {
    super(scope, id, {
      ...Broker.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Broker.GVK,
      ...toJson_BrokerProps(resolved),
    };
  }
}

/**
 * Broker is the Schema for the Brokers API. Provides an MQ Broker Resource
 *
 * @schema Broker
 */
export interface BrokerProps {
  /**
   * @schema Broker#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BrokerSpec defines the desired state of Broker
   *
   * @schema Broker#spec
   */
  readonly spec: BrokerSpec;

}

/**
 * Converts an object of type 'BrokerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerProps(obj: BrokerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BrokerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BrokerSpec defines the desired state of Broker
 *
 * @schema BrokerSpec
 */
export interface BrokerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BrokerSpec#deletionPolicy
   */
  readonly deletionPolicy?: BrokerSpecDeletionPolicy;

  /**
   * @schema BrokerSpec#forProvider
   */
  readonly forProvider: BrokerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema BrokerSpec#initProvider
   */
  readonly initProvider?: BrokerSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BrokerSpec#managementPolicies
   */
  readonly managementPolicies?: BrokerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BrokerSpec#providerConfigRef
   */
  readonly providerConfigRef?: BrokerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BrokerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BrokerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BrokerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BrokerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BrokerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpec(obj: BrokerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BrokerSpecForProvider(obj.forProvider),
    'initProvider': toJson_BrokerSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BrokerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_BrokerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BrokerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BrokerSpecDeletionPolicy
 */
export enum BrokerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BrokerSpecForProvider
 */
export interface BrokerSpecForProvider {
  /**
   * Specifies whether any broker modifications are applied immediately, or during the next maintenance window. Default is false.
   *
   * @default false.
   * @schema BrokerSpecForProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * Authentication strategy used to secure the broker. Valid values are simple and ldap. ldap is not supported for engine_type RabbitMQ.
   *
   * @schema BrokerSpecForProvider#authenticationStrategy
   */
  readonly authenticationStrategy?: string;

  /**
   * Whether to automatically upgrade to new minor versions of brokers as Amazon MQ makes releases available.
   *
   * @schema BrokerSpecForProvider#autoMinorVersionUpgrade
   */
  readonly autoMinorVersionUpgrade?: boolean;

  /**
   * Name of the broker.
   *
   * @schema BrokerSpecForProvider#brokerName
   */
  readonly brokerName?: string;

  /**
   * Configuration block for broker configuration. Applies to engine_type of ActiveMQ only. Detailed below.
   *
   * @schema BrokerSpecForProvider#configuration
   */
  readonly configuration?: BrokerSpecForProviderConfiguration[];

  /**
   * Deployment mode of the broker. Valid values are SINGLE_INSTANCE, ACTIVE_STANDBY_MULTI_AZ, and CLUSTER_MULTI_AZ. Default is SINGLE_INSTANCE.
   *
   * @default SINGLE_INSTANCE.
   * @schema BrokerSpecForProvider#deploymentMode
   */
  readonly deploymentMode?: string;

  /**
   * Configuration block containing encryption options. Detailed below.
   *
   * @schema BrokerSpecForProvider#encryptionOptions
   */
  readonly encryptionOptions?: BrokerSpecForProviderEncryptionOptions[];

  /**
   * Type of broker engine. Valid values are ActiveMQ and RabbitMQ.
   *
   * @schema BrokerSpecForProvider#engineType
   */
  readonly engineType?: string;

  /**
   * Version of the broker engine. See the AmazonMQ Broker Engine docs for supported versions. For example, 5.15.0.
   *
   * @schema BrokerSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * Broker's instance type. For example, mq.t3.micro, mq.m5.large.
   *
   * @schema BrokerSpecForProvider#hostInstanceType
   */
  readonly hostInstanceType?: string;

  /**
   * Configuration block for the LDAP server used to authenticate and authorize connections to the broker. Not supported for engine_type RabbitMQ. Detailed below. (Currently, AWS may not process changes to LDAP server metadata.)
   *
   * @schema BrokerSpecForProvider#ldapServerMetadata
   */
  readonly ldapServerMetadata?: BrokerSpecForProviderLdapServerMetadata[];

  /**
   * Configuration block for the logging configuration of the broker. Detailed below.
   *
   * @schema BrokerSpecForProvider#logs
   */
  readonly logs?: BrokerSpecForProviderLogs[];

  /**
   * Configuration block for the maintenance window start time. Detailed below.
   *
   * @schema BrokerSpecForProvider#maintenanceWindowStartTime
   */
  readonly maintenanceWindowStartTime?: BrokerSpecForProviderMaintenanceWindowStartTime[];

  /**
   * Whether to enable connections from applications outside of the VPC that hosts the broker's subnets.
   *
   * @schema BrokerSpecForProvider#publiclyAccessible
   */
  readonly publiclyAccessible?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BrokerSpecForProvider#region
   */
  readonly region: string;

  /**
   * References to SecurityGroup in ec2 to populate securityGroups.
   *
   * @schema BrokerSpecForProvider#securityGroupRefs
   */
  readonly securityGroupRefs?: BrokerSpecForProviderSecurityGroupRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate securityGroups.
   *
   * @schema BrokerSpecForProvider#securityGroupSelector
   */
  readonly securityGroupSelector?: BrokerSpecForProviderSecurityGroupSelector;

  /**
   * List of security group IDs assigned to the broker.
   *
   * @schema BrokerSpecForProvider#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * Storage type of the broker. For engine_type ActiveMQ, the valid values are efs and ebs, and the AWS-default is efs. For engine_type RabbitMQ, only ebs is supported. When using ebs, only the mq.m5 broker instance type family is supported.
   *
   * @schema BrokerSpecForProvider#storageType
   */
  readonly storageType?: string;

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema BrokerSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: BrokerSpecForProviderSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema BrokerSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: BrokerSpecForProviderSubnetIdSelector;

  /**
   * List of subnet IDs in which to launch the broker. A SINGLE_INSTANCE deployment requires one subnet. An ACTIVE_STANDBY_MULTI_AZ deployment requires multiple subnets.
   *
   * @schema BrokerSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema BrokerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Configuration block for broker users. For engine_type of RabbitMQ, Amazon MQ does not return broker users preventing this resource from making user updates and drift detection. Detailed below.
   *
   * @schema BrokerSpecForProvider#user
   */
  readonly user?: BrokerSpecForProviderUser[];

}

/**
 * Converts an object of type 'BrokerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProvider(obj: BrokerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyImmediately': obj.applyImmediately,
    'authenticationStrategy': obj.authenticationStrategy,
    'autoMinorVersionUpgrade': obj.autoMinorVersionUpgrade,
    'brokerName': obj.brokerName,
    'configuration': obj.configuration?.map(y => toJson_BrokerSpecForProviderConfiguration(y)),
    'deploymentMode': obj.deploymentMode,
    'encryptionOptions': obj.encryptionOptions?.map(y => toJson_BrokerSpecForProviderEncryptionOptions(y)),
    'engineType': obj.engineType,
    'engineVersion': obj.engineVersion,
    'hostInstanceType': obj.hostInstanceType,
    'ldapServerMetadata': obj.ldapServerMetadata?.map(y => toJson_BrokerSpecForProviderLdapServerMetadata(y)),
    'logs': obj.logs?.map(y => toJson_BrokerSpecForProviderLogs(y)),
    'maintenanceWindowStartTime': obj.maintenanceWindowStartTime?.map(y => toJson_BrokerSpecForProviderMaintenanceWindowStartTime(y)),
    'publiclyAccessible': obj.publiclyAccessible,
    'region': obj.region,
    'securityGroupRefs': obj.securityGroupRefs?.map(y => toJson_BrokerSpecForProviderSecurityGroupRefs(y)),
    'securityGroupSelector': toJson_BrokerSpecForProviderSecurityGroupSelector(obj.securityGroupSelector),
    'securityGroups': obj.securityGroups?.map(y => y),
    'storageType': obj.storageType,
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_BrokerSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_BrokerSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'user': obj.user?.map(y => toJson_BrokerSpecForProviderUser(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema BrokerSpecInitProvider
 */
export interface BrokerSpecInitProvider {
  /**
   * Specifies whether any broker modifications are applied immediately, or during the next maintenance window. Default is false.
   *
   * @default false.
   * @schema BrokerSpecInitProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * Authentication strategy used to secure the broker. Valid values are simple and ldap. ldap is not supported for engine_type RabbitMQ.
   *
   * @schema BrokerSpecInitProvider#authenticationStrategy
   */
  readonly authenticationStrategy?: string;

  /**
   * Whether to automatically upgrade to new minor versions of brokers as Amazon MQ makes releases available.
   *
   * @schema BrokerSpecInitProvider#autoMinorVersionUpgrade
   */
  readonly autoMinorVersionUpgrade?: boolean;

  /**
   * Name of the broker.
   *
   * @schema BrokerSpecInitProvider#brokerName
   */
  readonly brokerName?: string;

  /**
   * Configuration block for broker configuration. Applies to engine_type of ActiveMQ only. Detailed below.
   *
   * @schema BrokerSpecInitProvider#configuration
   */
  readonly configuration?: BrokerSpecInitProviderConfiguration[];

  /**
   * Deployment mode of the broker. Valid values are SINGLE_INSTANCE, ACTIVE_STANDBY_MULTI_AZ, and CLUSTER_MULTI_AZ. Default is SINGLE_INSTANCE.
   *
   * @default SINGLE_INSTANCE.
   * @schema BrokerSpecInitProvider#deploymentMode
   */
  readonly deploymentMode?: string;

  /**
   * Configuration block containing encryption options. Detailed below.
   *
   * @schema BrokerSpecInitProvider#encryptionOptions
   */
  readonly encryptionOptions?: BrokerSpecInitProviderEncryptionOptions[];

  /**
   * Type of broker engine. Valid values are ActiveMQ and RabbitMQ.
   *
   * @schema BrokerSpecInitProvider#engineType
   */
  readonly engineType?: string;

  /**
   * Version of the broker engine. See the AmazonMQ Broker Engine docs for supported versions. For example, 5.15.0.
   *
   * @schema BrokerSpecInitProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * Broker's instance type. For example, mq.t3.micro, mq.m5.large.
   *
   * @schema BrokerSpecInitProvider#hostInstanceType
   */
  readonly hostInstanceType?: string;

  /**
   * Configuration block for the LDAP server used to authenticate and authorize connections to the broker. Not supported for engine_type RabbitMQ. Detailed below. (Currently, AWS may not process changes to LDAP server metadata.)
   *
   * @schema BrokerSpecInitProvider#ldapServerMetadata
   */
  readonly ldapServerMetadata?: BrokerSpecInitProviderLdapServerMetadata[];

  /**
   * Configuration block for the logging configuration of the broker. Detailed below.
   *
   * @schema BrokerSpecInitProvider#logs
   */
  readonly logs?: BrokerSpecInitProviderLogs[];

  /**
   * Configuration block for the maintenance window start time. Detailed below.
   *
   * @schema BrokerSpecInitProvider#maintenanceWindowStartTime
   */
  readonly maintenanceWindowStartTime?: BrokerSpecInitProviderMaintenanceWindowStartTime[];

  /**
   * Whether to enable connections from applications outside of the VPC that hosts the broker's subnets.
   *
   * @schema BrokerSpecInitProvider#publiclyAccessible
   */
  readonly publiclyAccessible?: boolean;

  /**
   * Storage type of the broker. For engine_type ActiveMQ, the valid values are efs and ebs, and the AWS-default is efs. For engine_type RabbitMQ, only ebs is supported. When using ebs, only the mq.m5 broker instance type family is supported.
   *
   * @schema BrokerSpecInitProvider#storageType
   */
  readonly storageType?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema BrokerSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Configuration block for broker users. For engine_type of RabbitMQ, Amazon MQ does not return broker users preventing this resource from making user updates and drift detection. Detailed below.
   *
   * @schema BrokerSpecInitProvider#user
   */
  readonly user?: BrokerSpecInitProviderUser[];

}

/**
 * Converts an object of type 'BrokerSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecInitProvider(obj: BrokerSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyImmediately': obj.applyImmediately,
    'authenticationStrategy': obj.authenticationStrategy,
    'autoMinorVersionUpgrade': obj.autoMinorVersionUpgrade,
    'brokerName': obj.brokerName,
    'configuration': obj.configuration?.map(y => toJson_BrokerSpecInitProviderConfiguration(y)),
    'deploymentMode': obj.deploymentMode,
    'encryptionOptions': obj.encryptionOptions?.map(y => toJson_BrokerSpecInitProviderEncryptionOptions(y)),
    'engineType': obj.engineType,
    'engineVersion': obj.engineVersion,
    'hostInstanceType': obj.hostInstanceType,
    'ldapServerMetadata': obj.ldapServerMetadata?.map(y => toJson_BrokerSpecInitProviderLdapServerMetadata(y)),
    'logs': obj.logs?.map(y => toJson_BrokerSpecInitProviderLogs(y)),
    'maintenanceWindowStartTime': obj.maintenanceWindowStartTime?.map(y => toJson_BrokerSpecInitProviderMaintenanceWindowStartTime(y)),
    'publiclyAccessible': obj.publiclyAccessible,
    'storageType': obj.storageType,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'user': obj.user?.map(y => toJson_BrokerSpecInitProviderUser(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema BrokerSpecManagementPolicies
 */
export enum BrokerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BrokerSpecProviderConfigRef
 */
export interface BrokerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BrokerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BrokerSpecProviderConfigRef#policy
   */
  readonly policy?: BrokerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BrokerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecProviderConfigRef(obj: BrokerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BrokerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BrokerSpecPublishConnectionDetailsTo
 */
export interface BrokerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BrokerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BrokerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BrokerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BrokerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BrokerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BrokerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecPublishConnectionDetailsTo(obj: BrokerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BrokerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BrokerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BrokerSpecWriteConnectionSecretToRef
 */
export interface BrokerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BrokerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BrokerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BrokerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecWriteConnectionSecretToRef(obj: BrokerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BrokerSpecForProviderConfiguration
 */
export interface BrokerSpecForProviderConfiguration {
  /**
   * The Configuration ID.
   *
   * @schema BrokerSpecForProviderConfiguration#id
   */
  readonly id?: string;

  /**
   * Reference to a Configuration in mq to populate id.
   *
   * @schema BrokerSpecForProviderConfiguration#idRef
   */
  readonly idRef?: BrokerSpecForProviderConfigurationIdRef;

  /**
   * Selector for a Configuration in mq to populate id.
   *
   * @schema BrokerSpecForProviderConfiguration#idSelector
   */
  readonly idSelector?: BrokerSpecForProviderConfigurationIdSelector;

  /**
   * Revision of the Configuration.
   *
   * @schema BrokerSpecForProviderConfiguration#revision
   */
  readonly revision?: number;

}

/**
 * Converts an object of type 'BrokerSpecForProviderConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderConfiguration(obj: BrokerSpecForProviderConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'idRef': toJson_BrokerSpecForProviderConfigurationIdRef(obj.idRef),
    'idSelector': toJson_BrokerSpecForProviderConfigurationIdSelector(obj.idSelector),
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BrokerSpecForProviderEncryptionOptions
 */
export interface BrokerSpecForProviderEncryptionOptions {
  /**
   * Amazon Resource Name (ARN) of Key Management Service (KMS) Customer Master Key (CMK) to use for encryption at rest. Requires setting use_aws_owned_key to false. To perform drift detection when AWS-managed CMKs or customer-managed CMKs are in use, this value must be configured.
   *
   * @schema BrokerSpecForProviderEncryptionOptions#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Whether to enable an AWS-owned KMS CMK that is not in your account. Defaults to true. Setting to false without configuring kms_key_id will create an AWS-managed CMK aliased to aws/mq in your account.
   *
   * @default true. Setting to false without configuring kms_key_id will create an AWS-managed CMK aliased to aws/mq in your account.
   * @schema BrokerSpecForProviderEncryptionOptions#useAwsOwnedKey
   */
  readonly useAwsOwnedKey?: boolean;

}

/**
 * Converts an object of type 'BrokerSpecForProviderEncryptionOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderEncryptionOptions(obj: BrokerSpecForProviderEncryptionOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyId': obj.kmsKeyId,
    'useAwsOwnedKey': obj.useAwsOwnedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BrokerSpecForProviderLdapServerMetadata
 */
export interface BrokerSpecForProviderLdapServerMetadata {
  /**
   * List of a fully qualified domain name of the LDAP server and an optional failover server.
   *
   * @schema BrokerSpecForProviderLdapServerMetadata#hosts
   */
  readonly hosts?: string[];

  /**
   * Fully qualified name of the directory to search for a user’s groups.
   *
   * @schema BrokerSpecForProviderLdapServerMetadata#roleBase
   */
  readonly roleBase?: string;

  /**
   * Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
   *
   * @schema BrokerSpecForProviderLdapServerMetadata#roleName
   */
  readonly roleName?: string;

  /**
   * Search criteria for groups.
   *
   * @schema BrokerSpecForProviderLdapServerMetadata#roleSearchMatching
   */
  readonly roleSearchMatching?: string;

  /**
   * Whether the directory search scope is the entire sub-tree.
   *
   * @schema BrokerSpecForProviderLdapServerMetadata#roleSearchSubtree
   */
  readonly roleSearchSubtree?: boolean;

  /**
   * Service account password.
   *
   * @schema BrokerSpecForProviderLdapServerMetadata#serviceAccountPasswordSecretRef
   */
  readonly serviceAccountPasswordSecretRef?: BrokerSpecForProviderLdapServerMetadataServiceAccountPasswordSecretRef;

  /**
   * Service account username.
   *
   * @schema BrokerSpecForProviderLdapServerMetadata#serviceAccountUsername
   */
  readonly serviceAccountUsername?: string;

  /**
   * Fully qualified name of the directory where you want to search for users.
   *
   * @schema BrokerSpecForProviderLdapServerMetadata#userBase
   */
  readonly userBase?: string;

  /**
   * Specifies the name of the LDAP attribute for the user group membership.
   *
   * @schema BrokerSpecForProviderLdapServerMetadata#userRoleName
   */
  readonly userRoleName?: string;

  /**
   * Search criteria for users.
   *
   * @schema BrokerSpecForProviderLdapServerMetadata#userSearchMatching
   */
  readonly userSearchMatching?: string;

  /**
   * Whether the directory search scope is the entire sub-tree.
   *
   * @schema BrokerSpecForProviderLdapServerMetadata#userSearchSubtree
   */
  readonly userSearchSubtree?: boolean;

}

/**
 * Converts an object of type 'BrokerSpecForProviderLdapServerMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderLdapServerMetadata(obj: BrokerSpecForProviderLdapServerMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hosts': obj.hosts?.map(y => y),
    'roleBase': obj.roleBase,
    'roleName': obj.roleName,
    'roleSearchMatching': obj.roleSearchMatching,
    'roleSearchSubtree': obj.roleSearchSubtree,
    'serviceAccountPasswordSecretRef': toJson_BrokerSpecForProviderLdapServerMetadataServiceAccountPasswordSecretRef(obj.serviceAccountPasswordSecretRef),
    'serviceAccountUsername': obj.serviceAccountUsername,
    'userBase': obj.userBase,
    'userRoleName': obj.userRoleName,
    'userSearchMatching': obj.userSearchMatching,
    'userSearchSubtree': obj.userSearchSubtree,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BrokerSpecForProviderLogs
 */
export interface BrokerSpecForProviderLogs {
  /**
   * Enables audit logging. Auditing is only possible for engine_type of ActiveMQ. User management action made using JMX or the ActiveMQ Web Console is logged. Defaults to false.
   *
   * @default false.
   * @schema BrokerSpecForProviderLogs#audit
   */
  readonly audit?: string;

  /**
   * Enables general logging via CloudWatch. Defaults to false.
   *
   * @default false.
   * @schema BrokerSpecForProviderLogs#general
   */
  readonly general?: boolean;

}

/**
 * Converts an object of type 'BrokerSpecForProviderLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderLogs(obj: BrokerSpecForProviderLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audit': obj.audit,
    'general': obj.general,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BrokerSpecForProviderMaintenanceWindowStartTime
 */
export interface BrokerSpecForProviderMaintenanceWindowStartTime {
  /**
   * Day of the week, e.g., MONDAY, TUESDAY, or WEDNESDAY.
   *
   * @schema BrokerSpecForProviderMaintenanceWindowStartTime#dayOfWeek
   */
  readonly dayOfWeek?: string;

  /**
   * Time, in 24-hour format, e.g., 02:00.
   *
   * @schema BrokerSpecForProviderMaintenanceWindowStartTime#timeOfDay
   */
  readonly timeOfDay?: string;

  /**
   * Time zone in either the Country/City format or the UTC offset format, e.g., CET.
   *
   * @schema BrokerSpecForProviderMaintenanceWindowStartTime#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'BrokerSpecForProviderMaintenanceWindowStartTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderMaintenanceWindowStartTime(obj: BrokerSpecForProviderMaintenanceWindowStartTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dayOfWeek': obj.dayOfWeek,
    'timeOfDay': obj.timeOfDay,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema BrokerSpecForProviderSecurityGroupRefs
 */
export interface BrokerSpecForProviderSecurityGroupRefs {
  /**
   * Name of the referenced object.
   *
   * @schema BrokerSpecForProviderSecurityGroupRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BrokerSpecForProviderSecurityGroupRefs#policy
   */
  readonly policy?: BrokerSpecForProviderSecurityGroupRefsPolicy;

}

/**
 * Converts an object of type 'BrokerSpecForProviderSecurityGroupRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderSecurityGroupRefs(obj: BrokerSpecForProviderSecurityGroupRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BrokerSpecForProviderSecurityGroupRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate securityGroups.
 *
 * @schema BrokerSpecForProviderSecurityGroupSelector
 */
export interface BrokerSpecForProviderSecurityGroupSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BrokerSpecForProviderSecurityGroupSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BrokerSpecForProviderSecurityGroupSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BrokerSpecForProviderSecurityGroupSelector#policy
   */
  readonly policy?: BrokerSpecForProviderSecurityGroupSelectorPolicy;

}

/**
 * Converts an object of type 'BrokerSpecForProviderSecurityGroupSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderSecurityGroupSelector(obj: BrokerSpecForProviderSecurityGroupSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BrokerSpecForProviderSecurityGroupSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema BrokerSpecForProviderSubnetIdRefs
 */
export interface BrokerSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema BrokerSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BrokerSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: BrokerSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'BrokerSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderSubnetIdRefs(obj: BrokerSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BrokerSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema BrokerSpecForProviderSubnetIdSelector
 */
export interface BrokerSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BrokerSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BrokerSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BrokerSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: BrokerSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'BrokerSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderSubnetIdSelector(obj: BrokerSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BrokerSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BrokerSpecForProviderUser
 */
export interface BrokerSpecForProviderUser {
  /**
   * Whether to enable access to the ActiveMQ Web Console for the user. Applies to engine_type of ActiveMQ only.
   *
   * @schema BrokerSpecForProviderUser#consoleAccess
   */
  readonly consoleAccess?: boolean;

  /**
   * List of groups (20 maximum) to which the ActiveMQ user belongs. Applies to engine_type of ActiveMQ only.
   *
   * @schema BrokerSpecForProviderUser#groups
   */
  readonly groups?: string[];

  /**
   * Password of the user. It must be 12 to 250 characters long, at least 4 unique characters, and must not contain commas.
   *
   * @schema BrokerSpecForProviderUser#passwordSecretRef
   */
  readonly passwordSecretRef: BrokerSpecForProviderUserPasswordSecretRef;

  /**
   * Username of the user.
   *
   * @schema BrokerSpecForProviderUser#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'BrokerSpecForProviderUser' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderUser(obj: BrokerSpecForProviderUser | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consoleAccess': obj.consoleAccess,
    'groups': obj.groups?.map(y => y),
    'passwordSecretRef': toJson_BrokerSpecForProviderUserPasswordSecretRef(obj.passwordSecretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BrokerSpecInitProviderConfiguration
 */
export interface BrokerSpecInitProviderConfiguration {
  /**
   * Revision of the Configuration.
   *
   * @schema BrokerSpecInitProviderConfiguration#revision
   */
  readonly revision?: number;

}

/**
 * Converts an object of type 'BrokerSpecInitProviderConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecInitProviderConfiguration(obj: BrokerSpecInitProviderConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BrokerSpecInitProviderEncryptionOptions
 */
export interface BrokerSpecInitProviderEncryptionOptions {
  /**
   * Amazon Resource Name (ARN) of Key Management Service (KMS) Customer Master Key (CMK) to use for encryption at rest. Requires setting use_aws_owned_key to false. To perform drift detection when AWS-managed CMKs or customer-managed CMKs are in use, this value must be configured.
   *
   * @schema BrokerSpecInitProviderEncryptionOptions#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Whether to enable an AWS-owned KMS CMK that is not in your account. Defaults to true. Setting to false without configuring kms_key_id will create an AWS-managed CMK aliased to aws/mq in your account.
   *
   * @default true. Setting to false without configuring kms_key_id will create an AWS-managed CMK aliased to aws/mq in your account.
   * @schema BrokerSpecInitProviderEncryptionOptions#useAwsOwnedKey
   */
  readonly useAwsOwnedKey?: boolean;

}

/**
 * Converts an object of type 'BrokerSpecInitProviderEncryptionOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecInitProviderEncryptionOptions(obj: BrokerSpecInitProviderEncryptionOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyId': obj.kmsKeyId,
    'useAwsOwnedKey': obj.useAwsOwnedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BrokerSpecInitProviderLdapServerMetadata
 */
export interface BrokerSpecInitProviderLdapServerMetadata {
  /**
   * List of a fully qualified domain name of the LDAP server and an optional failover server.
   *
   * @schema BrokerSpecInitProviderLdapServerMetadata#hosts
   */
  readonly hosts?: string[];

  /**
   * Fully qualified name of the directory to search for a user’s groups.
   *
   * @schema BrokerSpecInitProviderLdapServerMetadata#roleBase
   */
  readonly roleBase?: string;

  /**
   * Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
   *
   * @schema BrokerSpecInitProviderLdapServerMetadata#roleName
   */
  readonly roleName?: string;

  /**
   * Search criteria for groups.
   *
   * @schema BrokerSpecInitProviderLdapServerMetadata#roleSearchMatching
   */
  readonly roleSearchMatching?: string;

  /**
   * Whether the directory search scope is the entire sub-tree.
   *
   * @schema BrokerSpecInitProviderLdapServerMetadata#roleSearchSubtree
   */
  readonly roleSearchSubtree?: boolean;

  /**
   * Service account username.
   *
   * @schema BrokerSpecInitProviderLdapServerMetadata#serviceAccountUsername
   */
  readonly serviceAccountUsername?: string;

  /**
   * Fully qualified name of the directory where you want to search for users.
   *
   * @schema BrokerSpecInitProviderLdapServerMetadata#userBase
   */
  readonly userBase?: string;

  /**
   * Specifies the name of the LDAP attribute for the user group membership.
   *
   * @schema BrokerSpecInitProviderLdapServerMetadata#userRoleName
   */
  readonly userRoleName?: string;

  /**
   * Search criteria for users.
   *
   * @schema BrokerSpecInitProviderLdapServerMetadata#userSearchMatching
   */
  readonly userSearchMatching?: string;

  /**
   * Whether the directory search scope is the entire sub-tree.
   *
   * @schema BrokerSpecInitProviderLdapServerMetadata#userSearchSubtree
   */
  readonly userSearchSubtree?: boolean;

}

/**
 * Converts an object of type 'BrokerSpecInitProviderLdapServerMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecInitProviderLdapServerMetadata(obj: BrokerSpecInitProviderLdapServerMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hosts': obj.hosts?.map(y => y),
    'roleBase': obj.roleBase,
    'roleName': obj.roleName,
    'roleSearchMatching': obj.roleSearchMatching,
    'roleSearchSubtree': obj.roleSearchSubtree,
    'serviceAccountUsername': obj.serviceAccountUsername,
    'userBase': obj.userBase,
    'userRoleName': obj.userRoleName,
    'userSearchMatching': obj.userSearchMatching,
    'userSearchSubtree': obj.userSearchSubtree,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BrokerSpecInitProviderLogs
 */
export interface BrokerSpecInitProviderLogs {
  /**
   * Enables audit logging. Auditing is only possible for engine_type of ActiveMQ. User management action made using JMX or the ActiveMQ Web Console is logged. Defaults to false.
   *
   * @default false.
   * @schema BrokerSpecInitProviderLogs#audit
   */
  readonly audit?: string;

  /**
   * Enables general logging via CloudWatch. Defaults to false.
   *
   * @default false.
   * @schema BrokerSpecInitProviderLogs#general
   */
  readonly general?: boolean;

}

/**
 * Converts an object of type 'BrokerSpecInitProviderLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecInitProviderLogs(obj: BrokerSpecInitProviderLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audit': obj.audit,
    'general': obj.general,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BrokerSpecInitProviderMaintenanceWindowStartTime
 */
export interface BrokerSpecInitProviderMaintenanceWindowStartTime {
  /**
   * Day of the week, e.g., MONDAY, TUESDAY, or WEDNESDAY.
   *
   * @schema BrokerSpecInitProviderMaintenanceWindowStartTime#dayOfWeek
   */
  readonly dayOfWeek?: string;

  /**
   * Time, in 24-hour format, e.g., 02:00.
   *
   * @schema BrokerSpecInitProviderMaintenanceWindowStartTime#timeOfDay
   */
  readonly timeOfDay?: string;

  /**
   * Time zone in either the Country/City format or the UTC offset format, e.g., CET.
   *
   * @schema BrokerSpecInitProviderMaintenanceWindowStartTime#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'BrokerSpecInitProviderMaintenanceWindowStartTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecInitProviderMaintenanceWindowStartTime(obj: BrokerSpecInitProviderMaintenanceWindowStartTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dayOfWeek': obj.dayOfWeek,
    'timeOfDay': obj.timeOfDay,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BrokerSpecInitProviderUser
 */
export interface BrokerSpecInitProviderUser {
  /**
   * Whether to enable access to the ActiveMQ Web Console for the user. Applies to engine_type of ActiveMQ only.
   *
   * @schema BrokerSpecInitProviderUser#consoleAccess
   */
  readonly consoleAccess?: boolean;

  /**
   * List of groups (20 maximum) to which the ActiveMQ user belongs. Applies to engine_type of ActiveMQ only.
   *
   * @schema BrokerSpecInitProviderUser#groups
   */
  readonly groups?: string[];

  /**
   * Username of the user.
   *
   * @schema BrokerSpecInitProviderUser#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'BrokerSpecInitProviderUser' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecInitProviderUser(obj: BrokerSpecInitProviderUser | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consoleAccess': obj.consoleAccess,
    'groups': obj.groups?.map(y => y),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BrokerSpecProviderConfigRefPolicy
 */
export interface BrokerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BrokerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BrokerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BrokerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BrokerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BrokerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecProviderConfigRefPolicy(obj: BrokerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BrokerSpecPublishConnectionDetailsToConfigRef
 */
export interface BrokerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BrokerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BrokerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BrokerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BrokerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecPublishConnectionDetailsToConfigRef(obj: BrokerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BrokerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BrokerSpecPublishConnectionDetailsToMetadata
 */
export interface BrokerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BrokerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BrokerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BrokerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BrokerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecPublishConnectionDetailsToMetadata(obj: BrokerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Configuration in mq to populate id.
 *
 * @schema BrokerSpecForProviderConfigurationIdRef
 */
export interface BrokerSpecForProviderConfigurationIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema BrokerSpecForProviderConfigurationIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BrokerSpecForProviderConfigurationIdRef#policy
   */
  readonly policy?: BrokerSpecForProviderConfigurationIdRefPolicy;

}

/**
 * Converts an object of type 'BrokerSpecForProviderConfigurationIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderConfigurationIdRef(obj: BrokerSpecForProviderConfigurationIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BrokerSpecForProviderConfigurationIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Configuration in mq to populate id.
 *
 * @schema BrokerSpecForProviderConfigurationIdSelector
 */
export interface BrokerSpecForProviderConfigurationIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BrokerSpecForProviderConfigurationIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BrokerSpecForProviderConfigurationIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BrokerSpecForProviderConfigurationIdSelector#policy
   */
  readonly policy?: BrokerSpecForProviderConfigurationIdSelectorPolicy;

}

/**
 * Converts an object of type 'BrokerSpecForProviderConfigurationIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderConfigurationIdSelector(obj: BrokerSpecForProviderConfigurationIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BrokerSpecForProviderConfigurationIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service account password.
 *
 * @schema BrokerSpecForProviderLdapServerMetadataServiceAccountPasswordSecretRef
 */
export interface BrokerSpecForProviderLdapServerMetadataServiceAccountPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema BrokerSpecForProviderLdapServerMetadataServiceAccountPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema BrokerSpecForProviderLdapServerMetadataServiceAccountPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BrokerSpecForProviderLdapServerMetadataServiceAccountPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BrokerSpecForProviderLdapServerMetadataServiceAccountPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderLdapServerMetadataServiceAccountPasswordSecretRef(obj: BrokerSpecForProviderLdapServerMetadataServiceAccountPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BrokerSpecForProviderSecurityGroupRefsPolicy
 */
export interface BrokerSpecForProviderSecurityGroupRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BrokerSpecForProviderSecurityGroupRefsPolicy#resolution
   */
  readonly resolution?: BrokerSpecForProviderSecurityGroupRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BrokerSpecForProviderSecurityGroupRefsPolicy#resolve
   */
  readonly resolve?: BrokerSpecForProviderSecurityGroupRefsPolicyResolve;

}

/**
 * Converts an object of type 'BrokerSpecForProviderSecurityGroupRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderSecurityGroupRefsPolicy(obj: BrokerSpecForProviderSecurityGroupRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BrokerSpecForProviderSecurityGroupSelectorPolicy
 */
export interface BrokerSpecForProviderSecurityGroupSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BrokerSpecForProviderSecurityGroupSelectorPolicy#resolution
   */
  readonly resolution?: BrokerSpecForProviderSecurityGroupSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BrokerSpecForProviderSecurityGroupSelectorPolicy#resolve
   */
  readonly resolve?: BrokerSpecForProviderSecurityGroupSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BrokerSpecForProviderSecurityGroupSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderSecurityGroupSelectorPolicy(obj: BrokerSpecForProviderSecurityGroupSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BrokerSpecForProviderSubnetIdRefsPolicy
 */
export interface BrokerSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BrokerSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: BrokerSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BrokerSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: BrokerSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'BrokerSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderSubnetIdRefsPolicy(obj: BrokerSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BrokerSpecForProviderSubnetIdSelectorPolicy
 */
export interface BrokerSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BrokerSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: BrokerSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BrokerSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: BrokerSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BrokerSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderSubnetIdSelectorPolicy(obj: BrokerSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Password of the user. It must be 12 to 250 characters long, at least 4 unique characters, and must not contain commas.
 *
 * @schema BrokerSpecForProviderUserPasswordSecretRef
 */
export interface BrokerSpecForProviderUserPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema BrokerSpecForProviderUserPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema BrokerSpecForProviderUserPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BrokerSpecForProviderUserPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BrokerSpecForProviderUserPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderUserPasswordSecretRef(obj: BrokerSpecForProviderUserPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BrokerSpecProviderConfigRefPolicyResolution
 */
export enum BrokerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BrokerSpecProviderConfigRefPolicyResolve
 */
export enum BrokerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BrokerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BrokerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BrokerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BrokerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BrokerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BrokerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BrokerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecPublishConnectionDetailsToConfigRefPolicy(obj: BrokerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BrokerSpecForProviderConfigurationIdRefPolicy
 */
export interface BrokerSpecForProviderConfigurationIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BrokerSpecForProviderConfigurationIdRefPolicy#resolution
   */
  readonly resolution?: BrokerSpecForProviderConfigurationIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BrokerSpecForProviderConfigurationIdRefPolicy#resolve
   */
  readonly resolve?: BrokerSpecForProviderConfigurationIdRefPolicyResolve;

}

/**
 * Converts an object of type 'BrokerSpecForProviderConfigurationIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderConfigurationIdRefPolicy(obj: BrokerSpecForProviderConfigurationIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BrokerSpecForProviderConfigurationIdSelectorPolicy
 */
export interface BrokerSpecForProviderConfigurationIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BrokerSpecForProviderConfigurationIdSelectorPolicy#resolution
   */
  readonly resolution?: BrokerSpecForProviderConfigurationIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BrokerSpecForProviderConfigurationIdSelectorPolicy#resolve
   */
  readonly resolve?: BrokerSpecForProviderConfigurationIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BrokerSpecForProviderConfigurationIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BrokerSpecForProviderConfigurationIdSelectorPolicy(obj: BrokerSpecForProviderConfigurationIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BrokerSpecForProviderSecurityGroupRefsPolicyResolution
 */
export enum BrokerSpecForProviderSecurityGroupRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BrokerSpecForProviderSecurityGroupRefsPolicyResolve
 */
export enum BrokerSpecForProviderSecurityGroupRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BrokerSpecForProviderSecurityGroupSelectorPolicyResolution
 */
export enum BrokerSpecForProviderSecurityGroupSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BrokerSpecForProviderSecurityGroupSelectorPolicyResolve
 */
export enum BrokerSpecForProviderSecurityGroupSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BrokerSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum BrokerSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BrokerSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum BrokerSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BrokerSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum BrokerSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BrokerSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum BrokerSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BrokerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BrokerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BrokerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BrokerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BrokerSpecForProviderConfigurationIdRefPolicyResolution
 */
export enum BrokerSpecForProviderConfigurationIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BrokerSpecForProviderConfigurationIdRefPolicyResolve
 */
export enum BrokerSpecForProviderConfigurationIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BrokerSpecForProviderConfigurationIdSelectorPolicyResolution
 */
export enum BrokerSpecForProviderConfigurationIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BrokerSpecForProviderConfigurationIdSelectorPolicyResolve
 */
export enum BrokerSpecForProviderConfigurationIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Configuration is the Schema for the Configurations API. Provides an MQ configuration Resource
 *
 * @schema Configuration
 */
export class Configuration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Configuration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'mq.aws.upbound.io/v1beta1',
    kind: 'Configuration',
  }

  /**
   * Renders a Kubernetes manifest for "Configuration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConfigurationProps): any {
    return {
      ...Configuration.GVK,
      ...toJson_ConfigurationProps(props),
    };
  }

  /**
   * Defines a "Configuration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConfigurationProps) {
    super(scope, id, {
      ...Configuration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Configuration.GVK,
      ...toJson_ConfigurationProps(resolved),
    };
  }
}

/**
 * Configuration is the Schema for the Configurations API. Provides an MQ configuration Resource
 *
 * @schema Configuration
 */
export interface ConfigurationProps {
  /**
   * @schema Configuration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConfigurationSpec defines the desired state of Configuration
   *
   * @schema Configuration#spec
   */
  readonly spec: ConfigurationSpec;

}

/**
 * Converts an object of type 'ConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProps(obj: ConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigurationSpec defines the desired state of Configuration
 *
 * @schema ConfigurationSpec
 */
export interface ConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConfigurationSpecDeletionPolicy;

  /**
   * @schema ConfigurationSpec#forProvider
   */
  readonly forProvider: ConfigurationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ConfigurationSpec#initProvider
   */
  readonly initProvider?: ConfigurationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ConfigurationSpec#managementPolicies
   */
  readonly managementPolicies?: ConfigurationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConfigurationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpec(obj: ConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConfigurationSpecForProvider(obj.forProvider),
    'initProvider': toJson_ConfigurationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConfigurationSpecDeletionPolicy
 */
export enum ConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConfigurationSpecForProvider
 */
export interface ConfigurationSpecForProvider {
  /**
   * Authentication strategy associated with the configuration. Valid values are simple and ldap. ldap is not supported for engine_type RabbitMQ.
   *
   * @schema ConfigurationSpecForProvider#authenticationStrategy
   */
  readonly authenticationStrategy?: string;

  /**
   * Broker configuration in XML format. See official docs for supported parameters and format of the XML.
   *
   * @schema ConfigurationSpecForProvider#data
   */
  readonly data?: string;

  /**
   * Description of the configuration.
   *
   * @schema ConfigurationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Type of broker engine. Valid values are ActiveMQ and RabbitMQ.
   *
   * @schema ConfigurationSpecForProvider#engineType
   */
  readonly engineType?: string;

  /**
   * Version of the broker engine.
   *
   * @schema ConfigurationSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * Name of the configuration.
   *
   * @schema ConfigurationSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ConfigurationSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecForProvider(obj: ConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticationStrategy': obj.authenticationStrategy,
    'data': obj.data,
    'description': obj.description,
    'engineType': obj.engineType,
    'engineVersion': obj.engineVersion,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ConfigurationSpecInitProvider
 */
export interface ConfigurationSpecInitProvider {
  /**
   * Authentication strategy associated with the configuration. Valid values are simple and ldap. ldap is not supported for engine_type RabbitMQ.
   *
   * @schema ConfigurationSpecInitProvider#authenticationStrategy
   */
  readonly authenticationStrategy?: string;

  /**
   * Broker configuration in XML format. See official docs for supported parameters and format of the XML.
   *
   * @schema ConfigurationSpecInitProvider#data
   */
  readonly data?: string;

  /**
   * Description of the configuration.
   *
   * @schema ConfigurationSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Type of broker engine. Valid values are ActiveMQ and RabbitMQ.
   *
   * @schema ConfigurationSpecInitProvider#engineType
   */
  readonly engineType?: string;

  /**
   * Version of the broker engine.
   *
   * @schema ConfigurationSpecInitProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * Name of the configuration.
   *
   * @schema ConfigurationSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ConfigurationSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ConfigurationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecInitProvider(obj: ConfigurationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticationStrategy': obj.authenticationStrategy,
    'data': obj.data,
    'description': obj.description,
    'engineType': obj.engineType,
    'engineVersion': obj.engineVersion,
    'name': obj.name,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ConfigurationSpecManagementPolicies
 */
export enum ConfigurationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConfigurationSpecProviderConfigRef
 */
export interface ConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: ConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecProviderConfigRef(obj: ConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsTo
 */
export interface ConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecPublishConnectionDetailsTo(obj: ConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConfigurationSpecWriteConnectionSecretToRef
 */
export interface ConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecWriteConnectionSecretToRef(obj: ConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSpecProviderConfigRefPolicy
 */
export interface ConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecProviderConfigRefPolicy(obj: ConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface ConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecPublishConnectionDetailsToConfigRef(obj: ConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface ConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecPublishConnectionDetailsToMetadata(obj: ConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum ConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum ConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

