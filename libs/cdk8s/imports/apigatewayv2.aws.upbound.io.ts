// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * API is the Schema for the APIs API. Manages an Amazon API Gateway Version 2 API.
 *
 * @schema API
 */
export class Api extends ApiObject {
  /**
   * Returns the apiVersion and kind for "API"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.upbound.io/v1beta1',
    kind: 'API',
  }

  /**
   * Renders a Kubernetes manifest for "API".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiProps): any {
    return {
      ...Api.GVK,
      ...toJson_ApiProps(props),
    };
  }

  /**
   * Defines a "API" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiProps) {
    super(scope, id, {
      ...Api.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Api.GVK,
      ...toJson_ApiProps(resolved),
    };
  }
}

/**
 * API is the Schema for the APIs API. Manages an Amazon API Gateway Version 2 API.
 *
 * @schema API
 */
export interface ApiProps {
  /**
   * @schema API#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * APISpec defines the desired state of API
   *
   * @schema API#spec
   */
  readonly spec: ApiSpec;

}

/**
 * Converts an object of type 'ApiProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiProps(obj: ApiProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APISpec defines the desired state of API
 *
 * @schema ApiSpec
 */
export interface ApiSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApiSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApiSpecDeletionPolicy;

  /**
   * @schema ApiSpec#forProvider
   */
  readonly forProvider: ApiSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApiSpec#managementPolicy
   */
  readonly managementPolicy?: ApiSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApiSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApiSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ApiSpec#providerRef
   */
  readonly providerRef?: ApiSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApiSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApiSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApiSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApiSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApiSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpec(obj: ApiSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApiSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ApiSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ApiSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ApiSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApiSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApiSpecDeletionPolicy
 */
export enum ApiSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApiSpecForProvider
 */
export interface ApiSpecForProvider {
  /**
   * An API key selection expression. Valid values: $context.authorizer.usageIdentifierKey, $request.header.x-api-key. Defaults to $request.header.x-api-key. Applicable for WebSocket APIs.
   *
   * @default request.header.x-api-key. Applicable for WebSocket APIs.
   * @schema ApiSpecForProvider#apiKeySelectionExpression
   */
  readonly apiKeySelectionExpression?: string;

  /**
   * An OpenAPI specification that defines the set of routes and integrations to create as part of the HTTP APIs. Supported only for HTTP APIs.
   *
   * @schema ApiSpecForProvider#body
   */
  readonly body?: string;

  /**
   * Cross-origin resource sharing (CORS) configuration. Applicable for HTTP APIs.
   *
   * @schema ApiSpecForProvider#corsConfiguration
   */
  readonly corsConfiguration?: ApiSpecForProviderCorsConfiguration[];

  /**
   * Part of quick create. Specifies any credentials required for the integration. Applicable for HTTP APIs.
   *
   * @schema ApiSpecForProvider#credentialsArn
   */
  readonly credentialsArn?: string;

  /**
   * Description of the API. Must be less than or equal to 1024 characters in length.
   *
   * @schema ApiSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Whether clients can invoke the API by using the default execute-api endpoint. By default, clients can invoke the API with the default {api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke the API, disable the default endpoint.
   *
   * @schema ApiSpecForProvider#disableExecuteApiEndpoint
   */
  readonly disableExecuteApiEndpoint?: boolean;

  /**
   * Whether warnings should return an error while API Gateway is creating or updating the resource using an OpenAPI specification. Defaults to false. Applicable for HTTP APIs.
   *
   * @default false. Applicable for HTTP APIs.
   * @schema ApiSpecForProvider#failOnWarnings
   */
  readonly failOnWarnings?: boolean;

  /**
   * Name of the API. Must be less than or equal to 128 characters in length.
   *
   * @schema ApiSpecForProvider#name
   */
  readonly name?: string;

  /**
   * API protocol. Valid values: HTTP, WEBSOCKET.
   *
   * @schema ApiSpecForProvider#protocolType
   */
  readonly protocolType?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ApiSpecForProvider#region
   */
  readonly region: string;

  /**
   * Part of quick create. Specifies any route key. Applicable for HTTP APIs.
   *
   * @schema ApiSpecForProvider#routeKey
   */
  readonly routeKey?: string;

  /**
   * The route selection expression for the API. Defaults to $request.method $request.path.
   *
   * @default request.method $request.path.
   * @schema ApiSpecForProvider#routeSelectionExpression
   */
  readonly routeSelectionExpression?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ApiSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Part of quick create. Quick create produces an API with an integration, a default catch-all route, and a default stage which is configured to automatically deploy changes. For HTTP integrations, specify a fully qualified URL. For Lambda integrations, specify a function ARN. The type of the integration will be HTTP_PROXY or AWS_PROXY, respectively. Applicable for HTTP APIs.
   *
   * @schema ApiSpecForProvider#target
   */
  readonly target?: string;

  /**
   * Version identifier for the API. Must be between 1 and 64 characters in length.
   *
   * @schema ApiSpecForProvider#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ApiSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecForProvider(obj: ApiSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKeySelectionExpression': obj.apiKeySelectionExpression,
    'body': obj.body,
    'corsConfiguration': obj.corsConfiguration?.map(y => toJson_ApiSpecForProviderCorsConfiguration(y)),
    'credentialsArn': obj.credentialsArn,
    'description': obj.description,
    'disableExecuteApiEndpoint': obj.disableExecuteApiEndpoint,
    'failOnWarnings': obj.failOnWarnings,
    'name': obj.name,
    'protocolType': obj.protocolType,
    'region': obj.region,
    'routeKey': obj.routeKey,
    'routeSelectionExpression': obj.routeSelectionExpression,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'target': obj.target,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApiSpecManagementPolicy
 */
export enum ApiSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApiSpecProviderConfigRef
 */
export interface ApiSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiSpecProviderConfigRef#policy
   */
  readonly policy?: ApiSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecProviderConfigRef(obj: ApiSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ApiSpecProviderRef
 */
export interface ApiSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiSpecProviderRef#policy
   */
  readonly policy?: ApiSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ApiSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecProviderRef(obj: ApiSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApiSpecPublishConnectionDetailsTo
 */
export interface ApiSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApiSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApiSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApiSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApiSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApiSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecPublishConnectionDetailsTo(obj: ApiSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApiSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApiSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApiSpecWriteConnectionSecretToRef
 */
export interface ApiSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApiSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApiSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApiSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecWriteConnectionSecretToRef(obj: ApiSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApiSpecForProviderCorsConfiguration
 */
export interface ApiSpecForProviderCorsConfiguration {
  /**
   * Whether credentials are included in the CORS request.
   *
   * @schema ApiSpecForProviderCorsConfiguration#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * Set of allowed HTTP headers.
   *
   * @schema ApiSpecForProviderCorsConfiguration#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * Set of allowed HTTP methods.
   *
   * @schema ApiSpecForProviderCorsConfiguration#allowMethods
   */
  readonly allowMethods?: string[];

  /**
   * Set of allowed origins.
   *
   * @schema ApiSpecForProviderCorsConfiguration#allowOrigins
   */
  readonly allowOrigins?: string[];

  /**
   * Set of exposed HTTP headers.
   *
   * @schema ApiSpecForProviderCorsConfiguration#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * Number of seconds that the browser should cache preflight request results.
   *
   * @schema ApiSpecForProviderCorsConfiguration#maxAge
   */
  readonly maxAge?: number;

}

/**
 * Converts an object of type 'ApiSpecForProviderCorsConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecForProviderCorsConfiguration(obj: ApiSpecForProviderCorsConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCredentials': obj.allowCredentials,
    'allowHeaders': obj.allowHeaders?.map(y => y),
    'allowMethods': obj.allowMethods?.map(y => y),
    'allowOrigins': obj.allowOrigins?.map(y => y),
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAge': obj.maxAge,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiSpecProviderConfigRefPolicy
 */
export interface ApiSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApiSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApiSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecProviderConfigRefPolicy(obj: ApiSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiSpecProviderRefPolicy
 */
export interface ApiSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ApiSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ApiSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecProviderRefPolicy(obj: ApiSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApiSpecPublishConnectionDetailsToConfigRef
 */
export interface ApiSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApiSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecPublishConnectionDetailsToConfigRef(obj: ApiSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApiSpecPublishConnectionDetailsToMetadata
 */
export interface ApiSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApiSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApiSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecPublishConnectionDetailsToMetadata(obj: ApiSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiSpecProviderConfigRefPolicyResolution
 */
export enum ApiSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiSpecProviderConfigRefPolicyResolve
 */
export enum ApiSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiSpecProviderRefPolicyResolution
 */
export enum ApiSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiSpecProviderRefPolicyResolve
 */
export enum ApiSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApiSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApiSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApiSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApiSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApiSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApiSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApiSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * APIMapping is the Schema for the APIMappings API. Manages an Amazon API Gateway Version 2 API mapping.
 *
 * @schema APIMapping
 */
export class ApiMapping extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APIMapping"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.upbound.io/v1beta1',
    kind: 'APIMapping',
  }

  /**
   * Renders a Kubernetes manifest for "APIMapping".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiMappingProps): any {
    return {
      ...ApiMapping.GVK,
      ...toJson_ApiMappingProps(props),
    };
  }

  /**
   * Defines a "APIMapping" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiMappingProps) {
    super(scope, id, {
      ...ApiMapping.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApiMapping.GVK,
      ...toJson_ApiMappingProps(resolved),
    };
  }
}

/**
 * APIMapping is the Schema for the APIMappings API. Manages an Amazon API Gateway Version 2 API mapping.
 *
 * @schema APIMapping
 */
export interface ApiMappingProps {
  /**
   * @schema APIMapping#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * APIMappingSpec defines the desired state of APIMapping
   *
   * @schema APIMapping#spec
   */
  readonly spec: ApiMappingSpec;

}

/**
 * Converts an object of type 'ApiMappingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingProps(obj: ApiMappingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiMappingSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIMappingSpec defines the desired state of APIMapping
 *
 * @schema ApiMappingSpec
 */
export interface ApiMappingSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApiMappingSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApiMappingSpecDeletionPolicy;

  /**
   * @schema ApiMappingSpec#forProvider
   */
  readonly forProvider: ApiMappingSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApiMappingSpec#managementPolicy
   */
  readonly managementPolicy?: ApiMappingSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApiMappingSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApiMappingSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ApiMappingSpec#providerRef
   */
  readonly providerRef?: ApiMappingSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApiMappingSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApiMappingSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApiMappingSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApiMappingSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApiMappingSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpec(obj: ApiMappingSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApiMappingSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ApiMappingSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ApiMappingSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ApiMappingSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApiMappingSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApiMappingSpecDeletionPolicy
 */
export enum ApiMappingSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApiMappingSpecForProvider
 */
export interface ApiMappingSpecForProvider {
  /**
   * API identifier.
   *
   * @schema ApiMappingSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * Reference to a API to populate apiId.
   *
   * @schema ApiMappingSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: ApiMappingSpecForProviderApiIdRef;

  /**
   * Selector for a API to populate apiId.
   *
   * @schema ApiMappingSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: ApiMappingSpecForProviderApiIdSelector;

  /**
   * The API mapping key. Refer to REST API, HTTP API or WebSocket API.
   *
   * @schema ApiMappingSpecForProvider#apiMappingKey
   */
  readonly apiMappingKey?: string;

  /**
   * Domain name. Use the aws_apigatewayv2_domain_name resource to configure a domain name.
   *
   * @schema ApiMappingSpecForProvider#domainName
   */
  readonly domainName?: string;

  /**
   * Reference to a DomainName to populate domainName.
   *
   * @schema ApiMappingSpecForProvider#domainNameRef
   */
  readonly domainNameRef?: ApiMappingSpecForProviderDomainNameRef;

  /**
   * Selector for a DomainName to populate domainName.
   *
   * @schema ApiMappingSpecForProvider#domainNameSelector
   */
  readonly domainNameSelector?: ApiMappingSpecForProviderDomainNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ApiMappingSpecForProvider#region
   */
  readonly region: string;

  /**
   * API stage. Use the aws_apigatewayv2_stage resource to configure an API stage.
   *
   * @schema ApiMappingSpecForProvider#stage
   */
  readonly stage?: string;

  /**
   * Reference to a Stage to populate stage.
   *
   * @schema ApiMappingSpecForProvider#stageRef
   */
  readonly stageRef?: ApiMappingSpecForProviderStageRef;

  /**
   * Selector for a Stage to populate stage.
   *
   * @schema ApiMappingSpecForProvider#stageSelector
   */
  readonly stageSelector?: ApiMappingSpecForProviderStageSelector;

}

/**
 * Converts an object of type 'ApiMappingSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProvider(obj: ApiMappingSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_ApiMappingSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_ApiMappingSpecForProviderApiIdSelector(obj.apiIdSelector),
    'apiMappingKey': obj.apiMappingKey,
    'domainName': obj.domainName,
    'domainNameRef': toJson_ApiMappingSpecForProviderDomainNameRef(obj.domainNameRef),
    'domainNameSelector': toJson_ApiMappingSpecForProviderDomainNameSelector(obj.domainNameSelector),
    'region': obj.region,
    'stage': obj.stage,
    'stageRef': toJson_ApiMappingSpecForProviderStageRef(obj.stageRef),
    'stageSelector': toJson_ApiMappingSpecForProviderStageSelector(obj.stageSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApiMappingSpecManagementPolicy
 */
export enum ApiMappingSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApiMappingSpecProviderConfigRef
 */
export interface ApiMappingSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiMappingSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiMappingSpecProviderConfigRef#policy
   */
  readonly policy?: ApiMappingSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiMappingSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecProviderConfigRef(obj: ApiMappingSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiMappingSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ApiMappingSpecProviderRef
 */
export interface ApiMappingSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiMappingSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiMappingSpecProviderRef#policy
   */
  readonly policy?: ApiMappingSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ApiMappingSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecProviderRef(obj: ApiMappingSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiMappingSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApiMappingSpecPublishConnectionDetailsTo
 */
export interface ApiMappingSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApiMappingSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApiMappingSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiMappingSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecPublishConnectionDetailsTo(obj: ApiMappingSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApiMappingSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApiMappingSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApiMappingSpecWriteConnectionSecretToRef
 */
export interface ApiMappingSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApiMappingSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApiMappingSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApiMappingSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecWriteConnectionSecretToRef(obj: ApiMappingSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a API to populate apiId.
 *
 * @schema ApiMappingSpecForProviderApiIdRef
 */
export interface ApiMappingSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiMappingSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiMappingSpecForProviderApiIdRef#policy
   */
  readonly policy?: ApiMappingSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderApiIdRef(obj: ApiMappingSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiMappingSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a API to populate apiId.
 *
 * @schema ApiMappingSpecForProviderApiIdSelector
 */
export interface ApiMappingSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApiMappingSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApiMappingSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApiMappingSpecForProviderApiIdSelector#policy
   */
  readonly policy?: ApiMappingSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderApiIdSelector(obj: ApiMappingSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApiMappingSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DomainName to populate domainName.
 *
 * @schema ApiMappingSpecForProviderDomainNameRef
 */
export interface ApiMappingSpecForProviderDomainNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiMappingSpecForProviderDomainNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiMappingSpecForProviderDomainNameRef#policy
   */
  readonly policy?: ApiMappingSpecForProviderDomainNameRefPolicy;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderDomainNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderDomainNameRef(obj: ApiMappingSpecForProviderDomainNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiMappingSpecForProviderDomainNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DomainName to populate domainName.
 *
 * @schema ApiMappingSpecForProviderDomainNameSelector
 */
export interface ApiMappingSpecForProviderDomainNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApiMappingSpecForProviderDomainNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApiMappingSpecForProviderDomainNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApiMappingSpecForProviderDomainNameSelector#policy
   */
  readonly policy?: ApiMappingSpecForProviderDomainNameSelectorPolicy;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderDomainNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderDomainNameSelector(obj: ApiMappingSpecForProviderDomainNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApiMappingSpecForProviderDomainNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stage to populate stage.
 *
 * @schema ApiMappingSpecForProviderStageRef
 */
export interface ApiMappingSpecForProviderStageRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiMappingSpecForProviderStageRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiMappingSpecForProviderStageRef#policy
   */
  readonly policy?: ApiMappingSpecForProviderStageRefPolicy;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderStageRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderStageRef(obj: ApiMappingSpecForProviderStageRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiMappingSpecForProviderStageRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stage to populate stage.
 *
 * @schema ApiMappingSpecForProviderStageSelector
 */
export interface ApiMappingSpecForProviderStageSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApiMappingSpecForProviderStageSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApiMappingSpecForProviderStageSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApiMappingSpecForProviderStageSelector#policy
   */
  readonly policy?: ApiMappingSpecForProviderStageSelectorPolicy;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderStageSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderStageSelector(obj: ApiMappingSpecForProviderStageSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApiMappingSpecForProviderStageSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiMappingSpecProviderConfigRefPolicy
 */
export interface ApiMappingSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiMappingSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApiMappingSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiMappingSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApiMappingSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiMappingSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecProviderConfigRefPolicy(obj: ApiMappingSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiMappingSpecProviderRefPolicy
 */
export interface ApiMappingSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiMappingSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ApiMappingSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiMappingSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ApiMappingSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiMappingSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecProviderRefPolicy(obj: ApiMappingSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApiMappingSpecPublishConnectionDetailsToConfigRef
 */
export interface ApiMappingSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiMappingSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecPublishConnectionDetailsToConfigRef(obj: ApiMappingSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApiMappingSpecPublishConnectionDetailsToMetadata
 */
export interface ApiMappingSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApiMappingSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecPublishConnectionDetailsToMetadata(obj: ApiMappingSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiMappingSpecForProviderApiIdRefPolicy
 */
export interface ApiMappingSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiMappingSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: ApiMappingSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiMappingSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: ApiMappingSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderApiIdRefPolicy(obj: ApiMappingSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApiMappingSpecForProviderApiIdSelectorPolicy
 */
export interface ApiMappingSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiMappingSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: ApiMappingSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiMappingSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: ApiMappingSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderApiIdSelectorPolicy(obj: ApiMappingSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiMappingSpecForProviderDomainNameRefPolicy
 */
export interface ApiMappingSpecForProviderDomainNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiMappingSpecForProviderDomainNameRefPolicy#resolution
   */
  readonly resolution?: ApiMappingSpecForProviderDomainNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiMappingSpecForProviderDomainNameRefPolicy#resolve
   */
  readonly resolve?: ApiMappingSpecForProviderDomainNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderDomainNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderDomainNameRefPolicy(obj: ApiMappingSpecForProviderDomainNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApiMappingSpecForProviderDomainNameSelectorPolicy
 */
export interface ApiMappingSpecForProviderDomainNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiMappingSpecForProviderDomainNameSelectorPolicy#resolution
   */
  readonly resolution?: ApiMappingSpecForProviderDomainNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiMappingSpecForProviderDomainNameSelectorPolicy#resolve
   */
  readonly resolve?: ApiMappingSpecForProviderDomainNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderDomainNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderDomainNameSelectorPolicy(obj: ApiMappingSpecForProviderDomainNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiMappingSpecForProviderStageRefPolicy
 */
export interface ApiMappingSpecForProviderStageRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiMappingSpecForProviderStageRefPolicy#resolution
   */
  readonly resolution?: ApiMappingSpecForProviderStageRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiMappingSpecForProviderStageRefPolicy#resolve
   */
  readonly resolve?: ApiMappingSpecForProviderStageRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderStageRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderStageRefPolicy(obj: ApiMappingSpecForProviderStageRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApiMappingSpecForProviderStageSelectorPolicy
 */
export interface ApiMappingSpecForProviderStageSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiMappingSpecForProviderStageSelectorPolicy#resolution
   */
  readonly resolution?: ApiMappingSpecForProviderStageSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiMappingSpecForProviderStageSelectorPolicy#resolve
   */
  readonly resolve?: ApiMappingSpecForProviderStageSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApiMappingSpecForProviderStageSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecForProviderStageSelectorPolicy(obj: ApiMappingSpecForProviderStageSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiMappingSpecProviderConfigRefPolicyResolution
 */
export enum ApiMappingSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiMappingSpecProviderConfigRefPolicyResolve
 */
export enum ApiMappingSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiMappingSpecProviderRefPolicyResolution
 */
export enum ApiMappingSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiMappingSpecProviderRefPolicyResolve
 */
export enum ApiMappingSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApiMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApiMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApiMappingSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiMappingSpecForProviderApiIdRefPolicyResolution
 */
export enum ApiMappingSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiMappingSpecForProviderApiIdRefPolicyResolve
 */
export enum ApiMappingSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiMappingSpecForProviderApiIdSelectorPolicyResolution
 */
export enum ApiMappingSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiMappingSpecForProviderApiIdSelectorPolicyResolve
 */
export enum ApiMappingSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiMappingSpecForProviderDomainNameRefPolicyResolution
 */
export enum ApiMappingSpecForProviderDomainNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiMappingSpecForProviderDomainNameRefPolicyResolve
 */
export enum ApiMappingSpecForProviderDomainNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiMappingSpecForProviderDomainNameSelectorPolicyResolution
 */
export enum ApiMappingSpecForProviderDomainNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiMappingSpecForProviderDomainNameSelectorPolicyResolve
 */
export enum ApiMappingSpecForProviderDomainNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiMappingSpecForProviderStageRefPolicyResolution
 */
export enum ApiMappingSpecForProviderStageRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiMappingSpecForProviderStageRefPolicyResolve
 */
export enum ApiMappingSpecForProviderStageRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiMappingSpecForProviderStageSelectorPolicyResolution
 */
export enum ApiMappingSpecForProviderStageSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiMappingSpecForProviderStageSelectorPolicyResolve
 */
export enum ApiMappingSpecForProviderStageSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApiMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApiMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Authorizer is the Schema for the Authorizers API. Manages an Amazon API Gateway Version 2 authorizer.
 *
 * @schema Authorizer
 */
export class Authorizer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Authorizer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.upbound.io/v1beta1',
    kind: 'Authorizer',
  }

  /**
   * Renders a Kubernetes manifest for "Authorizer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AuthorizerProps): any {
    return {
      ...Authorizer.GVK,
      ...toJson_AuthorizerProps(props),
    };
  }

  /**
   * Defines a "Authorizer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AuthorizerProps) {
    super(scope, id, {
      ...Authorizer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Authorizer.GVK,
      ...toJson_AuthorizerProps(resolved),
    };
  }
}

/**
 * Authorizer is the Schema for the Authorizers API. Manages an Amazon API Gateway Version 2 authorizer.
 *
 * @schema Authorizer
 */
export interface AuthorizerProps {
  /**
   * @schema Authorizer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AuthorizerSpec defines the desired state of Authorizer
   *
   * @schema Authorizer#spec
   */
  readonly spec: AuthorizerSpec;

}

/**
 * Converts an object of type 'AuthorizerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerProps(obj: AuthorizerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AuthorizerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AuthorizerSpec defines the desired state of Authorizer
 *
 * @schema AuthorizerSpec
 */
export interface AuthorizerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AuthorizerSpec#deletionPolicy
   */
  readonly deletionPolicy?: AuthorizerSpecDeletionPolicy;

  /**
   * @schema AuthorizerSpec#forProvider
   */
  readonly forProvider: AuthorizerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AuthorizerSpec#managementPolicy
   */
  readonly managementPolicy?: AuthorizerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AuthorizerSpec#providerConfigRef
   */
  readonly providerConfigRef?: AuthorizerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AuthorizerSpec#providerRef
   */
  readonly providerRef?: AuthorizerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AuthorizerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AuthorizerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AuthorizerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AuthorizerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AuthorizerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpec(obj: AuthorizerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AuthorizerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AuthorizerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AuthorizerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AuthorizerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AuthorizerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AuthorizerSpecDeletionPolicy
 */
export enum AuthorizerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AuthorizerSpecForProvider
 */
export interface AuthorizerSpecForProvider {
  /**
   * API identifier.
   *
   * @schema AuthorizerSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * Reference to a API to populate apiId.
   *
   * @schema AuthorizerSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: AuthorizerSpecForProviderApiIdRef;

  /**
   * Selector for a API to populate apiId.
   *
   * @schema AuthorizerSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: AuthorizerSpecForProviderApiIdSelector;

  /**
   * Required credentials as an IAM role for API Gateway to invoke the authorizer. Supported only for REQUEST authorizers.
   *
   * @schema AuthorizerSpecForProvider#authorizerCredentialsArn
   */
  readonly authorizerCredentialsArn?: string;

  /**
   * Format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Valid values: 1.0, 2.0.
   *
   * @schema AuthorizerSpecForProvider#authorizerPayloadFormatVersion
   */
  readonly authorizerPayloadFormatVersion?: string;

  /**
   * Time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Defaults to 300. Supported only for HTTP API Lambda authorizers.
   *
   * @default 300. Supported only for HTTP API Lambda authorizers.
   * @schema AuthorizerSpecForProvider#authorizerResultTtlInSeconds
   */
  readonly authorizerResultTtlInSeconds?: number;

  /**
   * Authorizer type. Valid values: JWT, REQUEST. Specify REQUEST for a Lambda function using incoming request parameters. For HTTP APIs, specify JWT to use JSON Web Tokens.
   *
   * @schema AuthorizerSpecForProvider#authorizerType
   */
  readonly authorizerType?: string;

  /**
   * Authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers this must be a well-formed Lambda function URI, such as the invoke_arn attribute of the aws_lambda_function resource. Supported only for REQUEST authorizers. Must be between 1 and 2048 characters in length.
   *
   * @schema AuthorizerSpecForProvider#authorizerUri
   */
  readonly authorizerUri?: string;

  /**
   * Reference to a Function in lambda to populate authorizerUri.
   *
   * @schema AuthorizerSpecForProvider#authorizerUriRef
   */
  readonly authorizerUriRef?: AuthorizerSpecForProviderAuthorizerUriRef;

  /**
   * Selector for a Function in lambda to populate authorizerUri.
   *
   * @schema AuthorizerSpecForProvider#authorizerUriSelector
   */
  readonly authorizerUriSelector?: AuthorizerSpecForProviderAuthorizerUriSelector;

  /**
   * Whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs.
   *
   * @schema AuthorizerSpecForProvider#enableSimpleResponses
   */
  readonly enableSimpleResponses?: boolean;

  /**
   * Identity sources for which authorization is requested. For REQUEST authorizers the value is a list of one or more mapping expressions of the specified request parameters. For JWT authorizers the single entry specifies where to extract the JSON Web Token (JWT) from inbound requests.
   *
   * @schema AuthorizerSpecForProvider#identitySources
   */
  readonly identitySources?: string[];

  /**
   * Configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
   *
   * @schema AuthorizerSpecForProvider#jwtConfiguration
   */
  readonly jwtConfiguration?: AuthorizerSpecForProviderJwtConfiguration[];

  /**
   * Name of the authorizer. Must be between 1 and 128 characters in length.
   *
   * @schema AuthorizerSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AuthorizerSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'AuthorizerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProvider(obj: AuthorizerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_AuthorizerSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_AuthorizerSpecForProviderApiIdSelector(obj.apiIdSelector),
    'authorizerCredentialsArn': obj.authorizerCredentialsArn,
    'authorizerPayloadFormatVersion': obj.authorizerPayloadFormatVersion,
    'authorizerResultTtlInSeconds': obj.authorizerResultTtlInSeconds,
    'authorizerType': obj.authorizerType,
    'authorizerUri': obj.authorizerUri,
    'authorizerUriRef': toJson_AuthorizerSpecForProviderAuthorizerUriRef(obj.authorizerUriRef),
    'authorizerUriSelector': toJson_AuthorizerSpecForProviderAuthorizerUriSelector(obj.authorizerUriSelector),
    'enableSimpleResponses': obj.enableSimpleResponses,
    'identitySources': obj.identitySources?.map(y => y),
    'jwtConfiguration': obj.jwtConfiguration?.map(y => toJson_AuthorizerSpecForProviderJwtConfiguration(y)),
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AuthorizerSpecManagementPolicy
 */
export enum AuthorizerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AuthorizerSpecProviderConfigRef
 */
export interface AuthorizerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthorizerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthorizerSpecProviderConfigRef#policy
   */
  readonly policy?: AuthorizerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecProviderConfigRef(obj: AuthorizerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthorizerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AuthorizerSpecProviderRef
 */
export interface AuthorizerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthorizerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthorizerSpecProviderRef#policy
   */
  readonly policy?: AuthorizerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecProviderRef(obj: AuthorizerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthorizerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsTo
 */
export interface AuthorizerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AuthorizerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AuthorizerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AuthorizerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecPublishConnectionDetailsTo(obj: AuthorizerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AuthorizerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AuthorizerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AuthorizerSpecWriteConnectionSecretToRef
 */
export interface AuthorizerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AuthorizerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AuthorizerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AuthorizerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecWriteConnectionSecretToRef(obj: AuthorizerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a API to populate apiId.
 *
 * @schema AuthorizerSpecForProviderApiIdRef
 */
export interface AuthorizerSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthorizerSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthorizerSpecForProviderApiIdRef#policy
   */
  readonly policy?: AuthorizerSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderApiIdRef(obj: AuthorizerSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthorizerSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a API to populate apiId.
 *
 * @schema AuthorizerSpecForProviderApiIdSelector
 */
export interface AuthorizerSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AuthorizerSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AuthorizerSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AuthorizerSpecForProviderApiIdSelector#policy
   */
  readonly policy?: AuthorizerSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderApiIdSelector(obj: AuthorizerSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AuthorizerSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function in lambda to populate authorizerUri.
 *
 * @schema AuthorizerSpecForProviderAuthorizerUriRef
 */
export interface AuthorizerSpecForProviderAuthorizerUriRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriRef#policy
   */
  readonly policy?: AuthorizerSpecForProviderAuthorizerUriRefPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderAuthorizerUriRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderAuthorizerUriRef(obj: AuthorizerSpecForProviderAuthorizerUriRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthorizerSpecForProviderAuthorizerUriRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function in lambda to populate authorizerUri.
 *
 * @schema AuthorizerSpecForProviderAuthorizerUriSelector
 */
export interface AuthorizerSpecForProviderAuthorizerUriSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriSelector#policy
   */
  readonly policy?: AuthorizerSpecForProviderAuthorizerUriSelectorPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderAuthorizerUriSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderAuthorizerUriSelector(obj: AuthorizerSpecForProviderAuthorizerUriSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AuthorizerSpecForProviderAuthorizerUriSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AuthorizerSpecForProviderJwtConfiguration
 */
export interface AuthorizerSpecForProviderJwtConfiguration {
  /**
   * List of the intended recipients of the JWT. A valid JWT must provide an aud that matches at least one entry in this list.
   *
   * @schema AuthorizerSpecForProviderJwtConfiguration#audience
   */
  readonly audience?: string[];

  /**
   * Base domain of the identity provider that issues JSON Web Tokens, such as the endpoint attribute of the aws_cognito_user_pool resource.
   *
   * @schema AuthorizerSpecForProviderJwtConfiguration#issuer
   */
  readonly issuer?: string;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderJwtConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderJwtConfiguration(obj: AuthorizerSpecForProviderJwtConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience?.map(y => y),
    'issuer': obj.issuer,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AuthorizerSpecProviderConfigRefPolicy
 */
export interface AuthorizerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecProviderConfigRefPolicy(obj: AuthorizerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AuthorizerSpecProviderRefPolicy
 */
export interface AuthorizerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecProviderRefPolicy(obj: AuthorizerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToConfigRef
 */
export interface AuthorizerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecPublishConnectionDetailsToConfigRef(obj: AuthorizerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToMetadata
 */
export interface AuthorizerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AuthorizerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecPublishConnectionDetailsToMetadata(obj: AuthorizerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AuthorizerSpecForProviderApiIdRefPolicy
 */
export interface AuthorizerSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderApiIdRefPolicy(obj: AuthorizerSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AuthorizerSpecForProviderApiIdSelectorPolicy
 */
export interface AuthorizerSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderApiIdSelectorPolicy(obj: AuthorizerSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AuthorizerSpecForProviderAuthorizerUriRefPolicy
 */
export interface AuthorizerSpecForProviderAuthorizerUriRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriRefPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecForProviderAuthorizerUriRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriRefPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecForProviderAuthorizerUriRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderAuthorizerUriRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderAuthorizerUriRefPolicy(obj: AuthorizerSpecForProviderAuthorizerUriRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AuthorizerSpecForProviderAuthorizerUriSelectorPolicy
 */
export interface AuthorizerSpecForProviderAuthorizerUriSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriSelectorPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecForProviderAuthorizerUriSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriSelectorPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecForProviderAuthorizerUriSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderAuthorizerUriSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderAuthorizerUriSelectorPolicy(obj: AuthorizerSpecForProviderAuthorizerUriSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecProviderConfigRefPolicyResolution
 */
export enum AuthorizerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecProviderConfigRefPolicyResolve
 */
export enum AuthorizerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecProviderRefPolicyResolution
 */
export enum AuthorizerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecProviderRefPolicyResolve
 */
export enum AuthorizerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy(obj: AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecForProviderApiIdRefPolicyResolution
 */
export enum AuthorizerSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecForProviderApiIdRefPolicyResolve
 */
export enum AuthorizerSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecForProviderApiIdSelectorPolicyResolution
 */
export enum AuthorizerSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecForProviderApiIdSelectorPolicyResolve
 */
export enum AuthorizerSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecForProviderAuthorizerUriRefPolicyResolution
 */
export enum AuthorizerSpecForProviderAuthorizerUriRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecForProviderAuthorizerUriRefPolicyResolve
 */
export enum AuthorizerSpecForProviderAuthorizerUriRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecForProviderAuthorizerUriSelectorPolicyResolution
 */
export enum AuthorizerSpecForProviderAuthorizerUriSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecForProviderAuthorizerUriSelectorPolicyResolve
 */
export enum AuthorizerSpecForProviderAuthorizerUriSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Deployment is the Schema for the Deployments API. Manages an Amazon API Gateway Version 2 deployment.
 *
 * @schema Deployment
 */
export class Deployment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Deployment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.upbound.io/v1beta1',
    kind: 'Deployment',
  }

  /**
   * Renders a Kubernetes manifest for "Deployment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DeploymentProps): any {
    return {
      ...Deployment.GVK,
      ...toJson_DeploymentProps(props),
    };
  }

  /**
   * Defines a "Deployment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DeploymentProps) {
    super(scope, id, {
      ...Deployment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Deployment.GVK,
      ...toJson_DeploymentProps(resolved),
    };
  }
}

/**
 * Deployment is the Schema for the Deployments API. Manages an Amazon API Gateway Version 2 deployment.
 *
 * @schema Deployment
 */
export interface DeploymentProps {
  /**
   * @schema Deployment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeploymentSpec defines the desired state of Deployment
   *
   * @schema Deployment#spec
   */
  readonly spec: DeploymentSpec;

}

/**
 * Converts an object of type 'DeploymentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentProps(obj: DeploymentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DeploymentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeploymentSpec defines the desired state of Deployment
 *
 * @schema DeploymentSpec
 */
export interface DeploymentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeploymentSpec#deletionPolicy
   */
  readonly deletionPolicy?: DeploymentSpecDeletionPolicy;

  /**
   * @schema DeploymentSpec#forProvider
   */
  readonly forProvider: DeploymentSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeploymentSpec#managementPolicy
   */
  readonly managementPolicy?: DeploymentSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DeploymentSpec#providerConfigRef
   */
  readonly providerConfigRef?: DeploymentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DeploymentSpec#providerRef
   */
  readonly providerRef?: DeploymentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DeploymentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DeploymentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DeploymentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DeploymentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DeploymentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpec(obj: DeploymentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DeploymentSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DeploymentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DeploymentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DeploymentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DeploymentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeploymentSpecDeletionPolicy
 */
export enum DeploymentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DeploymentSpecForProvider
 */
export interface DeploymentSpecForProvider {
  /**
   * API identifier.
   *
   * @schema DeploymentSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * Reference to a API to populate apiId.
   *
   * @schema DeploymentSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: DeploymentSpecForProviderApiIdRef;

  /**
   * Selector for a API to populate apiId.
   *
   * @schema DeploymentSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: DeploymentSpecForProviderApiIdSelector;

  /**
   * Description for the deployment resource. Must be less than or equal to 1024 characters in length.
   *
   * @schema DeploymentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DeploymentSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'DeploymentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProvider(obj: DeploymentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_DeploymentSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_DeploymentSpecForProviderApiIdSelector(obj.apiIdSelector),
    'description': obj.description,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeploymentSpecManagementPolicy
 */
export enum DeploymentSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DeploymentSpecProviderConfigRef
 */
export interface DeploymentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecProviderConfigRef#policy
   */
  readonly policy?: DeploymentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecProviderConfigRef(obj: DeploymentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DeploymentSpecProviderRef
 */
export interface DeploymentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecProviderRef#policy
   */
  readonly policy?: DeploymentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecProviderRef(obj: DeploymentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DeploymentSpecPublishConnectionDetailsTo
 */
export interface DeploymentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DeploymentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DeploymentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DeploymentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DeploymentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DeploymentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsTo(obj: DeploymentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DeploymentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DeploymentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DeploymentSpecWriteConnectionSecretToRef
 */
export interface DeploymentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DeploymentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeploymentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeploymentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecWriteConnectionSecretToRef(obj: DeploymentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a API to populate apiId.
 *
 * @schema DeploymentSpecForProviderApiIdRef
 */
export interface DeploymentSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecForProviderApiIdRef#policy
   */
  readonly policy?: DeploymentSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderApiIdRef(obj: DeploymentSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a API to populate apiId.
 *
 * @schema DeploymentSpecForProviderApiIdSelector
 */
export interface DeploymentSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeploymentSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeploymentSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeploymentSpecForProviderApiIdSelector#policy
   */
  readonly policy?: DeploymentSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderApiIdSelector(obj: DeploymentSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeploymentSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecProviderConfigRefPolicy
 */
export interface DeploymentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecProviderConfigRefPolicy(obj: DeploymentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecProviderRefPolicy
 */
export interface DeploymentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecProviderRefPolicy(obj: DeploymentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRef
 */
export interface DeploymentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DeploymentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsToConfigRef(obj: DeploymentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToMetadata
 */
export interface DeploymentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsToMetadata(obj: DeploymentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecForProviderApiIdRefPolicy
 */
export interface DeploymentSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderApiIdRefPolicy(obj: DeploymentSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeploymentSpecForProviderApiIdSelectorPolicy
 */
export interface DeploymentSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderApiIdSelectorPolicy(obj: DeploymentSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecProviderConfigRefPolicyResolution
 */
export enum DeploymentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecProviderConfigRefPolicyResolve
 */
export enum DeploymentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecProviderRefPolicyResolution
 */
export enum DeploymentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecProviderRefPolicyResolve
 */
export enum DeploymentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DeploymentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsToConfigRefPolicy(obj: DeploymentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderApiIdRefPolicyResolution
 */
export enum DeploymentSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderApiIdRefPolicyResolve
 */
export enum DeploymentSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderApiIdSelectorPolicyResolution
 */
export enum DeploymentSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderApiIdSelectorPolicyResolve
 */
export enum DeploymentSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DomainName is the Schema for the DomainNames API. Manages an Amazon API Gateway Version 2 domain name.
 *
 * @schema DomainName
 */
export class DomainName extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DomainName"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.upbound.io/v1beta1',
    kind: 'DomainName',
  }

  /**
   * Renders a Kubernetes manifest for "DomainName".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DomainNameProps): any {
    return {
      ...DomainName.GVK,
      ...toJson_DomainNameProps(props),
    };
  }

  /**
   * Defines a "DomainName" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DomainNameProps) {
    super(scope, id, {
      ...DomainName.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DomainName.GVK,
      ...toJson_DomainNameProps(resolved),
    };
  }
}

/**
 * DomainName is the Schema for the DomainNames API. Manages an Amazon API Gateway Version 2 domain name.
 *
 * @schema DomainName
 */
export interface DomainNameProps {
  /**
   * @schema DomainName#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DomainNameSpec defines the desired state of DomainName
   *
   * @schema DomainName#spec
   */
  readonly spec: DomainNameSpec;

}

/**
 * Converts an object of type 'DomainNameProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameProps(obj: DomainNameProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DomainNameSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainNameSpec defines the desired state of DomainName
 *
 * @schema DomainNameSpec
 */
export interface DomainNameSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainNameSpec#deletionPolicy
   */
  readonly deletionPolicy?: DomainNameSpecDeletionPolicy;

  /**
   * @schema DomainNameSpec#forProvider
   */
  readonly forProvider: DomainNameSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainNameSpec#managementPolicy
   */
  readonly managementPolicy?: DomainNameSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DomainNameSpec#providerConfigRef
   */
  readonly providerConfigRef?: DomainNameSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DomainNameSpec#providerRef
   */
  readonly providerRef?: DomainNameSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DomainNameSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DomainNameSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DomainNameSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DomainNameSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DomainNameSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpec(obj: DomainNameSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DomainNameSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DomainNameSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DomainNameSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DomainNameSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DomainNameSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainNameSpecDeletionPolicy
 */
export enum DomainNameSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DomainNameSpecForProvider
 */
export interface DomainNameSpecForProvider {
  /**
   * Domain name configuration. See below.
   *
   * @schema DomainNameSpecForProvider#domainNameConfiguration
   */
  readonly domainNameConfiguration?: DomainNameSpecForProviderDomainNameConfiguration[];

  /**
   * Mutual TLS authentication configuration for the domain name.
   *
   * @schema DomainNameSpecForProvider#mutualTlsAuthentication
   */
  readonly mutualTlsAuthentication?: DomainNameSpecForProviderMutualTlsAuthentication[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DomainNameSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema DomainNameSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DomainNameSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProvider(obj: DomainNameSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainNameConfiguration': obj.domainNameConfiguration?.map(y => toJson_DomainNameSpecForProviderDomainNameConfiguration(y)),
    'mutualTlsAuthentication': obj.mutualTlsAuthentication?.map(y => toJson_DomainNameSpecForProviderMutualTlsAuthentication(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainNameSpecManagementPolicy
 */
export enum DomainNameSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DomainNameSpecProviderConfigRef
 */
export interface DomainNameSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainNameSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainNameSpecProviderConfigRef#policy
   */
  readonly policy?: DomainNameSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainNameSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecProviderConfigRef(obj: DomainNameSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainNameSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DomainNameSpecProviderRef
 */
export interface DomainNameSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainNameSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainNameSpecProviderRef#policy
   */
  readonly policy?: DomainNameSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DomainNameSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecProviderRef(obj: DomainNameSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainNameSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DomainNameSpecPublishConnectionDetailsTo
 */
export interface DomainNameSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DomainNameSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DomainNameSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DomainNameSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DomainNameSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DomainNameSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DomainNameSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecPublishConnectionDetailsTo(obj: DomainNameSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DomainNameSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DomainNameSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DomainNameSpecWriteConnectionSecretToRef
 */
export interface DomainNameSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DomainNameSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainNameSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainNameSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecWriteConnectionSecretToRef(obj: DomainNameSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainNameSpecForProviderDomainNameConfiguration
 */
export interface DomainNameSpecForProviderDomainNameConfiguration {
  /**
   * ARN of an AWS-managed certificate that will be used by the endpoint for the domain name. AWS Certificate Manager is the only supported source. Use the aws_acm_certificate resource to configure an ACM certificate.
   *
   * @schema DomainNameSpecForProviderDomainNameConfiguration#certificateArn
   */
  readonly certificateArn?: string;

  /**
   * Reference to a Certificate in acm to populate certificateArn.
   *
   * @schema DomainNameSpecForProviderDomainNameConfiguration#certificateArnRef
   */
  readonly certificateArnRef?: DomainNameSpecForProviderDomainNameConfigurationCertificateArnRef;

  /**
   * Selector for a Certificate in acm to populate certificateArn.
   *
   * @schema DomainNameSpecForProviderDomainNameConfiguration#certificateArnSelector
   */
  readonly certificateArnSelector?: DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelector;

  /**
   * Endpoint type. Valid values: REGIONAL.
   *
   * @schema DomainNameSpecForProviderDomainNameConfiguration#endpointType
   */
  readonly endpointType: string;

  /**
   * ARN of the AWS-issued certificate used to validate custom domain ownership (when certificate_arn is issued via an ACM Private CA or mutual_tls_authentication is configured with an ACM-imported certificate.)
   *
   * @schema DomainNameSpecForProviderDomainNameConfiguration#ownershipVerificationCertificateArn
   */
  readonly ownershipVerificationCertificateArn?: string;

  /**
   * Transport Layer Security (TLS) version of the security policy for the domain name. Valid values: TLS_1_2.
   *
   * @schema DomainNameSpecForProviderDomainNameConfiguration#securityPolicy
   */
  readonly securityPolicy: string;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderDomainNameConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderDomainNameConfiguration(obj: DomainNameSpecForProviderDomainNameConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateArn': obj.certificateArn,
    'certificateArnRef': toJson_DomainNameSpecForProviderDomainNameConfigurationCertificateArnRef(obj.certificateArnRef),
    'certificateArnSelector': toJson_DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelector(obj.certificateArnSelector),
    'endpointType': obj.endpointType,
    'ownershipVerificationCertificateArn': obj.ownershipVerificationCertificateArn,
    'securityPolicy': obj.securityPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainNameSpecForProviderMutualTlsAuthentication
 */
export interface DomainNameSpecForProviderMutualTlsAuthentication {
  /**
   * Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version.
   *
   * @schema DomainNameSpecForProviderMutualTlsAuthentication#truststoreUri
   */
  readonly truststoreUri: string;

  /**
   * Version of the S3 object that contains the truststore. To specify a version, you must have versioning enabled for the S3 bucket.
   *
   * @schema DomainNameSpecForProviderMutualTlsAuthentication#truststoreVersion
   */
  readonly truststoreVersion?: string;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderMutualTlsAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderMutualTlsAuthentication(obj: DomainNameSpecForProviderMutualTlsAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'truststoreUri': obj.truststoreUri,
    'truststoreVersion': obj.truststoreVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainNameSpecProviderConfigRefPolicy
 */
export interface DomainNameSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainNameSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DomainNameSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainNameSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DomainNameSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainNameSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecProviderConfigRefPolicy(obj: DomainNameSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainNameSpecProviderRefPolicy
 */
export interface DomainNameSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainNameSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DomainNameSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainNameSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DomainNameSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainNameSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecProviderRefPolicy(obj: DomainNameSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToConfigRef
 */
export interface DomainNameSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DomainNameSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainNameSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecPublishConnectionDetailsToConfigRef(obj: DomainNameSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainNameSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToMetadata
 */
export interface DomainNameSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DomainNameSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecPublishConnectionDetailsToMetadata(obj: DomainNameSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Certificate in acm to populate certificateArn.
 *
 * @schema DomainNameSpecForProviderDomainNameConfigurationCertificateArnRef
 */
export interface DomainNameSpecForProviderDomainNameConfigurationCertificateArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainNameSpecForProviderDomainNameConfigurationCertificateArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainNameSpecForProviderDomainNameConfigurationCertificateArnRef#policy
   */
  readonly policy?: DomainNameSpecForProviderDomainNameConfigurationCertificateArnRefPolicy;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderDomainNameConfigurationCertificateArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderDomainNameConfigurationCertificateArnRef(obj: DomainNameSpecForProviderDomainNameConfigurationCertificateArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainNameSpecForProviderDomainNameConfigurationCertificateArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Certificate in acm to populate certificateArn.
 *
 * @schema DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelector
 */
export interface DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelector#policy
   */
  readonly policy?: DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelectorPolicy;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelector(obj: DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainNameSpecProviderConfigRefPolicyResolution
 */
export enum DomainNameSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainNameSpecProviderConfigRefPolicyResolve
 */
export enum DomainNameSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainNameSpecProviderRefPolicyResolution
 */
export enum DomainNameSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainNameSpecProviderRefPolicyResolve
 */
export enum DomainNameSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DomainNameSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainNameSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecPublishConnectionDetailsToConfigRefPolicy(obj: DomainNameSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainNameSpecForProviderDomainNameConfigurationCertificateArnRefPolicy
 */
export interface DomainNameSpecForProviderDomainNameConfigurationCertificateArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainNameSpecForProviderDomainNameConfigurationCertificateArnRefPolicy#resolution
   */
  readonly resolution?: DomainNameSpecForProviderDomainNameConfigurationCertificateArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainNameSpecForProviderDomainNameConfigurationCertificateArnRefPolicy#resolve
   */
  readonly resolve?: DomainNameSpecForProviderDomainNameConfigurationCertificateArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderDomainNameConfigurationCertificateArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderDomainNameConfigurationCertificateArnRefPolicy(obj: DomainNameSpecForProviderDomainNameConfigurationCertificateArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelectorPolicy
 */
export interface DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelectorPolicy#resolution
   */
  readonly resolution?: DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelectorPolicy#resolve
   */
  readonly resolve?: DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelectorPolicy(obj: DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainNameSpecForProviderDomainNameConfigurationCertificateArnRefPolicyResolution
 */
export enum DomainNameSpecForProviderDomainNameConfigurationCertificateArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainNameSpecForProviderDomainNameConfigurationCertificateArnRefPolicyResolve
 */
export enum DomainNameSpecForProviderDomainNameConfigurationCertificateArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelectorPolicyResolution
 */
export enum DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelectorPolicyResolve
 */
export enum DomainNameSpecForProviderDomainNameConfigurationCertificateArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Integration is the Schema for the Integrations API. Manages an Amazon API Gateway Version 2 integration.
 *
 * @schema Integration
 */
export class Integration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Integration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.upbound.io/v1beta1',
    kind: 'Integration',
  }

  /**
   * Renders a Kubernetes manifest for "Integration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IntegrationProps): any {
    return {
      ...Integration.GVK,
      ...toJson_IntegrationProps(props),
    };
  }

  /**
   * Defines a "Integration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IntegrationProps) {
    super(scope, id, {
      ...Integration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Integration.GVK,
      ...toJson_IntegrationProps(resolved),
    };
  }
}

/**
 * Integration is the Schema for the Integrations API. Manages an Amazon API Gateway Version 2 integration.
 *
 * @schema Integration
 */
export interface IntegrationProps {
  /**
   * @schema Integration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IntegrationSpec defines the desired state of Integration
   *
   * @schema Integration#spec
   */
  readonly spec: IntegrationSpec;

}

/**
 * Converts an object of type 'IntegrationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationProps(obj: IntegrationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IntegrationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IntegrationSpec defines the desired state of Integration
 *
 * @schema IntegrationSpec
 */
export interface IntegrationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IntegrationSpec#deletionPolicy
   */
  readonly deletionPolicy?: IntegrationSpecDeletionPolicy;

  /**
   * @schema IntegrationSpec#forProvider
   */
  readonly forProvider: IntegrationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IntegrationSpec#managementPolicy
   */
  readonly managementPolicy?: IntegrationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IntegrationSpec#providerConfigRef
   */
  readonly providerConfigRef?: IntegrationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema IntegrationSpec#providerRef
   */
  readonly providerRef?: IntegrationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IntegrationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IntegrationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IntegrationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IntegrationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IntegrationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpec(obj: IntegrationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IntegrationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_IntegrationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_IntegrationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_IntegrationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IntegrationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IntegrationSpecDeletionPolicy
 */
export enum IntegrationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema IntegrationSpecForProvider
 */
export interface IntegrationSpecForProvider {
  /**
   * API identifier.
   *
   * @schema IntegrationSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * Reference to a API to populate apiId.
   *
   * @schema IntegrationSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: IntegrationSpecForProviderApiIdRef;

  /**
   * Selector for a API to populate apiId.
   *
   * @schema IntegrationSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: IntegrationSpecForProviderApiIdSelector;

  /**
   * ID of the VPC link for a private integration. Supported only for HTTP APIs. Must be between 1 and 1024 characters in length.
   *
   * @schema IntegrationSpecForProvider#connectionId
   */
  readonly connectionId?: string;

  /**
   * Reference to a VPCLink in apigatewayv2 to populate connectionId.
   *
   * @schema IntegrationSpecForProvider#connectionIdRef
   */
  readonly connectionIdRef?: IntegrationSpecForProviderConnectionIdRef;

  /**
   * Selector for a VPCLink in apigatewayv2 to populate connectionId.
   *
   * @schema IntegrationSpecForProvider#connectionIdSelector
   */
  readonly connectionIdSelector?: IntegrationSpecForProviderConnectionIdSelector;

  /**
   * Type of the network connection to the integration endpoint. Valid values: INTERNET, VPC_LINK. Default is INTERNET.
   *
   * @default INTERNET.
   * @schema IntegrationSpecForProvider#connectionType
   */
  readonly connectionType?: string;

  /**
   * How to handle response payload content type conversions. Valid values: CONVERT_TO_BINARY, CONVERT_TO_TEXT. Supported only for WebSocket APIs.
   *
   * @schema IntegrationSpecForProvider#contentHandlingStrategy
   */
  readonly contentHandlingStrategy?: string;

  /**
   * Credentials required for the integration, if any.
   *
   * @schema IntegrationSpecForProvider#credentialsArn
   */
  readonly credentialsArn?: string;

  /**
   * Reference to a Role in iam to populate credentialsArn.
   *
   * @schema IntegrationSpecForProvider#credentialsArnRef
   */
  readonly credentialsArnRef?: IntegrationSpecForProviderCredentialsArnRef;

  /**
   * Selector for a Role in iam to populate credentialsArn.
   *
   * @schema IntegrationSpecForProvider#credentialsArnSelector
   */
  readonly credentialsArnSelector?: IntegrationSpecForProviderCredentialsArnSelector;

  /**
   * Description of the integration.
   *
   * @schema IntegrationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Integration's HTTP method. Must be specified if integration_type is not MOCK.
   *
   * @schema IntegrationSpecForProvider#integrationMethod
   */
  readonly integrationMethod?: string;

  /**
   * AWS service action to invoke. Supported only for HTTP APIs when integration_type is AWS_PROXY. See the AWS service integration reference documentation for supported values. Must be between 1 and 128 characters in length.
   *
   * @schema IntegrationSpecForProvider#integrationSubtype
   */
  readonly integrationSubtype?: string;

  /**
   * Integration type of an integration. Valid values: AWS (supported only for WebSocket APIs), AWS_PROXY, HTTP (supported only for WebSocket APIs), HTTP_PROXY, MOCK (supported only for WebSocket APIs). For an HTTP API private integration, use HTTP_PROXY.
   *
   * @schema IntegrationSpecForProvider#integrationType
   */
  readonly integrationType?: string;

  /**
   * URI of the Lambda function for a Lambda proxy integration, when integration_type is AWS_PROXY. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service.
   *
   * @schema IntegrationSpecForProvider#integrationUri
   */
  readonly integrationUri?: string;

  /**
   * Reference to a Function in lambda to populate integrationUri.
   *
   * @schema IntegrationSpecForProvider#integrationUriRef
   */
  readonly integrationUriRef?: IntegrationSpecForProviderIntegrationUriRef;

  /**
   * Selector for a Function in lambda to populate integrationUri.
   *
   * @schema IntegrationSpecForProvider#integrationUriSelector
   */
  readonly integrationUriSelector?: IntegrationSpecForProviderIntegrationUriSelector;

  /**
   * Pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the request_templates attribute. Valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, NEVER. Default is WHEN_NO_MATCH. Supported only for WebSocket APIs.
   *
   * @default WHEN_NO_MATCH. Supported only for WebSocket APIs.
   * @schema IntegrationSpecForProvider#passthroughBehavior
   */
  readonly passthroughBehavior?: string;

  /**
   * The format of the payload sent to an integration. Valid values: 1.0, 2.0. Default is 1.0.
   *
   * @default 1.0.
   * @schema IntegrationSpecForProvider#payloadFormatVersion
   */
  readonly payloadFormatVersion?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema IntegrationSpecForProvider#region
   */
  readonly region: string;

  /**
   * For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. For HTTP APIs with a specified integration_subtype, a key-value map specifying parameters that are passed to AWS_PROXY integrations. For HTTP APIs without a specified integration_subtype, a key-value map specifying how to transform HTTP requests before sending them to the backend. See the Amazon API Gateway Developer Guide for details.
   *
   * @schema IntegrationSpecForProvider#requestParameters
   */
  readonly requestParameters?: { [key: string]: string };

  /**
   * Map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. Supported only for WebSocket APIs.
   *
   * @schema IntegrationSpecForProvider#requestTemplates
   */
  readonly requestTemplates?: { [key: string]: string };

  /**
   * Mappings to transform the HTTP response from a backend integration before returning the response to clients. Supported only for HTTP APIs.
   *
   * @schema IntegrationSpecForProvider#responseParameters
   */
  readonly responseParameters?: IntegrationSpecForProviderResponseParameters[];

  /**
   * The template selection expression for the integration.
   *
   * @schema IntegrationSpecForProvider#templateSelectionExpression
   */
  readonly templateSelectionExpression?: string;

  /**
   * Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
   *
   * @schema IntegrationSpecForProvider#timeoutMilliseconds
   */
  readonly timeoutMilliseconds?: number;

  /**
   * TLS configuration for a private integration. Supported only for HTTP APIs.
   *
   * @schema IntegrationSpecForProvider#tlsConfig
   */
  readonly tlsConfig?: IntegrationSpecForProviderTlsConfig[];

}

/**
 * Converts an object of type 'IntegrationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProvider(obj: IntegrationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_IntegrationSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_IntegrationSpecForProviderApiIdSelector(obj.apiIdSelector),
    'connectionId': obj.connectionId,
    'connectionIdRef': toJson_IntegrationSpecForProviderConnectionIdRef(obj.connectionIdRef),
    'connectionIdSelector': toJson_IntegrationSpecForProviderConnectionIdSelector(obj.connectionIdSelector),
    'connectionType': obj.connectionType,
    'contentHandlingStrategy': obj.contentHandlingStrategy,
    'credentialsArn': obj.credentialsArn,
    'credentialsArnRef': toJson_IntegrationSpecForProviderCredentialsArnRef(obj.credentialsArnRef),
    'credentialsArnSelector': toJson_IntegrationSpecForProviderCredentialsArnSelector(obj.credentialsArnSelector),
    'description': obj.description,
    'integrationMethod': obj.integrationMethod,
    'integrationSubtype': obj.integrationSubtype,
    'integrationType': obj.integrationType,
    'integrationUri': obj.integrationUri,
    'integrationUriRef': toJson_IntegrationSpecForProviderIntegrationUriRef(obj.integrationUriRef),
    'integrationUriSelector': toJson_IntegrationSpecForProviderIntegrationUriSelector(obj.integrationUriSelector),
    'passthroughBehavior': obj.passthroughBehavior,
    'payloadFormatVersion': obj.payloadFormatVersion,
    'region': obj.region,
    'requestParameters': ((obj.requestParameters) === undefined) ? undefined : (Object.entries(obj.requestParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'requestTemplates': ((obj.requestTemplates) === undefined) ? undefined : (Object.entries(obj.requestTemplates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'responseParameters': obj.responseParameters?.map(y => toJson_IntegrationSpecForProviderResponseParameters(y)),
    'templateSelectionExpression': obj.templateSelectionExpression,
    'timeoutMilliseconds': obj.timeoutMilliseconds,
    'tlsConfig': obj.tlsConfig?.map(y => toJson_IntegrationSpecForProviderTlsConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IntegrationSpecManagementPolicy
 */
export enum IntegrationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IntegrationSpecProviderConfigRef
 */
export interface IntegrationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecProviderConfigRef#policy
   */
  readonly policy?: IntegrationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecProviderConfigRef(obj: IntegrationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema IntegrationSpecProviderRef
 */
export interface IntegrationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecProviderRef#policy
   */
  readonly policy?: IntegrationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecProviderRef(obj: IntegrationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IntegrationSpecPublishConnectionDetailsTo
 */
export interface IntegrationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IntegrationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IntegrationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IntegrationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IntegrationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IntegrationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IntegrationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecPublishConnectionDetailsTo(obj: IntegrationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IntegrationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IntegrationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IntegrationSpecWriteConnectionSecretToRef
 */
export interface IntegrationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IntegrationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IntegrationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IntegrationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecWriteConnectionSecretToRef(obj: IntegrationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a API to populate apiId.
 *
 * @schema IntegrationSpecForProviderApiIdRef
 */
export interface IntegrationSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecForProviderApiIdRef#policy
   */
  readonly policy?: IntegrationSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderApiIdRef(obj: IntegrationSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a API to populate apiId.
 *
 * @schema IntegrationSpecForProviderApiIdSelector
 */
export interface IntegrationSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationSpecForProviderApiIdSelector#policy
   */
  readonly policy?: IntegrationSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderApiIdSelector(obj: IntegrationSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPCLink in apigatewayv2 to populate connectionId.
 *
 * @schema IntegrationSpecForProviderConnectionIdRef
 */
export interface IntegrationSpecForProviderConnectionIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecForProviderConnectionIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecForProviderConnectionIdRef#policy
   */
  readonly policy?: IntegrationSpecForProviderConnectionIdRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderConnectionIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderConnectionIdRef(obj: IntegrationSpecForProviderConnectionIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecForProviderConnectionIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPCLink in apigatewayv2 to populate connectionId.
 *
 * @schema IntegrationSpecForProviderConnectionIdSelector
 */
export interface IntegrationSpecForProviderConnectionIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationSpecForProviderConnectionIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationSpecForProviderConnectionIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationSpecForProviderConnectionIdSelector#policy
   */
  readonly policy?: IntegrationSpecForProviderConnectionIdSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderConnectionIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderConnectionIdSelector(obj: IntegrationSpecForProviderConnectionIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationSpecForProviderConnectionIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate credentialsArn.
 *
 * @schema IntegrationSpecForProviderCredentialsArnRef
 */
export interface IntegrationSpecForProviderCredentialsArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecForProviderCredentialsArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecForProviderCredentialsArnRef#policy
   */
  readonly policy?: IntegrationSpecForProviderCredentialsArnRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderCredentialsArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderCredentialsArnRef(obj: IntegrationSpecForProviderCredentialsArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecForProviderCredentialsArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate credentialsArn.
 *
 * @schema IntegrationSpecForProviderCredentialsArnSelector
 */
export interface IntegrationSpecForProviderCredentialsArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationSpecForProviderCredentialsArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationSpecForProviderCredentialsArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationSpecForProviderCredentialsArnSelector#policy
   */
  readonly policy?: IntegrationSpecForProviderCredentialsArnSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderCredentialsArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderCredentialsArnSelector(obj: IntegrationSpecForProviderCredentialsArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationSpecForProviderCredentialsArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function in lambda to populate integrationUri.
 *
 * @schema IntegrationSpecForProviderIntegrationUriRef
 */
export interface IntegrationSpecForProviderIntegrationUriRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecForProviderIntegrationUriRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecForProviderIntegrationUriRef#policy
   */
  readonly policy?: IntegrationSpecForProviderIntegrationUriRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderIntegrationUriRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderIntegrationUriRef(obj: IntegrationSpecForProviderIntegrationUriRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecForProviderIntegrationUriRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function in lambda to populate integrationUri.
 *
 * @schema IntegrationSpecForProviderIntegrationUriSelector
 */
export interface IntegrationSpecForProviderIntegrationUriSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationSpecForProviderIntegrationUriSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationSpecForProviderIntegrationUriSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationSpecForProviderIntegrationUriSelector#policy
   */
  readonly policy?: IntegrationSpecForProviderIntegrationUriSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderIntegrationUriSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderIntegrationUriSelector(obj: IntegrationSpecForProviderIntegrationUriSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationSpecForProviderIntegrationUriSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntegrationSpecForProviderResponseParameters
 */
export interface IntegrationSpecForProviderResponseParameters {
  /**
   * Key-value map. The key of this map identifies the location of the request parameter to change, and how to change it. The corresponding value specifies the new data for the parameter. See the Amazon API Gateway Developer Guide for details.
   *
   * @schema IntegrationSpecForProviderResponseParameters#mappings
   */
  readonly mappings: { [key: string]: string };

  /**
   * HTTP status code in the range 200-599.
   *
   * @schema IntegrationSpecForProviderResponseParameters#statusCode
   */
  readonly statusCode: string;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderResponseParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderResponseParameters(obj: IntegrationSpecForProviderResponseParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mappings': ((obj.mappings) === undefined) ? undefined : (Object.entries(obj.mappings).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntegrationSpecForProviderTlsConfig
 */
export interface IntegrationSpecForProviderTlsConfig {
  /**
   * If you specify a server name, API Gateway uses it to verify the hostname on the integration's certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.
   *
   * @schema IntegrationSpecForProviderTlsConfig#serverNameToVerify
   */
  readonly serverNameToVerify?: string;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderTlsConfig(obj: IntegrationSpecForProviderTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serverNameToVerify': obj.serverNameToVerify,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecProviderConfigRefPolicy
 */
export interface IntegrationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecProviderConfigRefPolicy(obj: IntegrationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecProviderRefPolicy
 */
export interface IntegrationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecProviderRefPolicy(obj: IntegrationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToConfigRef
 */
export interface IntegrationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IntegrationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecPublishConnectionDetailsToConfigRef(obj: IntegrationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToMetadata
 */
export interface IntegrationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IntegrationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecPublishConnectionDetailsToMetadata(obj: IntegrationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecForProviderApiIdRefPolicy
 */
export interface IntegrationSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderApiIdRefPolicy(obj: IntegrationSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationSpecForProviderApiIdSelectorPolicy
 */
export interface IntegrationSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderApiIdSelectorPolicy(obj: IntegrationSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecForProviderConnectionIdRefPolicy
 */
export interface IntegrationSpecForProviderConnectionIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderConnectionIdRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderConnectionIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderConnectionIdRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderConnectionIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderConnectionIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderConnectionIdRefPolicy(obj: IntegrationSpecForProviderConnectionIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationSpecForProviderConnectionIdSelectorPolicy
 */
export interface IntegrationSpecForProviderConnectionIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderConnectionIdSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderConnectionIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderConnectionIdSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderConnectionIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderConnectionIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderConnectionIdSelectorPolicy(obj: IntegrationSpecForProviderConnectionIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecForProviderCredentialsArnRefPolicy
 */
export interface IntegrationSpecForProviderCredentialsArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderCredentialsArnRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderCredentialsArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderCredentialsArnRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderCredentialsArnRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderCredentialsArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderCredentialsArnRefPolicy(obj: IntegrationSpecForProviderCredentialsArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationSpecForProviderCredentialsArnSelectorPolicy
 */
export interface IntegrationSpecForProviderCredentialsArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderCredentialsArnSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderCredentialsArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderCredentialsArnSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderCredentialsArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderCredentialsArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderCredentialsArnSelectorPolicy(obj: IntegrationSpecForProviderCredentialsArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecForProviderIntegrationUriRefPolicy
 */
export interface IntegrationSpecForProviderIntegrationUriRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderIntegrationUriRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderIntegrationUriRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderIntegrationUriRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderIntegrationUriRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderIntegrationUriRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderIntegrationUriRefPolicy(obj: IntegrationSpecForProviderIntegrationUriRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationSpecForProviderIntegrationUriSelectorPolicy
 */
export interface IntegrationSpecForProviderIntegrationUriSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderIntegrationUriSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderIntegrationUriSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderIntegrationUriSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderIntegrationUriSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderIntegrationUriSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderIntegrationUriSelectorPolicy(obj: IntegrationSpecForProviderIntegrationUriSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecProviderConfigRefPolicyResolution
 */
export enum IntegrationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecProviderConfigRefPolicyResolve
 */
export enum IntegrationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecProviderRefPolicyResolution
 */
export enum IntegrationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecProviderRefPolicyResolve
 */
export enum IntegrationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IntegrationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecPublishConnectionDetailsToConfigRefPolicy(obj: IntegrationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderApiIdRefPolicyResolution
 */
export enum IntegrationSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderApiIdRefPolicyResolve
 */
export enum IntegrationSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderApiIdSelectorPolicyResolution
 */
export enum IntegrationSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderApiIdSelectorPolicyResolve
 */
export enum IntegrationSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderConnectionIdRefPolicyResolution
 */
export enum IntegrationSpecForProviderConnectionIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderConnectionIdRefPolicyResolve
 */
export enum IntegrationSpecForProviderConnectionIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderConnectionIdSelectorPolicyResolution
 */
export enum IntegrationSpecForProviderConnectionIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderConnectionIdSelectorPolicyResolve
 */
export enum IntegrationSpecForProviderConnectionIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderCredentialsArnRefPolicyResolution
 */
export enum IntegrationSpecForProviderCredentialsArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderCredentialsArnRefPolicyResolve
 */
export enum IntegrationSpecForProviderCredentialsArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderCredentialsArnSelectorPolicyResolution
 */
export enum IntegrationSpecForProviderCredentialsArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderCredentialsArnSelectorPolicyResolve
 */
export enum IntegrationSpecForProviderCredentialsArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderIntegrationUriRefPolicyResolution
 */
export enum IntegrationSpecForProviderIntegrationUriRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderIntegrationUriRefPolicyResolve
 */
export enum IntegrationSpecForProviderIntegrationUriRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderIntegrationUriSelectorPolicyResolution
 */
export enum IntegrationSpecForProviderIntegrationUriSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderIntegrationUriSelectorPolicyResolve
 */
export enum IntegrationSpecForProviderIntegrationUriSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * IntegrationResponse is the Schema for the IntegrationResponses API. Manages an Amazon API Gateway Version 2 integration response.
 *
 * @schema IntegrationResponse
 */
export class IntegrationResponse extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IntegrationResponse"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.upbound.io/v1beta1',
    kind: 'IntegrationResponse',
  }

  /**
   * Renders a Kubernetes manifest for "IntegrationResponse".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IntegrationResponseProps): any {
    return {
      ...IntegrationResponse.GVK,
      ...toJson_IntegrationResponseProps(props),
    };
  }

  /**
   * Defines a "IntegrationResponse" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IntegrationResponseProps) {
    super(scope, id, {
      ...IntegrationResponse.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IntegrationResponse.GVK,
      ...toJson_IntegrationResponseProps(resolved),
    };
  }
}

/**
 * IntegrationResponse is the Schema for the IntegrationResponses API. Manages an Amazon API Gateway Version 2 integration response.
 *
 * @schema IntegrationResponse
 */
export interface IntegrationResponseProps {
  /**
   * @schema IntegrationResponse#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IntegrationResponseSpec defines the desired state of IntegrationResponse
   *
   * @schema IntegrationResponse#spec
   */
  readonly spec: IntegrationResponseSpec;

}

/**
 * Converts an object of type 'IntegrationResponseProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseProps(obj: IntegrationResponseProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IntegrationResponseSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IntegrationResponseSpec defines the desired state of IntegrationResponse
 *
 * @schema IntegrationResponseSpec
 */
export interface IntegrationResponseSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IntegrationResponseSpec#deletionPolicy
   */
  readonly deletionPolicy?: IntegrationResponseSpecDeletionPolicy;

  /**
   * @schema IntegrationResponseSpec#forProvider
   */
  readonly forProvider: IntegrationResponseSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IntegrationResponseSpec#managementPolicy
   */
  readonly managementPolicy?: IntegrationResponseSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IntegrationResponseSpec#providerConfigRef
   */
  readonly providerConfigRef?: IntegrationResponseSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema IntegrationResponseSpec#providerRef
   */
  readonly providerRef?: IntegrationResponseSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IntegrationResponseSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IntegrationResponseSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IntegrationResponseSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IntegrationResponseSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IntegrationResponseSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpec(obj: IntegrationResponseSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IntegrationResponseSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_IntegrationResponseSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_IntegrationResponseSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_IntegrationResponseSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IntegrationResponseSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IntegrationResponseSpecDeletionPolicy
 */
export enum IntegrationResponseSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema IntegrationResponseSpecForProvider
 */
export interface IntegrationResponseSpecForProvider {
  /**
   * API identifier.
   *
   * @schema IntegrationResponseSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * Reference to a API to populate apiId.
   *
   * @schema IntegrationResponseSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: IntegrationResponseSpecForProviderApiIdRef;

  /**
   * Selector for a API to populate apiId.
   *
   * @schema IntegrationResponseSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: IntegrationResponseSpecForProviderApiIdSelector;

  /**
   * How to handle response payload content type conversions. Valid values: CONVERT_TO_BINARY, CONVERT_TO_TEXT.
   *
   * @schema IntegrationResponseSpecForProvider#contentHandlingStrategy
   */
  readonly contentHandlingStrategy?: string;

  /**
   * Identifier of the aws_apigatewayv2_integration.
   *
   * @schema IntegrationResponseSpecForProvider#integrationId
   */
  readonly integrationId?: string;

  /**
   * Reference to a Integration to populate integrationId.
   *
   * @schema IntegrationResponseSpecForProvider#integrationIdRef
   */
  readonly integrationIdRef?: IntegrationResponseSpecForProviderIntegrationIdRef;

  /**
   * Selector for a Integration to populate integrationId.
   *
   * @schema IntegrationResponseSpecForProvider#integrationIdSelector
   */
  readonly integrationIdSelector?: IntegrationResponseSpecForProviderIntegrationIdSelector;

  /**
   * Integration response key.
   *
   * @schema IntegrationResponseSpecForProvider#integrationResponseKey
   */
  readonly integrationResponseKey?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema IntegrationResponseSpecForProvider#region
   */
  readonly region: string;

  /**
   * Map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client.
   *
   * @schema IntegrationResponseSpecForProvider#responseTemplates
   */
  readonly responseTemplates?: { [key: string]: string };

  /**
   * The template selection expression for the integration response.
   *
   * @schema IntegrationResponseSpecForProvider#templateSelectionExpression
   */
  readonly templateSelectionExpression?: string;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProvider(obj: IntegrationResponseSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_IntegrationResponseSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_IntegrationResponseSpecForProviderApiIdSelector(obj.apiIdSelector),
    'contentHandlingStrategy': obj.contentHandlingStrategy,
    'integrationId': obj.integrationId,
    'integrationIdRef': toJson_IntegrationResponseSpecForProviderIntegrationIdRef(obj.integrationIdRef),
    'integrationIdSelector': toJson_IntegrationResponseSpecForProviderIntegrationIdSelector(obj.integrationIdSelector),
    'integrationResponseKey': obj.integrationResponseKey,
    'region': obj.region,
    'responseTemplates': ((obj.responseTemplates) === undefined) ? undefined : (Object.entries(obj.responseTemplates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'templateSelectionExpression': obj.templateSelectionExpression,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IntegrationResponseSpecManagementPolicy
 */
export enum IntegrationResponseSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IntegrationResponseSpecProviderConfigRef
 */
export interface IntegrationResponseSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecProviderConfigRef#policy
   */
  readonly policy?: IntegrationResponseSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecProviderConfigRef(obj: IntegrationResponseSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema IntegrationResponseSpecProviderRef
 */
export interface IntegrationResponseSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecProviderRef#policy
   */
  readonly policy?: IntegrationResponseSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecProviderRef(obj: IntegrationResponseSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsTo
 */
export interface IntegrationResponseSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IntegrationResponseSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IntegrationResponseSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IntegrationResponseSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecPublishConnectionDetailsTo(obj: IntegrationResponseSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IntegrationResponseSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IntegrationResponseSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IntegrationResponseSpecWriteConnectionSecretToRef
 */
export interface IntegrationResponseSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IntegrationResponseSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IntegrationResponseSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IntegrationResponseSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecWriteConnectionSecretToRef(obj: IntegrationResponseSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a API to populate apiId.
 *
 * @schema IntegrationResponseSpecForProviderApiIdRef
 */
export interface IntegrationResponseSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecForProviderApiIdRef#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderApiIdRef(obj: IntegrationResponseSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a API to populate apiId.
 *
 * @schema IntegrationResponseSpecForProviderApiIdSelector
 */
export interface IntegrationResponseSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationResponseSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationResponseSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationResponseSpecForProviderApiIdSelector#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderApiIdSelector(obj: IntegrationResponseSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationResponseSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Integration to populate integrationId.
 *
 * @schema IntegrationResponseSpecForProviderIntegrationIdRef
 */
export interface IntegrationResponseSpecForProviderIntegrationIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdRef#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderIntegrationIdRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderIntegrationIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderIntegrationIdRef(obj: IntegrationResponseSpecForProviderIntegrationIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecForProviderIntegrationIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Integration to populate integrationId.
 *
 * @schema IntegrationResponseSpecForProviderIntegrationIdSelector
 */
export interface IntegrationResponseSpecForProviderIntegrationIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdSelector#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderIntegrationIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderIntegrationIdSelector(obj: IntegrationResponseSpecForProviderIntegrationIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecProviderConfigRefPolicy
 */
export interface IntegrationResponseSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecProviderConfigRefPolicy(obj: IntegrationResponseSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecProviderRefPolicy
 */
export interface IntegrationResponseSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecProviderRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecProviderRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecProviderRefPolicy(obj: IntegrationResponseSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRef
 */
export interface IntegrationResponseSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecPublishConnectionDetailsToConfigRef(obj: IntegrationResponseSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToMetadata
 */
export interface IntegrationResponseSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IntegrationResponseSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecPublishConnectionDetailsToMetadata(obj: IntegrationResponseSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecForProviderApiIdRefPolicy
 */
export interface IntegrationResponseSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderApiIdRefPolicy(obj: IntegrationResponseSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationResponseSpecForProviderApiIdSelectorPolicy
 */
export interface IntegrationResponseSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderApiIdSelectorPolicy(obj: IntegrationResponseSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecForProviderIntegrationIdRefPolicy
 */
export interface IntegrationResponseSpecForProviderIntegrationIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderIntegrationIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderIntegrationIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderIntegrationIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderIntegrationIdRefPolicy(obj: IntegrationResponseSpecForProviderIntegrationIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy
 */
export interface IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderIntegrationIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderIntegrationIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy(obj: IntegrationResponseSpecForProviderIntegrationIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecProviderConfigRefPolicyResolution
 */
export enum IntegrationResponseSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecProviderConfigRefPolicyResolve
 */
export enum IntegrationResponseSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecProviderRefPolicyResolution
 */
export enum IntegrationResponseSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecProviderRefPolicyResolve
 */
export enum IntegrationResponseSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj: IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderApiIdRefPolicyResolution
 */
export enum IntegrationResponseSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderApiIdRefPolicyResolve
 */
export enum IntegrationResponseSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderApiIdSelectorPolicyResolution
 */
export enum IntegrationResponseSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderApiIdSelectorPolicyResolve
 */
export enum IntegrationResponseSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderIntegrationIdRefPolicyResolution
 */
export enum IntegrationResponseSpecForProviderIntegrationIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderIntegrationIdRefPolicyResolve
 */
export enum IntegrationResponseSpecForProviderIntegrationIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderIntegrationIdSelectorPolicyResolution
 */
export enum IntegrationResponseSpecForProviderIntegrationIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderIntegrationIdSelectorPolicyResolve
 */
export enum IntegrationResponseSpecForProviderIntegrationIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Model is the Schema for the Models API. Manages an Amazon API Gateway Version 2 model.
 *
 * @schema Model
 */
export class Model extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Model"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.upbound.io/v1beta1',
    kind: 'Model',
  }

  /**
   * Renders a Kubernetes manifest for "Model".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ModelProps): any {
    return {
      ...Model.GVK,
      ...toJson_ModelProps(props),
    };
  }

  /**
   * Defines a "Model" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ModelProps) {
    super(scope, id, {
      ...Model.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Model.GVK,
      ...toJson_ModelProps(resolved),
    };
  }
}

/**
 * Model is the Schema for the Models API. Manages an Amazon API Gateway Version 2 model.
 *
 * @schema Model
 */
export interface ModelProps {
  /**
   * @schema Model#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ModelSpec defines the desired state of Model
   *
   * @schema Model#spec
   */
  readonly spec: ModelSpec;

}

/**
 * Converts an object of type 'ModelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelProps(obj: ModelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ModelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ModelSpec defines the desired state of Model
 *
 * @schema ModelSpec
 */
export interface ModelSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ModelSpec#deletionPolicy
   */
  readonly deletionPolicy?: ModelSpecDeletionPolicy;

  /**
   * @schema ModelSpec#forProvider
   */
  readonly forProvider: ModelSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ModelSpec#managementPolicy
   */
  readonly managementPolicy?: ModelSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ModelSpec#providerConfigRef
   */
  readonly providerConfigRef?: ModelSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ModelSpec#providerRef
   */
  readonly providerRef?: ModelSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ModelSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ModelSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ModelSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ModelSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ModelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpec(obj: ModelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ModelSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ModelSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ModelSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ModelSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ModelSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ModelSpecDeletionPolicy
 */
export enum ModelSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ModelSpecForProvider
 */
export interface ModelSpecForProvider {
  /**
   * API identifier.
   *
   * @schema ModelSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * Reference to a API to populate apiId.
   *
   * @schema ModelSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: ModelSpecForProviderApiIdRef;

  /**
   * Selector for a API to populate apiId.
   *
   * @schema ModelSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: ModelSpecForProviderApiIdSelector;

  /**
   * The content-type for the model, for example, application/json. Must be between 1 and 256 characters in length.
   *
   * @schema ModelSpecForProvider#contentType
   */
  readonly contentType?: string;

  /**
   * Description of the model. Must be between 1 and 128 characters in length.
   *
   * @schema ModelSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Name of the model. Must be alphanumeric. Must be between 1 and 128 characters in length.
   *
   * @schema ModelSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ModelSpecForProvider#region
   */
  readonly region: string;

  /**
   * Schema for the model. This should be a JSON schema draft 4 model. Must be less than or equal to 32768 characters in length.
   *
   * @schema ModelSpecForProvider#schema
   */
  readonly schema?: string;

}

/**
 * Converts an object of type 'ModelSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProvider(obj: ModelSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_ModelSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_ModelSpecForProviderApiIdSelector(obj.apiIdSelector),
    'contentType': obj.contentType,
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'schema': obj.schema,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ModelSpecManagementPolicy
 */
export enum ModelSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ModelSpecProviderConfigRef
 */
export interface ModelSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelSpecProviderConfigRef#policy
   */
  readonly policy?: ModelSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ModelSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecProviderConfigRef(obj: ModelSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ModelSpecProviderRef
 */
export interface ModelSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelSpecProviderRef#policy
   */
  readonly policy?: ModelSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ModelSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecProviderRef(obj: ModelSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ModelSpecPublishConnectionDetailsTo
 */
export interface ModelSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ModelSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ModelSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ModelSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ModelSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ModelSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsTo(obj: ModelSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ModelSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ModelSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ModelSpecWriteConnectionSecretToRef
 */
export interface ModelSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ModelSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ModelSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ModelSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecWriteConnectionSecretToRef(obj: ModelSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a API to populate apiId.
 *
 * @schema ModelSpecForProviderApiIdRef
 */
export interface ModelSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelSpecForProviderApiIdRef#policy
   */
  readonly policy?: ModelSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'ModelSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderApiIdRef(obj: ModelSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a API to populate apiId.
 *
 * @schema ModelSpecForProviderApiIdSelector
 */
export interface ModelSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ModelSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ModelSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ModelSpecForProviderApiIdSelector#policy
   */
  readonly policy?: ModelSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'ModelSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderApiIdSelector(obj: ModelSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ModelSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ModelSpecProviderConfigRefPolicy
 */
export interface ModelSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ModelSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ModelSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecProviderConfigRefPolicy(obj: ModelSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ModelSpecProviderRefPolicy
 */
export interface ModelSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ModelSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ModelSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecProviderRefPolicy(obj: ModelSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRef
 */
export interface ModelSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ModelSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsToConfigRef(obj: ModelSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ModelSpecPublishConnectionDetailsToMetadata
 */
export interface ModelSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ModelSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ModelSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ModelSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsToMetadata(obj: ModelSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ModelSpecForProviderApiIdRefPolicy
 */
export interface ModelSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: ModelSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: ModelSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderApiIdRefPolicy(obj: ModelSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ModelSpecForProviderApiIdSelectorPolicy
 */
export interface ModelSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: ModelSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: ModelSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderApiIdSelectorPolicy(obj: ModelSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecProviderConfigRefPolicyResolution
 */
export enum ModelSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecProviderConfigRefPolicyResolve
 */
export enum ModelSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecProviderRefPolicyResolution
 */
export enum ModelSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecProviderRefPolicyResolve
 */
export enum ModelSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ModelSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ModelSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ModelSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsToConfigRefPolicy(obj: ModelSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecForProviderApiIdRefPolicyResolution
 */
export enum ModelSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecForProviderApiIdRefPolicyResolve
 */
export enum ModelSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecForProviderApiIdSelectorPolicyResolution
 */
export enum ModelSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecForProviderApiIdSelectorPolicyResolve
 */
export enum ModelSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ModelSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ModelSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Route is the Schema for the Routes API. Manages an Amazon API Gateway Version 2 route.
 *
 * @schema Route
 */
export class Route extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Route"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.upbound.io/v1beta1',
    kind: 'Route',
  }

  /**
   * Renders a Kubernetes manifest for "Route".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RouteProps): any {
    return {
      ...Route.GVK,
      ...toJson_RouteProps(props),
    };
  }

  /**
   * Defines a "Route" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RouteProps) {
    super(scope, id, {
      ...Route.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Route.GVK,
      ...toJson_RouteProps(resolved),
    };
  }
}

/**
 * Route is the Schema for the Routes API. Manages an Amazon API Gateway Version 2 route.
 *
 * @schema Route
 */
export interface RouteProps {
  /**
   * @schema Route#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RouteSpec defines the desired state of Route
   *
   * @schema Route#spec
   */
  readonly spec: RouteSpec;

}

/**
 * Converts an object of type 'RouteProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteProps(obj: RouteProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RouteSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RouteSpec defines the desired state of Route
 *
 * @schema RouteSpec
 */
export interface RouteSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RouteSpec#deletionPolicy
   */
  readonly deletionPolicy?: RouteSpecDeletionPolicy;

  /**
   * @schema RouteSpec#forProvider
   */
  readonly forProvider: RouteSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RouteSpec#managementPolicy
   */
  readonly managementPolicy?: RouteSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RouteSpec#providerConfigRef
   */
  readonly providerConfigRef?: RouteSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RouteSpec#providerRef
   */
  readonly providerRef?: RouteSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RouteSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RouteSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RouteSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RouteSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RouteSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpec(obj: RouteSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RouteSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RouteSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RouteSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RouteSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RouteSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RouteSpecDeletionPolicy
 */
export enum RouteSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RouteSpecForProvider
 */
export interface RouteSpecForProvider {
  /**
   * API identifier.
   *
   * @schema RouteSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * Reference to a API to populate apiId.
   *
   * @schema RouteSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: RouteSpecForProviderApiIdRef;

  /**
   * Selector for a API to populate apiId.
   *
   * @schema RouteSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: RouteSpecForProviderApiIdSelector;

  /**
   * Boolean whether an API key is required for the route. Defaults to false. Supported only for WebSocket APIs.
   *
   * @default false. Supported only for WebSocket APIs.
   * @schema RouteSpecForProvider#apiKeyRequired
   */
  readonly apiKeyRequired?: boolean;

  /**
   * Authorization scopes supported by this route. The scopes are used with a JWT authorizer to authorize the method invocation.
   *
   * @schema RouteSpecForProvider#authorizationScopes
   */
  readonly authorizationScopes?: string[];

  /**
   * Authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer. For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer. Defaults to NONE.
   *
   * @default NONE.
   * @schema RouteSpecForProvider#authorizationType
   */
  readonly authorizationType?: string;

  /**
   * Identifier of the aws_apigatewayv2_authorizer resource to be associated with this route.
   *
   * @schema RouteSpecForProvider#authorizerId
   */
  readonly authorizerId?: string;

  /**
   * Reference to a Authorizer to populate authorizerId.
   *
   * @schema RouteSpecForProvider#authorizerIdRef
   */
  readonly authorizerIdRef?: RouteSpecForProviderAuthorizerIdRef;

  /**
   * Selector for a Authorizer to populate authorizerId.
   *
   * @schema RouteSpecForProvider#authorizerIdSelector
   */
  readonly authorizerIdSelector?: RouteSpecForProviderAuthorizerIdSelector;

  /**
   * The model selection expression for the route. Supported only for WebSocket APIs.
   *
   * @schema RouteSpecForProvider#modelSelectionExpression
   */
  readonly modelSelectionExpression?: string;

  /**
   * Operation name for the route. Must be between 1 and 64 characters in length.
   *
   * @schema RouteSpecForProvider#operationName
   */
  readonly operationName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RouteSpecForProvider#region
   */
  readonly region: string;

  /**
   * Request models for the route. Supported only for WebSocket APIs.
   *
   * @schema RouteSpecForProvider#requestModels
   */
  readonly requestModels?: { [key: string]: string };

  /**
   * Request parameters for the route. Supported only for WebSocket APIs.
   *
   * @schema RouteSpecForProvider#requestParameter
   */
  readonly requestParameter?: RouteSpecForProviderRequestParameter[];

  /**
   * Route key for the route. For HTTP APIs, the route key can be either $default, or a combination of an HTTP method and resource path, for example, GET /pets.
   *
   * @schema RouteSpecForProvider#routeKey
   */
  readonly routeKey?: string;

  /**
   * The route response selection expression for the route. Supported only for WebSocket APIs.
   *
   * @schema RouteSpecForProvider#routeResponseSelectionExpression
   */
  readonly routeResponseSelectionExpression?: string;

  /**
   * Target for the route, of the form integrations/IntegrationID, where IntegrationID is the identifier of an aws_apigatewayv2_integration resource.
   *
   * @schema RouteSpecForProvider#target
   */
  readonly target?: string;

  /**
   * Reference to a Integration to populate target.
   *
   * @schema RouteSpecForProvider#targetRef
   */
  readonly targetRef?: RouteSpecForProviderTargetRef;

  /**
   * Selector for a Integration to populate target.
   *
   * @schema RouteSpecForProvider#targetSelector
   */
  readonly targetSelector?: RouteSpecForProviderTargetSelector;

}

/**
 * Converts an object of type 'RouteSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProvider(obj: RouteSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_RouteSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_RouteSpecForProviderApiIdSelector(obj.apiIdSelector),
    'apiKeyRequired': obj.apiKeyRequired,
    'authorizationScopes': obj.authorizationScopes?.map(y => y),
    'authorizationType': obj.authorizationType,
    'authorizerId': obj.authorizerId,
    'authorizerIdRef': toJson_RouteSpecForProviderAuthorizerIdRef(obj.authorizerIdRef),
    'authorizerIdSelector': toJson_RouteSpecForProviderAuthorizerIdSelector(obj.authorizerIdSelector),
    'modelSelectionExpression': obj.modelSelectionExpression,
    'operationName': obj.operationName,
    'region': obj.region,
    'requestModels': ((obj.requestModels) === undefined) ? undefined : (Object.entries(obj.requestModels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'requestParameter': obj.requestParameter?.map(y => toJson_RouteSpecForProviderRequestParameter(y)),
    'routeKey': obj.routeKey,
    'routeResponseSelectionExpression': obj.routeResponseSelectionExpression,
    'target': obj.target,
    'targetRef': toJson_RouteSpecForProviderTargetRef(obj.targetRef),
    'targetSelector': toJson_RouteSpecForProviderTargetSelector(obj.targetSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RouteSpecManagementPolicy
 */
export enum RouteSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RouteSpecProviderConfigRef
 */
export interface RouteSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecProviderConfigRef#policy
   */
  readonly policy?: RouteSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecProviderConfigRef(obj: RouteSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RouteSpecProviderRef
 */
export interface RouteSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecProviderRef#policy
   */
  readonly policy?: RouteSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecProviderRef(obj: RouteSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RouteSpecPublishConnectionDetailsTo
 */
export interface RouteSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RouteSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RouteSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RouteSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RouteSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RouteSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RouteSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecPublishConnectionDetailsTo(obj: RouteSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RouteSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RouteSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RouteSpecWriteConnectionSecretToRef
 */
export interface RouteSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RouteSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RouteSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RouteSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecWriteConnectionSecretToRef(obj: RouteSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a API to populate apiId.
 *
 * @schema RouteSpecForProviderApiIdRef
 */
export interface RouteSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecForProviderApiIdRef#policy
   */
  readonly policy?: RouteSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderApiIdRef(obj: RouteSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a API to populate apiId.
 *
 * @schema RouteSpecForProviderApiIdSelector
 */
export interface RouteSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteSpecForProviderApiIdSelector#policy
   */
  readonly policy?: RouteSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderApiIdSelector(obj: RouteSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Authorizer to populate authorizerId.
 *
 * @schema RouteSpecForProviderAuthorizerIdRef
 */
export interface RouteSpecForProviderAuthorizerIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecForProviderAuthorizerIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecForProviderAuthorizerIdRef#policy
   */
  readonly policy?: RouteSpecForProviderAuthorizerIdRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderAuthorizerIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderAuthorizerIdRef(obj: RouteSpecForProviderAuthorizerIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecForProviderAuthorizerIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Authorizer to populate authorizerId.
 *
 * @schema RouteSpecForProviderAuthorizerIdSelector
 */
export interface RouteSpecForProviderAuthorizerIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteSpecForProviderAuthorizerIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteSpecForProviderAuthorizerIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteSpecForProviderAuthorizerIdSelector#policy
   */
  readonly policy?: RouteSpecForProviderAuthorizerIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderAuthorizerIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderAuthorizerIdSelector(obj: RouteSpecForProviderAuthorizerIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteSpecForProviderAuthorizerIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RouteSpecForProviderRequestParameter
 */
export interface RouteSpecForProviderRequestParameter {
  /**
   * Request parameter key. This is a request data mapping parameter.
   *
   * @schema RouteSpecForProviderRequestParameter#requestParameterKey
   */
  readonly requestParameterKey: string;

  /**
   * Boolean whether or not the parameter is required.
   *
   * @schema RouteSpecForProviderRequestParameter#required
   */
  readonly required: boolean;

}

/**
 * Converts an object of type 'RouteSpecForProviderRequestParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderRequestParameter(obj: RouteSpecForProviderRequestParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestParameterKey': obj.requestParameterKey,
    'required': obj.required,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Integration to populate target.
 *
 * @schema RouteSpecForProviderTargetRef
 */
export interface RouteSpecForProviderTargetRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecForProviderTargetRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecForProviderTargetRef#policy
   */
  readonly policy?: RouteSpecForProviderTargetRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderTargetRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderTargetRef(obj: RouteSpecForProviderTargetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecForProviderTargetRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Integration to populate target.
 *
 * @schema RouteSpecForProviderTargetSelector
 */
export interface RouteSpecForProviderTargetSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteSpecForProviderTargetSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteSpecForProviderTargetSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteSpecForProviderTargetSelector#policy
   */
  readonly policy?: RouteSpecForProviderTargetSelectorPolicy;

}

/**
 * Converts an object of type 'RouteSpecForProviderTargetSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderTargetSelector(obj: RouteSpecForProviderTargetSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteSpecForProviderTargetSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecProviderConfigRefPolicy
 */
export interface RouteSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RouteSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RouteSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecProviderConfigRefPolicy(obj: RouteSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecProviderRefPolicy
 */
export interface RouteSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RouteSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RouteSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecProviderRefPolicy(obj: RouteSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RouteSpecPublishConnectionDetailsToConfigRef
 */
export interface RouteSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RouteSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecPublishConnectionDetailsToConfigRef(obj: RouteSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RouteSpecPublishConnectionDetailsToMetadata
 */
export interface RouteSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RouteSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RouteSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecPublishConnectionDetailsToMetadata(obj: RouteSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecForProviderApiIdRefPolicy
 */
export interface RouteSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderApiIdRefPolicy(obj: RouteSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteSpecForProviderApiIdSelectorPolicy
 */
export interface RouteSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderApiIdSelectorPolicy(obj: RouteSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecForProviderAuthorizerIdRefPolicy
 */
export interface RouteSpecForProviderAuthorizerIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderAuthorizerIdRefPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderAuthorizerIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderAuthorizerIdRefPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderAuthorizerIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderAuthorizerIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderAuthorizerIdRefPolicy(obj: RouteSpecForProviderAuthorizerIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteSpecForProviderAuthorizerIdSelectorPolicy
 */
export interface RouteSpecForProviderAuthorizerIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderAuthorizerIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderAuthorizerIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderAuthorizerIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderAuthorizerIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderAuthorizerIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderAuthorizerIdSelectorPolicy(obj: RouteSpecForProviderAuthorizerIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteSpecForProviderTargetRefPolicy
 */
export interface RouteSpecForProviderTargetRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderTargetRefPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderTargetRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderTargetRefPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderTargetRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderTargetRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderTargetRefPolicy(obj: RouteSpecForProviderTargetRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteSpecForProviderTargetSelectorPolicy
 */
export interface RouteSpecForProviderTargetSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecForProviderTargetSelectorPolicy#resolution
   */
  readonly resolution?: RouteSpecForProviderTargetSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecForProviderTargetSelectorPolicy#resolve
   */
  readonly resolve?: RouteSpecForProviderTargetSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecForProviderTargetSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecForProviderTargetSelectorPolicy(obj: RouteSpecForProviderTargetSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecProviderConfigRefPolicyResolution
 */
export enum RouteSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecProviderConfigRefPolicyResolve
 */
export enum RouteSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecProviderRefPolicyResolution
 */
export enum RouteSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecProviderRefPolicyResolve
 */
export enum RouteSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RouteSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RouteSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RouteSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteSpecPublishConnectionDetailsToConfigRefPolicy(obj: RouteSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderApiIdRefPolicyResolution
 */
export enum RouteSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderApiIdRefPolicyResolve
 */
export enum RouteSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderApiIdSelectorPolicyResolution
 */
export enum RouteSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderApiIdSelectorPolicyResolve
 */
export enum RouteSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderAuthorizerIdRefPolicyResolution
 */
export enum RouteSpecForProviderAuthorizerIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderAuthorizerIdRefPolicyResolve
 */
export enum RouteSpecForProviderAuthorizerIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderAuthorizerIdSelectorPolicyResolution
 */
export enum RouteSpecForProviderAuthorizerIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderAuthorizerIdSelectorPolicyResolve
 */
export enum RouteSpecForProviderAuthorizerIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderTargetRefPolicyResolution
 */
export enum RouteSpecForProviderTargetRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderTargetRefPolicyResolve
 */
export enum RouteSpecForProviderTargetRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecForProviderTargetSelectorPolicyResolution
 */
export enum RouteSpecForProviderTargetSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecForProviderTargetSelectorPolicyResolve
 */
export enum RouteSpecForProviderTargetSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RouteSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RouteSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RouteResponse is the Schema for the RouteResponses API. Manages an Amazon API Gateway Version 2 route response.
 *
 * @schema RouteResponse
 */
export class RouteResponse extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RouteResponse"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.upbound.io/v1beta1',
    kind: 'RouteResponse',
  }

  /**
   * Renders a Kubernetes manifest for "RouteResponse".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RouteResponseProps): any {
    return {
      ...RouteResponse.GVK,
      ...toJson_RouteResponseProps(props),
    };
  }

  /**
   * Defines a "RouteResponse" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RouteResponseProps) {
    super(scope, id, {
      ...RouteResponse.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RouteResponse.GVK,
      ...toJson_RouteResponseProps(resolved),
    };
  }
}

/**
 * RouteResponse is the Schema for the RouteResponses API. Manages an Amazon API Gateway Version 2 route response.
 *
 * @schema RouteResponse
 */
export interface RouteResponseProps {
  /**
   * @schema RouteResponse#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RouteResponseSpec defines the desired state of RouteResponse
   *
   * @schema RouteResponse#spec
   */
  readonly spec: RouteResponseSpec;

}

/**
 * Converts an object of type 'RouteResponseProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseProps(obj: RouteResponseProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RouteResponseSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RouteResponseSpec defines the desired state of RouteResponse
 *
 * @schema RouteResponseSpec
 */
export interface RouteResponseSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RouteResponseSpec#deletionPolicy
   */
  readonly deletionPolicy?: RouteResponseSpecDeletionPolicy;

  /**
   * @schema RouteResponseSpec#forProvider
   */
  readonly forProvider: RouteResponseSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RouteResponseSpec#managementPolicy
   */
  readonly managementPolicy?: RouteResponseSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RouteResponseSpec#providerConfigRef
   */
  readonly providerConfigRef?: RouteResponseSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RouteResponseSpec#providerRef
   */
  readonly providerRef?: RouteResponseSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RouteResponseSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RouteResponseSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RouteResponseSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RouteResponseSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RouteResponseSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpec(obj: RouteResponseSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RouteResponseSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RouteResponseSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RouteResponseSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RouteResponseSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RouteResponseSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RouteResponseSpecDeletionPolicy
 */
export enum RouteResponseSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RouteResponseSpecForProvider
 */
export interface RouteResponseSpecForProvider {
  /**
   * API identifier.
   *
   * @schema RouteResponseSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * Reference to a API to populate apiId.
   *
   * @schema RouteResponseSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: RouteResponseSpecForProviderApiIdRef;

  /**
   * Selector for a API to populate apiId.
   *
   * @schema RouteResponseSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: RouteResponseSpecForProviderApiIdSelector;

  /**
   * The model selection expression for the route response.
   *
   * @schema RouteResponseSpecForProvider#modelSelectionExpression
   */
  readonly modelSelectionExpression?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RouteResponseSpecForProvider#region
   */
  readonly region: string;

  /**
   * Response models for the route response.
   *
   * @schema RouteResponseSpecForProvider#responseModels
   */
  readonly responseModels?: { [key: string]: string };

  /**
   * Identifier of the aws_apigatewayv2_route.
   *
   * @schema RouteResponseSpecForProvider#routeId
   */
  readonly routeId?: string;

  /**
   * Reference to a Route to populate routeId.
   *
   * @schema RouteResponseSpecForProvider#routeIdRef
   */
  readonly routeIdRef?: RouteResponseSpecForProviderRouteIdRef;

  /**
   * Selector for a Route to populate routeId.
   *
   * @schema RouteResponseSpecForProvider#routeIdSelector
   */
  readonly routeIdSelector?: RouteResponseSpecForProviderRouteIdSelector;

  /**
   * Route response key.
   *
   * @schema RouteResponseSpecForProvider#routeResponseKey
   */
  readonly routeResponseKey?: string;

}

/**
 * Converts an object of type 'RouteResponseSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProvider(obj: RouteResponseSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_RouteResponseSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_RouteResponseSpecForProviderApiIdSelector(obj.apiIdSelector),
    'modelSelectionExpression': obj.modelSelectionExpression,
    'region': obj.region,
    'responseModels': ((obj.responseModels) === undefined) ? undefined : (Object.entries(obj.responseModels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'routeId': obj.routeId,
    'routeIdRef': toJson_RouteResponseSpecForProviderRouteIdRef(obj.routeIdRef),
    'routeIdSelector': toJson_RouteResponseSpecForProviderRouteIdSelector(obj.routeIdSelector),
    'routeResponseKey': obj.routeResponseKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RouteResponseSpecManagementPolicy
 */
export enum RouteResponseSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RouteResponseSpecProviderConfigRef
 */
export interface RouteResponseSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteResponseSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteResponseSpecProviderConfigRef#policy
   */
  readonly policy?: RouteResponseSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteResponseSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecProviderConfigRef(obj: RouteResponseSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteResponseSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RouteResponseSpecProviderRef
 */
export interface RouteResponseSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteResponseSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteResponseSpecProviderRef#policy
   */
  readonly policy?: RouteResponseSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RouteResponseSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecProviderRef(obj: RouteResponseSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteResponseSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RouteResponseSpecPublishConnectionDetailsTo
 */
export interface RouteResponseSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RouteResponseSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RouteResponseSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RouteResponseSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecPublishConnectionDetailsTo(obj: RouteResponseSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RouteResponseSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RouteResponseSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RouteResponseSpecWriteConnectionSecretToRef
 */
export interface RouteResponseSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RouteResponseSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RouteResponseSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RouteResponseSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecWriteConnectionSecretToRef(obj: RouteResponseSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a API to populate apiId.
 *
 * @schema RouteResponseSpecForProviderApiIdRef
 */
export interface RouteResponseSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteResponseSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteResponseSpecForProviderApiIdRef#policy
   */
  readonly policy?: RouteResponseSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'RouteResponseSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProviderApiIdRef(obj: RouteResponseSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteResponseSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a API to populate apiId.
 *
 * @schema RouteResponseSpecForProviderApiIdSelector
 */
export interface RouteResponseSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteResponseSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteResponseSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteResponseSpecForProviderApiIdSelector#policy
   */
  readonly policy?: RouteResponseSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteResponseSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProviderApiIdSelector(obj: RouteResponseSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteResponseSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Route to populate routeId.
 *
 * @schema RouteResponseSpecForProviderRouteIdRef
 */
export interface RouteResponseSpecForProviderRouteIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteResponseSpecForProviderRouteIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteResponseSpecForProviderRouteIdRef#policy
   */
  readonly policy?: RouteResponseSpecForProviderRouteIdRefPolicy;

}

/**
 * Converts an object of type 'RouteResponseSpecForProviderRouteIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProviderRouteIdRef(obj: RouteResponseSpecForProviderRouteIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteResponseSpecForProviderRouteIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Route to populate routeId.
 *
 * @schema RouteResponseSpecForProviderRouteIdSelector
 */
export interface RouteResponseSpecForProviderRouteIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RouteResponseSpecForProviderRouteIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RouteResponseSpecForProviderRouteIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RouteResponseSpecForProviderRouteIdSelector#policy
   */
  readonly policy?: RouteResponseSpecForProviderRouteIdSelectorPolicy;

}

/**
 * Converts an object of type 'RouteResponseSpecForProviderRouteIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProviderRouteIdSelector(obj: RouteResponseSpecForProviderRouteIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RouteResponseSpecForProviderRouteIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteResponseSpecProviderConfigRefPolicy
 */
export interface RouteResponseSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteResponseSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RouteResponseSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteResponseSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RouteResponseSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteResponseSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecProviderConfigRefPolicy(obj: RouteResponseSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteResponseSpecProviderRefPolicy
 */
export interface RouteResponseSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteResponseSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RouteResponseSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteResponseSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RouteResponseSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteResponseSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecProviderRefPolicy(obj: RouteResponseSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RouteResponseSpecPublishConnectionDetailsToConfigRef
 */
export interface RouteResponseSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RouteResponseSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecPublishConnectionDetailsToConfigRef(obj: RouteResponseSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RouteResponseSpecPublishConnectionDetailsToMetadata
 */
export interface RouteResponseSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RouteResponseSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecPublishConnectionDetailsToMetadata(obj: RouteResponseSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteResponseSpecForProviderApiIdRefPolicy
 */
export interface RouteResponseSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteResponseSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: RouteResponseSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteResponseSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: RouteResponseSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteResponseSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProviderApiIdRefPolicy(obj: RouteResponseSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteResponseSpecForProviderApiIdSelectorPolicy
 */
export interface RouteResponseSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteResponseSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteResponseSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteResponseSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteResponseSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteResponseSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProviderApiIdSelectorPolicy(obj: RouteResponseSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RouteResponseSpecForProviderRouteIdRefPolicy
 */
export interface RouteResponseSpecForProviderRouteIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteResponseSpecForProviderRouteIdRefPolicy#resolution
   */
  readonly resolution?: RouteResponseSpecForProviderRouteIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteResponseSpecForProviderRouteIdRefPolicy#resolve
   */
  readonly resolve?: RouteResponseSpecForProviderRouteIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteResponseSpecForProviderRouteIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProviderRouteIdRefPolicy(obj: RouteResponseSpecForProviderRouteIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RouteResponseSpecForProviderRouteIdSelectorPolicy
 */
export interface RouteResponseSpecForProviderRouteIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteResponseSpecForProviderRouteIdSelectorPolicy#resolution
   */
  readonly resolution?: RouteResponseSpecForProviderRouteIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteResponseSpecForProviderRouteIdSelectorPolicy#resolve
   */
  readonly resolve?: RouteResponseSpecForProviderRouteIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RouteResponseSpecForProviderRouteIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecForProviderRouteIdSelectorPolicy(obj: RouteResponseSpecForProviderRouteIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteResponseSpecProviderConfigRefPolicyResolution
 */
export enum RouteResponseSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteResponseSpecProviderConfigRefPolicyResolve
 */
export enum RouteResponseSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteResponseSpecProviderRefPolicyResolution
 */
export enum RouteResponseSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteResponseSpecProviderRefPolicyResolve
 */
export enum RouteResponseSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RouteResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RouteResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj: RouteResponseSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteResponseSpecForProviderApiIdRefPolicyResolution
 */
export enum RouteResponseSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteResponseSpecForProviderApiIdRefPolicyResolve
 */
export enum RouteResponseSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteResponseSpecForProviderApiIdSelectorPolicyResolution
 */
export enum RouteResponseSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteResponseSpecForProviderApiIdSelectorPolicyResolve
 */
export enum RouteResponseSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteResponseSpecForProviderRouteIdRefPolicyResolution
 */
export enum RouteResponseSpecForProviderRouteIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteResponseSpecForProviderRouteIdRefPolicyResolve
 */
export enum RouteResponseSpecForProviderRouteIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteResponseSpecForProviderRouteIdSelectorPolicyResolution
 */
export enum RouteResponseSpecForProviderRouteIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteResponseSpecForProviderRouteIdSelectorPolicyResolve
 */
export enum RouteResponseSpecForProviderRouteIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RouteResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RouteResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RouteResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RouteResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Stage is the Schema for the Stages API. Manages an Amazon API Gateway Version 2 stage.
 *
 * @schema Stage
 */
export class Stage extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Stage"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.upbound.io/v1beta1',
    kind: 'Stage',
  }

  /**
   * Renders a Kubernetes manifest for "Stage".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StageProps): any {
    return {
      ...Stage.GVK,
      ...toJson_StageProps(props),
    };
  }

  /**
   * Defines a "Stage" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StageProps) {
    super(scope, id, {
      ...Stage.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Stage.GVK,
      ...toJson_StageProps(resolved),
    };
  }
}

/**
 * Stage is the Schema for the Stages API. Manages an Amazon API Gateway Version 2 stage.
 *
 * @schema Stage
 */
export interface StageProps {
  /**
   * @schema Stage#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StageSpec defines the desired state of Stage
   *
   * @schema Stage#spec
   */
  readonly spec: StageSpec;

}

/**
 * Converts an object of type 'StageProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageProps(obj: StageProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StageSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StageSpec defines the desired state of Stage
 *
 * @schema StageSpec
 */
export interface StageSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StageSpec#deletionPolicy
   */
  readonly deletionPolicy?: StageSpecDeletionPolicy;

  /**
   * @schema StageSpec#forProvider
   */
  readonly forProvider: StageSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StageSpec#managementPolicy
   */
  readonly managementPolicy?: StageSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StageSpec#providerConfigRef
   */
  readonly providerConfigRef?: StageSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema StageSpec#providerRef
   */
  readonly providerRef?: StageSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StageSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StageSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StageSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StageSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StageSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpec(obj: StageSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StageSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_StageSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_StageSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_StageSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StageSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StageSpecDeletionPolicy
 */
export enum StageSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StageSpecForProvider
 */
export interface StageSpecForProvider {
  /**
   * Settings for logging access in this stage. Use the aws_api_gateway_account resource to configure permissions for CloudWatch Logging.
   *
   * @schema StageSpecForProvider#accessLogSettings
   */
  readonly accessLogSettings?: StageSpecForProviderAccessLogSettings[];

  /**
   * API identifier.
   *
   * @schema StageSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * Reference to a API to populate apiId.
   *
   * @schema StageSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: StageSpecForProviderApiIdRef;

  /**
   * Selector for a API to populate apiId.
   *
   * @schema StageSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: StageSpecForProviderApiIdSelector;

  /**
   * Whether updates to an API automatically trigger a new deployment. Defaults to false. Applicable for HTTP APIs.
   *
   * @default false. Applicable for HTTP APIs.
   * @schema StageSpecForProvider#autoDeploy
   */
  readonly autoDeploy?: boolean;

  /**
   * Identifier of a client certificate for the stage. Use the aws_api_gateway_client_certificate resource to configure a client certificate. Supported only for WebSocket APIs.
   *
   * @schema StageSpecForProvider#clientCertificateId
   */
  readonly clientCertificateId?: string;

  /**
   * Default route settings for the stage.
   *
   * @schema StageSpecForProvider#defaultRouteSettings
   */
  readonly defaultRouteSettings?: StageSpecForProviderDefaultRouteSettings[];

  /**
   * Deployment identifier of the stage. Use the aws_apigatewayv2_deployment resource to configure a deployment.
   *
   * @schema StageSpecForProvider#deploymentId
   */
  readonly deploymentId?: string;

  /**
   * Reference to a Deployment to populate deploymentId.
   *
   * @schema StageSpecForProvider#deploymentIdRef
   */
  readonly deploymentIdRef?: StageSpecForProviderDeploymentIdRef;

  /**
   * Selector for a Deployment to populate deploymentId.
   *
   * @schema StageSpecForProvider#deploymentIdSelector
   */
  readonly deploymentIdSelector?: StageSpecForProviderDeploymentIdSelector;

  /**
   * Description for the stage. Must be less than or equal to 1024 characters in length.
   *
   * @schema StageSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema StageSpecForProvider#region
   */
  readonly region: string;

  /**
   * Route settings for the stage.
   *
   * @schema StageSpecForProvider#routeSettings
   */
  readonly routeSettings?: StageSpecForProviderRouteSettings[];

  /**
   * Map that defines the stage variables for the stage.
   *
   * @schema StageSpecForProvider#stageVariables
   */
  readonly stageVariables?: { [key: string]: string };

  /**
   * Key-value map of resource tags.
   *
   * @schema StageSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'StageSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProvider(obj: StageSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLogSettings': obj.accessLogSettings?.map(y => toJson_StageSpecForProviderAccessLogSettings(y)),
    'apiId': obj.apiId,
    'apiIdRef': toJson_StageSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_StageSpecForProviderApiIdSelector(obj.apiIdSelector),
    'autoDeploy': obj.autoDeploy,
    'clientCertificateId': obj.clientCertificateId,
    'defaultRouteSettings': obj.defaultRouteSettings?.map(y => toJson_StageSpecForProviderDefaultRouteSettings(y)),
    'deploymentId': obj.deploymentId,
    'deploymentIdRef': toJson_StageSpecForProviderDeploymentIdRef(obj.deploymentIdRef),
    'deploymentIdSelector': toJson_StageSpecForProviderDeploymentIdSelector(obj.deploymentIdSelector),
    'description': obj.description,
    'region': obj.region,
    'routeSettings': obj.routeSettings?.map(y => toJson_StageSpecForProviderRouteSettings(y)),
    'stageVariables': ((obj.stageVariables) === undefined) ? undefined : (Object.entries(obj.stageVariables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StageSpecManagementPolicy
 */
export enum StageSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StageSpecProviderConfigRef
 */
export interface StageSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecProviderConfigRef#policy
   */
  readonly policy?: StageSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StageSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecProviderConfigRef(obj: StageSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema StageSpecProviderRef
 */
export interface StageSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecProviderRef#policy
   */
  readonly policy?: StageSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'StageSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecProviderRef(obj: StageSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StageSpecPublishConnectionDetailsTo
 */
export interface StageSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StageSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StageSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StageSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StageSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StageSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StageSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecPublishConnectionDetailsTo(obj: StageSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StageSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StageSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StageSpecWriteConnectionSecretToRef
 */
export interface StageSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StageSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StageSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StageSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecWriteConnectionSecretToRef(obj: StageSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StageSpecForProviderAccessLogSettings
 */
export interface StageSpecForProviderAccessLogSettings {
  /**
   * ARN of the CloudWatch Logs log group to receive access logs. Any trailing :* is trimmed from the ARN.
   *
   * @schema StageSpecForProviderAccessLogSettings#destinationArn
   */
  readonly destinationArn: string;

  /**
   * Single line format of the access logs of data. Refer to log settings for HTTP or Websocket.
   *
   * @schema StageSpecForProviderAccessLogSettings#format
   */
  readonly format: string;

}

/**
 * Converts an object of type 'StageSpecForProviderAccessLogSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderAccessLogSettings(obj: StageSpecForProviderAccessLogSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationArn': obj.destinationArn,
    'format': obj.format,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a API to populate apiId.
 *
 * @schema StageSpecForProviderApiIdRef
 */
export interface StageSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecForProviderApiIdRef#policy
   */
  readonly policy?: StageSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'StageSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderApiIdRef(obj: StageSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a API to populate apiId.
 *
 * @schema StageSpecForProviderApiIdSelector
 */
export interface StageSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StageSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StageSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StageSpecForProviderApiIdSelector#policy
   */
  readonly policy?: StageSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'StageSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderApiIdSelector(obj: StageSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StageSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StageSpecForProviderDefaultRouteSettings
 */
export interface StageSpecForProviderDefaultRouteSettings {
  /**
   * Whether data trace logging is enabled for the default route. Affects the log entries pushed to Amazon CloudWatch Logs. Defaults to false. Supported only for WebSocket APIs.
   *
   * @default false. Supported only for WebSocket APIs.
   * @schema StageSpecForProviderDefaultRouteSettings#dataTraceEnabled
   */
  readonly dataTraceEnabled?: boolean;

  /**
   * Whether detailed metrics are enabled for the default route. Defaults to false.
   *
   * @default false.
   * @schema StageSpecForProviderDefaultRouteSettings#detailedMetricsEnabled
   */
  readonly detailedMetricsEnabled?: boolean;

  /**
   * Logging level for the default route. Affects the log entries pushed to Amazon CloudWatch Logs. Valid values: ERROR, INFO, OFF. Defaults to OFF. Supported only for WebSocket APIs.
   *
   * @default OFF. Supported only for WebSocket APIs.
   * @schema StageSpecForProviderDefaultRouteSettings#loggingLevel
   */
  readonly loggingLevel?: string;

  /**
   * Throttling burst limit for the default route.
   *
   * @schema StageSpecForProviderDefaultRouteSettings#throttlingBurstLimit
   */
  readonly throttlingBurstLimit?: number;

  /**
   * Throttling rate limit for the default route.
   *
   * @schema StageSpecForProviderDefaultRouteSettings#throttlingRateLimit
   */
  readonly throttlingRateLimit?: number;

}

/**
 * Converts an object of type 'StageSpecForProviderDefaultRouteSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderDefaultRouteSettings(obj: StageSpecForProviderDefaultRouteSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataTraceEnabled': obj.dataTraceEnabled,
    'detailedMetricsEnabled': obj.detailedMetricsEnabled,
    'loggingLevel': obj.loggingLevel,
    'throttlingBurstLimit': obj.throttlingBurstLimit,
    'throttlingRateLimit': obj.throttlingRateLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Deployment to populate deploymentId.
 *
 * @schema StageSpecForProviderDeploymentIdRef
 */
export interface StageSpecForProviderDeploymentIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecForProviderDeploymentIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecForProviderDeploymentIdRef#policy
   */
  readonly policy?: StageSpecForProviderDeploymentIdRefPolicy;

}

/**
 * Converts an object of type 'StageSpecForProviderDeploymentIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderDeploymentIdRef(obj: StageSpecForProviderDeploymentIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecForProviderDeploymentIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Deployment to populate deploymentId.
 *
 * @schema StageSpecForProviderDeploymentIdSelector
 */
export interface StageSpecForProviderDeploymentIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StageSpecForProviderDeploymentIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StageSpecForProviderDeploymentIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StageSpecForProviderDeploymentIdSelector#policy
   */
  readonly policy?: StageSpecForProviderDeploymentIdSelectorPolicy;

}

/**
 * Converts an object of type 'StageSpecForProviderDeploymentIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderDeploymentIdSelector(obj: StageSpecForProviderDeploymentIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StageSpecForProviderDeploymentIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StageSpecForProviderRouteSettings
 */
export interface StageSpecForProviderRouteSettings {
  /**
   * Whether data trace logging is enabled for the route. Affects the log entries pushed to Amazon CloudWatch Logs. Defaults to false. Supported only for WebSocket APIs.
   *
   * @default false. Supported only for WebSocket APIs.
   * @schema StageSpecForProviderRouteSettings#dataTraceEnabled
   */
  readonly dataTraceEnabled?: boolean;

  /**
   * Whether detailed metrics are enabled for the route. Defaults to false.
   *
   * @default false.
   * @schema StageSpecForProviderRouteSettings#detailedMetricsEnabled
   */
  readonly detailedMetricsEnabled?: boolean;

  /**
   * Logging level for the route. Affects the log entries pushed to Amazon CloudWatch Logs. Valid values: ERROR, INFO, OFF. Defaults to OFF. Supported only for WebSocket APIs.
   *
   * @default OFF. Supported only for WebSocket APIs.
   * @schema StageSpecForProviderRouteSettings#loggingLevel
   */
  readonly loggingLevel?: string;

  /**
   * Route key.
   *
   * @schema StageSpecForProviderRouteSettings#routeKey
   */
  readonly routeKey: string;

  /**
   * Throttling burst limit for the route.
   *
   * @schema StageSpecForProviderRouteSettings#throttlingBurstLimit
   */
  readonly throttlingBurstLimit?: number;

  /**
   * Throttling rate limit for the route.
   *
   * @schema StageSpecForProviderRouteSettings#throttlingRateLimit
   */
  readonly throttlingRateLimit?: number;

}

/**
 * Converts an object of type 'StageSpecForProviderRouteSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderRouteSettings(obj: StageSpecForProviderRouteSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataTraceEnabled': obj.dataTraceEnabled,
    'detailedMetricsEnabled': obj.detailedMetricsEnabled,
    'loggingLevel': obj.loggingLevel,
    'routeKey': obj.routeKey,
    'throttlingBurstLimit': obj.throttlingBurstLimit,
    'throttlingRateLimit': obj.throttlingRateLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StageSpecProviderConfigRefPolicy
 */
export interface StageSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StageSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StageSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecProviderConfigRefPolicy(obj: StageSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StageSpecProviderRefPolicy
 */
export interface StageSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecProviderRefPolicy#resolution
   */
  readonly resolution?: StageSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecProviderRefPolicy#resolve
   */
  readonly resolve?: StageSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecProviderRefPolicy(obj: StageSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StageSpecPublishConnectionDetailsToConfigRef
 */
export interface StageSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StageSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StageSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecPublishConnectionDetailsToConfigRef(obj: StageSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StageSpecPublishConnectionDetailsToMetadata
 */
export interface StageSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StageSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StageSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StageSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StageSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecPublishConnectionDetailsToMetadata(obj: StageSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StageSpecForProviderApiIdRefPolicy
 */
export interface StageSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: StageSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: StageSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderApiIdRefPolicy(obj: StageSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StageSpecForProviderApiIdSelectorPolicy
 */
export interface StageSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: StageSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: StageSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderApiIdSelectorPolicy(obj: StageSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StageSpecForProviderDeploymentIdRefPolicy
 */
export interface StageSpecForProviderDeploymentIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecForProviderDeploymentIdRefPolicy#resolution
   */
  readonly resolution?: StageSpecForProviderDeploymentIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecForProviderDeploymentIdRefPolicy#resolve
   */
  readonly resolve?: StageSpecForProviderDeploymentIdRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecForProviderDeploymentIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderDeploymentIdRefPolicy(obj: StageSpecForProviderDeploymentIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StageSpecForProviderDeploymentIdSelectorPolicy
 */
export interface StageSpecForProviderDeploymentIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecForProviderDeploymentIdSelectorPolicy#resolution
   */
  readonly resolution?: StageSpecForProviderDeploymentIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecForProviderDeploymentIdSelectorPolicy#resolve
   */
  readonly resolve?: StageSpecForProviderDeploymentIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecForProviderDeploymentIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderDeploymentIdSelectorPolicy(obj: StageSpecForProviderDeploymentIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecProviderConfigRefPolicyResolution
 */
export enum StageSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecProviderConfigRefPolicyResolve
 */
export enum StageSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecProviderRefPolicyResolution
 */
export enum StageSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecProviderRefPolicyResolve
 */
export enum StageSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StageSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StageSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StageSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StageSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecPublishConnectionDetailsToConfigRefPolicy(obj: StageSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecForProviderApiIdRefPolicyResolution
 */
export enum StageSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecForProviderApiIdRefPolicyResolve
 */
export enum StageSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecForProviderApiIdSelectorPolicyResolution
 */
export enum StageSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecForProviderApiIdSelectorPolicyResolve
 */
export enum StageSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecForProviderDeploymentIdRefPolicyResolution
 */
export enum StageSpecForProviderDeploymentIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecForProviderDeploymentIdRefPolicyResolve
 */
export enum StageSpecForProviderDeploymentIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecForProviderDeploymentIdSelectorPolicyResolution
 */
export enum StageSpecForProviderDeploymentIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecForProviderDeploymentIdSelectorPolicyResolve
 */
export enum StageSpecForProviderDeploymentIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StageSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StageSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VPCLink is the Schema for the VPCLinks API. Manages an Amazon API Gateway Version 2 VPC Link.
 *
 * @schema VPCLink
 */
export class VpcLink extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VPCLink"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigatewayv2.aws.upbound.io/v1beta1',
    kind: 'VPCLink',
  }

  /**
   * Renders a Kubernetes manifest for "VPCLink".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VpcLinkProps): any {
    return {
      ...VpcLink.GVK,
      ...toJson_VpcLinkProps(props),
    };
  }

  /**
   * Defines a "VPCLink" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VpcLinkProps) {
    super(scope, id, {
      ...VpcLink.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VpcLink.GVK,
      ...toJson_VpcLinkProps(resolved),
    };
  }
}

/**
 * VPCLink is the Schema for the VPCLinks API. Manages an Amazon API Gateway Version 2 VPC Link.
 *
 * @schema VPCLink
 */
export interface VpcLinkProps {
  /**
   * @schema VPCLink#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VPCLinkSpec defines the desired state of VPCLink
   *
   * @schema VPCLink#spec
   */
  readonly spec: VpcLinkSpec;

}

/**
 * Converts an object of type 'VpcLinkProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkProps(obj: VpcLinkProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VpcLinkSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCLinkSpec defines the desired state of VPCLink
 *
 * @schema VpcLinkSpec
 */
export interface VpcLinkSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VpcLinkSpec#deletionPolicy
   */
  readonly deletionPolicy?: VpcLinkSpecDeletionPolicy;

  /**
   * @schema VpcLinkSpec#forProvider
   */
  readonly forProvider: VpcLinkSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VpcLinkSpec#managementPolicy
   */
  readonly managementPolicy?: VpcLinkSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VpcLinkSpec#providerConfigRef
   */
  readonly providerConfigRef?: VpcLinkSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema VpcLinkSpec#providerRef
   */
  readonly providerRef?: VpcLinkSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VpcLinkSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VpcLinkSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VpcLinkSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VpcLinkSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VpcLinkSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpec(obj: VpcLinkSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VpcLinkSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_VpcLinkSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_VpcLinkSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_VpcLinkSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VpcLinkSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VpcLinkSpecDeletionPolicy
 */
export enum VpcLinkSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VpcLinkSpecForProvider
 */
export interface VpcLinkSpecForProvider {
  /**
   * Name of the VPC Link. Must be between 1 and 128 characters in length.
   *
   * @schema VpcLinkSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VpcLinkSpecForProvider#region
   */
  readonly region: string;

  /**
   * References to SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema VpcLinkSpecForProvider#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: VpcLinkSpecForProviderSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema VpcLinkSpecForProvider#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: VpcLinkSpecForProviderSecurityGroupIdSelector;

  /**
   * Security group IDs for the VPC Link.
   *
   * @schema VpcLinkSpecForProvider#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema VpcLinkSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: VpcLinkSpecForProviderSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema VpcLinkSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: VpcLinkSpecForProviderSubnetIdSelector;

  /**
   * Subnet IDs for the VPC Link.
   *
   * @schema VpcLinkSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema VpcLinkSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'VpcLinkSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProvider(obj: VpcLinkSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'region': obj.region,
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_VpcLinkSpecForProviderSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_VpcLinkSpecForProviderSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_VpcLinkSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_VpcLinkSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VpcLinkSpecManagementPolicy
 */
export enum VpcLinkSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VpcLinkSpecProviderConfigRef
 */
export interface VpcLinkSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkSpecProviderConfigRef#policy
   */
  readonly policy?: VpcLinkSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecProviderConfigRef(obj: VpcLinkSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema VpcLinkSpecProviderRef
 */
export interface VpcLinkSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkSpecProviderRef#policy
   */
  readonly policy?: VpcLinkSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecProviderRef(obj: VpcLinkSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsTo
 */
export interface VpcLinkSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VpcLinkSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VpcLinkSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VpcLinkSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecPublishConnectionDetailsTo(obj: VpcLinkSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VpcLinkSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VpcLinkSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VpcLinkSpecWriteConnectionSecretToRef
 */
export interface VpcLinkSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VpcLinkSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VpcLinkSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VpcLinkSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecWriteConnectionSecretToRef(obj: VpcLinkSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema VpcLinkSpecForProviderSecurityGroupIdRefs
 */
export interface VpcLinkSpecForProviderSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdRefs#policy
   */
  readonly policy?: VpcLinkSpecForProviderSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderSecurityGroupIdRefs(obj: VpcLinkSpecForProviderSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkSpecForProviderSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
 *
 * @schema VpcLinkSpecForProviderSecurityGroupIdSelector
 */
export interface VpcLinkSpecForProviderSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdSelector#policy
   */
  readonly policy?: VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderSecurityGroupIdSelector(obj: VpcLinkSpecForProviderSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema VpcLinkSpecForProviderSubnetIdRefs
 */
export interface VpcLinkSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: VpcLinkSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderSubnetIdRefs(obj: VpcLinkSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema VpcLinkSpecForProviderSubnetIdSelector
 */
export interface VpcLinkSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcLinkSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcLinkSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcLinkSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: VpcLinkSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderSubnetIdSelector(obj: VpcLinkSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcLinkSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcLinkSpecProviderConfigRefPolicy
 */
export interface VpcLinkSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecProviderConfigRefPolicy(obj: VpcLinkSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcLinkSpecProviderRefPolicy
 */
export interface VpcLinkSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecProviderRefPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecProviderRefPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecProviderRefPolicy(obj: VpcLinkSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToConfigRef
 */
export interface VpcLinkSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecPublishConnectionDetailsToConfigRef(obj: VpcLinkSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToMetadata
 */
export interface VpcLinkSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VpcLinkSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecPublishConnectionDetailsToMetadata(obj: VpcLinkSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcLinkSpecForProviderSecurityGroupIdRefsPolicy
 */
export interface VpcLinkSpecForProviderSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecForProviderSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecForProviderSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderSecurityGroupIdRefsPolicy(obj: VpcLinkSpecForProviderSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy
 */
export interface VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecForProviderSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecForProviderSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy(obj: VpcLinkSpecForProviderSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcLinkSpecForProviderSubnetIdRefsPolicy
 */
export interface VpcLinkSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderSubnetIdRefsPolicy(obj: VpcLinkSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcLinkSpecForProviderSubnetIdSelectorPolicy
 */
export interface VpcLinkSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderSubnetIdSelectorPolicy(obj: VpcLinkSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecProviderConfigRefPolicyResolution
 */
export enum VpcLinkSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecProviderConfigRefPolicyResolve
 */
export enum VpcLinkSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecProviderRefPolicyResolution
 */
export enum VpcLinkSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecProviderRefPolicyResolve
 */
export enum VpcLinkSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy(obj: VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecForProviderSecurityGroupIdRefsPolicyResolution
 */
export enum VpcLinkSpecForProviderSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecForProviderSecurityGroupIdRefsPolicyResolve
 */
export enum VpcLinkSpecForProviderSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecForProviderSecurityGroupIdSelectorPolicyResolution
 */
export enum VpcLinkSpecForProviderSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecForProviderSecurityGroupIdSelectorPolicyResolve
 */
export enum VpcLinkSpecForProviderSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum VpcLinkSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum VpcLinkSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum VpcLinkSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum VpcLinkSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

