// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Trigger is the Schema for the Triggers API. Configuration for an automated build in response to source repository changes.
 *
 * @schema Trigger
 */
export class Trigger extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Trigger"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudbuild.gcp.upbound.io/v1beta1',
    kind: 'Trigger',
  }

  /**
   * Renders a Kubernetes manifest for "Trigger".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TriggerProps): any {
    return {
      ...Trigger.GVK,
      ...toJson_TriggerProps(props),
    };
  }

  /**
   * Defines a "Trigger" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TriggerProps) {
    super(scope, id, {
      ...Trigger.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Trigger.GVK,
      ...toJson_TriggerProps(resolved),
    };
  }
}

/**
 * Trigger is the Schema for the Triggers API. Configuration for an automated build in response to source repository changes.
 *
 * @schema Trigger
 */
export interface TriggerProps {
  /**
   * @schema Trigger#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TriggerSpec defines the desired state of Trigger
   *
   * @schema Trigger#spec
   */
  readonly spec: TriggerSpec;

}

/**
 * Converts an object of type 'TriggerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerProps(obj: TriggerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TriggerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TriggerSpec defines the desired state of Trigger
 *
 * @schema TriggerSpec
 */
export interface TriggerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TriggerSpec#deletionPolicy
   */
  readonly deletionPolicy?: TriggerSpecDeletionPolicy;

  /**
   * @schema TriggerSpec#forProvider
   */
  readonly forProvider: TriggerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TriggerSpec#managementPolicy
   */
  readonly managementPolicy?: TriggerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TriggerSpec#providerConfigRef
   */
  readonly providerConfigRef?: TriggerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TriggerSpec#providerRef
   */
  readonly providerRef?: TriggerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TriggerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TriggerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TriggerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TriggerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TriggerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpec(obj: TriggerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TriggerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_TriggerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TriggerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TriggerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TriggerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TriggerSpecDeletionPolicy
 */
export enum TriggerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TriggerSpecForProvider
 */
export interface TriggerSpecForProvider {
  /**
   * Configuration for manual approval to start a build invocation of this BuildTrigger. Builds created by this trigger will require approval before they execute. Any user with a Cloud Build Approver role for the project can approve a build. Structure is documented below.
   *
   * @schema TriggerSpecForProvider#approvalConfig
   */
  readonly approvalConfig?: TriggerSpecForProviderApprovalConfig[];

  /**
   * BitbucketServerTriggerConfig describes the configuration of a trigger that creates a build whenever a Bitbucket Server event is received. Structure is documented below.
   *
   * @schema TriggerSpecForProvider#bitbucketServerTriggerConfig
   */
  readonly bitbucketServerTriggerConfig?: TriggerSpecForProviderBitbucketServerTriggerConfig[];

  /**
   * Contents of the build template. Either a filename or build template must be provided. Structure is documented below.
   *
   * @schema TriggerSpecForProvider#build
   */
  readonly build?: TriggerSpecForProviderBuild[];

  /**
   * Human-readable description of the trigger.
   *
   * @schema TriggerSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Whether the trigger is disabled or not. If true, the trigger will never result in a build.
   *
   * @schema TriggerSpecForProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * Path, from the source root, to a file whose contents is used for the template. Either a filename or build template must be provided. Set this only when using trigger_template or github. When using Pub/Sub, Webhook or Manual set the file name using git_file_source instead.
   *
   * @schema TriggerSpecForProvider#filename
   */
  readonly filename?: string;

  /**
   * A Common Expression Language string. Used only with Pub/Sub and Webhook.
   *
   * @schema TriggerSpecForProvider#filter
   */
  readonly filter?: string;

  /**
   * The file source describing the local or remote Build template. Structure is documented below.
   *
   * @schema TriggerSpecForProvider#gitFileSource
   */
  readonly gitFileSource?: TriggerSpecForProviderGitFileSource[];

  /**
   * Describes the configuration of a trigger that creates a build whenever a GitHub event is received. One of trigger_template, github, pubsub_config or webhook_config must be provided. Structure is documented below.
   *
   * @schema TriggerSpecForProvider#github
   */
  readonly github?: TriggerSpecForProviderGithub[];

  /**
   * ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match extended with support for **. If ignoredFiles and changed files are both empty, then they are not used to determine whether or not to trigger a build. If ignoredFiles is not empty, then we ignore any files that match any of the ignored_file globs. If the change has no files that are outside of the ignoredFiles globs, then we do not trigger a build.
   *
   * @schema TriggerSpecForProvider#ignoredFiles
   */
  readonly ignoredFiles?: string[];

  /**
   * Build logs will be sent back to GitHub as part of the checkrun result.  Values can be INCLUDE_BUILD_LOGS_UNSPECIFIED or INCLUDE_BUILD_LOGS_WITH_STATUS Possible values are: INCLUDE_BUILD_LOGS_UNSPECIFIED, INCLUDE_BUILD_LOGS_WITH_STATUS.
   *
   * @schema TriggerSpecForProvider#includeBuildLogs
   */
  readonly includeBuildLogs?: string;

  /**
   * ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match extended with support for **. If any of the files altered in the commit pass the ignoredFiles filter and includedFiles is empty, then as far as this filter is concerned, we should trigger the build. If any of the files altered in the commit pass the ignoredFiles filter and includedFiles is not empty, then we make sure that at least one of those files matches a includedFiles glob. If not, then we do not trigger a build.
   *
   * @schema TriggerSpecForProvider#includedFiles
   */
  readonly includedFiles?: string[];

  /**
   * The Cloud Build location for the trigger. If not specified, "global" is used.
   *
   * @schema TriggerSpecForProvider#location
   */
  readonly location?: string;

  /**
   * Name of the trigger. Must be unique within the project.
   *
   * @schema TriggerSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema TriggerSpecForProvider#project
   */
  readonly project?: string;

  /**
   * PubsubConfig describes the configuration of a trigger that creates a build whenever a Pub/Sub message is published. One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided. Structure is documented below.
   *
   * @schema TriggerSpecForProvider#pubsubConfig
   */
  readonly pubsubConfig?: TriggerSpecForProviderPubsubConfig[];

  /**
   * The service account used for all user-controlled operations including triggers.patch, triggers.run, builds.create, and builds.cancel. If no service account is set, then the standard Cloud Build service account ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead. Format: projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}
   *
   * @schema TriggerSpecForProvider#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema TriggerSpecForProvider#serviceAccountRef
   */
  readonly serviceAccountRef?: TriggerSpecForProviderServiceAccountRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema TriggerSpecForProvider#serviceAccountSelector
   */
  readonly serviceAccountSelector?: TriggerSpecForProviderServiceAccountSelector;

  /**
   * The repo and ref of the repository from which to build. This field is used only for those triggers that do not respond to SCM events. Triggers that respond to such events build source at whatever commit caused the event. This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers. One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided. Structure is documented below.
   *
   * @schema TriggerSpecForProvider#sourceToBuild
   */
  readonly sourceToBuild?: TriggerSpecForProviderSourceToBuild[];

  /**
   * Substitutions data for Build resource.
   *
   * @schema TriggerSpecForProvider#substitutions
   */
  readonly substitutions?: { [key: string]: string };

  /**
   * Tags for annotation of a BuildTrigger
   *
   * @schema TriggerSpecForProvider#tags
   */
  readonly tags?: string[];

  /**
   * Template describing the types of source changes to trigger a build. Branch and tag names in trigger templates are interpreted as regular expressions. Any branch or tag change that matches that regular expression will trigger a build. One of trigger_template, github, pubsub_config, webhook_config or source_to_build must be provided. Structure is documented below.
   *
   * @schema TriggerSpecForProvider#triggerTemplate
   */
  readonly triggerTemplate?: TriggerSpecForProviderTriggerTemplate[];

  /**
   * WebhookConfig describes the configuration of a trigger that creates a build whenever a webhook is sent to a trigger's webhook URL. One of trigger_template, github, pubsub_config webhook_config or source_to_build must be provided. Structure is documented below.
   *
   * @schema TriggerSpecForProvider#webhookConfig
   */
  readonly webhookConfig?: TriggerSpecForProviderWebhookConfig[];

}

/**
 * Converts an object of type 'TriggerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProvider(obj: TriggerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'approvalConfig': obj.approvalConfig?.map(y => toJson_TriggerSpecForProviderApprovalConfig(y)),
    'bitbucketServerTriggerConfig': obj.bitbucketServerTriggerConfig?.map(y => toJson_TriggerSpecForProviderBitbucketServerTriggerConfig(y)),
    'build': obj.build?.map(y => toJson_TriggerSpecForProviderBuild(y)),
    'description': obj.description,
    'disabled': obj.disabled,
    'filename': obj.filename,
    'filter': obj.filter,
    'gitFileSource': obj.gitFileSource?.map(y => toJson_TriggerSpecForProviderGitFileSource(y)),
    'github': obj.github?.map(y => toJson_TriggerSpecForProviderGithub(y)),
    'ignoredFiles': obj.ignoredFiles?.map(y => y),
    'includeBuildLogs': obj.includeBuildLogs,
    'includedFiles': obj.includedFiles?.map(y => y),
    'location': obj.location,
    'name': obj.name,
    'project': obj.project,
    'pubsubConfig': obj.pubsubConfig?.map(y => toJson_TriggerSpecForProviderPubsubConfig(y)),
    'serviceAccount': obj.serviceAccount,
    'serviceAccountRef': toJson_TriggerSpecForProviderServiceAccountRef(obj.serviceAccountRef),
    'serviceAccountSelector': toJson_TriggerSpecForProviderServiceAccountSelector(obj.serviceAccountSelector),
    'sourceToBuild': obj.sourceToBuild?.map(y => toJson_TriggerSpecForProviderSourceToBuild(y)),
    'substitutions': ((obj.substitutions) === undefined) ? undefined : (Object.entries(obj.substitutions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tags': obj.tags?.map(y => y),
    'triggerTemplate': obj.triggerTemplate?.map(y => toJson_TriggerSpecForProviderTriggerTemplate(y)),
    'webhookConfig': obj.webhookConfig?.map(y => toJson_TriggerSpecForProviderWebhookConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TriggerSpecManagementPolicy
 */
export enum TriggerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TriggerSpecProviderConfigRef
 */
export interface TriggerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TriggerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TriggerSpecProviderConfigRef#policy
   */
  readonly policy?: TriggerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TriggerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecProviderConfigRef(obj: TriggerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TriggerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TriggerSpecProviderRef
 */
export interface TriggerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TriggerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TriggerSpecProviderRef#policy
   */
  readonly policy?: TriggerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TriggerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecProviderRef(obj: TriggerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TriggerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TriggerSpecPublishConnectionDetailsTo
 */
export interface TriggerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TriggerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TriggerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TriggerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TriggerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TriggerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TriggerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecPublishConnectionDetailsTo(obj: TriggerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TriggerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TriggerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TriggerSpecWriteConnectionSecretToRef
 */
export interface TriggerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TriggerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TriggerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TriggerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecWriteConnectionSecretToRef(obj: TriggerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderApprovalConfig
 */
export interface TriggerSpecForProviderApprovalConfig {
  /**
   * Whether or not approval is needed. If this is set on a build, it will become pending when run, and will need to be explicitly approved to start.
   *
   * @schema TriggerSpecForProviderApprovalConfig#approvalRequired
   */
  readonly approvalRequired?: boolean;

}

/**
 * Converts an object of type 'TriggerSpecForProviderApprovalConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderApprovalConfig(obj: TriggerSpecForProviderApprovalConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'approvalRequired': obj.approvalRequired,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderBitbucketServerTriggerConfig
 */
export interface TriggerSpecForProviderBitbucketServerTriggerConfig {
  /**
   * The Bitbucket server config resource that this trigger config maps to.
   *
   * @schema TriggerSpecForProviderBitbucketServerTriggerConfig#bitbucketServerConfigResource
   */
  readonly bitbucketServerConfigResource: string;

  /**
   * Key of the project that the repo is in. For example: The key for https://mybitbucket.server/projects/TEST/repos/test-repo is "TEST".
   *
   * @schema TriggerSpecForProviderBitbucketServerTriggerConfig#projectKey
   */
  readonly projectKey: string;

  /**
   * Filter to match changes in pull requests. Structure is documented below.
   *
   * @schema TriggerSpecForProviderBitbucketServerTriggerConfig#pullRequest
   */
  readonly pullRequest?: TriggerSpecForProviderBitbucketServerTriggerConfigPullRequest[];

  /**
   * Filter to match changes in refs like branches, tags. Structure is documented below.
   *
   * @schema TriggerSpecForProviderBitbucketServerTriggerConfig#push
   */
  readonly push?: TriggerSpecForProviderBitbucketServerTriggerConfigPush[];

  /**
   * Slug of the repository. A repository slug is a URL-friendly version of a repository name, automatically generated by Bitbucket for use in the URL. For example, if the repository name is 'test repo', in the URL it would become 'test-repo' as in https://mybitbucket.server/projects/TEST/repos/test-repo.
   *
   * @schema TriggerSpecForProviderBitbucketServerTriggerConfig#repoSlug
   */
  readonly repoSlug: string;

}

/**
 * Converts an object of type 'TriggerSpecForProviderBitbucketServerTriggerConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderBitbucketServerTriggerConfig(obj: TriggerSpecForProviderBitbucketServerTriggerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bitbucketServerConfigResource': obj.bitbucketServerConfigResource,
    'projectKey': obj.projectKey,
    'pullRequest': obj.pullRequest?.map(y => toJson_TriggerSpecForProviderBitbucketServerTriggerConfigPullRequest(y)),
    'push': obj.push?.map(y => toJson_TriggerSpecForProviderBitbucketServerTriggerConfigPush(y)),
    'repoSlug': obj.repoSlug,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderBuild
 */
export interface TriggerSpecForProviderBuild {
  /**
   * Artifacts produced by the build that should be uploaded upon successful completion of all build steps. Structure is documented below.
   *
   * @schema TriggerSpecForProviderBuild#artifacts
   */
  readonly artifacts?: TriggerSpecForProviderBuildArtifacts[];

  /**
   * Secrets and secret environment variables. Structure is documented below.
   *
   * @schema TriggerSpecForProviderBuild#availableSecrets
   */
  readonly availableSecrets?: TriggerSpecForProviderBuildAvailableSecrets[];

  /**
   * A list of images to be pushed upon the successful completion of all build steps. The images are pushed using the builder service account's credentials. The digests of the pushed images will be stored in the Build resource's results field. If any of the images fail to be pushed, the build status is marked FAILURE.
   *
   * @schema TriggerSpecForProviderBuild#images
   */
  readonly images?: string[];

  /**
   * Google Cloud Storage bucket where logs should be written. Logs file names will be of the format ${logsBucket}/log-${build_id}.txt.
   *
   * @schema TriggerSpecForProviderBuild#logsBucket
   */
  readonly logsBucket?: string;

  /**
   * Special options for this build. Structure is documented below.
   *
   * @schema TriggerSpecForProviderBuild#options
   */
  readonly options?: TriggerSpecForProviderBuildOptions[];

  /**
   * TTL in queue for this build. If provided and the build is enqueued longer than this value, the build will expire and the build status will be EXPIRED. The TTL starts ticking from createTime. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema TriggerSpecForProviderBuild#queueTtl
   */
  readonly queueTtl?: string;

  /**
   * Secrets to decrypt using Cloud Key Management Service. Structure is documented below.
   *
   * @schema TriggerSpecForProviderBuild#secret
   */
  readonly secret?: TriggerSpecForProviderBuildSecret[];

  /**
   * The location of the source files to build. One of storageSource or repoSource must be provided. Structure is documented below.
   *
   * @schema TriggerSpecForProviderBuild#source
   */
  readonly source?: TriggerSpecForProviderBuildSource[];

  /**
   * The operations to be performed on the workspace. Structure is documented below.
   *
   * @schema TriggerSpecForProviderBuild#step
   */
  readonly step: TriggerSpecForProviderBuildStep[];

  /**
   * Substitutions data for Build resource.
   *
   * @schema TriggerSpecForProviderBuild#substitutions
   */
  readonly substitutions?: { [key: string]: string };

  /**
   * Tags for annotation of a Build. These are not docker tags.
   *
   * @schema TriggerSpecForProviderBuild#tags
   */
  readonly tags?: string[];

  /**
   * Amount of time that this build should be allowed to run, to second granularity. If this amount of time elapses, work on the build will cease and the build status will be TIMEOUT. This timeout must be equal to or greater than the sum of the timeouts for build steps within the build. The expected format is the number of seconds followed by s. Default time is ten minutes (600s).
   *
   * @schema TriggerSpecForProviderBuild#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'TriggerSpecForProviderBuild' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderBuild(obj: TriggerSpecForProviderBuild | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'artifacts': obj.artifacts?.map(y => toJson_TriggerSpecForProviderBuildArtifacts(y)),
    'availableSecrets': obj.availableSecrets?.map(y => toJson_TriggerSpecForProviderBuildAvailableSecrets(y)),
    'images': obj.images?.map(y => y),
    'logsBucket': obj.logsBucket,
    'options': obj.options?.map(y => toJson_TriggerSpecForProviderBuildOptions(y)),
    'queueTtl': obj.queueTtl,
    'secret': obj.secret?.map(y => toJson_TriggerSpecForProviderBuildSecret(y)),
    'source': obj.source?.map(y => toJson_TriggerSpecForProviderBuildSource(y)),
    'step': obj.step?.map(y => toJson_TriggerSpecForProviderBuildStep(y)),
    'substitutions': ((obj.substitutions) === undefined) ? undefined : (Object.entries(obj.substitutions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tags': obj.tags?.map(y => y),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderGitFileSource
 */
export interface TriggerSpecForProviderGitFileSource {
  /**
   * The full resource name of the github enterprise config. Format: projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}. projects/{project}/githubEnterpriseConfigs/{id}.
   *
   * @schema TriggerSpecForProviderGitFileSource#githubEnterpriseConfig
   */
  readonly githubEnterpriseConfig?: string;

  /**
   * The path of the file, with the repo root as the root of the path.
   *
   * @schema TriggerSpecForProviderGitFileSource#path
   */
  readonly path: string;

  /**
   * The type of the repo, since it may not be explicit from the repo field (e.g from a URL). Values can be UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER Possible values are: UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER.
   *
   * @schema TriggerSpecForProviderGitFileSource#repoType
   */
  readonly repoType: string;

  /**
   * The branch, tag, arbitrary ref, or SHA version of the repo to use when resolving the filename . This field respects the same syntax/resolution as described here: https://git-scm.com/docs/gitrevisions If unspecified, the revision from which the trigger invocation originated is assumed to be the revision from which to read the specified path.
   *
   * @schema TriggerSpecForProviderGitFileSource#revision
   */
  readonly revision?: string;

  /**
   * The URI of the repo . If unspecified, the repo from which the trigger invocation originated is assumed to be the repo from which to read the specified path.
   *
   * @schema TriggerSpecForProviderGitFileSource#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'TriggerSpecForProviderGitFileSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderGitFileSource(obj: TriggerSpecForProviderGitFileSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'githubEnterpriseConfig': obj.githubEnterpriseConfig,
    'path': obj.path,
    'repoType': obj.repoType,
    'revision': obj.revision,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderGithub
 */
export interface TriggerSpecForProviderGithub {
  /**
   * The resource name of the github enterprise config that should be applied to this installation. For example: "projects/{$projectId}/locations/{$locationId}/githubEnterpriseConfigs/{$configId}"
   *
   * @schema TriggerSpecForProviderGithub#enterpriseConfigResourceName
   */
  readonly enterpriseConfigResourceName?: string;

  /**
   * Name of the repository. For example: The name for https://github.com/googlecloudplatform/cloud-builders is "cloud-builders".
   *
   * @schema TriggerSpecForProviderGithub#name
   */
  readonly name?: string;

  /**
   * Owner of the repository. For example: The owner for https://github.com/googlecloudplatform/cloud-builders is "googlecloudplatform".
   *
   * @schema TriggerSpecForProviderGithub#owner
   */
  readonly owner?: string;

  /**
   * filter to match changes in pull requests. Specify only one of pull_request or push. Structure is documented below.
   *
   * @schema TriggerSpecForProviderGithub#pullRequest
   */
  readonly pullRequest?: TriggerSpecForProviderGithubPullRequest[];

  /**
   * filter to match changes in refs, like branches or tags. Specify only one of pull_request or push. Structure is documented below.
   *
   * @schema TriggerSpecForProviderGithub#push
   */
  readonly push?: TriggerSpecForProviderGithubPush[];

}

/**
 * Converts an object of type 'TriggerSpecForProviderGithub' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderGithub(obj: TriggerSpecForProviderGithub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enterpriseConfigResourceName': obj.enterpriseConfigResourceName,
    'name': obj.name,
    'owner': obj.owner,
    'pullRequest': obj.pullRequest?.map(y => toJson_TriggerSpecForProviderGithubPullRequest(y)),
    'push': obj.push?.map(y => toJson_TriggerSpecForProviderGithubPush(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderPubsubConfig
 */
export interface TriggerSpecForProviderPubsubConfig {
  /**
   * Service account that will make the push request.
   *
   * @schema TriggerSpecForProviderPubsubConfig#serviceAccountEmail
   */
  readonly serviceAccountEmail?: string;

  /**
   * The name of the topic from which this subscription is receiving messages.
   *
   * @schema TriggerSpecForProviderPubsubConfig#topic
   */
  readonly topic?: string;

  /**
   * Reference to a Topic in pubsub to populate topic.
   *
   * @schema TriggerSpecForProviderPubsubConfig#topicRef
   */
  readonly topicRef?: TriggerSpecForProviderPubsubConfigTopicRef;

  /**
   * Selector for a Topic in pubsub to populate topic.
   *
   * @schema TriggerSpecForProviderPubsubConfig#topicSelector
   */
  readonly topicSelector?: TriggerSpecForProviderPubsubConfigTopicSelector;

}

/**
 * Converts an object of type 'TriggerSpecForProviderPubsubConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderPubsubConfig(obj: TriggerSpecForProviderPubsubConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountEmail': obj.serviceAccountEmail,
    'topic': obj.topic,
    'topicRef': toJson_TriggerSpecForProviderPubsubConfigTopicRef(obj.topicRef),
    'topicSelector': toJson_TriggerSpecForProviderPubsubConfigTopicSelector(obj.topicSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema TriggerSpecForProviderServiceAccountRef
 */
export interface TriggerSpecForProviderServiceAccountRef {
  /**
   * Name of the referenced object.
   *
   * @schema TriggerSpecForProviderServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TriggerSpecForProviderServiceAccountRef#policy
   */
  readonly policy?: TriggerSpecForProviderServiceAccountRefPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderServiceAccountRef(obj: TriggerSpecForProviderServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TriggerSpecForProviderServiceAccountRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema TriggerSpecForProviderServiceAccountSelector
 */
export interface TriggerSpecForProviderServiceAccountSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TriggerSpecForProviderServiceAccountSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TriggerSpecForProviderServiceAccountSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TriggerSpecForProviderServiceAccountSelector#policy
   */
  readonly policy?: TriggerSpecForProviderServiceAccountSelectorPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderServiceAccountSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderServiceAccountSelector(obj: TriggerSpecForProviderServiceAccountSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TriggerSpecForProviderServiceAccountSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderSourceToBuild
 */
export interface TriggerSpecForProviderSourceToBuild {
  /**
   * The full resource name of the github enterprise config. Format: projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}. projects/{project}/githubEnterpriseConfigs/{id}.
   *
   * @schema TriggerSpecForProviderSourceToBuild#githubEnterpriseConfig
   */
  readonly githubEnterpriseConfig?: string;

  /**
   * The branch or tag to use. Must start with "refs/" .
   *
   * @schema TriggerSpecForProviderSourceToBuild#ref
   */
  readonly ref: string;

  /**
   * The type of the repo, since it may not be explicit from the repo field (e.g from a URL). Values can be UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER Possible values are: UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER.
   *
   * @schema TriggerSpecForProviderSourceToBuild#repoType
   */
  readonly repoType: string;

  /**
   * The URI of the repo .
   *
   * @schema TriggerSpecForProviderSourceToBuild#uri
   */
  readonly uri: string;

}

/**
 * Converts an object of type 'TriggerSpecForProviderSourceToBuild' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderSourceToBuild(obj: TriggerSpecForProviderSourceToBuild | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'githubEnterpriseConfig': obj.githubEnterpriseConfig,
    'ref': obj.ref,
    'repoType': obj.repoType,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderTriggerTemplate
 */
export interface TriggerSpecForProviderTriggerTemplate {
  /**
   * Name of the branch to build. Exactly one a of branch name, tag, or commit SHA must be provided. This field is a regular expression.
   *
   * @schema TriggerSpecForProviderTriggerTemplate#branchName
   */
  readonly branchName?: string;

  /**
   * Explicit commit SHA to build. Exactly one of a branch name, tag, or commit SHA must be provided.
   *
   * @schema TriggerSpecForProviderTriggerTemplate#commitSha
   */
  readonly commitSha?: string;

  /**
   * Directory, relative to the source root, in which to run the build. This must be a relative path. If a step's dir is specified and is an absolute path, this value is ignored for that step's execution.
   *
   * @schema TriggerSpecForProviderTriggerTemplate#dir
   */
  readonly dir?: string;

  /**
   * Only trigger a build if the revision regex does NOT match the revision regex.
   *
   * @schema TriggerSpecForProviderTriggerTemplate#invertRegex
   */
  readonly invertRegex?: boolean;

  /**
   * ID of the project that owns the Cloud Source Repository. If omitted, the project ID requesting the build is assumed.
   *
   * @schema TriggerSpecForProviderTriggerTemplate#projectId
   */
  readonly projectId?: string;

  /**
   * Name of the Cloud Source Repository. If omitted, the name "default" is assumed.
   *
   * @schema TriggerSpecForProviderTriggerTemplate#repoName
   */
  readonly repoName?: string;

  /**
   * Name of the tag to build. Exactly one of a branch name, tag, or commit SHA must be provided. This field is a regular expression.
   *
   * @schema TriggerSpecForProviderTriggerTemplate#tagName
   */
  readonly tagName?: string;

}

/**
 * Converts an object of type 'TriggerSpecForProviderTriggerTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderTriggerTemplate(obj: TriggerSpecForProviderTriggerTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branchName': obj.branchName,
    'commitSha': obj.commitSha,
    'dir': obj.dir,
    'invertRegex': obj.invertRegex,
    'projectId': obj.projectId,
    'repoName': obj.repoName,
    'tagName': obj.tagName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderWebhookConfig
 */
export interface TriggerSpecForProviderWebhookConfig {
  /**
   * Resource name for the secret required as a URL parameter.
   *
   * @schema TriggerSpecForProviderWebhookConfig#secret
   */
  readonly secret?: string;

  /**
   * Reference to a SecretVersion in secretmanager to populate secret.
   *
   * @schema TriggerSpecForProviderWebhookConfig#secretRef
   */
  readonly secretRef?: TriggerSpecForProviderWebhookConfigSecretRef;

  /**
   * Selector for a SecretVersion in secretmanager to populate secret.
   *
   * @schema TriggerSpecForProviderWebhookConfig#secretSelector
   */
  readonly secretSelector?: TriggerSpecForProviderWebhookConfigSecretSelector;

}

/**
 * Converts an object of type 'TriggerSpecForProviderWebhookConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderWebhookConfig(obj: TriggerSpecForProviderWebhookConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secret': obj.secret,
    'secretRef': toJson_TriggerSpecForProviderWebhookConfigSecretRef(obj.secretRef),
    'secretSelector': toJson_TriggerSpecForProviderWebhookConfigSecretSelector(obj.secretSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TriggerSpecProviderConfigRefPolicy
 */
export interface TriggerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TriggerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TriggerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecProviderConfigRefPolicy(obj: TriggerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TriggerSpecProviderRefPolicy
 */
export interface TriggerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TriggerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TriggerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecProviderRefPolicy(obj: TriggerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TriggerSpecPublishConnectionDetailsToConfigRef
 */
export interface TriggerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TriggerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TriggerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TriggerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TriggerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecPublishConnectionDetailsToConfigRef(obj: TriggerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TriggerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TriggerSpecPublishConnectionDetailsToMetadata
 */
export interface TriggerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TriggerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TriggerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TriggerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TriggerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecPublishConnectionDetailsToMetadata(obj: TriggerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderBitbucketServerTriggerConfigPullRequest
 */
export interface TriggerSpecForProviderBitbucketServerTriggerConfigPullRequest {
  /**
   * Regex of branches to match. The syntax of the regular expressions accepted is the syntax accepted by RE2 and described at https://github.com/google/re2/wiki/Syntax
   *
   * @schema TriggerSpecForProviderBitbucketServerTriggerConfigPullRequest#branch
   */
  readonly branch: string;

  /**
   * Configure builds to run whether a repository owner or collaborator need to comment /gcbrun. Possible values are: COMMENTS_DISABLED, COMMENTS_ENABLED, COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY.
   *
   * @schema TriggerSpecForProviderBitbucketServerTriggerConfigPullRequest#commentControl
   */
  readonly commentControl?: string;

  /**
   * Only trigger a build if the revision regex does NOT match the revision regex.
   *
   * @schema TriggerSpecForProviderBitbucketServerTriggerConfigPullRequest#invertRegex
   */
  readonly invertRegex?: boolean;

}

/**
 * Converts an object of type 'TriggerSpecForProviderBitbucketServerTriggerConfigPullRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderBitbucketServerTriggerConfigPullRequest(obj: TriggerSpecForProviderBitbucketServerTriggerConfigPullRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'commentControl': obj.commentControl,
    'invertRegex': obj.invertRegex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderBitbucketServerTriggerConfigPush
 */
export interface TriggerSpecForProviderBitbucketServerTriggerConfigPush {
  /**
   * Regex of branches to match. The syntax of the regular expressions accepted is the syntax accepted by RE2 and described at https://github.com/google/re2/wiki/Syntax
   *
   * @schema TriggerSpecForProviderBitbucketServerTriggerConfigPush#branch
   */
  readonly branch?: string;

  /**
   * Only trigger a build if the revision regex does NOT match the revision regex.
   *
   * @schema TriggerSpecForProviderBitbucketServerTriggerConfigPush#invertRegex
   */
  readonly invertRegex?: boolean;

  /**
   * Regex of tags to match. The syntax of the regular expressions accepted is the syntax accepted by RE2 and described at https://github.com/google/re2/wiki/Syntax
   *
   * @schema TriggerSpecForProviderBitbucketServerTriggerConfigPush#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'TriggerSpecForProviderBitbucketServerTriggerConfigPush' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderBitbucketServerTriggerConfigPush(obj: TriggerSpecForProviderBitbucketServerTriggerConfigPush | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'invertRegex': obj.invertRegex,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderBuildArtifacts
 */
export interface TriggerSpecForProviderBuildArtifacts {
  /**
   * A list of images to be pushed upon the successful completion of all build steps. The images are pushed using the builder service account's credentials. The digests of the pushed images will be stored in the Build resource's results field. If any of the images fail to be pushed, the build status is marked FAILURE.
   *
   * @schema TriggerSpecForProviderBuildArtifacts#images
   */
  readonly images?: string[];

  /**
   * A list of objects to be uploaded to Cloud Storage upon successful completion of all build steps. Files in the workspace matching specified paths globs will be uploaded to the Cloud Storage location using the builder service account's credentials. The location and generation of the uploaded objects will be stored in the Build resource's results field. If any objects fail to be pushed, the build is marked FAILURE. Structure is documented below.
   *
   * @schema TriggerSpecForProviderBuildArtifacts#objects
   */
  readonly objects?: TriggerSpecForProviderBuildArtifactsObjects[];

}

/**
 * Converts an object of type 'TriggerSpecForProviderBuildArtifacts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderBuildArtifacts(obj: TriggerSpecForProviderBuildArtifacts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'images': obj.images?.map(y => y),
    'objects': obj.objects?.map(y => toJson_TriggerSpecForProviderBuildArtifactsObjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderBuildAvailableSecrets
 */
export interface TriggerSpecForProviderBuildAvailableSecrets {
  /**
   * Pairs a secret environment variable with a SecretVersion in Secret Manager. Structure is documented below.
   *
   * @schema TriggerSpecForProviderBuildAvailableSecrets#secretManager
   */
  readonly secretManager: TriggerSpecForProviderBuildAvailableSecretsSecretManager[];

}

/**
 * Converts an object of type 'TriggerSpecForProviderBuildAvailableSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderBuildAvailableSecrets(obj: TriggerSpecForProviderBuildAvailableSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretManager': obj.secretManager?.map(y => toJson_TriggerSpecForProviderBuildAvailableSecretsSecretManager(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderBuildOptions
 */
export interface TriggerSpecForProviderBuildOptions {
  /**
   * Requested disk size for the VM that runs the build. Note that this is NOT "disk free"; some of the space will be used by the operating system and build utilities. Also note that this is the minimum disk size that will be allocated for the build -- the build may run with a larger disk than requested. At present, the maximum disk size is 1000GB; builds that request more than the maximum are rejected with an error.
   *
   * @schema TriggerSpecForProviderBuildOptions#diskSizeGb
   */
  readonly diskSizeGb?: number;

  /**
   * Option to specify whether or not to apply bash style string operations to the substitutions. NOTE this is always enabled for triggered builds and cannot be overridden in the build configuration file.
   *
   * @schema TriggerSpecForProviderBuildOptions#dynamicSubstitutions
   */
  readonly dynamicSubstitutions?: boolean;

  /**
   * A list of environment variable definitions to be used when running a step. The elements are of the form "KEY=VALUE" for the environment variable "KEY" being given the value "VALUE".
   *
   * @schema TriggerSpecForProviderBuildOptions#env
   */
  readonly env?: string[];

  /**
   * Option to define build log streaming behavior to Google Cloud Storage. Possible values are: STREAM_DEFAULT, STREAM_ON, STREAM_OFF.
   *
   * @schema TriggerSpecForProviderBuildOptions#logStreamingOption
   */
  readonly logStreamingOption?: string;

  /**
   * Option to specify the logging mode, which determines if and where build logs are stored. Possible values are: LOGGING_UNSPECIFIED, LEGACY, GCS_ONLY, STACKDRIVER_ONLY, CLOUD_LOGGING_ONLY, NONE.
   *
   * @schema TriggerSpecForProviderBuildOptions#logging
   */
  readonly logging?: string;

  /**
   * Compute Engine machine type on which to run the build. Possible values are: UNSPECIFIED, N1_HIGHCPU_8, N1_HIGHCPU_32, E2_HIGHCPU_8, E2_HIGHCPU_32.
   *
   * @schema TriggerSpecForProviderBuildOptions#machineType
   */
  readonly machineType?: string;

  /**
   * Requested verifiability options. Possible values are: NOT_VERIFIED, VERIFIED.
   *
   * @schema TriggerSpecForProviderBuildOptions#requestedVerifyOption
   */
  readonly requestedVerifyOption?: string;

  /**
   * A list of environment variables which are encrypted using a Cloud Key Management Service crypto key. These values must be specified in the build's Secret.
   *
   * @schema TriggerSpecForProviderBuildOptions#secretEnv
   */
  readonly secretEnv?: string[];

  /**
   * Requested hash for SourceProvenance. Each value may be one of: NONE, SHA256, MD5.
   *
   * @schema TriggerSpecForProviderBuildOptions#sourceProvenanceHash
   */
  readonly sourceProvenanceHash?: string[];

  /**
   * Option to specify behavior when there is an error in the substitution checks. NOTE this is always set to ALLOW_LOOSE for triggered builds and cannot be overridden in the build configuration file. Possible values are: MUST_MATCH, ALLOW_LOOSE.
   *
   * @schema TriggerSpecForProviderBuildOptions#substitutionOption
   */
  readonly substitutionOption?: string;

  /**
   * List of volumes to mount into the build step. Each volume is created as an empty volume prior to execution of the build step. Upon completion of the build, volumes and their contents are discarded. Using a named volume in only one step is not valid as it is indicative of a build request with an incorrect configuration. Structure is documented below.
   *
   * @schema TriggerSpecForProviderBuildOptions#volumes
   */
  readonly volumes?: TriggerSpecForProviderBuildOptionsVolumes[];

  /**
   * Option to specify a WorkerPool for the build. Format projects/{project}/workerPools/{workerPool} This field is experimental.
   *
   * @schema TriggerSpecForProviderBuildOptions#workerPool
   */
  readonly workerPool?: string;

}

/**
 * Converts an object of type 'TriggerSpecForProviderBuildOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderBuildOptions(obj: TriggerSpecForProviderBuildOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'diskSizeGb': obj.diskSizeGb,
    'dynamicSubstitutions': obj.dynamicSubstitutions,
    'env': obj.env?.map(y => y),
    'logStreamingOption': obj.logStreamingOption,
    'logging': obj.logging,
    'machineType': obj.machineType,
    'requestedVerifyOption': obj.requestedVerifyOption,
    'secretEnv': obj.secretEnv?.map(y => y),
    'sourceProvenanceHash': obj.sourceProvenanceHash?.map(y => y),
    'substitutionOption': obj.substitutionOption,
    'volumes': obj.volumes?.map(y => toJson_TriggerSpecForProviderBuildOptionsVolumes(y)),
    'workerPool': obj.workerPool,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderBuildSecret
 */
export interface TriggerSpecForProviderBuildSecret {
  /**
   * Cloud KMS key name to use to decrypt these envs.
   *
   * @schema TriggerSpecForProviderBuildSecret#kmsKeyName
   */
  readonly kmsKeyName: string;

  /**
   * A list of environment variables which are encrypted using a Cloud Key Management Service crypto key. These values must be specified in the build's Secret.
   *
   * @schema TriggerSpecForProviderBuildSecret#secretEnv
   */
  readonly secretEnv?: { [key: string]: string };

}

/**
 * Converts an object of type 'TriggerSpecForProviderBuildSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderBuildSecret(obj: TriggerSpecForProviderBuildSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyName': obj.kmsKeyName,
    'secretEnv': ((obj.secretEnv) === undefined) ? undefined : (Object.entries(obj.secretEnv).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderBuildSource
 */
export interface TriggerSpecForProviderBuildSource {
  /**
   * Location of the source in a Google Cloud Source Repository. Structure is documented below.
   *
   * @schema TriggerSpecForProviderBuildSource#repoSource
   */
  readonly repoSource?: TriggerSpecForProviderBuildSourceRepoSource[];

  /**
   * Location of the source in an archive file in Google Cloud Storage. Structure is documented below.
   *
   * @schema TriggerSpecForProviderBuildSource#storageSource
   */
  readonly storageSource?: TriggerSpecForProviderBuildSourceStorageSource[];

}

/**
 * Converts an object of type 'TriggerSpecForProviderBuildSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderBuildSource(obj: TriggerSpecForProviderBuildSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repoSource': obj.repoSource?.map(y => toJson_TriggerSpecForProviderBuildSourceRepoSource(y)),
    'storageSource': obj.storageSource?.map(y => toJson_TriggerSpecForProviderBuildSourceStorageSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderBuildStep
 */
export interface TriggerSpecForProviderBuildStep {
  /**
   * A list of arguments that will be presented to the step when it is started. If the image used to run the step's container has an entrypoint, the args are used as arguments to that entrypoint. If the image does not define an entrypoint, the first element in args is used as the entrypoint, and the remainder will be used as arguments.
   *
   * @schema TriggerSpecForProviderBuildStep#args
   */
  readonly args?: string[];

  /**
   * Directory, relative to the source root, in which to run the build. This must be a relative path. If a step's dir is specified and is an absolute path, this value is ignored for that step's execution.
   *
   * @schema TriggerSpecForProviderBuildStep#dir
   */
  readonly dir?: string;

  /**
   * Entrypoint to be used instead of the build step image's default entrypoint. If unset, the image's default entrypoint is used
   *
   * @schema TriggerSpecForProviderBuildStep#entrypoint
   */
  readonly entrypoint?: string;

  /**
   * A list of environment variable definitions to be used when running a step. The elements are of the form "KEY=VALUE" for the environment variable "KEY" being given the value "VALUE".
   *
   * @schema TriggerSpecForProviderBuildStep#env
   */
  readonly env?: string[];

  /**
   * Unique identifier for this build step, used in wait_for to reference this build step as a dependency.
   *
   * @schema TriggerSpecForProviderBuildStep#id
   */
  readonly id?: string;

  /**
   * Name of the volume to mount. Volume names must be unique per build step and must be valid names for Docker volumes. Each named volume must be used by at least two build steps.
   *
   * @schema TriggerSpecForProviderBuildStep#name
   */
  readonly name: string;

  /**
   * A shell script to be executed in the step. When script is provided, the user cannot specify the entrypoint or args.
   *
   * @schema TriggerSpecForProviderBuildStep#script
   */
  readonly script?: string;

  /**
   * A list of environment variables which are encrypted using a Cloud Key Management Service crypto key. These values must be specified in the build's Secret.
   *
   * @schema TriggerSpecForProviderBuildStep#secretEnv
   */
  readonly secretEnv?: string[];

  /**
   * Time limit for executing this build step. If not defined, the step has no time limit and will be allowed to continue to run until either it completes or the build itself times out.
   *
   * @schema TriggerSpecForProviderBuildStep#timeout
   */
  readonly timeout?: string;

  /**
   * Output only. Stores timing information for executing this build step.
   *
   * @schema TriggerSpecForProviderBuildStep#timing
   */
  readonly timing?: string;

  /**
   * List of volumes to mount into the build step. Each volume is created as an empty volume prior to execution of the build step. Upon completion of the build, volumes and their contents are discarded. Using a named volume in only one step is not valid as it is indicative of a build request with an incorrect configuration. Structure is documented below.
   *
   * @schema TriggerSpecForProviderBuildStep#volumes
   */
  readonly volumes?: TriggerSpecForProviderBuildStepVolumes[];

  /**
   * The ID(s) of the step(s) that this build step depends on. This build step will not start until all the build steps in wait_for have completed successfully. If wait_for is empty, this build step will start when all previous build steps in the Build.Steps list have completed successfully.
   *
   * @schema TriggerSpecForProviderBuildStep#waitFor
   */
  readonly waitFor?: string[];

}

/**
 * Converts an object of type 'TriggerSpecForProviderBuildStep' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderBuildStep(obj: TriggerSpecForProviderBuildStep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'dir': obj.dir,
    'entrypoint': obj.entrypoint,
    'env': obj.env?.map(y => y),
    'id': obj.id,
    'name': obj.name,
    'script': obj.script,
    'secretEnv': obj.secretEnv?.map(y => y),
    'timeout': obj.timeout,
    'timing': obj.timing,
    'volumes': obj.volumes?.map(y => toJson_TriggerSpecForProviderBuildStepVolumes(y)),
    'waitFor': obj.waitFor?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderGithubPullRequest
 */
export interface TriggerSpecForProviderGithubPullRequest {
  /**
   * Regex of branches to match. The syntax of the regular expressions accepted is the syntax accepted by RE2 and described at https://github.com/google/re2/wiki/Syntax
   *
   * @schema TriggerSpecForProviderGithubPullRequest#branch
   */
  readonly branch: string;

  /**
   * Configure builds to run whether a repository owner or collaborator need to comment /gcbrun. Possible values are: COMMENTS_DISABLED, COMMENTS_ENABLED, COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY.
   *
   * @schema TriggerSpecForProviderGithubPullRequest#commentControl
   */
  readonly commentControl?: string;

  /**
   * Only trigger a build if the revision regex does NOT match the revision regex.
   *
   * @schema TriggerSpecForProviderGithubPullRequest#invertRegex
   */
  readonly invertRegex?: boolean;

}

/**
 * Converts an object of type 'TriggerSpecForProviderGithubPullRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderGithubPullRequest(obj: TriggerSpecForProviderGithubPullRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'commentControl': obj.commentControl,
    'invertRegex': obj.invertRegex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderGithubPush
 */
export interface TriggerSpecForProviderGithubPush {
  /**
   * Regex of branches to match. The syntax of the regular expressions accepted is the syntax accepted by RE2 and described at https://github.com/google/re2/wiki/Syntax
   *
   * @schema TriggerSpecForProviderGithubPush#branch
   */
  readonly branch?: string;

  /**
   * Only trigger a build if the revision regex does NOT match the revision regex.
   *
   * @schema TriggerSpecForProviderGithubPush#invertRegex
   */
  readonly invertRegex?: boolean;

  /**
   * Regex of tags to match. The syntax of the regular expressions accepted is the syntax accepted by RE2 and described at https://github.com/google/re2/wiki/Syntax
   *
   * @schema TriggerSpecForProviderGithubPush#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'TriggerSpecForProviderGithubPush' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderGithubPush(obj: TriggerSpecForProviderGithubPush | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'invertRegex': obj.invertRegex,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in pubsub to populate topic.
 *
 * @schema TriggerSpecForProviderPubsubConfigTopicRef
 */
export interface TriggerSpecForProviderPubsubConfigTopicRef {
  /**
   * Name of the referenced object.
   *
   * @schema TriggerSpecForProviderPubsubConfigTopicRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TriggerSpecForProviderPubsubConfigTopicRef#policy
   */
  readonly policy?: TriggerSpecForProviderPubsubConfigTopicRefPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderPubsubConfigTopicRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderPubsubConfigTopicRef(obj: TriggerSpecForProviderPubsubConfigTopicRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TriggerSpecForProviderPubsubConfigTopicRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in pubsub to populate topic.
 *
 * @schema TriggerSpecForProviderPubsubConfigTopicSelector
 */
export interface TriggerSpecForProviderPubsubConfigTopicSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TriggerSpecForProviderPubsubConfigTopicSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TriggerSpecForProviderPubsubConfigTopicSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TriggerSpecForProviderPubsubConfigTopicSelector#policy
   */
  readonly policy?: TriggerSpecForProviderPubsubConfigTopicSelectorPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderPubsubConfigTopicSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderPubsubConfigTopicSelector(obj: TriggerSpecForProviderPubsubConfigTopicSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TriggerSpecForProviderPubsubConfigTopicSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TriggerSpecForProviderServiceAccountRefPolicy
 */
export interface TriggerSpecForProviderServiceAccountRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderServiceAccountRefPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderServiceAccountRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderServiceAccountRefPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderServiceAccountRefPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderServiceAccountRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderServiceAccountRefPolicy(obj: TriggerSpecForProviderServiceAccountRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TriggerSpecForProviderServiceAccountSelectorPolicy
 */
export interface TriggerSpecForProviderServiceAccountSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderServiceAccountSelectorPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderServiceAccountSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderServiceAccountSelectorPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderServiceAccountSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderServiceAccountSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderServiceAccountSelectorPolicy(obj: TriggerSpecForProviderServiceAccountSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a SecretVersion in secretmanager to populate secret.
 *
 * @schema TriggerSpecForProviderWebhookConfigSecretRef
 */
export interface TriggerSpecForProviderWebhookConfigSecretRef {
  /**
   * Name of the referenced object.
   *
   * @schema TriggerSpecForProviderWebhookConfigSecretRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TriggerSpecForProviderWebhookConfigSecretRef#policy
   */
  readonly policy?: TriggerSpecForProviderWebhookConfigSecretRefPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderWebhookConfigSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderWebhookConfigSecretRef(obj: TriggerSpecForProviderWebhookConfigSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TriggerSpecForProviderWebhookConfigSecretRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a SecretVersion in secretmanager to populate secret.
 *
 * @schema TriggerSpecForProviderWebhookConfigSecretSelector
 */
export interface TriggerSpecForProviderWebhookConfigSecretSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TriggerSpecForProviderWebhookConfigSecretSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TriggerSpecForProviderWebhookConfigSecretSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TriggerSpecForProviderWebhookConfigSecretSelector#policy
   */
  readonly policy?: TriggerSpecForProviderWebhookConfigSecretSelectorPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderWebhookConfigSecretSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderWebhookConfigSecretSelector(obj: TriggerSpecForProviderWebhookConfigSecretSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TriggerSpecForProviderWebhookConfigSecretSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecProviderConfigRefPolicyResolution
 */
export enum TriggerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecProviderConfigRefPolicyResolve
 */
export enum TriggerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecProviderRefPolicyResolution
 */
export enum TriggerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecProviderRefPolicyResolve
 */
export enum TriggerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TriggerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TriggerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecPublishConnectionDetailsToConfigRefPolicy(obj: TriggerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderBuildArtifactsObjects
 */
export interface TriggerSpecForProviderBuildArtifactsObjects {
  /**
   * Cloud Storage bucket and optional object path, in the form "gs://bucket/path/to/somewhere/". Files in the workspace matching any path pattern will be uploaded to Cloud Storage with this location as a prefix.
   *
   * @schema TriggerSpecForProviderBuildArtifactsObjects#location
   */
  readonly location?: string;

  /**
   * Path globs used to match files in the build's workspace.
   *
   * @schema TriggerSpecForProviderBuildArtifactsObjects#paths
   */
  readonly paths?: string[];

}

/**
 * Converts an object of type 'TriggerSpecForProviderBuildArtifactsObjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderBuildArtifactsObjects(obj: TriggerSpecForProviderBuildArtifactsObjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'location': obj.location,
    'paths': obj.paths?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderBuildAvailableSecretsSecretManager
 */
export interface TriggerSpecForProviderBuildAvailableSecretsSecretManager {
  /**
   * A list of environment variable definitions to be used when running a step. The elements are of the form "KEY=VALUE" for the environment variable "KEY" being given the value "VALUE".
   *
   * @schema TriggerSpecForProviderBuildAvailableSecretsSecretManager#env
   */
  readonly env: string;

  /**
   * Resource name of the SecretVersion. In format: projects//secrets//versions/*
   *
   * @schema TriggerSpecForProviderBuildAvailableSecretsSecretManager#versionName
   */
  readonly versionName: string;

}

/**
 * Converts an object of type 'TriggerSpecForProviderBuildAvailableSecretsSecretManager' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderBuildAvailableSecretsSecretManager(obj: TriggerSpecForProviderBuildAvailableSecretsSecretManager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env,
    'versionName': obj.versionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderBuildOptionsVolumes
 */
export interface TriggerSpecForProviderBuildOptionsVolumes {
  /**
   * Name of the volume to mount. Volume names must be unique per build step and must be valid names for Docker volumes. Each named volume must be used by at least two build steps.
   *
   * @schema TriggerSpecForProviderBuildOptionsVolumes#name
   */
  readonly name?: string;

  /**
   * Path at which to mount the volume. Paths must be absolute and cannot conflict with other volume paths on the same build step or with certain reserved volume paths.
   *
   * @schema TriggerSpecForProviderBuildOptionsVolumes#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'TriggerSpecForProviderBuildOptionsVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderBuildOptionsVolumes(obj: TriggerSpecForProviderBuildOptionsVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderBuildSourceRepoSource
 */
export interface TriggerSpecForProviderBuildSourceRepoSource {
  /**
   * Name of the branch to build. Exactly one a of branch name, tag, or commit SHA must be provided. This field is a regular expression.
   *
   * @schema TriggerSpecForProviderBuildSourceRepoSource#branchName
   */
  readonly branchName?: string;

  /**
   * Explicit commit SHA to build. Exactly one of a branch name, tag, or commit SHA must be provided.
   *
   * @schema TriggerSpecForProviderBuildSourceRepoSource#commitSha
   */
  readonly commitSha?: string;

  /**
   * Directory, relative to the source root, in which to run the build. This must be a relative path. If a step's dir is specified and is an absolute path, this value is ignored for that step's execution.
   *
   * @schema TriggerSpecForProviderBuildSourceRepoSource#dir
   */
  readonly dir?: string;

  /**
   * Only trigger a build if the revision regex does NOT match the revision regex.
   *
   * @schema TriggerSpecForProviderBuildSourceRepoSource#invertRegex
   */
  readonly invertRegex?: boolean;

  /**
   * ID of the project that owns the Cloud Source Repository. If omitted, the project ID requesting the build is assumed.
   *
   * @schema TriggerSpecForProviderBuildSourceRepoSource#projectId
   */
  readonly projectId?: string;

  /**
   * Name of the Cloud Source Repository. If omitted, the name "default" is assumed.
   *
   * @schema TriggerSpecForProviderBuildSourceRepoSource#repoName
   */
  readonly repoName: string;

  /**
   * Substitutions data for Build resource.
   *
   * @schema TriggerSpecForProviderBuildSourceRepoSource#substitutions
   */
  readonly substitutions?: { [key: string]: string };

  /**
   * Name of the tag to build. Exactly one of a branch name, tag, or commit SHA must be provided. This field is a regular expression.
   *
   * @schema TriggerSpecForProviderBuildSourceRepoSource#tagName
   */
  readonly tagName?: string;

}

/**
 * Converts an object of type 'TriggerSpecForProviderBuildSourceRepoSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderBuildSourceRepoSource(obj: TriggerSpecForProviderBuildSourceRepoSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branchName': obj.branchName,
    'commitSha': obj.commitSha,
    'dir': obj.dir,
    'invertRegex': obj.invertRegex,
    'projectId': obj.projectId,
    'repoName': obj.repoName,
    'substitutions': ((obj.substitutions) === undefined) ? undefined : (Object.entries(obj.substitutions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tagName': obj.tagName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderBuildSourceStorageSource
 */
export interface TriggerSpecForProviderBuildSourceStorageSource {
  /**
   * Google Cloud Storage bucket containing the source.
   *
   * @schema TriggerSpecForProviderBuildSourceStorageSource#bucket
   */
  readonly bucket: string;

  /**
   * Google Cloud Storage generation for the object. If the generation is omitted, the latest generation will be used
   *
   * @schema TriggerSpecForProviderBuildSourceStorageSource#generation
   */
  readonly generation?: string;

  /**
   * Google Cloud Storage object containing the source. This object must be a gzipped archive file (.tar.gz) containing source to build.
   *
   * @schema TriggerSpecForProviderBuildSourceStorageSource#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'TriggerSpecForProviderBuildSourceStorageSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderBuildSourceStorageSource(obj: TriggerSpecForProviderBuildSourceStorageSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderBuildStepVolumes
 */
export interface TriggerSpecForProviderBuildStepVolumes {
  /**
   * Name of the volume to mount. Volume names must be unique per build step and must be valid names for Docker volumes. Each named volume must be used by at least two build steps.
   *
   * @schema TriggerSpecForProviderBuildStepVolumes#name
   */
  readonly name: string;

  /**
   * Path at which to mount the volume. Paths must be absolute and cannot conflict with other volume paths on the same build step or with certain reserved volume paths.
   *
   * @schema TriggerSpecForProviderBuildStepVolumes#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'TriggerSpecForProviderBuildStepVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderBuildStepVolumes(obj: TriggerSpecForProviderBuildStepVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TriggerSpecForProviderPubsubConfigTopicRefPolicy
 */
export interface TriggerSpecForProviderPubsubConfigTopicRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderPubsubConfigTopicRefPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderPubsubConfigTopicRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderPubsubConfigTopicRefPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderPubsubConfigTopicRefPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderPubsubConfigTopicRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderPubsubConfigTopicRefPolicy(obj: TriggerSpecForProviderPubsubConfigTopicRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TriggerSpecForProviderPubsubConfigTopicSelectorPolicy
 */
export interface TriggerSpecForProviderPubsubConfigTopicSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderPubsubConfigTopicSelectorPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderPubsubConfigTopicSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderPubsubConfigTopicSelectorPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderPubsubConfigTopicSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderPubsubConfigTopicSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderPubsubConfigTopicSelectorPolicy(obj: TriggerSpecForProviderPubsubConfigTopicSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderServiceAccountRefPolicyResolution
 */
export enum TriggerSpecForProviderServiceAccountRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderServiceAccountRefPolicyResolve
 */
export enum TriggerSpecForProviderServiceAccountRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderServiceAccountSelectorPolicyResolution
 */
export enum TriggerSpecForProviderServiceAccountSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderServiceAccountSelectorPolicyResolve
 */
export enum TriggerSpecForProviderServiceAccountSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TriggerSpecForProviderWebhookConfigSecretRefPolicy
 */
export interface TriggerSpecForProviderWebhookConfigSecretRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderWebhookConfigSecretRefPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderWebhookConfigSecretRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderWebhookConfigSecretRefPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderWebhookConfigSecretRefPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderWebhookConfigSecretRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderWebhookConfigSecretRefPolicy(obj: TriggerSpecForProviderWebhookConfigSecretRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TriggerSpecForProviderWebhookConfigSecretSelectorPolicy
 */
export interface TriggerSpecForProviderWebhookConfigSecretSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderWebhookConfigSecretSelectorPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderWebhookConfigSecretSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderWebhookConfigSecretSelectorPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderWebhookConfigSecretSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderWebhookConfigSecretSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderWebhookConfigSecretSelectorPolicy(obj: TriggerSpecForProviderWebhookConfigSecretSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderPubsubConfigTopicRefPolicyResolution
 */
export enum TriggerSpecForProviderPubsubConfigTopicRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderPubsubConfigTopicRefPolicyResolve
 */
export enum TriggerSpecForProviderPubsubConfigTopicRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderPubsubConfigTopicSelectorPolicyResolution
 */
export enum TriggerSpecForProviderPubsubConfigTopicSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderPubsubConfigTopicSelectorPolicyResolve
 */
export enum TriggerSpecForProviderPubsubConfigTopicSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderWebhookConfigSecretRefPolicyResolution
 */
export enum TriggerSpecForProviderWebhookConfigSecretRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderWebhookConfigSecretRefPolicyResolve
 */
export enum TriggerSpecForProviderWebhookConfigSecretRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderWebhookConfigSecretSelectorPolicyResolution
 */
export enum TriggerSpecForProviderWebhookConfigSecretSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderWebhookConfigSecretSelectorPolicyResolve
 */
export enum TriggerSpecForProviderWebhookConfigSecretSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * WorkerPool is the Schema for the WorkerPools API. Configuration for custom WorkerPool to run builds
 *
 * @schema WorkerPool
 */
export class WorkerPool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WorkerPool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudbuild.gcp.upbound.io/v1beta1',
    kind: 'WorkerPool',
  }

  /**
   * Renders a Kubernetes manifest for "WorkerPool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkerPoolProps): any {
    return {
      ...WorkerPool.GVK,
      ...toJson_WorkerPoolProps(props),
    };
  }

  /**
   * Defines a "WorkerPool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkerPoolProps) {
    super(scope, id, {
      ...WorkerPool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...WorkerPool.GVK,
      ...toJson_WorkerPoolProps(resolved),
    };
  }
}

/**
 * WorkerPool is the Schema for the WorkerPools API. Configuration for custom WorkerPool to run builds
 *
 * @schema WorkerPool
 */
export interface WorkerPoolProps {
  /**
   * @schema WorkerPool#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WorkerPoolSpec defines the desired state of WorkerPool
   *
   * @schema WorkerPool#spec
   */
  readonly spec: WorkerPoolSpec;

}

/**
 * Converts an object of type 'WorkerPoolProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolProps(obj: WorkerPoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkerPoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkerPoolSpec defines the desired state of WorkerPool
 *
 * @schema WorkerPoolSpec
 */
export interface WorkerPoolSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WorkerPoolSpec#deletionPolicy
   */
  readonly deletionPolicy?: WorkerPoolSpecDeletionPolicy;

  /**
   * @schema WorkerPoolSpec#forProvider
   */
  readonly forProvider: WorkerPoolSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WorkerPoolSpec#managementPolicy
   */
  readonly managementPolicy?: WorkerPoolSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WorkerPoolSpec#providerConfigRef
   */
  readonly providerConfigRef?: WorkerPoolSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema WorkerPoolSpec#providerRef
   */
  readonly providerRef?: WorkerPoolSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WorkerPoolSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WorkerPoolSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WorkerPoolSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WorkerPoolSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WorkerPoolSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolSpec(obj: WorkerPoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WorkerPoolSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_WorkerPoolSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_WorkerPoolSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_WorkerPoolSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WorkerPoolSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WorkerPoolSpecDeletionPolicy
 */
export enum WorkerPoolSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WorkerPoolSpecForProvider
 */
export interface WorkerPoolSpecForProvider {
  /**
   * @schema WorkerPoolSpecForProvider#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * User-defined name of the WorkerPool.
   *
   * @schema WorkerPoolSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The location for the resource
   *
   * @schema WorkerPoolSpecForProvider#location
   */
  readonly location: string;

  /**
   * Network configuration for the WorkerPool. Structure is documented below.
   *
   * @schema WorkerPoolSpecForProvider#networkConfig
   */
  readonly networkConfig?: WorkerPoolSpecForProviderNetworkConfig[];

  /**
   * The project for the resource
   *
   * @schema WorkerPoolSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Configuration to be used for a creating workers in the WorkerPool. Structure is documented below.
   *
   * @schema WorkerPoolSpecForProvider#workerConfig
   */
  readonly workerConfig?: WorkerPoolSpecForProviderWorkerConfig[];

}

/**
 * Converts an object of type 'WorkerPoolSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolSpecForProvider(obj: WorkerPoolSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'displayName': obj.displayName,
    'location': obj.location,
    'networkConfig': obj.networkConfig?.map(y => toJson_WorkerPoolSpecForProviderNetworkConfig(y)),
    'project': obj.project,
    'workerConfig': obj.workerConfig?.map(y => toJson_WorkerPoolSpecForProviderWorkerConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WorkerPoolSpecManagementPolicy
 */
export enum WorkerPoolSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WorkerPoolSpecProviderConfigRef
 */
export interface WorkerPoolSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkerPoolSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkerPoolSpecProviderConfigRef#policy
   */
  readonly policy?: WorkerPoolSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkerPoolSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolSpecProviderConfigRef(obj: WorkerPoolSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkerPoolSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema WorkerPoolSpecProviderRef
 */
export interface WorkerPoolSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkerPoolSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkerPoolSpecProviderRef#policy
   */
  readonly policy?: WorkerPoolSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'WorkerPoolSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolSpecProviderRef(obj: WorkerPoolSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkerPoolSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WorkerPoolSpecPublishConnectionDetailsTo
 */
export interface WorkerPoolSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WorkerPoolSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WorkerPoolSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WorkerPoolSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WorkerPoolSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WorkerPoolSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WorkerPoolSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolSpecPublishConnectionDetailsTo(obj: WorkerPoolSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WorkerPoolSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WorkerPoolSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WorkerPoolSpecWriteConnectionSecretToRef
 */
export interface WorkerPoolSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WorkerPoolSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WorkerPoolSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WorkerPoolSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolSpecWriteConnectionSecretToRef(obj: WorkerPoolSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkerPoolSpecForProviderNetworkConfig
 */
export interface WorkerPoolSpecForProviderNetworkConfig {
  /**
   * Immutable. The network definition that the workers are peered to. If this section is left empty, the workers will be peered to WorkerPool.project_id on the service producer network. Must be in the format projects/{project}/global/networks/{network}, where {project} is a project number, such as 12345, and {network} is the name of a VPC network in the project. See (https://cloud.google.com/cloud-build/docs/custom-workers/set-up-custom-worker-pool-environment#understanding_the_network_configuration_options)
   *
   * @schema WorkerPoolSpecForProviderNetworkConfig#peeredNetwork
   */
  readonly peeredNetwork?: string;

  /**
   * Immutable. Subnet IP range within the peered network. This is specified in CIDR notation with a slash and the subnet prefix size. You can optionally specify an IP address before the subnet prefix value. e.g. 192.168.0.0/29 would specify an IP range starting at 192.168.0.0 with a prefix size of 29 bits. /16 would specify a prefix size of 16 bits, with an automatically determined IP within the peered VPC. If unspecified, a value of /24 will be used.
   *
   * @schema WorkerPoolSpecForProviderNetworkConfig#peeredNetworkIpRange
   */
  readonly peeredNetworkIpRange?: string;

  /**
   * Reference to a Network in compute to populate peeredNetwork.
   *
   * @schema WorkerPoolSpecForProviderNetworkConfig#peeredNetworkRef
   */
  readonly peeredNetworkRef?: WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRef;

  /**
   * Selector for a Network in compute to populate peeredNetwork.
   *
   * @schema WorkerPoolSpecForProviderNetworkConfig#peeredNetworkSelector
   */
  readonly peeredNetworkSelector?: WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelector;

}

/**
 * Converts an object of type 'WorkerPoolSpecForProviderNetworkConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolSpecForProviderNetworkConfig(obj: WorkerPoolSpecForProviderNetworkConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'peeredNetwork': obj.peeredNetwork,
    'peeredNetworkIpRange': obj.peeredNetworkIpRange,
    'peeredNetworkRef': toJson_WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRef(obj.peeredNetworkRef),
    'peeredNetworkSelector': toJson_WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelector(obj.peeredNetworkSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkerPoolSpecForProviderWorkerConfig
 */
export interface WorkerPoolSpecForProviderWorkerConfig {
  /**
   * Size of the disk attached to the worker, in GB. See (https://cloud.google.com/cloud-build/docs/custom-workers/worker-pool-config-file). Specify a value of up to 1000. If 0 is specified, Cloud Build will use a standard disk size.
   *
   * @schema WorkerPoolSpecForProviderWorkerConfig#diskSizeGb
   */
  readonly diskSizeGb?: number;

  /**
   * Machine type of a worker, such as n1-standard-1. See (https://cloud.google.com/cloud-build/docs/custom-workers/worker-pool-config-file). If left blank, Cloud Build will use n1-standard-1.
   *
   * @schema WorkerPoolSpecForProviderWorkerConfig#machineType
   */
  readonly machineType?: string;

  /**
   * If true, workers are created without any public address, which prevents network egress to public IPs.
   *
   * @schema WorkerPoolSpecForProviderWorkerConfig#noExternalIp
   */
  readonly noExternalIp?: boolean;

}

/**
 * Converts an object of type 'WorkerPoolSpecForProviderWorkerConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolSpecForProviderWorkerConfig(obj: WorkerPoolSpecForProviderWorkerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'diskSizeGb': obj.diskSizeGb,
    'machineType': obj.machineType,
    'noExternalIp': obj.noExternalIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkerPoolSpecProviderConfigRefPolicy
 */
export interface WorkerPoolSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkerPoolSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WorkerPoolSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkerPoolSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WorkerPoolSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkerPoolSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolSpecProviderConfigRefPolicy(obj: WorkerPoolSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkerPoolSpecProviderRefPolicy
 */
export interface WorkerPoolSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkerPoolSpecProviderRefPolicy#resolution
   */
  readonly resolution?: WorkerPoolSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkerPoolSpecProviderRefPolicy#resolve
   */
  readonly resolve?: WorkerPoolSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkerPoolSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolSpecProviderRefPolicy(obj: WorkerPoolSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WorkerPoolSpecPublishConnectionDetailsToConfigRef
 */
export interface WorkerPoolSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkerPoolSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkerPoolSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WorkerPoolSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkerPoolSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolSpecPublishConnectionDetailsToConfigRef(obj: WorkerPoolSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkerPoolSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WorkerPoolSpecPublishConnectionDetailsToMetadata
 */
export interface WorkerPoolSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkerPoolSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkerPoolSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WorkerPoolSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkerPoolSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolSpecPublishConnectionDetailsToMetadata(obj: WorkerPoolSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Network in compute to populate peeredNetwork.
 *
 * @schema WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRef
 */
export interface WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRef#policy
   */
  readonly policy?: WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRefPolicy;

}

/**
 * Converts an object of type 'WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRef(obj: WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Network in compute to populate peeredNetwork.
 *
 * @schema WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelector
 */
export interface WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelector#policy
   */
  readonly policy?: WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelectorPolicy;

}

/**
 * Converts an object of type 'WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelector(obj: WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkerPoolSpecProviderConfigRefPolicyResolution
 */
export enum WorkerPoolSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkerPoolSpecProviderConfigRefPolicyResolve
 */
export enum WorkerPoolSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkerPoolSpecProviderRefPolicyResolution
 */
export enum WorkerPoolSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkerPoolSpecProviderRefPolicyResolve
 */
export enum WorkerPoolSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WorkerPoolSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WorkerPoolSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkerPoolSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WorkerPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkerPoolSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WorkerPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkerPoolSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolSpecPublishConnectionDetailsToConfigRefPolicy(obj: WorkerPoolSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRefPolicy
 */
export interface WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRefPolicy#resolution
   */
  readonly resolution?: WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRefPolicy#resolve
   */
  readonly resolve?: WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRefPolicy(obj: WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelectorPolicy
 */
export interface WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelectorPolicy#resolution
   */
  readonly resolution?: WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelectorPolicy#resolve
   */
  readonly resolve?: WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelectorPolicy(obj: WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkerPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WorkerPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkerPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WorkerPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRefPolicyResolution
 */
export enum WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRefPolicyResolve
 */
export enum WorkerPoolSpecForProviderNetworkConfigPeeredNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelectorPolicyResolution
 */
export enum WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelectorPolicyResolve
 */
export enum WorkerPoolSpecForProviderNetworkConfigPeeredNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

