// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ContributorInsights is the Schema for the ContributorInsightss API. Provides a DynamoDB contributor insights resource
 *
 * @schema ContributorInsights
 */
export class ContributorInsights extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ContributorInsights"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dynamodb.aws.upbound.io/v1beta1',
    kind: 'ContributorInsights',
  }

  /**
   * Renders a Kubernetes manifest for "ContributorInsights".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ContributorInsightsProps): any {
    return {
      ...ContributorInsights.GVK,
      ...toJson_ContributorInsightsProps(props),
    };
  }

  /**
   * Defines a "ContributorInsights" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ContributorInsightsProps) {
    super(scope, id, {
      ...ContributorInsights.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ContributorInsights.GVK,
      ...toJson_ContributorInsightsProps(resolved),
    };
  }
}

/**
 * ContributorInsights is the Schema for the ContributorInsightss API. Provides a DynamoDB contributor insights resource
 *
 * @schema ContributorInsights
 */
export interface ContributorInsightsProps {
  /**
   * @schema ContributorInsights#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ContributorInsightsSpec defines the desired state of ContributorInsights
   *
   * @schema ContributorInsights#spec
   */
  readonly spec: ContributorInsightsSpec;

}

/**
 * Converts an object of type 'ContributorInsightsProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContributorInsightsProps(obj: ContributorInsightsProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ContributorInsightsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContributorInsightsSpec defines the desired state of ContributorInsights
 *
 * @schema ContributorInsightsSpec
 */
export interface ContributorInsightsSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ContributorInsightsSpec#deletionPolicy
   */
  readonly deletionPolicy?: ContributorInsightsSpecDeletionPolicy;

  /**
   * @schema ContributorInsightsSpec#forProvider
   */
  readonly forProvider: ContributorInsightsSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ContributorInsightsSpec#managementPolicy
   */
  readonly managementPolicy?: ContributorInsightsSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ContributorInsightsSpec#providerConfigRef
   */
  readonly providerConfigRef?: ContributorInsightsSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ContributorInsightsSpec#providerRef
   */
  readonly providerRef?: ContributorInsightsSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ContributorInsightsSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ContributorInsightsSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ContributorInsightsSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ContributorInsightsSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ContributorInsightsSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContributorInsightsSpec(obj: ContributorInsightsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ContributorInsightsSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ContributorInsightsSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ContributorInsightsSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ContributorInsightsSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ContributorInsightsSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ContributorInsightsSpecDeletionPolicy
 */
export enum ContributorInsightsSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ContributorInsightsSpecForProvider
 */
export interface ContributorInsightsSpecForProvider {
  /**
   * The global secondary index name
   *
   * @schema ContributorInsightsSpecForProvider#indexName
   */
  readonly indexName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ContributorInsightsSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name of the table to enable contributor insights
   *
   * @schema ContributorInsightsSpecForProvider#tableName
   */
  readonly tableName?: string;

  /**
   * Reference to a Table to populate tableName.
   *
   * @schema ContributorInsightsSpecForProvider#tableNameRef
   */
  readonly tableNameRef?: ContributorInsightsSpecForProviderTableNameRef;

  /**
   * Selector for a Table to populate tableName.
   *
   * @schema ContributorInsightsSpecForProvider#tableNameSelector
   */
  readonly tableNameSelector?: ContributorInsightsSpecForProviderTableNameSelector;

}

/**
 * Converts an object of type 'ContributorInsightsSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContributorInsightsSpecForProvider(obj: ContributorInsightsSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'indexName': obj.indexName,
    'region': obj.region,
    'tableName': obj.tableName,
    'tableNameRef': toJson_ContributorInsightsSpecForProviderTableNameRef(obj.tableNameRef),
    'tableNameSelector': toJson_ContributorInsightsSpecForProviderTableNameSelector(obj.tableNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ContributorInsightsSpecManagementPolicy
 */
export enum ContributorInsightsSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ContributorInsightsSpecProviderConfigRef
 */
export interface ContributorInsightsSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContributorInsightsSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContributorInsightsSpecProviderConfigRef#policy
   */
  readonly policy?: ContributorInsightsSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ContributorInsightsSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContributorInsightsSpecProviderConfigRef(obj: ContributorInsightsSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContributorInsightsSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ContributorInsightsSpecProviderRef
 */
export interface ContributorInsightsSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContributorInsightsSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContributorInsightsSpecProviderRef#policy
   */
  readonly policy?: ContributorInsightsSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ContributorInsightsSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContributorInsightsSpecProviderRef(obj: ContributorInsightsSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContributorInsightsSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ContributorInsightsSpecPublishConnectionDetailsTo
 */
export interface ContributorInsightsSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ContributorInsightsSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ContributorInsightsSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ContributorInsightsSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ContributorInsightsSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ContributorInsightsSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ContributorInsightsSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContributorInsightsSpecPublishConnectionDetailsTo(obj: ContributorInsightsSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ContributorInsightsSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ContributorInsightsSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ContributorInsightsSpecWriteConnectionSecretToRef
 */
export interface ContributorInsightsSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ContributorInsightsSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ContributorInsightsSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContributorInsightsSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContributorInsightsSpecWriteConnectionSecretToRef(obj: ContributorInsightsSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Table to populate tableName.
 *
 * @schema ContributorInsightsSpecForProviderTableNameRef
 */
export interface ContributorInsightsSpecForProviderTableNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContributorInsightsSpecForProviderTableNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContributorInsightsSpecForProviderTableNameRef#policy
   */
  readonly policy?: ContributorInsightsSpecForProviderTableNameRefPolicy;

}

/**
 * Converts an object of type 'ContributorInsightsSpecForProviderTableNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContributorInsightsSpecForProviderTableNameRef(obj: ContributorInsightsSpecForProviderTableNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContributorInsightsSpecForProviderTableNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Table to populate tableName.
 *
 * @schema ContributorInsightsSpecForProviderTableNameSelector
 */
export interface ContributorInsightsSpecForProviderTableNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ContributorInsightsSpecForProviderTableNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ContributorInsightsSpecForProviderTableNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ContributorInsightsSpecForProviderTableNameSelector#policy
   */
  readonly policy?: ContributorInsightsSpecForProviderTableNameSelectorPolicy;

}

/**
 * Converts an object of type 'ContributorInsightsSpecForProviderTableNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContributorInsightsSpecForProviderTableNameSelector(obj: ContributorInsightsSpecForProviderTableNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ContributorInsightsSpecForProviderTableNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ContributorInsightsSpecProviderConfigRefPolicy
 */
export interface ContributorInsightsSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContributorInsightsSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ContributorInsightsSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContributorInsightsSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ContributorInsightsSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ContributorInsightsSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContributorInsightsSpecProviderConfigRefPolicy(obj: ContributorInsightsSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ContributorInsightsSpecProviderRefPolicy
 */
export interface ContributorInsightsSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContributorInsightsSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ContributorInsightsSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContributorInsightsSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ContributorInsightsSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ContributorInsightsSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContributorInsightsSpecProviderRefPolicy(obj: ContributorInsightsSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ContributorInsightsSpecPublishConnectionDetailsToConfigRef
 */
export interface ContributorInsightsSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContributorInsightsSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContributorInsightsSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ContributorInsightsSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ContributorInsightsSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContributorInsightsSpecPublishConnectionDetailsToConfigRef(obj: ContributorInsightsSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContributorInsightsSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ContributorInsightsSpecPublishConnectionDetailsToMetadata
 */
export interface ContributorInsightsSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ContributorInsightsSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ContributorInsightsSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ContributorInsightsSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ContributorInsightsSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContributorInsightsSpecPublishConnectionDetailsToMetadata(obj: ContributorInsightsSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ContributorInsightsSpecForProviderTableNameRefPolicy
 */
export interface ContributorInsightsSpecForProviderTableNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContributorInsightsSpecForProviderTableNameRefPolicy#resolution
   */
  readonly resolution?: ContributorInsightsSpecForProviderTableNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContributorInsightsSpecForProviderTableNameRefPolicy#resolve
   */
  readonly resolve?: ContributorInsightsSpecForProviderTableNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ContributorInsightsSpecForProviderTableNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContributorInsightsSpecForProviderTableNameRefPolicy(obj: ContributorInsightsSpecForProviderTableNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ContributorInsightsSpecForProviderTableNameSelectorPolicy
 */
export interface ContributorInsightsSpecForProviderTableNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContributorInsightsSpecForProviderTableNameSelectorPolicy#resolution
   */
  readonly resolution?: ContributorInsightsSpecForProviderTableNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContributorInsightsSpecForProviderTableNameSelectorPolicy#resolve
   */
  readonly resolve?: ContributorInsightsSpecForProviderTableNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ContributorInsightsSpecForProviderTableNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContributorInsightsSpecForProviderTableNameSelectorPolicy(obj: ContributorInsightsSpecForProviderTableNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContributorInsightsSpecProviderConfigRefPolicyResolution
 */
export enum ContributorInsightsSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContributorInsightsSpecProviderConfigRefPolicyResolve
 */
export enum ContributorInsightsSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContributorInsightsSpecProviderRefPolicyResolution
 */
export enum ContributorInsightsSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContributorInsightsSpecProviderRefPolicyResolve
 */
export enum ContributorInsightsSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ContributorInsightsSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ContributorInsightsSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContributorInsightsSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ContributorInsightsSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContributorInsightsSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ContributorInsightsSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ContributorInsightsSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContributorInsightsSpecPublishConnectionDetailsToConfigRefPolicy(obj: ContributorInsightsSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContributorInsightsSpecForProviderTableNameRefPolicyResolution
 */
export enum ContributorInsightsSpecForProviderTableNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContributorInsightsSpecForProviderTableNameRefPolicyResolve
 */
export enum ContributorInsightsSpecForProviderTableNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContributorInsightsSpecForProviderTableNameSelectorPolicyResolution
 */
export enum ContributorInsightsSpecForProviderTableNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContributorInsightsSpecForProviderTableNameSelectorPolicyResolve
 */
export enum ContributorInsightsSpecForProviderTableNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContributorInsightsSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ContributorInsightsSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContributorInsightsSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ContributorInsightsSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GlobalTable is the Schema for the GlobalTables API. Manages DynamoDB Global Tables V1 (version 2017.11.29)
 *
 * @schema GlobalTable
 */
export class GlobalTable extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GlobalTable"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dynamodb.aws.upbound.io/v1beta1',
    kind: 'GlobalTable',
  }

  /**
   * Renders a Kubernetes manifest for "GlobalTable".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GlobalTableProps): any {
    return {
      ...GlobalTable.GVK,
      ...toJson_GlobalTableProps(props),
    };
  }

  /**
   * Defines a "GlobalTable" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GlobalTableProps) {
    super(scope, id, {
      ...GlobalTable.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GlobalTable.GVK,
      ...toJson_GlobalTableProps(resolved),
    };
  }
}

/**
 * GlobalTable is the Schema for the GlobalTables API. Manages DynamoDB Global Tables V1 (version 2017.11.29)
 *
 * @schema GlobalTable
 */
export interface GlobalTableProps {
  /**
   * @schema GlobalTable#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GlobalTableSpec defines the desired state of GlobalTable
   *
   * @schema GlobalTable#spec
   */
  readonly spec: GlobalTableSpec;

}

/**
 * Converts an object of type 'GlobalTableProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableProps(obj: GlobalTableProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GlobalTableSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalTableSpec defines the desired state of GlobalTable
 *
 * @schema GlobalTableSpec
 */
export interface GlobalTableSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GlobalTableSpec#deletionPolicy
   */
  readonly deletionPolicy?: GlobalTableSpecDeletionPolicy;

  /**
   * @schema GlobalTableSpec#forProvider
   */
  readonly forProvider: GlobalTableSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GlobalTableSpec#managementPolicy
   */
  readonly managementPolicy?: GlobalTableSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GlobalTableSpec#providerConfigRef
   */
  readonly providerConfigRef?: GlobalTableSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema GlobalTableSpec#providerRef
   */
  readonly providerRef?: GlobalTableSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GlobalTableSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GlobalTableSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GlobalTableSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GlobalTableSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GlobalTableSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpec(obj: GlobalTableSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GlobalTableSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_GlobalTableSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_GlobalTableSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_GlobalTableSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GlobalTableSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GlobalTableSpecDeletionPolicy
 */
export enum GlobalTableSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GlobalTableSpecForProvider
 */
export interface GlobalTableSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GlobalTableSpecForProvider#region
   */
  readonly region: string;

  /**
   * Underlying DynamoDB Table. At least 1 replica must be defined. See below.
   *
   * @schema GlobalTableSpecForProvider#replica
   */
  readonly replica?: GlobalTableSpecForProviderReplica[];

}

/**
 * Converts an object of type 'GlobalTableSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecForProvider(obj: GlobalTableSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'replica': obj.replica?.map(y => toJson_GlobalTableSpecForProviderReplica(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GlobalTableSpecManagementPolicy
 */
export enum GlobalTableSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GlobalTableSpecProviderConfigRef
 */
export interface GlobalTableSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalTableSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalTableSpecProviderConfigRef#policy
   */
  readonly policy?: GlobalTableSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GlobalTableSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecProviderConfigRef(obj: GlobalTableSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalTableSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema GlobalTableSpecProviderRef
 */
export interface GlobalTableSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalTableSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalTableSpecProviderRef#policy
   */
  readonly policy?: GlobalTableSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'GlobalTableSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecProviderRef(obj: GlobalTableSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalTableSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GlobalTableSpecPublishConnectionDetailsTo
 */
export interface GlobalTableSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GlobalTableSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GlobalTableSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GlobalTableSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecPublishConnectionDetailsTo(obj: GlobalTableSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GlobalTableSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GlobalTableSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GlobalTableSpecWriteConnectionSecretToRef
 */
export interface GlobalTableSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GlobalTableSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GlobalTableSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GlobalTableSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecWriteConnectionSecretToRef(obj: GlobalTableSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GlobalTableSpecForProviderReplica
 */
export interface GlobalTableSpecForProviderReplica {
  /**
   * AWS region name of replica DynamoDB TableE.g., us-east-1
   *
   * @schema GlobalTableSpecForProviderReplica#regionName
   */
  readonly regionName: string;

}

/**
 * Converts an object of type 'GlobalTableSpecForProviderReplica' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecForProviderReplica(obj: GlobalTableSpecForProviderReplica | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regionName': obj.regionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GlobalTableSpecProviderConfigRefPolicy
 */
export interface GlobalTableSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalTableSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GlobalTableSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalTableSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GlobalTableSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalTableSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecProviderConfigRefPolicy(obj: GlobalTableSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GlobalTableSpecProviderRefPolicy
 */
export interface GlobalTableSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalTableSpecProviderRefPolicy#resolution
   */
  readonly resolution?: GlobalTableSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalTableSpecProviderRefPolicy#resolve
   */
  readonly resolve?: GlobalTableSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalTableSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecProviderRefPolicy(obj: GlobalTableSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GlobalTableSpecPublishConnectionDetailsToConfigRef
 */
export interface GlobalTableSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GlobalTableSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecPublishConnectionDetailsToConfigRef(obj: GlobalTableSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GlobalTableSpecPublishConnectionDetailsToMetadata
 */
export interface GlobalTableSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GlobalTableSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecPublishConnectionDetailsToMetadata(obj: GlobalTableSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalTableSpecProviderConfigRefPolicyResolution
 */
export enum GlobalTableSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalTableSpecProviderConfigRefPolicyResolve
 */
export enum GlobalTableSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalTableSpecProviderRefPolicyResolution
 */
export enum GlobalTableSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalTableSpecProviderRefPolicyResolve
 */
export enum GlobalTableSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GlobalTableSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GlobalTableSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy(obj: GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalTableSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GlobalTableSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalTableSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GlobalTableSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * KinesisStreamingDestination is the Schema for the KinesisStreamingDestinations API. Enables a Kinesis streaming destination for a DynamoDB table
 *
 * @schema KinesisStreamingDestination
 */
export class KinesisStreamingDestination extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KinesisStreamingDestination"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dynamodb.aws.upbound.io/v1beta1',
    kind: 'KinesisStreamingDestination',
  }

  /**
   * Renders a Kubernetes manifest for "KinesisStreamingDestination".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KinesisStreamingDestinationProps): any {
    return {
      ...KinesisStreamingDestination.GVK,
      ...toJson_KinesisStreamingDestinationProps(props),
    };
  }

  /**
   * Defines a "KinesisStreamingDestination" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KinesisStreamingDestinationProps) {
    super(scope, id, {
      ...KinesisStreamingDestination.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KinesisStreamingDestination.GVK,
      ...toJson_KinesisStreamingDestinationProps(resolved),
    };
  }
}

/**
 * KinesisStreamingDestination is the Schema for the KinesisStreamingDestinations API. Enables a Kinesis streaming destination for a DynamoDB table
 *
 * @schema KinesisStreamingDestination
 */
export interface KinesisStreamingDestinationProps {
  /**
   * @schema KinesisStreamingDestination#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * KinesisStreamingDestinationSpec defines the desired state of KinesisStreamingDestination
   *
   * @schema KinesisStreamingDestination#spec
   */
  readonly spec: KinesisStreamingDestinationSpec;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationProps(obj: KinesisStreamingDestinationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KinesisStreamingDestinationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KinesisStreamingDestinationSpec defines the desired state of KinesisStreamingDestination
 *
 * @schema KinesisStreamingDestinationSpec
 */
export interface KinesisStreamingDestinationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema KinesisStreamingDestinationSpec#deletionPolicy
   */
  readonly deletionPolicy?: KinesisStreamingDestinationSpecDeletionPolicy;

  /**
   * @schema KinesisStreamingDestinationSpec#forProvider
   */
  readonly forProvider: KinesisStreamingDestinationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema KinesisStreamingDestinationSpec#managementPolicy
   */
  readonly managementPolicy?: KinesisStreamingDestinationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema KinesisStreamingDestinationSpec#providerConfigRef
   */
  readonly providerConfigRef?: KinesisStreamingDestinationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema KinesisStreamingDestinationSpec#providerRef
   */
  readonly providerRef?: KinesisStreamingDestinationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema KinesisStreamingDestinationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: KinesisStreamingDestinationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema KinesisStreamingDestinationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: KinesisStreamingDestinationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpec(obj: KinesisStreamingDestinationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_KinesisStreamingDestinationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_KinesisStreamingDestinationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_KinesisStreamingDestinationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_KinesisStreamingDestinationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_KinesisStreamingDestinationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema KinesisStreamingDestinationSpecDeletionPolicy
 */
export enum KinesisStreamingDestinationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema KinesisStreamingDestinationSpecForProvider
 */
export interface KinesisStreamingDestinationSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema KinesisStreamingDestinationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ARN for a Kinesis data stream. This must exist in the same account and region as the DynamoDB table.
   *
   * @schema KinesisStreamingDestinationSpecForProvider#streamArn
   */
  readonly streamArn?: string;

  /**
   * Reference to a Stream in kinesis to populate streamArn.
   *
   * @schema KinesisStreamingDestinationSpecForProvider#streamArnRef
   */
  readonly streamArnRef?: KinesisStreamingDestinationSpecForProviderStreamArnRef;

  /**
   * Selector for a Stream in kinesis to populate streamArn.
   *
   * @schema KinesisStreamingDestinationSpecForProvider#streamArnSelector
   */
  readonly streamArnSelector?: KinesisStreamingDestinationSpecForProviderStreamArnSelector;

  /**
   * The name of the DynamoDB table. There can only be one Kinesis streaming destination for a given DynamoDB table.
   *
   * @schema KinesisStreamingDestinationSpecForProvider#tableName
   */
  readonly tableName?: string;

  /**
   * Reference to a Table to populate tableName.
   *
   * @schema KinesisStreamingDestinationSpecForProvider#tableNameRef
   */
  readonly tableNameRef?: KinesisStreamingDestinationSpecForProviderTableNameRef;

  /**
   * Selector for a Table to populate tableName.
   *
   * @schema KinesisStreamingDestinationSpecForProvider#tableNameSelector
   */
  readonly tableNameSelector?: KinesisStreamingDestinationSpecForProviderTableNameSelector;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecForProvider(obj: KinesisStreamingDestinationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'streamArn': obj.streamArn,
    'streamArnRef': toJson_KinesisStreamingDestinationSpecForProviderStreamArnRef(obj.streamArnRef),
    'streamArnSelector': toJson_KinesisStreamingDestinationSpecForProviderStreamArnSelector(obj.streamArnSelector),
    'tableName': obj.tableName,
    'tableNameRef': toJson_KinesisStreamingDestinationSpecForProviderTableNameRef(obj.tableNameRef),
    'tableNameSelector': toJson_KinesisStreamingDestinationSpecForProviderTableNameSelector(obj.tableNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema KinesisStreamingDestinationSpecManagementPolicy
 */
export enum KinesisStreamingDestinationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema KinesisStreamingDestinationSpecProviderConfigRef
 */
export interface KinesisStreamingDestinationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema KinesisStreamingDestinationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KinesisStreamingDestinationSpecProviderConfigRef#policy
   */
  readonly policy?: KinesisStreamingDestinationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecProviderConfigRef(obj: KinesisStreamingDestinationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KinesisStreamingDestinationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema KinesisStreamingDestinationSpecProviderRef
 */
export interface KinesisStreamingDestinationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema KinesisStreamingDestinationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KinesisStreamingDestinationSpecProviderRef#policy
   */
  readonly policy?: KinesisStreamingDestinationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecProviderRef(obj: KinesisStreamingDestinationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KinesisStreamingDestinationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema KinesisStreamingDestinationSpecPublishConnectionDetailsTo
 */
export interface KinesisStreamingDestinationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema KinesisStreamingDestinationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema KinesisStreamingDestinationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: KinesisStreamingDestinationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema KinesisStreamingDestinationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecPublishConnectionDetailsTo(obj: KinesisStreamingDestinationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_KinesisStreamingDestinationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema KinesisStreamingDestinationSpecWriteConnectionSecretToRef
 */
export interface KinesisStreamingDestinationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema KinesisStreamingDestinationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema KinesisStreamingDestinationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecWriteConnectionSecretToRef(obj: KinesisStreamingDestinationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stream in kinesis to populate streamArn.
 *
 * @schema KinesisStreamingDestinationSpecForProviderStreamArnRef
 */
export interface KinesisStreamingDestinationSpecForProviderStreamArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema KinesisStreamingDestinationSpecForProviderStreamArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KinesisStreamingDestinationSpecForProviderStreamArnRef#policy
   */
  readonly policy?: KinesisStreamingDestinationSpecForProviderStreamArnRefPolicy;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecForProviderStreamArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecForProviderStreamArnRef(obj: KinesisStreamingDestinationSpecForProviderStreamArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KinesisStreamingDestinationSpecForProviderStreamArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stream in kinesis to populate streamArn.
 *
 * @schema KinesisStreamingDestinationSpecForProviderStreamArnSelector
 */
export interface KinesisStreamingDestinationSpecForProviderStreamArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema KinesisStreamingDestinationSpecForProviderStreamArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema KinesisStreamingDestinationSpecForProviderStreamArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema KinesisStreamingDestinationSpecForProviderStreamArnSelector#policy
   */
  readonly policy?: KinesisStreamingDestinationSpecForProviderStreamArnSelectorPolicy;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecForProviderStreamArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecForProviderStreamArnSelector(obj: KinesisStreamingDestinationSpecForProviderStreamArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_KinesisStreamingDestinationSpecForProviderStreamArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Table to populate tableName.
 *
 * @schema KinesisStreamingDestinationSpecForProviderTableNameRef
 */
export interface KinesisStreamingDestinationSpecForProviderTableNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema KinesisStreamingDestinationSpecForProviderTableNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KinesisStreamingDestinationSpecForProviderTableNameRef#policy
   */
  readonly policy?: KinesisStreamingDestinationSpecForProviderTableNameRefPolicy;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecForProviderTableNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecForProviderTableNameRef(obj: KinesisStreamingDestinationSpecForProviderTableNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KinesisStreamingDestinationSpecForProviderTableNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Table to populate tableName.
 *
 * @schema KinesisStreamingDestinationSpecForProviderTableNameSelector
 */
export interface KinesisStreamingDestinationSpecForProviderTableNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema KinesisStreamingDestinationSpecForProviderTableNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema KinesisStreamingDestinationSpecForProviderTableNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema KinesisStreamingDestinationSpecForProviderTableNameSelector#policy
   */
  readonly policy?: KinesisStreamingDestinationSpecForProviderTableNameSelectorPolicy;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecForProviderTableNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecForProviderTableNameSelector(obj: KinesisStreamingDestinationSpecForProviderTableNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_KinesisStreamingDestinationSpecForProviderTableNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema KinesisStreamingDestinationSpecProviderConfigRefPolicy
 */
export interface KinesisStreamingDestinationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KinesisStreamingDestinationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: KinesisStreamingDestinationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KinesisStreamingDestinationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: KinesisStreamingDestinationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecProviderConfigRefPolicy(obj: KinesisStreamingDestinationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema KinesisStreamingDestinationSpecProviderRefPolicy
 */
export interface KinesisStreamingDestinationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KinesisStreamingDestinationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: KinesisStreamingDestinationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KinesisStreamingDestinationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: KinesisStreamingDestinationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecProviderRefPolicy(obj: KinesisStreamingDestinationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRef
 */
export interface KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRef(obj: KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema KinesisStreamingDestinationSpecPublishConnectionDetailsToMetadata
 */
export interface KinesisStreamingDestinationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema KinesisStreamingDestinationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema KinesisStreamingDestinationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema KinesisStreamingDestinationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecPublishConnectionDetailsToMetadata(obj: KinesisStreamingDestinationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema KinesisStreamingDestinationSpecForProviderStreamArnRefPolicy
 */
export interface KinesisStreamingDestinationSpecForProviderStreamArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KinesisStreamingDestinationSpecForProviderStreamArnRefPolicy#resolution
   */
  readonly resolution?: KinesisStreamingDestinationSpecForProviderStreamArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KinesisStreamingDestinationSpecForProviderStreamArnRefPolicy#resolve
   */
  readonly resolve?: KinesisStreamingDestinationSpecForProviderStreamArnRefPolicyResolve;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecForProviderStreamArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecForProviderStreamArnRefPolicy(obj: KinesisStreamingDestinationSpecForProviderStreamArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema KinesisStreamingDestinationSpecForProviderStreamArnSelectorPolicy
 */
export interface KinesisStreamingDestinationSpecForProviderStreamArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KinesisStreamingDestinationSpecForProviderStreamArnSelectorPolicy#resolution
   */
  readonly resolution?: KinesisStreamingDestinationSpecForProviderStreamArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KinesisStreamingDestinationSpecForProviderStreamArnSelectorPolicy#resolve
   */
  readonly resolve?: KinesisStreamingDestinationSpecForProviderStreamArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecForProviderStreamArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecForProviderStreamArnSelectorPolicy(obj: KinesisStreamingDestinationSpecForProviderStreamArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema KinesisStreamingDestinationSpecForProviderTableNameRefPolicy
 */
export interface KinesisStreamingDestinationSpecForProviderTableNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KinesisStreamingDestinationSpecForProviderTableNameRefPolicy#resolution
   */
  readonly resolution?: KinesisStreamingDestinationSpecForProviderTableNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KinesisStreamingDestinationSpecForProviderTableNameRefPolicy#resolve
   */
  readonly resolve?: KinesisStreamingDestinationSpecForProviderTableNameRefPolicyResolve;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecForProviderTableNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecForProviderTableNameRefPolicy(obj: KinesisStreamingDestinationSpecForProviderTableNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema KinesisStreamingDestinationSpecForProviderTableNameSelectorPolicy
 */
export interface KinesisStreamingDestinationSpecForProviderTableNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KinesisStreamingDestinationSpecForProviderTableNameSelectorPolicy#resolution
   */
  readonly resolution?: KinesisStreamingDestinationSpecForProviderTableNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KinesisStreamingDestinationSpecForProviderTableNameSelectorPolicy#resolve
   */
  readonly resolve?: KinesisStreamingDestinationSpecForProviderTableNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecForProviderTableNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecForProviderTableNameSelectorPolicy(obj: KinesisStreamingDestinationSpecForProviderTableNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KinesisStreamingDestinationSpecProviderConfigRefPolicyResolution
 */
export enum KinesisStreamingDestinationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KinesisStreamingDestinationSpecProviderConfigRefPolicyResolve
 */
export enum KinesisStreamingDestinationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KinesisStreamingDestinationSpecProviderRefPolicyResolution
 */
export enum KinesisStreamingDestinationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KinesisStreamingDestinationSpecProviderRefPolicyResolve
 */
export enum KinesisStreamingDestinationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRefPolicy(obj: KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KinesisStreamingDestinationSpecForProviderStreamArnRefPolicyResolution
 */
export enum KinesisStreamingDestinationSpecForProviderStreamArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KinesisStreamingDestinationSpecForProviderStreamArnRefPolicyResolve
 */
export enum KinesisStreamingDestinationSpecForProviderStreamArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KinesisStreamingDestinationSpecForProviderStreamArnSelectorPolicyResolution
 */
export enum KinesisStreamingDestinationSpecForProviderStreamArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KinesisStreamingDestinationSpecForProviderStreamArnSelectorPolicyResolve
 */
export enum KinesisStreamingDestinationSpecForProviderStreamArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KinesisStreamingDestinationSpecForProviderTableNameRefPolicyResolution
 */
export enum KinesisStreamingDestinationSpecForProviderTableNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KinesisStreamingDestinationSpecForProviderTableNameRefPolicyResolve
 */
export enum KinesisStreamingDestinationSpecForProviderTableNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KinesisStreamingDestinationSpecForProviderTableNameSelectorPolicyResolution
 */
export enum KinesisStreamingDestinationSpecForProviderTableNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KinesisStreamingDestinationSpecForProviderTableNameSelectorPolicyResolve
 */
export enum KinesisStreamingDestinationSpecForProviderTableNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum KinesisStreamingDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Table is the Schema for the Tables API. Provides a DynamoDB table resource
 *
 * @schema Table
 */
export class Table extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Table"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dynamodb.aws.upbound.io/v1beta1',
    kind: 'Table',
  }

  /**
   * Renders a Kubernetes manifest for "Table".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TableProps): any {
    return {
      ...Table.GVK,
      ...toJson_TableProps(props),
    };
  }

  /**
   * Defines a "Table" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TableProps) {
    super(scope, id, {
      ...Table.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Table.GVK,
      ...toJson_TableProps(resolved),
    };
  }
}

/**
 * Table is the Schema for the Tables API. Provides a DynamoDB table resource
 *
 * @schema Table
 */
export interface TableProps {
  /**
   * @schema Table#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TableSpec defines the desired state of Table
   *
   * @schema Table#spec
   */
  readonly spec: TableSpec;

}

/**
 * Converts an object of type 'TableProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableProps(obj: TableProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TableSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TableSpec defines the desired state of Table
 *
 * @schema TableSpec
 */
export interface TableSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TableSpec#deletionPolicy
   */
  readonly deletionPolicy?: TableSpecDeletionPolicy;

  /**
   * @schema TableSpec#forProvider
   */
  readonly forProvider: TableSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TableSpec#managementPolicy
   */
  readonly managementPolicy?: TableSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TableSpec#providerConfigRef
   */
  readonly providerConfigRef?: TableSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TableSpec#providerRef
   */
  readonly providerRef?: TableSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TableSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TableSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TableSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TableSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TableSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpec(obj: TableSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TableSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_TableSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TableSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TableSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TableSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TableSpecDeletionPolicy
 */
export enum TableSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TableSpecForProvider
 */
export interface TableSpecForProvider {
  /**
   * Set of nested attribute definitions. Only required for hash_key and range_key attributes. See below.
   *
   * @schema TableSpecForProvider#attribute
   */
  readonly attribute?: TableSpecForProviderAttribute[];

  /**
   * Controls how you are charged for read and write throughput and how you manage capacity. The valid values are PROVISIONED and PAY_PER_REQUEST. Defaults to PROVISIONED.
   *
   * @default PROVISIONED.
   * @schema TableSpecForProvider#billingMode
   */
  readonly billingMode?: string;

  /**
   * Enables deletion protection for table. Defaults to false.
   *
   * @default false.
   * @schema TableSpecForProvider#deletionProtectionEnabled
   */
  readonly deletionProtectionEnabled?: boolean;

  /**
   * Describe a GSI for the table; subject to the normal limits on the number of GSIs, projected attributes, etc. See below.
   *
   * @schema TableSpecForProvider#globalSecondaryIndex
   */
  readonly globalSecondaryIndex?: TableSpecForProviderGlobalSecondaryIndex[];

  /**
   * Attribute to use as the hash (partition) key. Must also be defined as an attribute. See below.
   *
   * @schema TableSpecForProvider#hashKey
   */
  readonly hashKey?: string;

  /**
   * Describe an LSI on the table; these can only be allocated at creation so you cannot change this definition after you have created the resource. See below.
   *
   * @schema TableSpecForProvider#localSecondaryIndex
   */
  readonly localSecondaryIndex?: TableSpecForProviderLocalSecondaryIndex[];

  /**
   * Enable point-in-time recovery options. See below.
   *
   * @schema TableSpecForProvider#pointInTimeRecovery
   */
  readonly pointInTimeRecovery?: TableSpecForProviderPointInTimeRecovery[];

  /**
   * Attribute to use as the range (sort) key. Must also be defined as an attribute, see below.
   *
   * @schema TableSpecForProvider#rangeKey
   */
  readonly rangeKey?: string;

  /**
   * Number of read units for this table. If the billing_mode is PROVISIONED, this field is required.
   *
   * @schema TableSpecForProvider#readCapacity
   */
  readonly readCapacity?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TableSpecForProvider#region
   */
  readonly region: string;

  /**
   * Configuration block(s) with DynamoDB Global Tables V2 (version 2019.11.21) replication configurations. See below.
   *
   * @schema TableSpecForProvider#replica
   */
  readonly replica?: TableSpecForProviderReplica[];

  /**
   * Time of the point-in-time recovery point to restore.
   *
   * @schema TableSpecForProvider#restoreDateTime
   */
  readonly restoreDateTime?: string;

  /**
   * Name of the table to restore. Must match the name of an existing table.
   *
   * @schema TableSpecForProvider#restoreSourceName
   */
  readonly restoreSourceName?: string;

  /**
   * If set, restores table to the most recent point-in-time recovery point.
   *
   * @schema TableSpecForProvider#restoreToLatestTime
   */
  readonly restoreToLatestTime?: boolean;

  /**
   * Encryption at rest options. AWS DynamoDB tables are automatically encrypted at rest with an AWS-owned Customer Master Key if this argument isn't specified. See below.
   *
   * @schema TableSpecForProvider#serverSideEncryption
   */
  readonly serverSideEncryption?: TableSpecForProviderServerSideEncryption[];

  /**
   * Whether Streams are enabled.
   *
   * @schema TableSpecForProvider#streamEnabled
   */
  readonly streamEnabled?: boolean;

  /**
   * When an item in the table is modified, StreamViewType determines what information is written to the table's stream. Valid values are KEYS_ONLY, NEW_IMAGE, OLD_IMAGE, NEW_AND_OLD_IMAGES.
   *
   * @schema TableSpecForProvider#streamViewType
   */
  readonly streamViewType?: string;

  /**
   * Storage class of the table. Valid values are STANDARD and STANDARD_INFREQUENT_ACCESS. Default value is STANDARD.
   *
   * @schema TableSpecForProvider#tableClass
   */
  readonly tableClass?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema TableSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Configuration block for TTL. See below.
   *
   * @schema TableSpecForProvider#ttl
   */
  readonly ttl?: TableSpecForProviderTtl[];

  /**
   * Number of write units for this table. If the billing_mode is PROVISIONED, this field is required.
   *
   * @schema TableSpecForProvider#writeCapacity
   */
  readonly writeCapacity?: number;

}

/**
 * Converts an object of type 'TableSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProvider(obj: TableSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attribute': obj.attribute?.map(y => toJson_TableSpecForProviderAttribute(y)),
    'billingMode': obj.billingMode,
    'deletionProtectionEnabled': obj.deletionProtectionEnabled,
    'globalSecondaryIndex': obj.globalSecondaryIndex?.map(y => toJson_TableSpecForProviderGlobalSecondaryIndex(y)),
    'hashKey': obj.hashKey,
    'localSecondaryIndex': obj.localSecondaryIndex?.map(y => toJson_TableSpecForProviderLocalSecondaryIndex(y)),
    'pointInTimeRecovery': obj.pointInTimeRecovery?.map(y => toJson_TableSpecForProviderPointInTimeRecovery(y)),
    'rangeKey': obj.rangeKey,
    'readCapacity': obj.readCapacity,
    'region': obj.region,
    'replica': obj.replica?.map(y => toJson_TableSpecForProviderReplica(y)),
    'restoreDateTime': obj.restoreDateTime,
    'restoreSourceName': obj.restoreSourceName,
    'restoreToLatestTime': obj.restoreToLatestTime,
    'serverSideEncryption': obj.serverSideEncryption?.map(y => toJson_TableSpecForProviderServerSideEncryption(y)),
    'streamEnabled': obj.streamEnabled,
    'streamViewType': obj.streamViewType,
    'tableClass': obj.tableClass,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'ttl': obj.ttl?.map(y => toJson_TableSpecForProviderTtl(y)),
    'writeCapacity': obj.writeCapacity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TableSpecManagementPolicy
 */
export enum TableSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TableSpecProviderConfigRef
 */
export interface TableSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableSpecProviderConfigRef#policy
   */
  readonly policy?: TableSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TableSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecProviderConfigRef(obj: TableSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TableSpecProviderRef
 */
export interface TableSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableSpecProviderRef#policy
   */
  readonly policy?: TableSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TableSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecProviderRef(obj: TableSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TableSpecPublishConnectionDetailsTo
 */
export interface TableSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TableSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TableSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TableSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TableSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TableSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TableSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecPublishConnectionDetailsTo(obj: TableSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TableSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TableSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TableSpecWriteConnectionSecretToRef
 */
export interface TableSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TableSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TableSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TableSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecWriteConnectionSecretToRef(obj: TableSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderAttribute
 */
export interface TableSpecForProviderAttribute {
  /**
   * Name of the attribute
   *
   * @schema TableSpecForProviderAttribute#name
   */
  readonly name: string;

  /**
   * Attribute type. Valid values are S (string), N (number), B (binary).
   *
   * @schema TableSpecForProviderAttribute#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'TableSpecForProviderAttribute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderAttribute(obj: TableSpecForProviderAttribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderGlobalSecondaryIndex
 */
export interface TableSpecForProviderGlobalSecondaryIndex {
  /**
   * Name of the hash key in the index; must be defined as an attribute in the resource.
   *
   * @schema TableSpecForProviderGlobalSecondaryIndex#hashKey
   */
  readonly hashKey: string;

  /**
   * Name of the index.
   *
   * @schema TableSpecForProviderGlobalSecondaryIndex#name
   */
  readonly name: string;

  /**
   * Only required with INCLUDE as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
   *
   * @schema TableSpecForProviderGlobalSecondaryIndex#nonKeyAttributes
   */
  readonly nonKeyAttributes?: string[];

  /**
   * One of ALL, INCLUDE or KEYS_ONLY where ALL projects every attribute into the index, KEYS_ONLY projects  into the index only the table and index hash_key and sort_key attributes ,  INCLUDE projects into the index all of the attributes that are defined in non_key_attributes in addition to the attributes that thatKEYS_ONLY project.
   *
   * @schema TableSpecForProviderGlobalSecondaryIndex#projectionType
   */
  readonly projectionType: string;

  /**
   * Name of the range key; must be defined
   *
   * @schema TableSpecForProviderGlobalSecondaryIndex#rangeKey
   */
  readonly rangeKey?: string;

  /**
   * Number of read units for this index. Must be set if billing_mode is set to PROVISIONED.
   *
   * @schema TableSpecForProviderGlobalSecondaryIndex#readCapacity
   */
  readonly readCapacity?: number;

  /**
   * Number of write units for this index. Must be set if billing_mode is set to PROVISIONED.
   *
   * @schema TableSpecForProviderGlobalSecondaryIndex#writeCapacity
   */
  readonly writeCapacity?: number;

}

/**
 * Converts an object of type 'TableSpecForProviderGlobalSecondaryIndex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderGlobalSecondaryIndex(obj: TableSpecForProviderGlobalSecondaryIndex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hashKey': obj.hashKey,
    'name': obj.name,
    'nonKeyAttributes': obj.nonKeyAttributes?.map(y => y),
    'projectionType': obj.projectionType,
    'rangeKey': obj.rangeKey,
    'readCapacity': obj.readCapacity,
    'writeCapacity': obj.writeCapacity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderLocalSecondaryIndex
 */
export interface TableSpecForProviderLocalSecondaryIndex {
  /**
   * Name of the index
   *
   * @schema TableSpecForProviderLocalSecondaryIndex#name
   */
  readonly name: string;

  /**
   * Only required with INCLUDE as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
   *
   * @schema TableSpecForProviderLocalSecondaryIndex#nonKeyAttributes
   */
  readonly nonKeyAttributes?: string[];

  /**
   * One of ALL, INCLUDE or KEYS_ONLY where ALL projects every attribute into the index, KEYS_ONLY projects  into the index only the table and index hash_key and sort_key attributes ,  INCLUDE projects into the index all of the attributes that are defined in non_key_attributes in addition to the attributes that thatKEYS_ONLY project.
   *
   * @schema TableSpecForProviderLocalSecondaryIndex#projectionType
   */
  readonly projectionType: string;

  /**
   * Name of the range key.
   *
   * @schema TableSpecForProviderLocalSecondaryIndex#rangeKey
   */
  readonly rangeKey: string;

}

/**
 * Converts an object of type 'TableSpecForProviderLocalSecondaryIndex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderLocalSecondaryIndex(obj: TableSpecForProviderLocalSecondaryIndex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'nonKeyAttributes': obj.nonKeyAttributes?.map(y => y),
    'projectionType': obj.projectionType,
    'rangeKey': obj.rangeKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderPointInTimeRecovery
 */
export interface TableSpecForProviderPointInTimeRecovery {
  /**
   * Whether to enable point-in-time recovery. It can take 10 minutes to enable for new tables. If the point_in_time_recovery block is not provided, this defaults to false.
   *
   * @schema TableSpecForProviderPointInTimeRecovery#enabled
   */
  readonly enabled: boolean;

}

/**
 * Converts an object of type 'TableSpecForProviderPointInTimeRecovery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderPointInTimeRecovery(obj: TableSpecForProviderPointInTimeRecovery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderReplica
 */
export interface TableSpecForProviderReplica {
  /**
   * ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, alias/aws/dynamodb. Note: This attribute will not be populated with the ARN of default keys.
   *
   * @schema TableSpecForProviderReplica#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Whether to enable Point In Time Recovery for the replica. Default is false.
   *
   * @default false.
   * @schema TableSpecForProviderReplica#pointInTimeRecovery
   */
  readonly pointInTimeRecovery?: boolean;

  /**
   * Whether to propagate the global table's tags to a replica. Default is false. Changes to tags only move in one direction: from global (source) to replica. In other words, tag drift on a replica will not trigger an update. Tag or replica changes on the global table, whether from drift or configuration changes, are propagated to replicas. Changing from true to false on a subsequent apply means replica tags are left as they were, unmanaged, not deleted.
   *
   * @default false. Changes to tags only move in one direction: from global (source) to replica. In other words, tag drift on a replica will not trigger an update. Tag or replica changes on the global table, whether from drift or configuration changes, are propagated to replicas. Changing from true to false on a subsequent apply means replica tags are left as they were, unmanaged, not deleted.
   * @schema TableSpecForProviderReplica#propagateTags
   */
  readonly propagateTags?: boolean;

  /**
   * Region name of the replica.
   *
   * @schema TableSpecForProviderReplica#regionName
   */
  readonly regionName: string;

}

/**
 * Converts an object of type 'TableSpecForProviderReplica' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderReplica(obj: TableSpecForProviderReplica | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyArn': obj.kmsKeyArn,
    'pointInTimeRecovery': obj.pointInTimeRecovery,
    'propagateTags': obj.propagateTags,
    'regionName': obj.regionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderServerSideEncryption
 */
export interface TableSpecForProviderServerSideEncryption {
  /**
   * Whether or not to enable encryption at rest using an AWS managed KMS customer master key (CMK). If enabled is false then server-side encryption is set to AWS-owned key (shown as DEFAULT in the AWS console). Potentially confusingly, if enabled is true and no kms_key_arn is specified then server-side encryption is set to the default KMS-managed key (shown as KMS in the AWS console). The AWS KMS documentation explains the difference between AWS-owned and KMS-managed keys.
   *
   * @schema TableSpecForProviderServerSideEncryption#enabled
   */
  readonly enabled: boolean;

  /**
   * ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, alias/aws/dynamodb. Note: This attribute will not be populated with the ARN of default keys.
   *
   * @schema TableSpecForProviderServerSideEncryption#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

}

/**
 * Converts an object of type 'TableSpecForProviderServerSideEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderServerSideEncryption(obj: TableSpecForProviderServerSideEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'kmsKeyArn': obj.kmsKeyArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderTtl
 */
export interface TableSpecForProviderTtl {
  /**
   * Name of the table attribute to store the TTL timestamp in.
   *
   * @schema TableSpecForProviderTtl#attributeName
   */
  readonly attributeName: string;

  /**
   * Whether TTL is enabled.
   *
   * @schema TableSpecForProviderTtl#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'TableSpecForProviderTtl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderTtl(obj: TableSpecForProviderTtl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributeName': obj.attributeName,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableSpecProviderConfigRefPolicy
 */
export interface TableSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TableSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TableSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecProviderConfigRefPolicy(obj: TableSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableSpecProviderRefPolicy
 */
export interface TableSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TableSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TableSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TableSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecProviderRefPolicy(obj: TableSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TableSpecPublishConnectionDetailsToConfigRef
 */
export interface TableSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TableSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TableSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecPublishConnectionDetailsToConfigRef(obj: TableSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TableSpecPublishConnectionDetailsToMetadata
 */
export interface TableSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TableSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TableSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecPublishConnectionDetailsToMetadata(obj: TableSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableSpecProviderConfigRefPolicyResolution
 */
export enum TableSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableSpecProviderConfigRefPolicyResolve
 */
export enum TableSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableSpecProviderRefPolicyResolution
 */
export enum TableSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableSpecProviderRefPolicyResolve
 */
export enum TableSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TableSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TableSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TableSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TableSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecPublishConnectionDetailsToConfigRefPolicy(obj: TableSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TableSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TableSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TableItem is the Schema for the TableItems API. Provides a DynamoDB table item resource
 *
 * @schema TableItem
 */
export class TableItem extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TableItem"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dynamodb.aws.upbound.io/v1beta1',
    kind: 'TableItem',
  }

  /**
   * Renders a Kubernetes manifest for "TableItem".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TableItemProps): any {
    return {
      ...TableItem.GVK,
      ...toJson_TableItemProps(props),
    };
  }

  /**
   * Defines a "TableItem" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TableItemProps) {
    super(scope, id, {
      ...TableItem.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TableItem.GVK,
      ...toJson_TableItemProps(resolved),
    };
  }
}

/**
 * TableItem is the Schema for the TableItems API. Provides a DynamoDB table item resource
 *
 * @schema TableItem
 */
export interface TableItemProps {
  /**
   * @schema TableItem#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TableItemSpec defines the desired state of TableItem
   *
   * @schema TableItem#spec
   */
  readonly spec: TableItemSpec;

}

/**
 * Converts an object of type 'TableItemProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableItemProps(obj: TableItemProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TableItemSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TableItemSpec defines the desired state of TableItem
 *
 * @schema TableItemSpec
 */
export interface TableItemSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TableItemSpec#deletionPolicy
   */
  readonly deletionPolicy?: TableItemSpecDeletionPolicy;

  /**
   * @schema TableItemSpec#forProvider
   */
  readonly forProvider: TableItemSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TableItemSpec#managementPolicy
   */
  readonly managementPolicy?: TableItemSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TableItemSpec#providerConfigRef
   */
  readonly providerConfigRef?: TableItemSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TableItemSpec#providerRef
   */
  readonly providerRef?: TableItemSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TableItemSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TableItemSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TableItemSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TableItemSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TableItemSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableItemSpec(obj: TableItemSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TableItemSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_TableItemSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TableItemSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TableItemSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TableItemSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TableItemSpecDeletionPolicy
 */
export enum TableItemSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TableItemSpecForProvider
 */
export interface TableItemSpecForProvider {
  /**
   * Hash key to use for lookups and identification of the item
   *
   * @schema TableItemSpecForProvider#hashKey
   */
  readonly hashKey?: string;

  /**
   * JSON representation of a map of attribute name/value pairs, one for each attribute. Only the primary key attributes are required; you can optionally provide other attribute name-value pairs for the item.
   *
   * @schema TableItemSpecForProvider#item
   */
  readonly item?: string;

  /**
   * Range key to use for lookups and identification of the item. Required if there is range key defined in the table.
   *
   * @schema TableItemSpecForProvider#rangeKey
   */
  readonly rangeKey?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TableItemSpecForProvider#region
   */
  readonly region: string;

  /**
   * Name of the table to contain the item.
   *
   * @schema TableItemSpecForProvider#tableName
   */
  readonly tableName?: string;

  /**
   * Reference to a Table to populate tableName.
   *
   * @schema TableItemSpecForProvider#tableNameRef
   */
  readonly tableNameRef?: TableItemSpecForProviderTableNameRef;

  /**
   * Selector for a Table to populate tableName.
   *
   * @schema TableItemSpecForProvider#tableNameSelector
   */
  readonly tableNameSelector?: TableItemSpecForProviderTableNameSelector;

}

/**
 * Converts an object of type 'TableItemSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableItemSpecForProvider(obj: TableItemSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hashKey': obj.hashKey,
    'item': obj.item,
    'rangeKey': obj.rangeKey,
    'region': obj.region,
    'tableName': obj.tableName,
    'tableNameRef': toJson_TableItemSpecForProviderTableNameRef(obj.tableNameRef),
    'tableNameSelector': toJson_TableItemSpecForProviderTableNameSelector(obj.tableNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TableItemSpecManagementPolicy
 */
export enum TableItemSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TableItemSpecProviderConfigRef
 */
export interface TableItemSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableItemSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableItemSpecProviderConfigRef#policy
   */
  readonly policy?: TableItemSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TableItemSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableItemSpecProviderConfigRef(obj: TableItemSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableItemSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TableItemSpecProviderRef
 */
export interface TableItemSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableItemSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableItemSpecProviderRef#policy
   */
  readonly policy?: TableItemSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TableItemSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableItemSpecProviderRef(obj: TableItemSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableItemSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TableItemSpecPublishConnectionDetailsTo
 */
export interface TableItemSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TableItemSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TableItemSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TableItemSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TableItemSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TableItemSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TableItemSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableItemSpecPublishConnectionDetailsTo(obj: TableItemSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TableItemSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TableItemSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TableItemSpecWriteConnectionSecretToRef
 */
export interface TableItemSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TableItemSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TableItemSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TableItemSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableItemSpecWriteConnectionSecretToRef(obj: TableItemSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Table to populate tableName.
 *
 * @schema TableItemSpecForProviderTableNameRef
 */
export interface TableItemSpecForProviderTableNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableItemSpecForProviderTableNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableItemSpecForProviderTableNameRef#policy
   */
  readonly policy?: TableItemSpecForProviderTableNameRefPolicy;

}

/**
 * Converts an object of type 'TableItemSpecForProviderTableNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableItemSpecForProviderTableNameRef(obj: TableItemSpecForProviderTableNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableItemSpecForProviderTableNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Table to populate tableName.
 *
 * @schema TableItemSpecForProviderTableNameSelector
 */
export interface TableItemSpecForProviderTableNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TableItemSpecForProviderTableNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TableItemSpecForProviderTableNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TableItemSpecForProviderTableNameSelector#policy
   */
  readonly policy?: TableItemSpecForProviderTableNameSelectorPolicy;

}

/**
 * Converts an object of type 'TableItemSpecForProviderTableNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableItemSpecForProviderTableNameSelector(obj: TableItemSpecForProviderTableNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TableItemSpecForProviderTableNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableItemSpecProviderConfigRefPolicy
 */
export interface TableItemSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableItemSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TableItemSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableItemSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TableItemSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableItemSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableItemSpecProviderConfigRefPolicy(obj: TableItemSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableItemSpecProviderRefPolicy
 */
export interface TableItemSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableItemSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TableItemSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableItemSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TableItemSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TableItemSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableItemSpecProviderRefPolicy(obj: TableItemSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TableItemSpecPublishConnectionDetailsToConfigRef
 */
export interface TableItemSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableItemSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableItemSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TableItemSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TableItemSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableItemSpecPublishConnectionDetailsToConfigRef(obj: TableItemSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableItemSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TableItemSpecPublishConnectionDetailsToMetadata
 */
export interface TableItemSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableItemSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableItemSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TableItemSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TableItemSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableItemSpecPublishConnectionDetailsToMetadata(obj: TableItemSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableItemSpecForProviderTableNameRefPolicy
 */
export interface TableItemSpecForProviderTableNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableItemSpecForProviderTableNameRefPolicy#resolution
   */
  readonly resolution?: TableItemSpecForProviderTableNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableItemSpecForProviderTableNameRefPolicy#resolve
   */
  readonly resolve?: TableItemSpecForProviderTableNameRefPolicyResolve;

}

/**
 * Converts an object of type 'TableItemSpecForProviderTableNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableItemSpecForProviderTableNameRefPolicy(obj: TableItemSpecForProviderTableNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TableItemSpecForProviderTableNameSelectorPolicy
 */
export interface TableItemSpecForProviderTableNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableItemSpecForProviderTableNameSelectorPolicy#resolution
   */
  readonly resolution?: TableItemSpecForProviderTableNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableItemSpecForProviderTableNameSelectorPolicy#resolve
   */
  readonly resolve?: TableItemSpecForProviderTableNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TableItemSpecForProviderTableNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableItemSpecForProviderTableNameSelectorPolicy(obj: TableItemSpecForProviderTableNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableItemSpecProviderConfigRefPolicyResolution
 */
export enum TableItemSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableItemSpecProviderConfigRefPolicyResolve
 */
export enum TableItemSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableItemSpecProviderRefPolicyResolution
 */
export enum TableItemSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableItemSpecProviderRefPolicyResolve
 */
export enum TableItemSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TableItemSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TableItemSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableItemSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TableItemSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableItemSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TableItemSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableItemSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableItemSpecPublishConnectionDetailsToConfigRefPolicy(obj: TableItemSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableItemSpecForProviderTableNameRefPolicyResolution
 */
export enum TableItemSpecForProviderTableNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableItemSpecForProviderTableNameRefPolicyResolve
 */
export enum TableItemSpecForProviderTableNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableItemSpecForProviderTableNameSelectorPolicyResolution
 */
export enum TableItemSpecForProviderTableNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableItemSpecForProviderTableNameSelectorPolicyResolve
 */
export enum TableItemSpecForProviderTableNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableItemSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TableItemSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableItemSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TableItemSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TableReplica is the Schema for the TableReplicas API. Provides a DynamoDB table replica resource
 *
 * @schema TableReplica
 */
export class TableReplica extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TableReplica"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dynamodb.aws.upbound.io/v1beta1',
    kind: 'TableReplica',
  }

  /**
   * Renders a Kubernetes manifest for "TableReplica".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TableReplicaProps): any {
    return {
      ...TableReplica.GVK,
      ...toJson_TableReplicaProps(props),
    };
  }

  /**
   * Defines a "TableReplica" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TableReplicaProps) {
    super(scope, id, {
      ...TableReplica.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TableReplica.GVK,
      ...toJson_TableReplicaProps(resolved),
    };
  }
}

/**
 * TableReplica is the Schema for the TableReplicas API. Provides a DynamoDB table replica resource
 *
 * @schema TableReplica
 */
export interface TableReplicaProps {
  /**
   * @schema TableReplica#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TableReplicaSpec defines the desired state of TableReplica
   *
   * @schema TableReplica#spec
   */
  readonly spec: TableReplicaSpec;

}

/**
 * Converts an object of type 'TableReplicaProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaProps(obj: TableReplicaProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TableReplicaSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TableReplicaSpec defines the desired state of TableReplica
 *
 * @schema TableReplicaSpec
 */
export interface TableReplicaSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TableReplicaSpec#deletionPolicy
   */
  readonly deletionPolicy?: TableReplicaSpecDeletionPolicy;

  /**
   * @schema TableReplicaSpec#forProvider
   */
  readonly forProvider: TableReplicaSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TableReplicaSpec#managementPolicy
   */
  readonly managementPolicy?: TableReplicaSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TableReplicaSpec#providerConfigRef
   */
  readonly providerConfigRef?: TableReplicaSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TableReplicaSpec#providerRef
   */
  readonly providerRef?: TableReplicaSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TableReplicaSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TableReplicaSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TableReplicaSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TableReplicaSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TableReplicaSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpec(obj: TableReplicaSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TableReplicaSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_TableReplicaSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TableReplicaSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TableReplicaSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TableReplicaSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TableReplicaSpecDeletionPolicy
 */
export enum TableReplicaSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TableReplicaSpecForProvider
 */
export interface TableReplicaSpecForProvider {
  /**
   * ARN of the main or global table which this resource will replicate.
   *
   * @schema TableReplicaSpecForProvider#globalTableArn
   */
  readonly globalTableArn?: string;

  /**
   * Reference to a Table in dynamodb to populate globalTableArn.
   *
   * @schema TableReplicaSpecForProvider#globalTableArnRef
   */
  readonly globalTableArnRef?: TableReplicaSpecForProviderGlobalTableArnRef;

  /**
   * Selector for a Table in dynamodb to populate globalTableArn.
   *
   * @schema TableReplicaSpecForProvider#globalTableArnSelector
   */
  readonly globalTableArnSelector?: TableReplicaSpecForProviderGlobalTableArnSelector;

  /**
   * ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, alias/aws/dynamodb. Note: This attribute will not be populated with the ARN of default keys.
   *
   * @schema TableReplicaSpecForProvider#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyArn.
   *
   * @schema TableReplicaSpecForProvider#kmsKeyArnRef
   */
  readonly kmsKeyArnRef?: TableReplicaSpecForProviderKmsKeyArnRef;

  /**
   * Selector for a Key in kms to populate kmsKeyArn.
   *
   * @schema TableReplicaSpecForProvider#kmsKeyArnSelector
   */
  readonly kmsKeyArnSelector?: TableReplicaSpecForProviderKmsKeyArnSelector;

  /**
   * Whether to enable Point In Time Recovery for the replica. Default is false.
   *
   * @default false.
   * @schema TableReplicaSpecForProvider#pointInTimeRecovery
   */
  readonly pointInTimeRecovery?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TableReplicaSpecForProvider#region
   */
  readonly region: string;

  /**
   * Storage class of the table replica. Valid values are STANDARD and STANDARD_INFREQUENT_ACCESS. If not used, the table replica will use the same class as the global table.
   *
   * @schema TableReplicaSpecForProvider#tableClassOverride
   */
  readonly tableClassOverride?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema TableReplicaSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'TableReplicaSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecForProvider(obj: TableReplicaSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'globalTableArn': obj.globalTableArn,
    'globalTableArnRef': toJson_TableReplicaSpecForProviderGlobalTableArnRef(obj.globalTableArnRef),
    'globalTableArnSelector': toJson_TableReplicaSpecForProviderGlobalTableArnSelector(obj.globalTableArnSelector),
    'kmsKeyArn': obj.kmsKeyArn,
    'kmsKeyArnRef': toJson_TableReplicaSpecForProviderKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyArnSelector': toJson_TableReplicaSpecForProviderKmsKeyArnSelector(obj.kmsKeyArnSelector),
    'pointInTimeRecovery': obj.pointInTimeRecovery,
    'region': obj.region,
    'tableClassOverride': obj.tableClassOverride,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TableReplicaSpecManagementPolicy
 */
export enum TableReplicaSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TableReplicaSpecProviderConfigRef
 */
export interface TableReplicaSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableReplicaSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableReplicaSpecProviderConfigRef#policy
   */
  readonly policy?: TableReplicaSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TableReplicaSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecProviderConfigRef(obj: TableReplicaSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableReplicaSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TableReplicaSpecProviderRef
 */
export interface TableReplicaSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableReplicaSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableReplicaSpecProviderRef#policy
   */
  readonly policy?: TableReplicaSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TableReplicaSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecProviderRef(obj: TableReplicaSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableReplicaSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TableReplicaSpecPublishConnectionDetailsTo
 */
export interface TableReplicaSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TableReplicaSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TableReplicaSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TableReplicaSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TableReplicaSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TableReplicaSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TableReplicaSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecPublishConnectionDetailsTo(obj: TableReplicaSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TableReplicaSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TableReplicaSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TableReplicaSpecWriteConnectionSecretToRef
 */
export interface TableReplicaSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TableReplicaSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TableReplicaSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TableReplicaSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecWriteConnectionSecretToRef(obj: TableReplicaSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Table in dynamodb to populate globalTableArn.
 *
 * @schema TableReplicaSpecForProviderGlobalTableArnRef
 */
export interface TableReplicaSpecForProviderGlobalTableArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableReplicaSpecForProviderGlobalTableArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableReplicaSpecForProviderGlobalTableArnRef#policy
   */
  readonly policy?: TableReplicaSpecForProviderGlobalTableArnRefPolicy;

}

/**
 * Converts an object of type 'TableReplicaSpecForProviderGlobalTableArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecForProviderGlobalTableArnRef(obj: TableReplicaSpecForProviderGlobalTableArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableReplicaSpecForProviderGlobalTableArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Table in dynamodb to populate globalTableArn.
 *
 * @schema TableReplicaSpecForProviderGlobalTableArnSelector
 */
export interface TableReplicaSpecForProviderGlobalTableArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TableReplicaSpecForProviderGlobalTableArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TableReplicaSpecForProviderGlobalTableArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TableReplicaSpecForProviderGlobalTableArnSelector#policy
   */
  readonly policy?: TableReplicaSpecForProviderGlobalTableArnSelectorPolicy;

}

/**
 * Converts an object of type 'TableReplicaSpecForProviderGlobalTableArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecForProviderGlobalTableArnSelector(obj: TableReplicaSpecForProviderGlobalTableArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TableReplicaSpecForProviderGlobalTableArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyArn.
 *
 * @schema TableReplicaSpecForProviderKmsKeyArnRef
 */
export interface TableReplicaSpecForProviderKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableReplicaSpecForProviderKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableReplicaSpecForProviderKmsKeyArnRef#policy
   */
  readonly policy?: TableReplicaSpecForProviderKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'TableReplicaSpecForProviderKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecForProviderKmsKeyArnRef(obj: TableReplicaSpecForProviderKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableReplicaSpecForProviderKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyArn.
 *
 * @schema TableReplicaSpecForProviderKmsKeyArnSelector
 */
export interface TableReplicaSpecForProviderKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TableReplicaSpecForProviderKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TableReplicaSpecForProviderKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TableReplicaSpecForProviderKmsKeyArnSelector#policy
   */
  readonly policy?: TableReplicaSpecForProviderKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'TableReplicaSpecForProviderKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecForProviderKmsKeyArnSelector(obj: TableReplicaSpecForProviderKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TableReplicaSpecForProviderKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableReplicaSpecProviderConfigRefPolicy
 */
export interface TableReplicaSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableReplicaSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TableReplicaSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableReplicaSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TableReplicaSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableReplicaSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecProviderConfigRefPolicy(obj: TableReplicaSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableReplicaSpecProviderRefPolicy
 */
export interface TableReplicaSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableReplicaSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TableReplicaSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableReplicaSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TableReplicaSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TableReplicaSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecProviderRefPolicy(obj: TableReplicaSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TableReplicaSpecPublishConnectionDetailsToConfigRef
 */
export interface TableReplicaSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableReplicaSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableReplicaSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TableReplicaSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TableReplicaSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecPublishConnectionDetailsToConfigRef(obj: TableReplicaSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableReplicaSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TableReplicaSpecPublishConnectionDetailsToMetadata
 */
export interface TableReplicaSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableReplicaSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableReplicaSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TableReplicaSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TableReplicaSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecPublishConnectionDetailsToMetadata(obj: TableReplicaSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableReplicaSpecForProviderGlobalTableArnRefPolicy
 */
export interface TableReplicaSpecForProviderGlobalTableArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableReplicaSpecForProviderGlobalTableArnRefPolicy#resolution
   */
  readonly resolution?: TableReplicaSpecForProviderGlobalTableArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableReplicaSpecForProviderGlobalTableArnRefPolicy#resolve
   */
  readonly resolve?: TableReplicaSpecForProviderGlobalTableArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TableReplicaSpecForProviderGlobalTableArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecForProviderGlobalTableArnRefPolicy(obj: TableReplicaSpecForProviderGlobalTableArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TableReplicaSpecForProviderGlobalTableArnSelectorPolicy
 */
export interface TableReplicaSpecForProviderGlobalTableArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableReplicaSpecForProviderGlobalTableArnSelectorPolicy#resolution
   */
  readonly resolution?: TableReplicaSpecForProviderGlobalTableArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableReplicaSpecForProviderGlobalTableArnSelectorPolicy#resolve
   */
  readonly resolve?: TableReplicaSpecForProviderGlobalTableArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TableReplicaSpecForProviderGlobalTableArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecForProviderGlobalTableArnSelectorPolicy(obj: TableReplicaSpecForProviderGlobalTableArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableReplicaSpecForProviderKmsKeyArnRefPolicy
 */
export interface TableReplicaSpecForProviderKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableReplicaSpecForProviderKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: TableReplicaSpecForProviderKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableReplicaSpecForProviderKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: TableReplicaSpecForProviderKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TableReplicaSpecForProviderKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecForProviderKmsKeyArnRefPolicy(obj: TableReplicaSpecForProviderKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TableReplicaSpecForProviderKmsKeyArnSelectorPolicy
 */
export interface TableReplicaSpecForProviderKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableReplicaSpecForProviderKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: TableReplicaSpecForProviderKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableReplicaSpecForProviderKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: TableReplicaSpecForProviderKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TableReplicaSpecForProviderKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecForProviderKmsKeyArnSelectorPolicy(obj: TableReplicaSpecForProviderKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableReplicaSpecProviderConfigRefPolicyResolution
 */
export enum TableReplicaSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableReplicaSpecProviderConfigRefPolicyResolve
 */
export enum TableReplicaSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableReplicaSpecProviderRefPolicyResolution
 */
export enum TableReplicaSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableReplicaSpecProviderRefPolicyResolve
 */
export enum TableReplicaSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TableReplicaSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TableReplicaSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableReplicaSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TableReplicaSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableReplicaSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TableReplicaSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableReplicaSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableReplicaSpecPublishConnectionDetailsToConfigRefPolicy(obj: TableReplicaSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableReplicaSpecForProviderGlobalTableArnRefPolicyResolution
 */
export enum TableReplicaSpecForProviderGlobalTableArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableReplicaSpecForProviderGlobalTableArnRefPolicyResolve
 */
export enum TableReplicaSpecForProviderGlobalTableArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableReplicaSpecForProviderGlobalTableArnSelectorPolicyResolution
 */
export enum TableReplicaSpecForProviderGlobalTableArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableReplicaSpecForProviderGlobalTableArnSelectorPolicyResolve
 */
export enum TableReplicaSpecForProviderGlobalTableArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableReplicaSpecForProviderKmsKeyArnRefPolicyResolution
 */
export enum TableReplicaSpecForProviderKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableReplicaSpecForProviderKmsKeyArnRefPolicyResolve
 */
export enum TableReplicaSpecForProviderKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableReplicaSpecForProviderKmsKeyArnSelectorPolicyResolution
 */
export enum TableReplicaSpecForProviderKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableReplicaSpecForProviderKmsKeyArnSelectorPolicyResolve
 */
export enum TableReplicaSpecForProviderKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableReplicaSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TableReplicaSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableReplicaSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TableReplicaSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Tag is the Schema for the Tags API. Manages an individual DynamoDB resource tag
 *
 * @schema Tag
 */
export class Tag extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Tag"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dynamodb.aws.upbound.io/v1beta1',
    kind: 'Tag',
  }

  /**
   * Renders a Kubernetes manifest for "Tag".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TagProps): any {
    return {
      ...Tag.GVK,
      ...toJson_TagProps(props),
    };
  }

  /**
   * Defines a "Tag" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TagProps) {
    super(scope, id, {
      ...Tag.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Tag.GVK,
      ...toJson_TagProps(resolved),
    };
  }
}

/**
 * Tag is the Schema for the Tags API. Manages an individual DynamoDB resource tag
 *
 * @schema Tag
 */
export interface TagProps {
  /**
   * @schema Tag#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TagSpec defines the desired state of Tag
   *
   * @schema Tag#spec
   */
  readonly spec: TagSpec;

}

/**
 * Converts an object of type 'TagProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagProps(obj: TagProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TagSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TagSpec defines the desired state of Tag
 *
 * @schema TagSpec
 */
export interface TagSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TagSpec#deletionPolicy
   */
  readonly deletionPolicy?: TagSpecDeletionPolicy;

  /**
   * @schema TagSpec#forProvider
   */
  readonly forProvider: TagSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TagSpec#managementPolicy
   */
  readonly managementPolicy?: TagSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TagSpec#providerConfigRef
   */
  readonly providerConfigRef?: TagSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TagSpec#providerRef
   */
  readonly providerRef?: TagSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TagSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TagSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TagSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TagSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TagSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpec(obj: TagSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TagSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_TagSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TagSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TagSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TagSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TagSpecDeletionPolicy
 */
export enum TagSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TagSpecForProvider
 */
export interface TagSpecForProvider {
  /**
   * Tag name.
   *
   * @schema TagSpecForProvider#key
   */
  readonly key: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TagSpecForProvider#region
   */
  readonly region: string;

  /**
   * Amazon Resource Name (ARN) of the DynamoDB resource to tag.
   *
   * @schema TagSpecForProvider#resourceArn
   */
  readonly resourceArn: string;

  /**
   * Tag value.
   *
   * @schema TagSpecForProvider#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TagSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecForProvider(obj: TagSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'region': obj.region,
    'resourceArn': obj.resourceArn,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TagSpecManagementPolicy
 */
export enum TagSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TagSpecProviderConfigRef
 */
export interface TagSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagSpecProviderConfigRef#policy
   */
  readonly policy?: TagSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TagSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecProviderConfigRef(obj: TagSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TagSpecProviderRef
 */
export interface TagSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagSpecProviderRef#policy
   */
  readonly policy?: TagSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TagSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecProviderRef(obj: TagSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TagSpecPublishConnectionDetailsTo
 */
export interface TagSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TagSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TagSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TagSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TagSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TagSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TagSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecPublishConnectionDetailsTo(obj: TagSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TagSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TagSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TagSpecWriteConnectionSecretToRef
 */
export interface TagSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TagSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TagSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TagSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecWriteConnectionSecretToRef(obj: TagSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TagSpecProviderConfigRefPolicy
 */
export interface TagSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TagSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TagSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TagSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecProviderConfigRefPolicy(obj: TagSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TagSpecProviderRefPolicy
 */
export interface TagSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TagSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TagSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TagSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecProviderRefPolicy(obj: TagSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TagSpecPublishConnectionDetailsToConfigRef
 */
export interface TagSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TagSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TagSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecPublishConnectionDetailsToConfigRef(obj: TagSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TagSpecPublishConnectionDetailsToMetadata
 */
export interface TagSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TagSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TagSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TagSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TagSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecPublishConnectionDetailsToMetadata(obj: TagSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagSpecProviderConfigRefPolicyResolution
 */
export enum TagSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagSpecProviderConfigRefPolicyResolve
 */
export enum TagSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagSpecProviderRefPolicyResolution
 */
export enum TagSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagSpecProviderRefPolicyResolve
 */
export enum TagSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TagSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TagSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TagSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TagSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TagSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecPublishConnectionDetailsToConfigRefPolicy(obj: TagSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TagSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TagSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

