// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Discoverer is the Schema for the Discoverers API. Provides an EventBridge Schema Discoverer resource.
 *
 * @schema Discoverer
 */
export class Discoverer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Discoverer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'schemas.aws.upbound.io/v1beta1',
    kind: 'Discoverer',
  }

  /**
   * Renders a Kubernetes manifest for "Discoverer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DiscovererProps): any {
    return {
      ...Discoverer.GVK,
      ...toJson_DiscovererProps(props),
    };
  }

  /**
   * Defines a "Discoverer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DiscovererProps) {
    super(scope, id, {
      ...Discoverer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Discoverer.GVK,
      ...toJson_DiscovererProps(resolved),
    };
  }
}

/**
 * Discoverer is the Schema for the Discoverers API. Provides an EventBridge Schema Discoverer resource.
 *
 * @schema Discoverer
 */
export interface DiscovererProps {
  /**
   * @schema Discoverer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DiscovererSpec defines the desired state of Discoverer
   *
   * @schema Discoverer#spec
   */
  readonly spec: DiscovererSpec;

}

/**
 * Converts an object of type 'DiscovererProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DiscovererProps(obj: DiscovererProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DiscovererSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DiscovererSpec defines the desired state of Discoverer
 *
 * @schema DiscovererSpec
 */
export interface DiscovererSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DiscovererSpec#deletionPolicy
   */
  readonly deletionPolicy?: DiscovererSpecDeletionPolicy;

  /**
   * @schema DiscovererSpec#forProvider
   */
  readonly forProvider: DiscovererSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DiscovererSpec#initProvider
   */
  readonly initProvider?: DiscovererSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DiscovererSpec#managementPolicies
   */
  readonly managementPolicies?: DiscovererSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DiscovererSpec#providerConfigRef
   */
  readonly providerConfigRef?: DiscovererSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DiscovererSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DiscovererSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DiscovererSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DiscovererSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DiscovererSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DiscovererSpec(obj: DiscovererSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DiscovererSpecForProvider(obj.forProvider),
    'initProvider': toJson_DiscovererSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DiscovererSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DiscovererSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DiscovererSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DiscovererSpecDeletionPolicy
 */
export enum DiscovererSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DiscovererSpecForProvider
 */
export interface DiscovererSpecForProvider {
  /**
   * The description of the discoverer. Maximum of 256 characters.
   *
   * @schema DiscovererSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DiscovererSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ARN of the event bus to discover event schemas on.
   *
   * @schema DiscovererSpecForProvider#sourceArn
   */
  readonly sourceArn?: string;

  /**
   * Reference to a Bus in cloudwatchevents to populate sourceArn.
   *
   * @schema DiscovererSpecForProvider#sourceArnRef
   */
  readonly sourceArnRef?: DiscovererSpecForProviderSourceArnRef;

  /**
   * Selector for a Bus in cloudwatchevents to populate sourceArn.
   *
   * @schema DiscovererSpecForProvider#sourceArnSelector
   */
  readonly sourceArnSelector?: DiscovererSpecForProviderSourceArnSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema DiscovererSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DiscovererSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DiscovererSpecForProvider(obj: DiscovererSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'region': obj.region,
    'sourceArn': obj.sourceArn,
    'sourceArnRef': toJson_DiscovererSpecForProviderSourceArnRef(obj.sourceArnRef),
    'sourceArnSelector': toJson_DiscovererSpecForProviderSourceArnSelector(obj.sourceArnSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DiscovererSpecInitProvider
 */
export interface DiscovererSpecInitProvider {
  /**
   * The description of the discoverer. Maximum of 256 characters.
   *
   * @schema DiscovererSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema DiscovererSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DiscovererSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DiscovererSpecInitProvider(obj: DiscovererSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DiscovererSpecManagementPolicies
 */
export enum DiscovererSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DiscovererSpecProviderConfigRef
 */
export interface DiscovererSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DiscovererSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DiscovererSpecProviderConfigRef#policy
   */
  readonly policy?: DiscovererSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DiscovererSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DiscovererSpecProviderConfigRef(obj: DiscovererSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DiscovererSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DiscovererSpecPublishConnectionDetailsTo
 */
export interface DiscovererSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DiscovererSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DiscovererSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DiscovererSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DiscovererSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DiscovererSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DiscovererSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DiscovererSpecPublishConnectionDetailsTo(obj: DiscovererSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DiscovererSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DiscovererSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DiscovererSpecWriteConnectionSecretToRef
 */
export interface DiscovererSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DiscovererSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DiscovererSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DiscovererSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DiscovererSpecWriteConnectionSecretToRef(obj: DiscovererSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bus in cloudwatchevents to populate sourceArn.
 *
 * @schema DiscovererSpecForProviderSourceArnRef
 */
export interface DiscovererSpecForProviderSourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DiscovererSpecForProviderSourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DiscovererSpecForProviderSourceArnRef#policy
   */
  readonly policy?: DiscovererSpecForProviderSourceArnRefPolicy;

}

/**
 * Converts an object of type 'DiscovererSpecForProviderSourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DiscovererSpecForProviderSourceArnRef(obj: DiscovererSpecForProviderSourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DiscovererSpecForProviderSourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bus in cloudwatchevents to populate sourceArn.
 *
 * @schema DiscovererSpecForProviderSourceArnSelector
 */
export interface DiscovererSpecForProviderSourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DiscovererSpecForProviderSourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DiscovererSpecForProviderSourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DiscovererSpecForProviderSourceArnSelector#policy
   */
  readonly policy?: DiscovererSpecForProviderSourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'DiscovererSpecForProviderSourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DiscovererSpecForProviderSourceArnSelector(obj: DiscovererSpecForProviderSourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DiscovererSpecForProviderSourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DiscovererSpecProviderConfigRefPolicy
 */
export interface DiscovererSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DiscovererSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DiscovererSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DiscovererSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DiscovererSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DiscovererSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DiscovererSpecProviderConfigRefPolicy(obj: DiscovererSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DiscovererSpecPublishConnectionDetailsToConfigRef
 */
export interface DiscovererSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DiscovererSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DiscovererSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DiscovererSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DiscovererSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DiscovererSpecPublishConnectionDetailsToConfigRef(obj: DiscovererSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DiscovererSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DiscovererSpecPublishConnectionDetailsToMetadata
 */
export interface DiscovererSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DiscovererSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DiscovererSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DiscovererSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DiscovererSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DiscovererSpecPublishConnectionDetailsToMetadata(obj: DiscovererSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DiscovererSpecForProviderSourceArnRefPolicy
 */
export interface DiscovererSpecForProviderSourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DiscovererSpecForProviderSourceArnRefPolicy#resolution
   */
  readonly resolution?: DiscovererSpecForProviderSourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DiscovererSpecForProviderSourceArnRefPolicy#resolve
   */
  readonly resolve?: DiscovererSpecForProviderSourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DiscovererSpecForProviderSourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DiscovererSpecForProviderSourceArnRefPolicy(obj: DiscovererSpecForProviderSourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DiscovererSpecForProviderSourceArnSelectorPolicy
 */
export interface DiscovererSpecForProviderSourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DiscovererSpecForProviderSourceArnSelectorPolicy#resolution
   */
  readonly resolution?: DiscovererSpecForProviderSourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DiscovererSpecForProviderSourceArnSelectorPolicy#resolve
   */
  readonly resolve?: DiscovererSpecForProviderSourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DiscovererSpecForProviderSourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DiscovererSpecForProviderSourceArnSelectorPolicy(obj: DiscovererSpecForProviderSourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DiscovererSpecProviderConfigRefPolicyResolution
 */
export enum DiscovererSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DiscovererSpecProviderConfigRefPolicyResolve
 */
export enum DiscovererSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DiscovererSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DiscovererSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DiscovererSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DiscovererSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DiscovererSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DiscovererSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DiscovererSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DiscovererSpecPublishConnectionDetailsToConfigRefPolicy(obj: DiscovererSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DiscovererSpecForProviderSourceArnRefPolicyResolution
 */
export enum DiscovererSpecForProviderSourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DiscovererSpecForProviderSourceArnRefPolicyResolve
 */
export enum DiscovererSpecForProviderSourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DiscovererSpecForProviderSourceArnSelectorPolicyResolution
 */
export enum DiscovererSpecForProviderSourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DiscovererSpecForProviderSourceArnSelectorPolicyResolve
 */
export enum DiscovererSpecForProviderSourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DiscovererSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DiscovererSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DiscovererSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DiscovererSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Registry is the Schema for the Registrys API. Provides an EventBridge Custom Schema Registry resource.
 *
 * @schema Registry
 */
export class Registry extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Registry"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'schemas.aws.upbound.io/v1beta1',
    kind: 'Registry',
  }

  /**
   * Renders a Kubernetes manifest for "Registry".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RegistryProps): any {
    return {
      ...Registry.GVK,
      ...toJson_RegistryProps(props),
    };
  }

  /**
   * Defines a "Registry" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RegistryProps) {
    super(scope, id, {
      ...Registry.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Registry.GVK,
      ...toJson_RegistryProps(resolved),
    };
  }
}

/**
 * Registry is the Schema for the Registrys API. Provides an EventBridge Custom Schema Registry resource.
 *
 * @schema Registry
 */
export interface RegistryProps {
  /**
   * @schema Registry#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RegistrySpec defines the desired state of Registry
   *
   * @schema Registry#spec
   */
  readonly spec: RegistrySpec;

}

/**
 * Converts an object of type 'RegistryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryProps(obj: RegistryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RegistrySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RegistrySpec defines the desired state of Registry
 *
 * @schema RegistrySpec
 */
export interface RegistrySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RegistrySpec#deletionPolicy
   */
  readonly deletionPolicy?: RegistrySpecDeletionPolicy;

  /**
   * @schema RegistrySpec#forProvider
   */
  readonly forProvider: RegistrySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema RegistrySpec#initProvider
   */
  readonly initProvider?: RegistrySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RegistrySpec#managementPolicies
   */
  readonly managementPolicies?: RegistrySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RegistrySpec#providerConfigRef
   */
  readonly providerConfigRef?: RegistrySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RegistrySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RegistrySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RegistrySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RegistrySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RegistrySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpec(obj: RegistrySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RegistrySpecForProvider(obj.forProvider),
    'initProvider': toJson_RegistrySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RegistrySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RegistrySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RegistrySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RegistrySpecDeletionPolicy
 */
export enum RegistrySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RegistrySpecForProvider
 */
export interface RegistrySpecForProvider {
  /**
   * The description of the discoverer. Maximum of 256 characters.
   *
   * @schema RegistrySpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RegistrySpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RegistrySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RegistrySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecForProvider(obj: RegistrySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema RegistrySpecInitProvider
 */
export interface RegistrySpecInitProvider {
  /**
   * The description of the discoverer. Maximum of 256 characters.
   *
   * @schema RegistrySpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RegistrySpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RegistrySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecInitProvider(obj: RegistrySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RegistrySpecManagementPolicies
 */
export enum RegistrySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RegistrySpecProviderConfigRef
 */
export interface RegistrySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegistrySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegistrySpecProviderConfigRef#policy
   */
  readonly policy?: RegistrySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RegistrySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecProviderConfigRef(obj: RegistrySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegistrySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RegistrySpecPublishConnectionDetailsTo
 */
export interface RegistrySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RegistrySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RegistrySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RegistrySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RegistrySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RegistrySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RegistrySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecPublishConnectionDetailsTo(obj: RegistrySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RegistrySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RegistrySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RegistrySpecWriteConnectionSecretToRef
 */
export interface RegistrySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RegistrySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RegistrySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RegistrySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecWriteConnectionSecretToRef(obj: RegistrySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RegistrySpecProviderConfigRefPolicy
 */
export interface RegistrySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegistrySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RegistrySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegistrySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RegistrySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RegistrySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecProviderConfigRefPolicy(obj: RegistrySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RegistrySpecPublishConnectionDetailsToConfigRef
 */
export interface RegistrySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegistrySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegistrySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RegistrySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RegistrySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecPublishConnectionDetailsToConfigRef(obj: RegistrySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegistrySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RegistrySpecPublishConnectionDetailsToMetadata
 */
export interface RegistrySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RegistrySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RegistrySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RegistrySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RegistrySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecPublishConnectionDetailsToMetadata(obj: RegistrySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegistrySpecProviderConfigRefPolicyResolution
 */
export enum RegistrySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegistrySpecProviderConfigRefPolicyResolve
 */
export enum RegistrySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RegistrySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RegistrySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegistrySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegistrySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RegistrySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecPublishConnectionDetailsToConfigRefPolicy(obj: RegistrySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Schema is the Schema for the Schemas API. Provides an EventBridge Schema resource.
 *
 * @schema Schema
 */
export class Schema extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Schema"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'schemas.aws.upbound.io/v1beta1',
    kind: 'Schema',
  }

  /**
   * Renders a Kubernetes manifest for "Schema".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SchemaProps): any {
    return {
      ...Schema.GVK,
      ...toJson_SchemaProps(props),
    };
  }

  /**
   * Defines a "Schema" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SchemaProps) {
    super(scope, id, {
      ...Schema.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Schema.GVK,
      ...toJson_SchemaProps(resolved),
    };
  }
}

/**
 * Schema is the Schema for the Schemas API. Provides an EventBridge Schema resource.
 *
 * @schema Schema
 */
export interface SchemaProps {
  /**
   * @schema Schema#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SchemaSpec defines the desired state of Schema
   *
   * @schema Schema#spec
   */
  readonly spec: SchemaSpec;

}

/**
 * Converts an object of type 'SchemaProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaProps(obj: SchemaProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SchemaSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SchemaSpec defines the desired state of Schema
 *
 * @schema SchemaSpec
 */
export interface SchemaSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SchemaSpec#deletionPolicy
   */
  readonly deletionPolicy?: SchemaSpecDeletionPolicy;

  /**
   * @schema SchemaSpec#forProvider
   */
  readonly forProvider: SchemaSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SchemaSpec#initProvider
   */
  readonly initProvider?: SchemaSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SchemaSpec#managementPolicies
   */
  readonly managementPolicies?: SchemaSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SchemaSpec#providerConfigRef
   */
  readonly providerConfigRef?: SchemaSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SchemaSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SchemaSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SchemaSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SchemaSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SchemaSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpec(obj: SchemaSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SchemaSpecForProvider(obj.forProvider),
    'initProvider': toJson_SchemaSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SchemaSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SchemaSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SchemaSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SchemaSpecDeletionPolicy
 */
export enum SchemaSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SchemaSpecForProvider
 */
export interface SchemaSpecForProvider {
  /**
   * The schema specification. Must be a valid Open API 3.0 spec.
   *
   * @schema SchemaSpecForProvider#content
   */
  readonly content?: string;

  /**
   * The description of the schema. Maximum of 256 characters.
   *
   * @schema SchemaSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name of the schema. Maximum of 385 characters consisting of lower case letters, upper case letters, ., -, _, @.
   *
   * @schema SchemaSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SchemaSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name of the registry in which this schema belongs.
   *
   * @schema SchemaSpecForProvider#registryName
   */
  readonly registryName?: string;

  /**
   * Reference to a Registry in schemas to populate registryName.
   *
   * @schema SchemaSpecForProvider#registryNameRef
   */
  readonly registryNameRef?: SchemaSpecForProviderRegistryNameRef;

  /**
   * Selector for a Registry in schemas to populate registryName.
   *
   * @schema SchemaSpecForProvider#registryNameSelector
   */
  readonly registryNameSelector?: SchemaSpecForProviderRegistryNameSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema SchemaSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The type of the schema. Valid values: OpenApi3.
   *
   * @schema SchemaSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SchemaSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecForProvider(obj: SchemaSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'registryName': obj.registryName,
    'registryNameRef': toJson_SchemaSpecForProviderRegistryNameRef(obj.registryNameRef),
    'registryNameSelector': toJson_SchemaSpecForProviderRegistryNameSelector(obj.registryNameSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SchemaSpecInitProvider
 */
export interface SchemaSpecInitProvider {
  /**
   * The schema specification. Must be a valid Open API 3.0 spec.
   *
   * @schema SchemaSpecInitProvider#content
   */
  readonly content?: string;

  /**
   * The description of the schema. Maximum of 256 characters.
   *
   * @schema SchemaSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The name of the schema. Maximum of 385 characters consisting of lower case letters, upper case letters, ., -, _, @.
   *
   * @schema SchemaSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema SchemaSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The type of the schema. Valid values: OpenApi3.
   *
   * @schema SchemaSpecInitProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SchemaSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecInitProvider(obj: SchemaSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'description': obj.description,
    'name': obj.name,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SchemaSpecManagementPolicies
 */
export enum SchemaSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SchemaSpecProviderConfigRef
 */
export interface SchemaSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SchemaSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SchemaSpecProviderConfigRef#policy
   */
  readonly policy?: SchemaSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SchemaSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecProviderConfigRef(obj: SchemaSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SchemaSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SchemaSpecPublishConnectionDetailsTo
 */
export interface SchemaSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SchemaSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SchemaSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SchemaSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SchemaSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SchemaSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SchemaSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecPublishConnectionDetailsTo(obj: SchemaSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SchemaSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SchemaSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SchemaSpecWriteConnectionSecretToRef
 */
export interface SchemaSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SchemaSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SchemaSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SchemaSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecWriteConnectionSecretToRef(obj: SchemaSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Registry in schemas to populate registryName.
 *
 * @schema SchemaSpecForProviderRegistryNameRef
 */
export interface SchemaSpecForProviderRegistryNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema SchemaSpecForProviderRegistryNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SchemaSpecForProviderRegistryNameRef#policy
   */
  readonly policy?: SchemaSpecForProviderRegistryNameRefPolicy;

}

/**
 * Converts an object of type 'SchemaSpecForProviderRegistryNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecForProviderRegistryNameRef(obj: SchemaSpecForProviderRegistryNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SchemaSpecForProviderRegistryNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Registry in schemas to populate registryName.
 *
 * @schema SchemaSpecForProviderRegistryNameSelector
 */
export interface SchemaSpecForProviderRegistryNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SchemaSpecForProviderRegistryNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SchemaSpecForProviderRegistryNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SchemaSpecForProviderRegistryNameSelector#policy
   */
  readonly policy?: SchemaSpecForProviderRegistryNameSelectorPolicy;

}

/**
 * Converts an object of type 'SchemaSpecForProviderRegistryNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecForProviderRegistryNameSelector(obj: SchemaSpecForProviderRegistryNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SchemaSpecForProviderRegistryNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SchemaSpecProviderConfigRefPolicy
 */
export interface SchemaSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SchemaSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SchemaSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SchemaSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SchemaSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SchemaSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecProviderConfigRefPolicy(obj: SchemaSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SchemaSpecPublishConnectionDetailsToConfigRef
 */
export interface SchemaSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SchemaSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SchemaSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SchemaSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SchemaSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecPublishConnectionDetailsToConfigRef(obj: SchemaSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SchemaSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SchemaSpecPublishConnectionDetailsToMetadata
 */
export interface SchemaSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SchemaSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SchemaSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SchemaSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SchemaSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecPublishConnectionDetailsToMetadata(obj: SchemaSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SchemaSpecForProviderRegistryNameRefPolicy
 */
export interface SchemaSpecForProviderRegistryNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SchemaSpecForProviderRegistryNameRefPolicy#resolution
   */
  readonly resolution?: SchemaSpecForProviderRegistryNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SchemaSpecForProviderRegistryNameRefPolicy#resolve
   */
  readonly resolve?: SchemaSpecForProviderRegistryNameRefPolicyResolve;

}

/**
 * Converts an object of type 'SchemaSpecForProviderRegistryNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecForProviderRegistryNameRefPolicy(obj: SchemaSpecForProviderRegistryNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SchemaSpecForProviderRegistryNameSelectorPolicy
 */
export interface SchemaSpecForProviderRegistryNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SchemaSpecForProviderRegistryNameSelectorPolicy#resolution
   */
  readonly resolution?: SchemaSpecForProviderRegistryNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SchemaSpecForProviderRegistryNameSelectorPolicy#resolve
   */
  readonly resolve?: SchemaSpecForProviderRegistryNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SchemaSpecForProviderRegistryNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecForProviderRegistryNameSelectorPolicy(obj: SchemaSpecForProviderRegistryNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SchemaSpecProviderConfigRefPolicyResolution
 */
export enum SchemaSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SchemaSpecProviderConfigRefPolicyResolve
 */
export enum SchemaSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SchemaSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SchemaSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SchemaSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SchemaSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SchemaSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecPublishConnectionDetailsToConfigRefPolicy(obj: SchemaSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SchemaSpecForProviderRegistryNameRefPolicyResolution
 */
export enum SchemaSpecForProviderRegistryNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SchemaSpecForProviderRegistryNameRefPolicyResolve
 */
export enum SchemaSpecForProviderRegistryNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SchemaSpecForProviderRegistryNameSelectorPolicyResolution
 */
export enum SchemaSpecForProviderRegistryNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SchemaSpecForProviderRegistryNameSelectorPolicyResolve
 */
export enum SchemaSpecForProviderRegistryNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

