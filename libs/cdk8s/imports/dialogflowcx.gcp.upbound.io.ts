// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Agent is the Schema for the Agents API. Agents are best described as Natural Language Understanding (NLU) modules that transform user requests into actionable data.
 *
 * @schema Agent
 */
export class Agent extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Agent"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dialogflowcx.gcp.upbound.io/v1beta1',
    kind: 'Agent',
  }

  /**
   * Renders a Kubernetes manifest for "Agent".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AgentProps): any {
    return {
      ...Agent.GVK,
      ...toJson_AgentProps(props),
    };
  }

  /**
   * Defines a "Agent" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AgentProps) {
    super(scope, id, {
      ...Agent.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Agent.GVK,
      ...toJson_AgentProps(resolved),
    };
  }
}

/**
 * Agent is the Schema for the Agents API. Agents are best described as Natural Language Understanding (NLU) modules that transform user requests into actionable data.
 *
 * @schema Agent
 */
export interface AgentProps {
  /**
   * @schema Agent#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AgentSpec defines the desired state of Agent
   *
   * @schema Agent#spec
   */
  readonly spec: AgentSpec;

}

/**
 * Converts an object of type 'AgentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AgentProps(obj: AgentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AgentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AgentSpec defines the desired state of Agent
 *
 * @schema AgentSpec
 */
export interface AgentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema AgentSpec#deletionPolicy
   */
  readonly deletionPolicy?: AgentSpecDeletionPolicy;

  /**
   * @schema AgentSpec#forProvider
   */
  readonly forProvider: AgentSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AgentSpec#providerConfigRef
   */
  readonly providerConfigRef?: AgentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AgentSpec#providerRef
   */
  readonly providerRef?: AgentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AgentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AgentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AgentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AgentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AgentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AgentSpec(obj: AgentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AgentSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_AgentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AgentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AgentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AgentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema AgentSpecDeletionPolicy
 */
export enum AgentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AgentSpecForProvider
 */
export interface AgentSpecForProvider {
  /**
   * The URI of the agent's avatar. Avatars are used throughout the Dialogflow console and in the self-hosted Web Demo integration.
   *
   * @schema AgentSpecForProvider#avatarUri
   */
  readonly avatarUri?: string;

  /**
   * The default language of the agent as a language tag. See Language Support for a list of the currently supported language codes. This field cannot be updated after creation.
   *
   * @schema AgentSpecForProvider#defaultLanguageCode
   */
  readonly defaultLanguageCode: string;

  /**
   * The description of this agent. The maximum length is 500 characters. If exceeded, the request is rejected.
   *
   * @schema AgentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The human-readable name of the agent, unique within the location.
   *
   * @schema AgentSpecForProvider#displayName
   */
  readonly displayName: string;

  /**
   * Indicates if automatic spell correction is enabled in detect intent requests.
   *
   * @schema AgentSpecForProvider#enableSpellCorrection
   */
  readonly enableSpellCorrection?: boolean;

  /**
   * Determines whether this agent should log conversation queries.
   *
   * @schema AgentSpecForProvider#enableStackdriverLogging
   */
  readonly enableStackdriverLogging?: boolean;

  /**
   * The name of the location this agent is located in. ~> Note: The first time you are deploying an Agent in your project you must configure location settings. This is a one time step but at the moment you can only configure location settings via the Dialogflow CX console. Another options is to use global location so you don't need to manually configure location settings.
   *
   * @schema AgentSpecForProvider#location
   */
  readonly location: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema AgentSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Name of the SecuritySettings reference for the agent. Format: projects//locations//securitySettings/.
   *
   * @schema AgentSpecForProvider#securitySettings
   */
  readonly securitySettings?: string;

  /**
   * Settings related to speech recognition. Structure is documented below.
   *
   * @schema AgentSpecForProvider#speechToTextSettings
   */
  readonly speechToTextSettings?: AgentSpecForProviderSpeechToTextSettings[];

  /**
   * The list of all languages supported by this agent (except for the default_language_code).
   *
   * @schema AgentSpecForProvider#supportedLanguageCodes
   */
  readonly supportedLanguageCodes?: string[];

  /**
   * The time zone of this agent from the time zone database, e.g., America/New_York, Europe/Paris.
   *
   * @schema AgentSpecForProvider#timeZone
   */
  readonly timeZone: string;

}

/**
 * Converts an object of type 'AgentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AgentSpecForProvider(obj: AgentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'avatarUri': obj.avatarUri,
    'defaultLanguageCode': obj.defaultLanguageCode,
    'description': obj.description,
    'displayName': obj.displayName,
    'enableSpellCorrection': obj.enableSpellCorrection,
    'enableStackdriverLogging': obj.enableStackdriverLogging,
    'location': obj.location,
    'project': obj.project,
    'securitySettings': obj.securitySettings,
    'speechToTextSettings': obj.speechToTextSettings?.map(y => toJson_AgentSpecForProviderSpeechToTextSettings(y)),
    'supportedLanguageCodes': obj.supportedLanguageCodes?.map(y => y),
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AgentSpecProviderConfigRef
 */
export interface AgentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AgentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AgentSpecProviderConfigRef#policy
   */
  readonly policy?: AgentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AgentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AgentSpecProviderConfigRef(obj: AgentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AgentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AgentSpecProviderRef
 */
export interface AgentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AgentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AgentSpecProviderRef#policy
   */
  readonly policy?: AgentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AgentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AgentSpecProviderRef(obj: AgentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AgentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AgentSpecPublishConnectionDetailsTo
 */
export interface AgentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AgentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AgentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AgentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AgentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AgentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AgentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AgentSpecPublishConnectionDetailsTo(obj: AgentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AgentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AgentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AgentSpecWriteConnectionSecretToRef
 */
export interface AgentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AgentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AgentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AgentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AgentSpecWriteConnectionSecretToRef(obj: AgentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AgentSpecForProviderSpeechToTextSettings
 */
export interface AgentSpecForProviderSpeechToTextSettings {
  /**
   * Whether to use speech adaptation for speech recognition.
   *
   * @schema AgentSpecForProviderSpeechToTextSettings#enableSpeechAdaptation
   */
  readonly enableSpeechAdaptation?: boolean;

}

/**
 * Converts an object of type 'AgentSpecForProviderSpeechToTextSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AgentSpecForProviderSpeechToTextSettings(obj: AgentSpecForProviderSpeechToTextSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableSpeechAdaptation': obj.enableSpeechAdaptation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AgentSpecProviderConfigRefPolicy
 */
export interface AgentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AgentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AgentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AgentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AgentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AgentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AgentSpecProviderConfigRefPolicy(obj: AgentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AgentSpecProviderRefPolicy
 */
export interface AgentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AgentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AgentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AgentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AgentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AgentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AgentSpecProviderRefPolicy(obj: AgentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AgentSpecPublishConnectionDetailsToConfigRef
 */
export interface AgentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AgentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AgentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AgentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AgentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AgentSpecPublishConnectionDetailsToConfigRef(obj: AgentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AgentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AgentSpecPublishConnectionDetailsToMetadata
 */
export interface AgentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AgentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AgentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AgentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AgentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AgentSpecPublishConnectionDetailsToMetadata(obj: AgentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AgentSpecProviderConfigRefPolicyResolution
 */
export enum AgentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AgentSpecProviderConfigRefPolicyResolve
 */
export enum AgentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AgentSpecProviderRefPolicyResolution
 */
export enum AgentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AgentSpecProviderRefPolicyResolve
 */
export enum AgentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AgentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AgentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AgentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AgentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AgentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AgentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AgentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AgentSpecPublishConnectionDetailsToConfigRefPolicy(obj: AgentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AgentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AgentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AgentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AgentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EntityType is the Schema for the EntityTypes API. Entities are extracted from user input and represent parameters that are meaningful to your application.
 *
 * @schema EntityType
 */
export class EntityType extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EntityType"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dialogflowcx.gcp.upbound.io/v1beta1',
    kind: 'EntityType',
  }

  /**
   * Renders a Kubernetes manifest for "EntityType".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EntityTypeProps): any {
    return {
      ...EntityType.GVK,
      ...toJson_EntityTypeProps(props),
    };
  }

  /**
   * Defines a "EntityType" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EntityTypeProps) {
    super(scope, id, {
      ...EntityType.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EntityType.GVK,
      ...toJson_EntityTypeProps(resolved),
    };
  }
}

/**
 * EntityType is the Schema for the EntityTypes API. Entities are extracted from user input and represent parameters that are meaningful to your application.
 *
 * @schema EntityType
 */
export interface EntityTypeProps {
  /**
   * @schema EntityType#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EntityTypeSpec defines the desired state of EntityType
   *
   * @schema EntityType#spec
   */
  readonly spec: EntityTypeSpec;

}

/**
 * Converts an object of type 'EntityTypeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeProps(obj: EntityTypeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EntityTypeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EntityTypeSpec defines the desired state of EntityType
 *
 * @schema EntityTypeSpec
 */
export interface EntityTypeSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema EntityTypeSpec#deletionPolicy
   */
  readonly deletionPolicy?: EntityTypeSpecDeletionPolicy;

  /**
   * @schema EntityTypeSpec#forProvider
   */
  readonly forProvider: EntityTypeSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EntityTypeSpec#providerConfigRef
   */
  readonly providerConfigRef?: EntityTypeSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EntityTypeSpec#providerRef
   */
  readonly providerRef?: EntityTypeSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EntityTypeSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EntityTypeSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EntityTypeSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EntityTypeSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EntityTypeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeSpec(obj: EntityTypeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EntityTypeSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_EntityTypeSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EntityTypeSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EntityTypeSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EntityTypeSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema EntityTypeSpecDeletionPolicy
 */
export enum EntityTypeSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EntityTypeSpecForProvider
 */
export interface EntityTypeSpecForProvider {
  /**
   * Represents kinds of entities.
   *
   * @schema EntityTypeSpecForProvider#autoExpansionMode
   */
  readonly autoExpansionMode?: string;

  /**
   * The human-readable name of the entity type, unique within the agent.
   *
   * @schema EntityTypeSpecForProvider#displayName
   */
  readonly displayName: string;

  /**
   * Enables fuzzy entity extraction during classification.
   *
   * @schema EntityTypeSpecForProvider#enableFuzzyExtraction
   */
  readonly enableFuzzyExtraction?: boolean;

  /**
   * The collection of entity entries associated with the entity type. Structure is documented below.
   *
   * @schema EntityTypeSpecForProvider#entities
   */
  readonly entities: EntityTypeSpecForProviderEntities[];

  /**
   * Collection of exceptional words and phrases that shouldn't be matched. For example, if you have a size entity type with entry giant(an adjective), you might consider adding giants(a noun) as an exclusion. If the kind of entity type is KIND_MAP, then the phrases specified by entities and excluded phrases should be mutually exclusive. Structure is documented below.
   *
   * @schema EntityTypeSpecForProvider#excludedPhrases
   */
  readonly excludedPhrases?: EntityTypeSpecForProviderExcludedPhrases[];

  /**
   * Indicates whether the entity type can be automatically expanded.
   *
   * @schema EntityTypeSpecForProvider#kind
   */
  readonly kind: string;

  /**
   * The language of the following fields in entityType: EntityType.entities.value EntityType.entities.synonyms EntityType.excluded_phrases.value If not specified, the agent's default language is used. Many languages are supported. Note: languages must be enabled in the agent before they can be used.
   *
   * @schema EntityTypeSpecForProvider#languageCode
   */
  readonly languageCode?: string;

  /**
   * The agent to create a entity type for. Format: projects//locations//agents/.
   *
   * @schema EntityTypeSpecForProvider#parent
   */
  readonly parent?: string;

  /**
   * Reference to a Agent in dialogflowcx to populate parent.
   *
   * @schema EntityTypeSpecForProvider#parentRef
   */
  readonly parentRef?: EntityTypeSpecForProviderParentRef;

  /**
   * Selector for a Agent in dialogflowcx to populate parent.
   *
   * @schema EntityTypeSpecForProvider#parentSelector
   */
  readonly parentSelector?: EntityTypeSpecForProviderParentSelector;

  /**
   * Indicates whether parameters of the entity type should be redacted in log. If redaction is enabled, page parameters and intent parameters referring to the entity type will be replaced by parameter name when logging.
   *
   * @schema EntityTypeSpecForProvider#redact
   */
  readonly redact?: boolean;

}

/**
 * Converts an object of type 'EntityTypeSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeSpecForProvider(obj: EntityTypeSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoExpansionMode': obj.autoExpansionMode,
    'displayName': obj.displayName,
    'enableFuzzyExtraction': obj.enableFuzzyExtraction,
    'entities': obj.entities?.map(y => toJson_EntityTypeSpecForProviderEntities(y)),
    'excludedPhrases': obj.excludedPhrases?.map(y => toJson_EntityTypeSpecForProviderExcludedPhrases(y)),
    'kind': obj.kind,
    'languageCode': obj.languageCode,
    'parent': obj.parent,
    'parentRef': toJson_EntityTypeSpecForProviderParentRef(obj.parentRef),
    'parentSelector': toJson_EntityTypeSpecForProviderParentSelector(obj.parentSelector),
    'redact': obj.redact,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EntityTypeSpecProviderConfigRef
 */
export interface EntityTypeSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EntityTypeSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EntityTypeSpecProviderConfigRef#policy
   */
  readonly policy?: EntityTypeSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EntityTypeSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeSpecProviderConfigRef(obj: EntityTypeSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EntityTypeSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EntityTypeSpecProviderRef
 */
export interface EntityTypeSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EntityTypeSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EntityTypeSpecProviderRef#policy
   */
  readonly policy?: EntityTypeSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EntityTypeSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeSpecProviderRef(obj: EntityTypeSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EntityTypeSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EntityTypeSpecPublishConnectionDetailsTo
 */
export interface EntityTypeSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EntityTypeSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EntityTypeSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EntityTypeSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EntityTypeSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EntityTypeSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EntityTypeSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeSpecPublishConnectionDetailsTo(obj: EntityTypeSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EntityTypeSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EntityTypeSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EntityTypeSpecWriteConnectionSecretToRef
 */
export interface EntityTypeSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EntityTypeSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EntityTypeSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EntityTypeSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeSpecWriteConnectionSecretToRef(obj: EntityTypeSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EntityTypeSpecForProviderEntities
 */
export interface EntityTypeSpecForProviderEntities {
  /**
   * A collection of value synonyms. For example, if the entity type is vegetable, and value is scallions, a synonym could be green onions. For KIND_LIST entity types: This collection must contain exactly one synonym equal to value.
   *
   * @schema EntityTypeSpecForProviderEntities#synonyms
   */
  readonly synonyms?: string[];

  /**
   * The primary value associated with this entity entry. For example, if the entity type is vegetable, the value could be scallions. For KIND_MAP entity types: A canonical value to be used in place of synonyms. For KIND_LIST entity types: A string that can contain references to other entity types (with or without aliases).
   *
   * @schema EntityTypeSpecForProviderEntities#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'EntityTypeSpecForProviderEntities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeSpecForProviderEntities(obj: EntityTypeSpecForProviderEntities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'synonyms': obj.synonyms?.map(y => y),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EntityTypeSpecForProviderExcludedPhrases
 */
export interface EntityTypeSpecForProviderExcludedPhrases {
  /**
   * The word or phrase to be excluded.
   *
   * @schema EntityTypeSpecForProviderExcludedPhrases#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'EntityTypeSpecForProviderExcludedPhrases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeSpecForProviderExcludedPhrases(obj: EntityTypeSpecForProviderExcludedPhrases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Agent in dialogflowcx to populate parent.
 *
 * @schema EntityTypeSpecForProviderParentRef
 */
export interface EntityTypeSpecForProviderParentRef {
  /**
   * Name of the referenced object.
   *
   * @schema EntityTypeSpecForProviderParentRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EntityTypeSpecForProviderParentRef#policy
   */
  readonly policy?: EntityTypeSpecForProviderParentRefPolicy;

}

/**
 * Converts an object of type 'EntityTypeSpecForProviderParentRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeSpecForProviderParentRef(obj: EntityTypeSpecForProviderParentRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EntityTypeSpecForProviderParentRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Agent in dialogflowcx to populate parent.
 *
 * @schema EntityTypeSpecForProviderParentSelector
 */
export interface EntityTypeSpecForProviderParentSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EntityTypeSpecForProviderParentSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EntityTypeSpecForProviderParentSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EntityTypeSpecForProviderParentSelector#policy
   */
  readonly policy?: EntityTypeSpecForProviderParentSelectorPolicy;

}

/**
 * Converts an object of type 'EntityTypeSpecForProviderParentSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeSpecForProviderParentSelector(obj: EntityTypeSpecForProviderParentSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EntityTypeSpecForProviderParentSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EntityTypeSpecProviderConfigRefPolicy
 */
export interface EntityTypeSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EntityTypeSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EntityTypeSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EntityTypeSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EntityTypeSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EntityTypeSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeSpecProviderConfigRefPolicy(obj: EntityTypeSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EntityTypeSpecProviderRefPolicy
 */
export interface EntityTypeSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EntityTypeSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EntityTypeSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EntityTypeSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EntityTypeSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EntityTypeSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeSpecProviderRefPolicy(obj: EntityTypeSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EntityTypeSpecPublishConnectionDetailsToConfigRef
 */
export interface EntityTypeSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EntityTypeSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EntityTypeSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EntityTypeSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EntityTypeSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeSpecPublishConnectionDetailsToConfigRef(obj: EntityTypeSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EntityTypeSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EntityTypeSpecPublishConnectionDetailsToMetadata
 */
export interface EntityTypeSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EntityTypeSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EntityTypeSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EntityTypeSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EntityTypeSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeSpecPublishConnectionDetailsToMetadata(obj: EntityTypeSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EntityTypeSpecForProviderParentRefPolicy
 */
export interface EntityTypeSpecForProviderParentRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EntityTypeSpecForProviderParentRefPolicy#resolution
   */
  readonly resolution?: EntityTypeSpecForProviderParentRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EntityTypeSpecForProviderParentRefPolicy#resolve
   */
  readonly resolve?: EntityTypeSpecForProviderParentRefPolicyResolve;

}

/**
 * Converts an object of type 'EntityTypeSpecForProviderParentRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeSpecForProviderParentRefPolicy(obj: EntityTypeSpecForProviderParentRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EntityTypeSpecForProviderParentSelectorPolicy
 */
export interface EntityTypeSpecForProviderParentSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EntityTypeSpecForProviderParentSelectorPolicy#resolution
   */
  readonly resolution?: EntityTypeSpecForProviderParentSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EntityTypeSpecForProviderParentSelectorPolicy#resolve
   */
  readonly resolve?: EntityTypeSpecForProviderParentSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EntityTypeSpecForProviderParentSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeSpecForProviderParentSelectorPolicy(obj: EntityTypeSpecForProviderParentSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EntityTypeSpecProviderConfigRefPolicyResolution
 */
export enum EntityTypeSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EntityTypeSpecProviderConfigRefPolicyResolve
 */
export enum EntityTypeSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EntityTypeSpecProviderRefPolicyResolution
 */
export enum EntityTypeSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EntityTypeSpecProviderRefPolicyResolve
 */
export enum EntityTypeSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EntityTypeSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EntityTypeSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EntityTypeSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EntityTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EntityTypeSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EntityTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EntityTypeSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntityTypeSpecPublishConnectionDetailsToConfigRefPolicy(obj: EntityTypeSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EntityTypeSpecForProviderParentRefPolicyResolution
 */
export enum EntityTypeSpecForProviderParentRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EntityTypeSpecForProviderParentRefPolicyResolve
 */
export enum EntityTypeSpecForProviderParentRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EntityTypeSpecForProviderParentSelectorPolicyResolution
 */
export enum EntityTypeSpecForProviderParentSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EntityTypeSpecForProviderParentSelectorPolicyResolve
 */
export enum EntityTypeSpecForProviderParentSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EntityTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EntityTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EntityTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EntityTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Environment is the Schema for the Environments API. Represents an environment for an agent.
 *
 * @schema Environment
 */
export class Environment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Environment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dialogflowcx.gcp.upbound.io/v1beta1',
    kind: 'Environment',
  }

  /**
   * Renders a Kubernetes manifest for "Environment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EnvironmentProps): any {
    return {
      ...Environment.GVK,
      ...toJson_EnvironmentProps(props),
    };
  }

  /**
   * Defines a "Environment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EnvironmentProps) {
    super(scope, id, {
      ...Environment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Environment.GVK,
      ...toJson_EnvironmentProps(resolved),
    };
  }
}

/**
 * Environment is the Schema for the Environments API. Represents an environment for an agent.
 *
 * @schema Environment
 */
export interface EnvironmentProps {
  /**
   * @schema Environment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EnvironmentSpec defines the desired state of Environment
   *
   * @schema Environment#spec
   */
  readonly spec: EnvironmentSpec;

}

/**
 * Converts an object of type 'EnvironmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentProps(obj: EnvironmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EnvironmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvironmentSpec defines the desired state of Environment
 *
 * @schema EnvironmentSpec
 */
export interface EnvironmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema EnvironmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: EnvironmentSpecDeletionPolicy;

  /**
   * @schema EnvironmentSpec#forProvider
   */
  readonly forProvider: EnvironmentSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EnvironmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: EnvironmentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EnvironmentSpec#providerRef
   */
  readonly providerRef?: EnvironmentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EnvironmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EnvironmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EnvironmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EnvironmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EnvironmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpec(obj: EnvironmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EnvironmentSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_EnvironmentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EnvironmentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EnvironmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EnvironmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema EnvironmentSpecDeletionPolicy
 */
export enum EnvironmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EnvironmentSpecForProvider
 */
export interface EnvironmentSpecForProvider {
  /**
   * The human-readable description of the environment. The maximum length is 500 characters. If exceeded, the request is rejected.
   *
   * @schema EnvironmentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The human-readable name of the environment (unique in an agent). Limit of 64 characters.
   *
   * @schema EnvironmentSpecForProvider#displayName
   */
  readonly displayName: string;

  /**
   * The Agent to create an Environment for. Format: projects//locations//agents/.
   *
   * @schema EnvironmentSpecForProvider#parent
   */
  readonly parent?: string;

  /**
   * Reference to a Agent in dialogflowcx to populate parent.
   *
   * @schema EnvironmentSpecForProvider#parentRef
   */
  readonly parentRef?: EnvironmentSpecForProviderParentRef;

  /**
   * Selector for a Agent in dialogflowcx to populate parent.
   *
   * @schema EnvironmentSpecForProvider#parentSelector
   */
  readonly parentSelector?: EnvironmentSpecForProviderParentSelector;

  /**
   * A list of configurations for flow versions. You should include version configs for all flows that are reachable from [Start Flow][Agent.start_flow] in the agent. Otherwise, an error will be returned. Structure is documented below.
   *
   * @schema EnvironmentSpecForProvider#versionConfigs
   */
  readonly versionConfigs: EnvironmentSpecForProviderVersionConfigs[];

}

/**
 * Converts an object of type 'EnvironmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProvider(obj: EnvironmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'parent': obj.parent,
    'parentRef': toJson_EnvironmentSpecForProviderParentRef(obj.parentRef),
    'parentSelector': toJson_EnvironmentSpecForProviderParentSelector(obj.parentSelector),
    'versionConfigs': obj.versionConfigs?.map(y => toJson_EnvironmentSpecForProviderVersionConfigs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EnvironmentSpecProviderConfigRef
 */
export interface EnvironmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecProviderConfigRef#policy
   */
  readonly policy?: EnvironmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderConfigRef(obj: EnvironmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EnvironmentSpecProviderRef
 */
export interface EnvironmentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecProviderRef#policy
   */
  readonly policy?: EnvironmentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderRef(obj: EnvironmentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsTo
 */
export interface EnvironmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EnvironmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EnvironmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsTo(obj: EnvironmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EnvironmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EnvironmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EnvironmentSpecWriteConnectionSecretToRef
 */
export interface EnvironmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EnvironmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EnvironmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EnvironmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecWriteConnectionSecretToRef(obj: EnvironmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Agent in dialogflowcx to populate parent.
 *
 * @schema EnvironmentSpecForProviderParentRef
 */
export interface EnvironmentSpecForProviderParentRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecForProviderParentRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecForProviderParentRef#policy
   */
  readonly policy?: EnvironmentSpecForProviderParentRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderParentRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderParentRef(obj: EnvironmentSpecForProviderParentRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecForProviderParentRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Agent in dialogflowcx to populate parent.
 *
 * @schema EnvironmentSpecForProviderParentSelector
 */
export interface EnvironmentSpecForProviderParentSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EnvironmentSpecForProviderParentSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EnvironmentSpecForProviderParentSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EnvironmentSpecForProviderParentSelector#policy
   */
  readonly policy?: EnvironmentSpecForProviderParentSelectorPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderParentSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderParentSelector(obj: EnvironmentSpecForProviderParentSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EnvironmentSpecForProviderParentSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderVersionConfigs
 */
export interface EnvironmentSpecForProviderVersionConfigs {
  /**
   * Format: projects/{{project}}/locations/{{location}}/agents/{{agent}}/flows/{{flow}}/versions/{{version}}.
   *
   * @schema EnvironmentSpecForProviderVersionConfigs#version
   */
  readonly version?: string;

  /**
   * Reference to a Version in dialogflowcx to populate version.
   *
   * @schema EnvironmentSpecForProviderVersionConfigs#versionRef
   */
  readonly versionRef?: EnvironmentSpecForProviderVersionConfigsVersionRef;

  /**
   * Selector for a Version in dialogflowcx to populate version.
   *
   * @schema EnvironmentSpecForProviderVersionConfigs#versionSelector
   */
  readonly versionSelector?: EnvironmentSpecForProviderVersionConfigsVersionSelector;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderVersionConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderVersionConfigs(obj: EnvironmentSpecForProviderVersionConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
    'versionRef': toJson_EnvironmentSpecForProviderVersionConfigsVersionRef(obj.versionRef),
    'versionSelector': toJson_EnvironmentSpecForProviderVersionConfigsVersionSelector(obj.versionSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicy
 */
export interface EnvironmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderConfigRefPolicy(obj: EnvironmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecProviderRefPolicy
 */
export interface EnvironmentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderRefPolicy(obj: EnvironmentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef
 */
export interface EnvironmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToConfigRef(obj: EnvironmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToMetadata
 */
export interface EnvironmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToMetadata(obj: EnvironmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecForProviderParentRefPolicy
 */
export interface EnvironmentSpecForProviderParentRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderParentRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderParentRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderParentRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderParentRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderParentRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderParentRefPolicy(obj: EnvironmentSpecForProviderParentRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EnvironmentSpecForProviderParentSelectorPolicy
 */
export interface EnvironmentSpecForProviderParentSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderParentSelectorPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderParentSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderParentSelectorPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderParentSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderParentSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderParentSelectorPolicy(obj: EnvironmentSpecForProviderParentSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Version in dialogflowcx to populate version.
 *
 * @schema EnvironmentSpecForProviderVersionConfigsVersionRef
 */
export interface EnvironmentSpecForProviderVersionConfigsVersionRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecForProviderVersionConfigsVersionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecForProviderVersionConfigsVersionRef#policy
   */
  readonly policy?: EnvironmentSpecForProviderVersionConfigsVersionRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderVersionConfigsVersionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderVersionConfigsVersionRef(obj: EnvironmentSpecForProviderVersionConfigsVersionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecForProviderVersionConfigsVersionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Version in dialogflowcx to populate version.
 *
 * @schema EnvironmentSpecForProviderVersionConfigsVersionSelector
 */
export interface EnvironmentSpecForProviderVersionConfigsVersionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EnvironmentSpecForProviderVersionConfigsVersionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EnvironmentSpecForProviderVersionConfigsVersionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EnvironmentSpecForProviderVersionConfigsVersionSelector#policy
   */
  readonly policy?: EnvironmentSpecForProviderVersionConfigsVersionSelectorPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderVersionConfigsVersionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderVersionConfigsVersionSelector(obj: EnvironmentSpecForProviderVersionConfigsVersionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EnvironmentSpecForProviderVersionConfigsVersionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicyResolution
 */
export enum EnvironmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicyResolve
 */
export enum EnvironmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecProviderRefPolicyResolution
 */
export enum EnvironmentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecProviderRefPolicyResolve
 */
export enum EnvironmentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderParentRefPolicyResolution
 */
export enum EnvironmentSpecForProviderParentRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderParentRefPolicyResolve
 */
export enum EnvironmentSpecForProviderParentRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderParentSelectorPolicyResolution
 */
export enum EnvironmentSpecForProviderParentSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderParentSelectorPolicyResolve
 */
export enum EnvironmentSpecForProviderParentSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecForProviderVersionConfigsVersionRefPolicy
 */
export interface EnvironmentSpecForProviderVersionConfigsVersionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderVersionConfigsVersionRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderVersionConfigsVersionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderVersionConfigsVersionRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderVersionConfigsVersionRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderVersionConfigsVersionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderVersionConfigsVersionRefPolicy(obj: EnvironmentSpecForProviderVersionConfigsVersionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EnvironmentSpecForProviderVersionConfigsVersionSelectorPolicy
 */
export interface EnvironmentSpecForProviderVersionConfigsVersionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderVersionConfigsVersionSelectorPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderVersionConfigsVersionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderVersionConfigsVersionSelectorPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderVersionConfigsVersionSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderVersionConfigsVersionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderVersionConfigsVersionSelectorPolicy(obj: EnvironmentSpecForProviderVersionConfigsVersionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderVersionConfigsVersionRefPolicyResolution
 */
export enum EnvironmentSpecForProviderVersionConfigsVersionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderVersionConfigsVersionRefPolicyResolve
 */
export enum EnvironmentSpecForProviderVersionConfigsVersionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderVersionConfigsVersionSelectorPolicyResolution
 */
export enum EnvironmentSpecForProviderVersionConfigsVersionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderVersionConfigsVersionSelectorPolicyResolve
 */
export enum EnvironmentSpecForProviderVersionConfigsVersionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Flow is the Schema for the Flows API. Flows represents the conversation flows when you build your chatbot agent.
 *
 * @schema Flow
 */
export class Flow extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Flow"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dialogflowcx.gcp.upbound.io/v1beta1',
    kind: 'Flow',
  }

  /**
   * Renders a Kubernetes manifest for "Flow".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FlowProps): any {
    return {
      ...Flow.GVK,
      ...toJson_FlowProps(props),
    };
  }

  /**
   * Defines a "Flow" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FlowProps) {
    super(scope, id, {
      ...Flow.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Flow.GVK,
      ...toJson_FlowProps(resolved),
    };
  }
}

/**
 * Flow is the Schema for the Flows API. Flows represents the conversation flows when you build your chatbot agent.
 *
 * @schema Flow
 */
export interface FlowProps {
  /**
   * @schema Flow#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FlowSpec defines the desired state of Flow
   *
   * @schema Flow#spec
   */
  readonly spec: FlowSpec;

}

/**
 * Converts an object of type 'FlowProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowProps(obj: FlowProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FlowSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FlowSpec defines the desired state of Flow
 *
 * @schema FlowSpec
 */
export interface FlowSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema FlowSpec#deletionPolicy
   */
  readonly deletionPolicy?: FlowSpecDeletionPolicy;

  /**
   * @schema FlowSpec#forProvider
   */
  readonly forProvider: FlowSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FlowSpec#providerConfigRef
   */
  readonly providerConfigRef?: FlowSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema FlowSpec#providerRef
   */
  readonly providerRef?: FlowSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FlowSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FlowSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FlowSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FlowSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FlowSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpec(obj: FlowSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FlowSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_FlowSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_FlowSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_FlowSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FlowSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema FlowSpecDeletionPolicy
 */
export enum FlowSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FlowSpecForProvider
 */
export interface FlowSpecForProvider {
  /**
   * The description of the flow. The maximum length is 500 characters. If exceeded, the request is rejected.
   *
   * @schema FlowSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The human-readable name of the flow.
   *
   * @schema FlowSpecForProvider#displayName
   */
  readonly displayName: string;

  /**
   * A flow's event handlers serve two purposes: They are responsible for handling events (e.g. no match, webhook errors) in the flow. They are inherited by every page's [event handlers][Page.event_handlers], which can be used to handle common events regardless of the current page. Event handlers defined in the page have higher priority than those defined in the flow. Unlike transitionRoutes, these handlers are evaluated on a first-match basis. The first one that matches the event get executed, with the rest being ignored. Structure is documented below.
   *
   * @schema FlowSpecForProvider#eventHandlers
   */
  readonly eventHandlers?: FlowSpecForProviderEventHandlers[];

  /**
   * The language of the following fields in flow: Flow.event_handlers.trigger_fulfillment.messages Flow.event_handlers.trigger_fulfillment.conditional_cases Flow.transition_routes.trigger_fulfillment.messages Flow.transition_routes.trigger_fulfillment.conditional_cases If not specified, the agent's default language is used. Many languages are supported. Note: languages must be enabled in the agent before they can be used.
   *
   * @schema FlowSpecForProvider#languageCode
   */
  readonly languageCode?: string;

  /**
   * NLU related settings of the flow. Structure is documented below.
   *
   * @schema FlowSpecForProvider#nluSettings
   */
  readonly nluSettings?: FlowSpecForProviderNluSettings[];

  /**
   * The agent to create a flow for. Format: projects//locations//agents/.
   *
   * @schema FlowSpecForProvider#parent
   */
  readonly parent?: string;

  /**
   * Reference to a Agent in dialogflowcx to populate parent.
   *
   * @schema FlowSpecForProvider#parentRef
   */
  readonly parentRef?: FlowSpecForProviderParentRef;

  /**
   * Selector for a Agent in dialogflowcx to populate parent.
   *
   * @schema FlowSpecForProvider#parentSelector
   */
  readonly parentSelector?: FlowSpecForProviderParentSelector;

  /**
   * A flow's transition route group serve two purposes: They are responsible for matching the user's first utterances in the flow. They are inherited by every page's [transition route groups][Page.transition_route_groups]. Transition route groups defined in the page have higher priority than those defined in the flow. Format:projects//locations//agents//flows//transitionRouteGroups/.
   *
   * @schema FlowSpecForProvider#transitionRouteGroups
   */
  readonly transitionRouteGroups?: string[];

  /**
   * A flow's transition routes serve two purposes: They are responsible for matching the user's first utterances in the flow. They are inherited by every page's [transition routes][Page.transition_routes] and can support use cases such as the user saying "help" or "can I talk to a human?", which can be handled in a common way regardless of the current page. Transition routes defined in the page have higher priority than those defined in the flow. TransitionRoutes are evalauted in the following order: TransitionRoutes with intent specified. TransitionRoutes with only condition specified. TransitionRoutes with intent specified are inherited by pages in the flow. Structure is documented below.
   *
   * @schema FlowSpecForProvider#transitionRoutes
   */
  readonly transitionRoutes?: FlowSpecForProviderTransitionRoutes[];

}

/**
 * Converts an object of type 'FlowSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProvider(obj: FlowSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'eventHandlers': obj.eventHandlers?.map(y => toJson_FlowSpecForProviderEventHandlers(y)),
    'languageCode': obj.languageCode,
    'nluSettings': obj.nluSettings?.map(y => toJson_FlowSpecForProviderNluSettings(y)),
    'parent': obj.parent,
    'parentRef': toJson_FlowSpecForProviderParentRef(obj.parentRef),
    'parentSelector': toJson_FlowSpecForProviderParentSelector(obj.parentSelector),
    'transitionRouteGroups': obj.transitionRouteGroups?.map(y => y),
    'transitionRoutes': obj.transitionRoutes?.map(y => toJson_FlowSpecForProviderTransitionRoutes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FlowSpecProviderConfigRef
 */
export interface FlowSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowSpecProviderConfigRef#policy
   */
  readonly policy?: FlowSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FlowSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecProviderConfigRef(obj: FlowSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema FlowSpecProviderRef
 */
export interface FlowSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowSpecProviderRef#policy
   */
  readonly policy?: FlowSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'FlowSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecProviderRef(obj: FlowSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FlowSpecPublishConnectionDetailsTo
 */
export interface FlowSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FlowSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FlowSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FlowSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FlowSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FlowSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FlowSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecPublishConnectionDetailsTo(obj: FlowSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FlowSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FlowSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FlowSpecWriteConnectionSecretToRef
 */
export interface FlowSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FlowSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FlowSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FlowSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecWriteConnectionSecretToRef(obj: FlowSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderEventHandlers
 */
export interface FlowSpecForProviderEventHandlers {
  /**
   * The name of the event to handle.
   *
   * @schema FlowSpecForProviderEventHandlers#event
   */
  readonly event?: string;

  /**
   * The target flow to transition to. Format: projects//locations//agents//flows/.
   *
   * @schema FlowSpecForProviderEventHandlers#targetFlow
   */
  readonly targetFlow?: string;

  /**
   * The target page to transition to. Format: projects//locations//agents//flows//pages/.
   *
   * @schema FlowSpecForProviderEventHandlers#targetPage
   */
  readonly targetPage?: string;

  /**
   * The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks. Structure is documented below.
   *
   * @schema FlowSpecForProviderEventHandlers#triggerFulfillment
   */
  readonly triggerFulfillment?: FlowSpecForProviderEventHandlersTriggerFulfillment[];

}

/**
 * Converts an object of type 'FlowSpecForProviderEventHandlers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderEventHandlers(obj: FlowSpecForProviderEventHandlers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'event': obj.event,
    'targetFlow': obj.targetFlow,
    'targetPage': obj.targetPage,
    'triggerFulfillment': obj.triggerFulfillment?.map(y => toJson_FlowSpecForProviderEventHandlersTriggerFulfillment(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderNluSettings
 */
export interface FlowSpecForProviderNluSettings {
  /**
   * To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
   *
   * @schema FlowSpecForProviderNluSettings#classificationThreshold
   */
  readonly classificationThreshold?: number;

  /**
   * Indicates NLU model training mode.
   *
   * @schema FlowSpecForProviderNluSettings#modelTrainingMode
   */
  readonly modelTrainingMode?: string;

  /**
   * Indicates the type of NLU model.
   *
   * @schema FlowSpecForProviderNluSettings#modelType
   */
  readonly modelType?: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderNluSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderNluSettings(obj: FlowSpecForProviderNluSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'classificationThreshold': obj.classificationThreshold,
    'modelTrainingMode': obj.modelTrainingMode,
    'modelType': obj.modelType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Agent in dialogflowcx to populate parent.
 *
 * @schema FlowSpecForProviderParentRef
 */
export interface FlowSpecForProviderParentRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowSpecForProviderParentRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowSpecForProviderParentRef#policy
   */
  readonly policy?: FlowSpecForProviderParentRefPolicy;

}

/**
 * Converts an object of type 'FlowSpecForProviderParentRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderParentRef(obj: FlowSpecForProviderParentRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowSpecForProviderParentRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Agent in dialogflowcx to populate parent.
 *
 * @schema FlowSpecForProviderParentSelector
 */
export interface FlowSpecForProviderParentSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FlowSpecForProviderParentSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FlowSpecForProviderParentSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FlowSpecForProviderParentSelector#policy
   */
  readonly policy?: FlowSpecForProviderParentSelectorPolicy;

}

/**
 * Converts an object of type 'FlowSpecForProviderParentSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderParentSelector(obj: FlowSpecForProviderParentSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FlowSpecForProviderParentSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderTransitionRoutes
 */
export interface FlowSpecForProviderTransitionRoutes {
  /**
   * The condition to evaluate against form parameters or session parameters. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
   *
   * @schema FlowSpecForProviderTransitionRoutes#condition
   */
  readonly condition?: string;

  /**
   * The unique identifier of an Intent. Format: projects//locations//agents//intents/. Indicates that the transition can only happen when the given intent is matched. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
   *
   * @schema FlowSpecForProviderTransitionRoutes#intent
   */
  readonly intent?: string;

  /**
   * The target flow to transition to. Format: projects//locations//agents//flows/.
   *
   * @schema FlowSpecForProviderTransitionRoutes#targetFlow
   */
  readonly targetFlow?: string;

  /**
   * The target page to transition to. Format: projects//locations//agents//flows//pages/.
   *
   * @schema FlowSpecForProviderTransitionRoutes#targetPage
   */
  readonly targetPage?: string;

  /**
   * The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first. Structure is documented below.
   *
   * @schema FlowSpecForProviderTransitionRoutes#triggerFulfillment
   */
  readonly triggerFulfillment?: FlowSpecForProviderTransitionRoutesTriggerFulfillment[];

}

/**
 * Converts an object of type 'FlowSpecForProviderTransitionRoutes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderTransitionRoutes(obj: FlowSpecForProviderTransitionRoutes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition,
    'intent': obj.intent,
    'targetFlow': obj.targetFlow,
    'targetPage': obj.targetPage,
    'triggerFulfillment': obj.triggerFulfillment?.map(y => toJson_FlowSpecForProviderTransitionRoutesTriggerFulfillment(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FlowSpecProviderConfigRefPolicy
 */
export interface FlowSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FlowSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FlowSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecProviderConfigRefPolicy(obj: FlowSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FlowSpecProviderRefPolicy
 */
export interface FlowSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowSpecProviderRefPolicy#resolution
   */
  readonly resolution?: FlowSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowSpecProviderRefPolicy#resolve
   */
  readonly resolve?: FlowSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecProviderRefPolicy(obj: FlowSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FlowSpecPublishConnectionDetailsToConfigRef
 */
export interface FlowSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FlowSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FlowSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecPublishConnectionDetailsToConfigRef(obj: FlowSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FlowSpecPublishConnectionDetailsToMetadata
 */
export interface FlowSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FlowSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FlowSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FlowSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FlowSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecPublishConnectionDetailsToMetadata(obj: FlowSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderEventHandlersTriggerFulfillment
 */
export interface FlowSpecForProviderEventHandlersTriggerFulfillment {
  /**
   * The list of rich message responses to present to the user. Structure is documented below.
   *
   * @schema FlowSpecForProviderEventHandlersTriggerFulfillment#messages
   */
  readonly messages?: FlowSpecForProviderEventHandlersTriggerFulfillmentMessages[];

  /**
   * Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
   *
   * @schema FlowSpecForProviderEventHandlersTriggerFulfillment#returnPartialResponses
   */
  readonly returnPartialResponses?: boolean;

  /**
   * The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
   *
   * @schema FlowSpecForProviderEventHandlersTriggerFulfillment#tag
   */
  readonly tag?: string;

  /**
   * The webhook to call. Format: projects//locations//agents//webhooks/.
   *
   * @schema FlowSpecForProviderEventHandlersTriggerFulfillment#webhook
   */
  readonly webhook?: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderEventHandlersTriggerFulfillment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderEventHandlersTriggerFulfillment(obj: FlowSpecForProviderEventHandlersTriggerFulfillment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'messages': obj.messages?.map(y => toJson_FlowSpecForProviderEventHandlersTriggerFulfillmentMessages(y)),
    'returnPartialResponses': obj.returnPartialResponses,
    'tag': obj.tag,
    'webhook': obj.webhook,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FlowSpecForProviderParentRefPolicy
 */
export interface FlowSpecForProviderParentRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowSpecForProviderParentRefPolicy#resolution
   */
  readonly resolution?: FlowSpecForProviderParentRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowSpecForProviderParentRefPolicy#resolve
   */
  readonly resolve?: FlowSpecForProviderParentRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowSpecForProviderParentRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderParentRefPolicy(obj: FlowSpecForProviderParentRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FlowSpecForProviderParentSelectorPolicy
 */
export interface FlowSpecForProviderParentSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowSpecForProviderParentSelectorPolicy#resolution
   */
  readonly resolution?: FlowSpecForProviderParentSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowSpecForProviderParentSelectorPolicy#resolve
   */
  readonly resolve?: FlowSpecForProviderParentSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FlowSpecForProviderParentSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderParentSelectorPolicy(obj: FlowSpecForProviderParentSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderTransitionRoutesTriggerFulfillment
 */
export interface FlowSpecForProviderTransitionRoutesTriggerFulfillment {
  /**
   * The list of rich message responses to present to the user. Structure is documented below.
   *
   * @schema FlowSpecForProviderTransitionRoutesTriggerFulfillment#messages
   */
  readonly messages?: FlowSpecForProviderTransitionRoutesTriggerFulfillmentMessages[];

  /**
   * Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
   *
   * @schema FlowSpecForProviderTransitionRoutesTriggerFulfillment#returnPartialResponses
   */
  readonly returnPartialResponses?: boolean;

  /**
   * The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
   *
   * @schema FlowSpecForProviderTransitionRoutesTriggerFulfillment#tag
   */
  readonly tag?: string;

  /**
   * The webhook to call. Format: projects//locations//agents//webhooks/.
   *
   * @schema FlowSpecForProviderTransitionRoutesTriggerFulfillment#webhook
   */
  readonly webhook?: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderTransitionRoutesTriggerFulfillment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderTransitionRoutesTriggerFulfillment(obj: FlowSpecForProviderTransitionRoutesTriggerFulfillment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'messages': obj.messages?.map(y => toJson_FlowSpecForProviderTransitionRoutesTriggerFulfillmentMessages(y)),
    'returnPartialResponses': obj.returnPartialResponses,
    'tag': obj.tag,
    'webhook': obj.webhook,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowSpecProviderConfigRefPolicyResolution
 */
export enum FlowSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowSpecProviderConfigRefPolicyResolve
 */
export enum FlowSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowSpecProviderRefPolicyResolution
 */
export enum FlowSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowSpecProviderRefPolicyResolve
 */
export enum FlowSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FlowSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FlowSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FlowSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FlowSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecPublishConnectionDetailsToConfigRefPolicy(obj: FlowSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderEventHandlersTriggerFulfillmentMessages
 */
export interface FlowSpecForProviderEventHandlersTriggerFulfillmentMessages {
  /**
   * A collection of text responses.
   *
   * @schema FlowSpecForProviderEventHandlersTriggerFulfillmentMessages#text
   */
  readonly text?: FlowSpecForProviderEventHandlersTriggerFulfillmentMessagesText[];

}

/**
 * Converts an object of type 'FlowSpecForProviderEventHandlersTriggerFulfillmentMessages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderEventHandlersTriggerFulfillmentMessages(obj: FlowSpecForProviderEventHandlersTriggerFulfillmentMessages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'text': obj.text?.map(y => toJson_FlowSpecForProviderEventHandlersTriggerFulfillmentMessagesText(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowSpecForProviderParentRefPolicyResolution
 */
export enum FlowSpecForProviderParentRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowSpecForProviderParentRefPolicyResolve
 */
export enum FlowSpecForProviderParentRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowSpecForProviderParentSelectorPolicyResolution
 */
export enum FlowSpecForProviderParentSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowSpecForProviderParentSelectorPolicyResolve
 */
export enum FlowSpecForProviderParentSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema FlowSpecForProviderTransitionRoutesTriggerFulfillmentMessages
 */
export interface FlowSpecForProviderTransitionRoutesTriggerFulfillmentMessages {
  /**
   * A collection of text responses.
   *
   * @schema FlowSpecForProviderTransitionRoutesTriggerFulfillmentMessages#text
   */
  readonly text?: FlowSpecForProviderTransitionRoutesTriggerFulfillmentMessagesText[];

}

/**
 * Converts an object of type 'FlowSpecForProviderTransitionRoutesTriggerFulfillmentMessages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderTransitionRoutesTriggerFulfillmentMessages(obj: FlowSpecForProviderTransitionRoutesTriggerFulfillmentMessages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'text': obj.text?.map(y => toJson_FlowSpecForProviderTransitionRoutesTriggerFulfillmentMessagesText(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FlowSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FlowSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema FlowSpecForProviderEventHandlersTriggerFulfillmentMessagesText
 */
export interface FlowSpecForProviderEventHandlersTriggerFulfillmentMessagesText {
  /**
   * A collection of text responses.
   *
   * @schema FlowSpecForProviderEventHandlersTriggerFulfillmentMessagesText#text
   */
  readonly text?: string[];

}

/**
 * Converts an object of type 'FlowSpecForProviderEventHandlersTriggerFulfillmentMessagesText' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderEventHandlersTriggerFulfillmentMessagesText(obj: FlowSpecForProviderEventHandlersTriggerFulfillmentMessagesText | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'text': obj.text?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderTransitionRoutesTriggerFulfillmentMessagesText
 */
export interface FlowSpecForProviderTransitionRoutesTriggerFulfillmentMessagesText {
  /**
   * A collection of text responses.
   *
   * @schema FlowSpecForProviderTransitionRoutesTriggerFulfillmentMessagesText#text
   */
  readonly text?: string[];

}

/**
 * Converts an object of type 'FlowSpecForProviderTransitionRoutesTriggerFulfillmentMessagesText' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderTransitionRoutesTriggerFulfillmentMessagesText(obj: FlowSpecForProviderTransitionRoutesTriggerFulfillmentMessagesText | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'text': obj.text?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Intent is the Schema for the Intents API. An intent represents a user's intent to interact with a conversational agent.
 *
 * @schema Intent
 */
export class Intent extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Intent"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dialogflowcx.gcp.upbound.io/v1beta1',
    kind: 'Intent',
  }

  /**
   * Renders a Kubernetes manifest for "Intent".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IntentProps): any {
    return {
      ...Intent.GVK,
      ...toJson_IntentProps(props),
    };
  }

  /**
   * Defines a "Intent" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IntentProps) {
    super(scope, id, {
      ...Intent.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Intent.GVK,
      ...toJson_IntentProps(resolved),
    };
  }
}

/**
 * Intent is the Schema for the Intents API. An intent represents a user's intent to interact with a conversational agent.
 *
 * @schema Intent
 */
export interface IntentProps {
  /**
   * @schema Intent#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IntentSpec defines the desired state of Intent
   *
   * @schema Intent#spec
   */
  readonly spec: IntentSpec;

}

/**
 * Converts an object of type 'IntentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentProps(obj: IntentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IntentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IntentSpec defines the desired state of Intent
 *
 * @schema IntentSpec
 */
export interface IntentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema IntentSpec#deletionPolicy
   */
  readonly deletionPolicy?: IntentSpecDeletionPolicy;

  /**
   * @schema IntentSpec#forProvider
   */
  readonly forProvider: IntentSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IntentSpec#providerConfigRef
   */
  readonly providerConfigRef?: IntentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema IntentSpec#providerRef
   */
  readonly providerRef?: IntentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IntentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IntentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IntentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IntentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IntentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpec(obj: IntentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IntentSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_IntentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_IntentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_IntentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IntentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema IntentSpecDeletionPolicy
 */
export enum IntentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema IntentSpecForProvider
 */
export interface IntentSpecForProvider {
  /**
   * Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
   *
   * @schema IntentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The human-readable name of the intent, unique within the agent.
   *
   * @schema IntentSpecForProvider#displayName
   */
  readonly displayName: string;

  /**
   * Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
   *
   * @schema IntentSpecForProvider#isFallback
   */
  readonly isFallback?: boolean;

  /**
   * The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols '-' and '_'. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix "sys-" is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. "sys-head" means the intent is a head intent. "sys.contextual" means the intent is a contextual intent. An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
   *
   * @schema IntentSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The language of the following fields in intent: Intent.training_phrases.parts.text If not specified, the agent's default language is used. Many languages are supported. Note: languages must be enabled in the agent before they can be used.
   *
   * @schema IntentSpecForProvider#languageCode
   */
  readonly languageCode?: string;

  /**
   * The collection of parameters associated with the intent. Structure is documented below.
   *
   * @schema IntentSpecForProvider#parameters
   */
  readonly parameters?: IntentSpecForProviderParameters[];

  /**
   * The agent to create an intent for. Format: projects//locations//agents/.
   *
   * @schema IntentSpecForProvider#parent
   */
  readonly parent?: string;

  /**
   * Reference to a Agent in dialogflowcx to populate parent.
   *
   * @schema IntentSpecForProvider#parentRef
   */
  readonly parentRef?: IntentSpecForProviderParentRef;

  /**
   * Selector for a Agent in dialogflowcx to populate parent.
   *
   * @schema IntentSpecForProvider#parentSelector
   */
  readonly parentSelector?: IntentSpecForProviderParentSelector;

  /**
   * The priority of this intent. Higher numbers represent higher priorities. If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the Normal priority in the console. If the supplied value is negative, the intent is ignored in runtime detect intent requests.
   *
   * @schema IntentSpecForProvider#priority
   */
  readonly priority?: number;

  /**
   * The collection of training phrases the agent is trained on to identify the intent. Structure is documented below.
   *
   * @schema IntentSpecForProvider#trainingPhrases
   */
  readonly trainingPhrases?: IntentSpecForProviderTrainingPhrases[];

}

/**
 * Converts an object of type 'IntentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProvider(obj: IntentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'isFallback': obj.isFallback,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'languageCode': obj.languageCode,
    'parameters': obj.parameters?.map(y => toJson_IntentSpecForProviderParameters(y)),
    'parent': obj.parent,
    'parentRef': toJson_IntentSpecForProviderParentRef(obj.parentRef),
    'parentSelector': toJson_IntentSpecForProviderParentSelector(obj.parentSelector),
    'priority': obj.priority,
    'trainingPhrases': obj.trainingPhrases?.map(y => toJson_IntentSpecForProviderTrainingPhrases(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IntentSpecProviderConfigRef
 */
export interface IntentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntentSpecProviderConfigRef#policy
   */
  readonly policy?: IntentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IntentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecProviderConfigRef(obj: IntentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema IntentSpecProviderRef
 */
export interface IntentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntentSpecProviderRef#policy
   */
  readonly policy?: IntentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'IntentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecProviderRef(obj: IntentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IntentSpecPublishConnectionDetailsTo
 */
export interface IntentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IntentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IntentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IntentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IntentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IntentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IntentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecPublishConnectionDetailsTo(obj: IntentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IntentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IntentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IntentSpecWriteConnectionSecretToRef
 */
export interface IntentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IntentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IntentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IntentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecWriteConnectionSecretToRef(obj: IntentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderParameters
 */
export interface IntentSpecForProviderParameters {
  /**
   * The entity type of the parameter. Format: projects/-/locations/-/agents/-/entityTypes/ for system entity types (for example, projects/-/locations/-/agents/-/entityTypes/sys.date), or projects//locations//agents//entityTypes/ for developer entity types.
   *
   * @schema IntentSpecForProviderParameters#entityType
   */
  readonly entityType: string;

  /**
   * The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
   *
   * @schema IntentSpecForProviderParameters#id
   */
  readonly id: string;

  /**
   * Indicates whether the parameter represents a list of values.
   *
   * @schema IntentSpecForProviderParameters#isList
   */
  readonly isList?: boolean;

  /**
   * Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
   *
   * @schema IntentSpecForProviderParameters#redact
   */
  readonly redact?: boolean;

}

/**
 * Converts an object of type 'IntentSpecForProviderParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderParameters(obj: IntentSpecForProviderParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entityType': obj.entityType,
    'id': obj.id,
    'isList': obj.isList,
    'redact': obj.redact,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Agent in dialogflowcx to populate parent.
 *
 * @schema IntentSpecForProviderParentRef
 */
export interface IntentSpecForProviderParentRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntentSpecForProviderParentRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntentSpecForProviderParentRef#policy
   */
  readonly policy?: IntentSpecForProviderParentRefPolicy;

}

/**
 * Converts an object of type 'IntentSpecForProviderParentRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderParentRef(obj: IntentSpecForProviderParentRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntentSpecForProviderParentRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Agent in dialogflowcx to populate parent.
 *
 * @schema IntentSpecForProviderParentSelector
 */
export interface IntentSpecForProviderParentSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntentSpecForProviderParentSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntentSpecForProviderParentSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntentSpecForProviderParentSelector#policy
   */
  readonly policy?: IntentSpecForProviderParentSelectorPolicy;

}

/**
 * Converts an object of type 'IntentSpecForProviderParentSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderParentSelector(obj: IntentSpecForProviderParentSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntentSpecForProviderParentSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderTrainingPhrases
 */
export interface IntentSpecForProviderTrainingPhrases {
  /**
   * The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: Part.text is set to a part of the phrase that has no parameters. Part.text is set to a part of the phrase that you want to annotate, and the parameterId field is set. Structure is documented below.
   *
   * @schema IntentSpecForProviderTrainingPhrases#parts
   */
  readonly parts: IntentSpecForProviderTrainingPhrasesParts[];

  /**
   * Indicates how many times this example was added to the intent.
   *
   * @schema IntentSpecForProviderTrainingPhrases#repeatCount
   */
  readonly repeatCount?: number;

}

/**
 * Converts an object of type 'IntentSpecForProviderTrainingPhrases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderTrainingPhrases(obj: IntentSpecForProviderTrainingPhrases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parts': obj.parts?.map(y => toJson_IntentSpecForProviderTrainingPhrasesParts(y)),
    'repeatCount': obj.repeatCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntentSpecProviderConfigRefPolicy
 */
export interface IntentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IntentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IntentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecProviderConfigRefPolicy(obj: IntentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntentSpecProviderRefPolicy
 */
export interface IntentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: IntentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: IntentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'IntentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecProviderRefPolicy(obj: IntentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IntentSpecPublishConnectionDetailsToConfigRef
 */
export interface IntentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IntentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IntentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecPublishConnectionDetailsToConfigRef(obj: IntentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IntentSpecPublishConnectionDetailsToMetadata
 */
export interface IntentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IntentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IntentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecPublishConnectionDetailsToMetadata(obj: IntentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntentSpecForProviderParentRefPolicy
 */
export interface IntentSpecForProviderParentRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntentSpecForProviderParentRefPolicy#resolution
   */
  readonly resolution?: IntentSpecForProviderParentRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntentSpecForProviderParentRefPolicy#resolve
   */
  readonly resolve?: IntentSpecForProviderParentRefPolicyResolve;

}

/**
 * Converts an object of type 'IntentSpecForProviderParentRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderParentRefPolicy(obj: IntentSpecForProviderParentRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntentSpecForProviderParentSelectorPolicy
 */
export interface IntentSpecForProviderParentSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntentSpecForProviderParentSelectorPolicy#resolution
   */
  readonly resolution?: IntentSpecForProviderParentSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntentSpecForProviderParentSelectorPolicy#resolve
   */
  readonly resolve?: IntentSpecForProviderParentSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntentSpecForProviderParentSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderParentSelectorPolicy(obj: IntentSpecForProviderParentSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntentSpecForProviderTrainingPhrasesParts
 */
export interface IntentSpecForProviderTrainingPhrasesParts {
  /**
   * The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
   *
   * @schema IntentSpecForProviderTrainingPhrasesParts#parameterId
   */
  readonly parameterId?: string;

  /**
   * The text for this part.
   *
   * @schema IntentSpecForProviderTrainingPhrasesParts#text
   */
  readonly text: string;

}

/**
 * Converts an object of type 'IntentSpecForProviderTrainingPhrasesParts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecForProviderTrainingPhrasesParts(obj: IntentSpecForProviderTrainingPhrasesParts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterId': obj.parameterId,
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntentSpecProviderConfigRefPolicyResolution
 */
export enum IntentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntentSpecProviderConfigRefPolicyResolve
 */
export enum IntentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntentSpecProviderRefPolicyResolution
 */
export enum IntentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntentSpecProviderRefPolicyResolve
 */
export enum IntentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IntentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IntentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IntentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IntentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntentSpecPublishConnectionDetailsToConfigRefPolicy(obj: IntentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntentSpecForProviderParentRefPolicyResolution
 */
export enum IntentSpecForProviderParentRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntentSpecForProviderParentRefPolicyResolve
 */
export enum IntentSpecForProviderParentRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntentSpecForProviderParentSelectorPolicyResolution
 */
export enum IntentSpecForProviderParentSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntentSpecForProviderParentSelectorPolicyResolve
 */
export enum IntentSpecForProviderParentSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IntentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IntentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Page is the Schema for the Pages API. A Dialogflow CX conversation (session) can be described and visualized as a state machine.
 *
 * @schema Page
 */
export class Page extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Page"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dialogflowcx.gcp.upbound.io/v1beta1',
    kind: 'Page',
  }

  /**
   * Renders a Kubernetes manifest for "Page".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PageProps): any {
    return {
      ...Page.GVK,
      ...toJson_PageProps(props),
    };
  }

  /**
   * Defines a "Page" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PageProps) {
    super(scope, id, {
      ...Page.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Page.GVK,
      ...toJson_PageProps(resolved),
    };
  }
}

/**
 * Page is the Schema for the Pages API. A Dialogflow CX conversation (session) can be described and visualized as a state machine.
 *
 * @schema Page
 */
export interface PageProps {
  /**
   * @schema Page#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PageSpec defines the desired state of Page
   *
   * @schema Page#spec
   */
  readonly spec: PageSpec;

}

/**
 * Converts an object of type 'PageProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageProps(obj: PageProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PageSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PageSpec defines the desired state of Page
 *
 * @schema PageSpec
 */
export interface PageSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema PageSpec#deletionPolicy
   */
  readonly deletionPolicy?: PageSpecDeletionPolicy;

  /**
   * @schema PageSpec#forProvider
   */
  readonly forProvider: PageSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PageSpec#providerConfigRef
   */
  readonly providerConfigRef?: PageSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PageSpec#providerRef
   */
  readonly providerRef?: PageSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PageSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PageSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PageSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PageSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PageSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpec(obj: PageSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PageSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_PageSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PageSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PageSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PageSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema PageSpecDeletionPolicy
 */
export enum PageSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PageSpecForProvider
 */
export interface PageSpecForProvider {
  /**
   * The human-readable name of the page, unique within the agent.
   *
   * @schema PageSpecForProvider#displayName
   */
  readonly displayName: string;

  /**
   * The fulfillment to call when the session is entering the page. Structure is documented below.
   *
   * @schema PageSpecForProvider#entryFulfillment
   */
  readonly entryFulfillment?: PageSpecForProviderEntryFulfillment[];

  /**
   * Handlers associated with the page to handle events such as webhook errors, no match or no input. Structure is documented below.
   *
   * @schema PageSpecForProvider#eventHandlers
   */
  readonly eventHandlers?: PageSpecForProviderEventHandlers[];

  /**
   * The form associated with the page, used for collecting parameters relevant to the page. Structure is documented below.
   *
   * @schema PageSpecForProvider#form
   */
  readonly form?: PageSpecForProviderForm[];

  /**
   * The language of the following fields in page: Page.entry_fulfillment.messages Page.entry_fulfillment.conditional_cases Page.event_handlers.trigger_fulfillment.messages Page.event_handlers.trigger_fulfillment.conditional_cases Page.form.parameters.fill_behavior.initial_prompt_fulfillment.messages Page.form.parameters.fill_behavior.initial_prompt_fulfillment.conditional_cases Page.form.parameters.fill_behavior.reprompt_event_handlers.messages Page.form.parameters.fill_behavior.reprompt_event_handlers.conditional_cases Page.transition_routes.trigger_fulfillment.messages Page.transition_routes.trigger_fulfillment.conditional_cases If not specified, the agent's default language is used. Many languages are supported. Note: languages must be enabled in the agent before they can be used.
   *
   * @schema PageSpecForProvider#languageCode
   */
  readonly languageCode?: string;

  /**
   * The flow to create a page for. Format: projects//locations//agents//flows/.
   *
   * @schema PageSpecForProvider#parent
   */
  readonly parent?: string;

  /**
   * Reference to a Agent in dialogflowcx to populate parent.
   *
   * @schema PageSpecForProvider#parentRef
   */
  readonly parentRef?: PageSpecForProviderParentRef;

  /**
   * Selector for a Agent in dialogflowcx to populate parent.
   *
   * @schema PageSpecForProvider#parentSelector
   */
  readonly parentSelector?: PageSpecForProviderParentSelector;

  /**
   * Ordered list of TransitionRouteGroups associated with the page. Transition route groups must be unique within a page. If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page's transition route -> page's transition route group -> flow's transition routes. If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:projects//locations//agents//flows//transitionRouteGroups/.
   *
   * @schema PageSpecForProvider#transitionRouteGroups
   */
  readonly transitionRouteGroups?: string[];

  /**
   * A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: TransitionRoutes defined in the page with intent specified. TransitionRoutes defined in the transition route groups with intent specified. TransitionRoutes defined in flow with intent specified. TransitionRoutes defined in the transition route groups with intent specified. TransitionRoutes defined in the page with only condition specified. TransitionRoutes defined in the transition route groups with only condition specified. Structure is documented below.
   *
   * @schema PageSpecForProvider#transitionRoutes
   */
  readonly transitionRoutes?: PageSpecForProviderTransitionRoutes[];

}

/**
 * Converts an object of type 'PageSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProvider(obj: PageSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'entryFulfillment': obj.entryFulfillment?.map(y => toJson_PageSpecForProviderEntryFulfillment(y)),
    'eventHandlers': obj.eventHandlers?.map(y => toJson_PageSpecForProviderEventHandlers(y)),
    'form': obj.form?.map(y => toJson_PageSpecForProviderForm(y)),
    'languageCode': obj.languageCode,
    'parent': obj.parent,
    'parentRef': toJson_PageSpecForProviderParentRef(obj.parentRef),
    'parentSelector': toJson_PageSpecForProviderParentSelector(obj.parentSelector),
    'transitionRouteGroups': obj.transitionRouteGroups?.map(y => y),
    'transitionRoutes': obj.transitionRoutes?.map(y => toJson_PageSpecForProviderTransitionRoutes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PageSpecProviderConfigRef
 */
export interface PageSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PageSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PageSpecProviderConfigRef#policy
   */
  readonly policy?: PageSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PageSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecProviderConfigRef(obj: PageSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PageSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PageSpecProviderRef
 */
export interface PageSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PageSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PageSpecProviderRef#policy
   */
  readonly policy?: PageSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PageSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecProviderRef(obj: PageSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PageSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PageSpecPublishConnectionDetailsTo
 */
export interface PageSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PageSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PageSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PageSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PageSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PageSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PageSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecPublishConnectionDetailsTo(obj: PageSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PageSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PageSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PageSpecWriteConnectionSecretToRef
 */
export interface PageSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PageSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PageSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PageSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecWriteConnectionSecretToRef(obj: PageSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PageSpecForProviderEntryFulfillment
 */
export interface PageSpecForProviderEntryFulfillment {
  /**
   * The list of rich message responses to present to the user. Structure is documented below.
   *
   * @schema PageSpecForProviderEntryFulfillment#messages
   */
  readonly messages?: PageSpecForProviderEntryFulfillmentMessages[];

  /**
   * Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
   *
   * @schema PageSpecForProviderEntryFulfillment#returnPartialResponses
   */
  readonly returnPartialResponses?: boolean;

  /**
   * The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
   *
   * @schema PageSpecForProviderEntryFulfillment#tag
   */
  readonly tag?: string;

  /**
   * The webhook to call. Format: projects//locations//agents//webhooks/.
   *
   * @schema PageSpecForProviderEntryFulfillment#webhook
   */
  readonly webhook?: string;

}

/**
 * Converts an object of type 'PageSpecForProviderEntryFulfillment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderEntryFulfillment(obj: PageSpecForProviderEntryFulfillment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'messages': obj.messages?.map(y => toJson_PageSpecForProviderEntryFulfillmentMessages(y)),
    'returnPartialResponses': obj.returnPartialResponses,
    'tag': obj.tag,
    'webhook': obj.webhook,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PageSpecForProviderEventHandlers
 */
export interface PageSpecForProviderEventHandlers {
  /**
   * The name of the event to handle.
   *
   * @schema PageSpecForProviderEventHandlers#event
   */
  readonly event?: string;

  /**
   * The target flow to transition to. Format: projects//locations//agents//flows/.
   *
   * @schema PageSpecForProviderEventHandlers#targetFlow
   */
  readonly targetFlow?: string;

  /**
   * The target page to transition to. Format: projects//locations//agents//flows//pages/.
   *
   * @schema PageSpecForProviderEventHandlers#targetPage
   */
  readonly targetPage?: string;

  /**
   * The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks. Structure is documented below.
   *
   * @schema PageSpecForProviderEventHandlers#triggerFulfillment
   */
  readonly triggerFulfillment?: PageSpecForProviderEventHandlersTriggerFulfillment[];

}

/**
 * Converts an object of type 'PageSpecForProviderEventHandlers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderEventHandlers(obj: PageSpecForProviderEventHandlers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'event': obj.event,
    'targetFlow': obj.targetFlow,
    'targetPage': obj.targetPage,
    'triggerFulfillment': obj.triggerFulfillment?.map(y => toJson_PageSpecForProviderEventHandlersTriggerFulfillment(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PageSpecForProviderForm
 */
export interface PageSpecForProviderForm {
  /**
   * Parameters to collect from the user. Structure is documented below.
   *
   * @schema PageSpecForProviderForm#parameters
   */
  readonly parameters?: PageSpecForProviderFormParameters[];

}

/**
 * Converts an object of type 'PageSpecForProviderForm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderForm(obj: PageSpecForProviderForm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameters': obj.parameters?.map(y => toJson_PageSpecForProviderFormParameters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Agent in dialogflowcx to populate parent.
 *
 * @schema PageSpecForProviderParentRef
 */
export interface PageSpecForProviderParentRef {
  /**
   * Name of the referenced object.
   *
   * @schema PageSpecForProviderParentRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PageSpecForProviderParentRef#policy
   */
  readonly policy?: PageSpecForProviderParentRefPolicy;

}

/**
 * Converts an object of type 'PageSpecForProviderParentRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderParentRef(obj: PageSpecForProviderParentRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PageSpecForProviderParentRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Agent in dialogflowcx to populate parent.
 *
 * @schema PageSpecForProviderParentSelector
 */
export interface PageSpecForProviderParentSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PageSpecForProviderParentSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PageSpecForProviderParentSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PageSpecForProviderParentSelector#policy
   */
  readonly policy?: PageSpecForProviderParentSelectorPolicy;

}

/**
 * Converts an object of type 'PageSpecForProviderParentSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderParentSelector(obj: PageSpecForProviderParentSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PageSpecForProviderParentSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PageSpecForProviderTransitionRoutes
 */
export interface PageSpecForProviderTransitionRoutes {
  /**
   * The condition to evaluate against form parameters or session parameters. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
   *
   * @schema PageSpecForProviderTransitionRoutes#condition
   */
  readonly condition?: string;

  /**
   * The unique identifier of an Intent. Format: projects//locations//agents//intents/. Indicates that the transition can only happen when the given intent is matched. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
   *
   * @schema PageSpecForProviderTransitionRoutes#intent
   */
  readonly intent?: string;

  /**
   * The target flow to transition to. Format: projects//locations//agents//flows/.
   *
   * @schema PageSpecForProviderTransitionRoutes#targetFlow
   */
  readonly targetFlow?: string;

  /**
   * The target page to transition to. Format: projects//locations//agents//flows//pages/.
   *
   * @schema PageSpecForProviderTransitionRoutes#targetPage
   */
  readonly targetPage?: string;

  /**
   * Reference to a Page in dialogflowcx to populate targetPage.
   *
   * @schema PageSpecForProviderTransitionRoutes#targetPageRef
   */
  readonly targetPageRef?: PageSpecForProviderTransitionRoutesTargetPageRef;

  /**
   * Selector for a Page in dialogflowcx to populate targetPage.
   *
   * @schema PageSpecForProviderTransitionRoutes#targetPageSelector
   */
  readonly targetPageSelector?: PageSpecForProviderTransitionRoutesTargetPageSelector;

  /**
   * The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks. Structure is documented below.
   *
   * @schema PageSpecForProviderTransitionRoutes#triggerFulfillment
   */
  readonly triggerFulfillment?: PageSpecForProviderTransitionRoutesTriggerFulfillment[];

}

/**
 * Converts an object of type 'PageSpecForProviderTransitionRoutes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderTransitionRoutes(obj: PageSpecForProviderTransitionRoutes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition,
    'intent': obj.intent,
    'targetFlow': obj.targetFlow,
    'targetPage': obj.targetPage,
    'targetPageRef': toJson_PageSpecForProviderTransitionRoutesTargetPageRef(obj.targetPageRef),
    'targetPageSelector': toJson_PageSpecForProviderTransitionRoutesTargetPageSelector(obj.targetPageSelector),
    'triggerFulfillment': obj.triggerFulfillment?.map(y => toJson_PageSpecForProviderTransitionRoutesTriggerFulfillment(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PageSpecProviderConfigRefPolicy
 */
export interface PageSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PageSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PageSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PageSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PageSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PageSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecProviderConfigRefPolicy(obj: PageSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PageSpecProviderRefPolicy
 */
export interface PageSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PageSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PageSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PageSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PageSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PageSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecProviderRefPolicy(obj: PageSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PageSpecPublishConnectionDetailsToConfigRef
 */
export interface PageSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PageSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PageSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PageSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PageSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecPublishConnectionDetailsToConfigRef(obj: PageSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PageSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PageSpecPublishConnectionDetailsToMetadata
 */
export interface PageSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PageSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PageSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PageSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PageSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecPublishConnectionDetailsToMetadata(obj: PageSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PageSpecForProviderEntryFulfillmentMessages
 */
export interface PageSpecForProviderEntryFulfillmentMessages {
  /**
   * A collection of text responses.
   *
   * @schema PageSpecForProviderEntryFulfillmentMessages#text
   */
  readonly text?: PageSpecForProviderEntryFulfillmentMessagesText[];

}

/**
 * Converts an object of type 'PageSpecForProviderEntryFulfillmentMessages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderEntryFulfillmentMessages(obj: PageSpecForProviderEntryFulfillmentMessages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'text': obj.text?.map(y => toJson_PageSpecForProviderEntryFulfillmentMessagesText(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PageSpecForProviderEventHandlersTriggerFulfillment
 */
export interface PageSpecForProviderEventHandlersTriggerFulfillment {
  /**
   * The list of rich message responses to present to the user. Structure is documented below.
   *
   * @schema PageSpecForProviderEventHandlersTriggerFulfillment#messages
   */
  readonly messages?: PageSpecForProviderEventHandlersTriggerFulfillmentMessages[];

  /**
   * Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
   *
   * @schema PageSpecForProviderEventHandlersTriggerFulfillment#returnPartialResponses
   */
  readonly returnPartialResponses?: boolean;

  /**
   * The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
   *
   * @schema PageSpecForProviderEventHandlersTriggerFulfillment#tag
   */
  readonly tag?: string;

  /**
   * The webhook to call. Format: projects//locations//agents//webhooks/.
   *
   * @schema PageSpecForProviderEventHandlersTriggerFulfillment#webhook
   */
  readonly webhook?: string;

}

/**
 * Converts an object of type 'PageSpecForProviderEventHandlersTriggerFulfillment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderEventHandlersTriggerFulfillment(obj: PageSpecForProviderEventHandlersTriggerFulfillment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'messages': obj.messages?.map(y => toJson_PageSpecForProviderEventHandlersTriggerFulfillmentMessages(y)),
    'returnPartialResponses': obj.returnPartialResponses,
    'tag': obj.tag,
    'webhook': obj.webhook,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PageSpecForProviderFormParameters
 */
export interface PageSpecForProviderFormParameters {
  /**
   * The human-readable name of the parameter, unique within the form.
   *
   * @schema PageSpecForProviderFormParameters#displayName
   */
  readonly displayName?: string;

  /**
   * The entity type of the parameter. Format: projects/-/locations/-/agents/-/entityTypes/ for system entity types (for example, projects/-/locations/-/agents/-/entityTypes/sys.date), or projects//locations//agents//entityTypes/ for developer entity types.
   *
   * @schema PageSpecForProviderFormParameters#entityType
   */
  readonly entityType?: string;

  /**
   * Defines fill behavior for the parameter. Structure is documented below.
   *
   * @schema PageSpecForProviderFormParameters#fillBehavior
   */
  readonly fillBehavior?: PageSpecForProviderFormParametersFillBehavior[];

  /**
   * Indicates whether the parameter represents a list of values.
   *
   * @schema PageSpecForProviderFormParameters#isList
   */
  readonly isList?: boolean;

  /**
   * Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
   *
   * @schema PageSpecForProviderFormParameters#redact
   */
  readonly redact?: boolean;

  /**
   * Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
   *
   * @schema PageSpecForProviderFormParameters#required
   */
  readonly required?: boolean;

}

/**
 * Converts an object of type 'PageSpecForProviderFormParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderFormParameters(obj: PageSpecForProviderFormParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'entityType': obj.entityType,
    'fillBehavior': obj.fillBehavior?.map(y => toJson_PageSpecForProviderFormParametersFillBehavior(y)),
    'isList': obj.isList,
    'redact': obj.redact,
    'required': obj.required,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PageSpecForProviderParentRefPolicy
 */
export interface PageSpecForProviderParentRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PageSpecForProviderParentRefPolicy#resolution
   */
  readonly resolution?: PageSpecForProviderParentRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PageSpecForProviderParentRefPolicy#resolve
   */
  readonly resolve?: PageSpecForProviderParentRefPolicyResolve;

}

/**
 * Converts an object of type 'PageSpecForProviderParentRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderParentRefPolicy(obj: PageSpecForProviderParentRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PageSpecForProviderParentSelectorPolicy
 */
export interface PageSpecForProviderParentSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PageSpecForProviderParentSelectorPolicy#resolution
   */
  readonly resolution?: PageSpecForProviderParentSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PageSpecForProviderParentSelectorPolicy#resolve
   */
  readonly resolve?: PageSpecForProviderParentSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PageSpecForProviderParentSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderParentSelectorPolicy(obj: PageSpecForProviderParentSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Page in dialogflowcx to populate targetPage.
 *
 * @schema PageSpecForProviderTransitionRoutesTargetPageRef
 */
export interface PageSpecForProviderTransitionRoutesTargetPageRef {
  /**
   * Name of the referenced object.
   *
   * @schema PageSpecForProviderTransitionRoutesTargetPageRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PageSpecForProviderTransitionRoutesTargetPageRef#policy
   */
  readonly policy?: PageSpecForProviderTransitionRoutesTargetPageRefPolicy;

}

/**
 * Converts an object of type 'PageSpecForProviderTransitionRoutesTargetPageRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderTransitionRoutesTargetPageRef(obj: PageSpecForProviderTransitionRoutesTargetPageRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PageSpecForProviderTransitionRoutesTargetPageRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Page in dialogflowcx to populate targetPage.
 *
 * @schema PageSpecForProviderTransitionRoutesTargetPageSelector
 */
export interface PageSpecForProviderTransitionRoutesTargetPageSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PageSpecForProviderTransitionRoutesTargetPageSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PageSpecForProviderTransitionRoutesTargetPageSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PageSpecForProviderTransitionRoutesTargetPageSelector#policy
   */
  readonly policy?: PageSpecForProviderTransitionRoutesTargetPageSelectorPolicy;

}

/**
 * Converts an object of type 'PageSpecForProviderTransitionRoutesTargetPageSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderTransitionRoutesTargetPageSelector(obj: PageSpecForProviderTransitionRoutesTargetPageSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PageSpecForProviderTransitionRoutesTargetPageSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PageSpecForProviderTransitionRoutesTriggerFulfillment
 */
export interface PageSpecForProviderTransitionRoutesTriggerFulfillment {
  /**
   * The list of rich message responses to present to the user. Structure is documented below.
   *
   * @schema PageSpecForProviderTransitionRoutesTriggerFulfillment#messages
   */
  readonly messages?: PageSpecForProviderTransitionRoutesTriggerFulfillmentMessages[];

  /**
   * Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
   *
   * @schema PageSpecForProviderTransitionRoutesTriggerFulfillment#returnPartialResponses
   */
  readonly returnPartialResponses?: boolean;

  /**
   * The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
   *
   * @schema PageSpecForProviderTransitionRoutesTriggerFulfillment#tag
   */
  readonly tag?: string;

  /**
   * The webhook to call. Format: projects//locations//agents//webhooks/.
   *
   * @schema PageSpecForProviderTransitionRoutesTriggerFulfillment#webhook
   */
  readonly webhook?: string;

}

/**
 * Converts an object of type 'PageSpecForProviderTransitionRoutesTriggerFulfillment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderTransitionRoutesTriggerFulfillment(obj: PageSpecForProviderTransitionRoutesTriggerFulfillment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'messages': obj.messages?.map(y => toJson_PageSpecForProviderTransitionRoutesTriggerFulfillmentMessages(y)),
    'returnPartialResponses': obj.returnPartialResponses,
    'tag': obj.tag,
    'webhook': obj.webhook,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PageSpecProviderConfigRefPolicyResolution
 */
export enum PageSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PageSpecProviderConfigRefPolicyResolve
 */
export enum PageSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PageSpecProviderRefPolicyResolution
 */
export enum PageSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PageSpecProviderRefPolicyResolve
 */
export enum PageSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PageSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PageSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PageSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PageSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PageSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PageSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PageSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecPublishConnectionDetailsToConfigRefPolicy(obj: PageSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PageSpecForProviderEntryFulfillmentMessagesText
 */
export interface PageSpecForProviderEntryFulfillmentMessagesText {
  /**
   * A collection of text responses.
   *
   * @schema PageSpecForProviderEntryFulfillmentMessagesText#text
   */
  readonly text?: string[];

}

/**
 * Converts an object of type 'PageSpecForProviderEntryFulfillmentMessagesText' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderEntryFulfillmentMessagesText(obj: PageSpecForProviderEntryFulfillmentMessagesText | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'text': obj.text?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PageSpecForProviderEventHandlersTriggerFulfillmentMessages
 */
export interface PageSpecForProviderEventHandlersTriggerFulfillmentMessages {
  /**
   * A collection of text responses.
   *
   * @schema PageSpecForProviderEventHandlersTriggerFulfillmentMessages#text
   */
  readonly text?: PageSpecForProviderEventHandlersTriggerFulfillmentMessagesText[];

}

/**
 * Converts an object of type 'PageSpecForProviderEventHandlersTriggerFulfillmentMessages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderEventHandlersTriggerFulfillmentMessages(obj: PageSpecForProviderEventHandlersTriggerFulfillmentMessages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'text': obj.text?.map(y => toJson_PageSpecForProviderEventHandlersTriggerFulfillmentMessagesText(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PageSpecForProviderFormParametersFillBehavior
 */
export interface PageSpecForProviderFormParametersFillBehavior {
  /**
   * The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter. Structure is documented below.
   *
   * @schema PageSpecForProviderFormParametersFillBehavior#initialPromptFulfillment
   */
  readonly initialPromptFulfillment?: PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillment[];

}

/**
 * Converts an object of type 'PageSpecForProviderFormParametersFillBehavior' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderFormParametersFillBehavior(obj: PageSpecForProviderFormParametersFillBehavior | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'initialPromptFulfillment': obj.initialPromptFulfillment?.map(y => toJson_PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillment(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PageSpecForProviderParentRefPolicyResolution
 */
export enum PageSpecForProviderParentRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PageSpecForProviderParentRefPolicyResolve
 */
export enum PageSpecForProviderParentRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PageSpecForProviderParentSelectorPolicyResolution
 */
export enum PageSpecForProviderParentSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PageSpecForProviderParentSelectorPolicyResolve
 */
export enum PageSpecForProviderParentSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PageSpecForProviderTransitionRoutesTargetPageRefPolicy
 */
export interface PageSpecForProviderTransitionRoutesTargetPageRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PageSpecForProviderTransitionRoutesTargetPageRefPolicy#resolution
   */
  readonly resolution?: PageSpecForProviderTransitionRoutesTargetPageRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PageSpecForProviderTransitionRoutesTargetPageRefPolicy#resolve
   */
  readonly resolve?: PageSpecForProviderTransitionRoutesTargetPageRefPolicyResolve;

}

/**
 * Converts an object of type 'PageSpecForProviderTransitionRoutesTargetPageRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderTransitionRoutesTargetPageRefPolicy(obj: PageSpecForProviderTransitionRoutesTargetPageRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PageSpecForProviderTransitionRoutesTargetPageSelectorPolicy
 */
export interface PageSpecForProviderTransitionRoutesTargetPageSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PageSpecForProviderTransitionRoutesTargetPageSelectorPolicy#resolution
   */
  readonly resolution?: PageSpecForProviderTransitionRoutesTargetPageSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PageSpecForProviderTransitionRoutesTargetPageSelectorPolicy#resolve
   */
  readonly resolve?: PageSpecForProviderTransitionRoutesTargetPageSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PageSpecForProviderTransitionRoutesTargetPageSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderTransitionRoutesTargetPageSelectorPolicy(obj: PageSpecForProviderTransitionRoutesTargetPageSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PageSpecForProviderTransitionRoutesTriggerFulfillmentMessages
 */
export interface PageSpecForProviderTransitionRoutesTriggerFulfillmentMessages {
  /**
   * A collection of text responses.
   *
   * @schema PageSpecForProviderTransitionRoutesTriggerFulfillmentMessages#text
   */
  readonly text?: PageSpecForProviderTransitionRoutesTriggerFulfillmentMessagesText[];

}

/**
 * Converts an object of type 'PageSpecForProviderTransitionRoutesTriggerFulfillmentMessages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderTransitionRoutesTriggerFulfillmentMessages(obj: PageSpecForProviderTransitionRoutesTriggerFulfillmentMessages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'text': obj.text?.map(y => toJson_PageSpecForProviderTransitionRoutesTriggerFulfillmentMessagesText(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PageSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PageSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PageSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PageSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema PageSpecForProviderEventHandlersTriggerFulfillmentMessagesText
 */
export interface PageSpecForProviderEventHandlersTriggerFulfillmentMessagesText {
  /**
   * A collection of text responses.
   *
   * @schema PageSpecForProviderEventHandlersTriggerFulfillmentMessagesText#text
   */
  readonly text?: string[];

}

/**
 * Converts an object of type 'PageSpecForProviderEventHandlersTriggerFulfillmentMessagesText' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderEventHandlersTriggerFulfillmentMessagesText(obj: PageSpecForProviderEventHandlersTriggerFulfillmentMessagesText | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'text': obj.text?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillment
 */
export interface PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillment {
  /**
   * The list of rich message responses to present to the user. Structure is documented below.
   *
   * @schema PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillment#messages
   */
  readonly messages?: PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillmentMessages[];

  /**
   * Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
   *
   * @schema PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillment#returnPartialResponses
   */
  readonly returnPartialResponses?: boolean;

  /**
   * The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
   *
   * @schema PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillment#tag
   */
  readonly tag?: string;

  /**
   * The webhook to call. Format: projects//locations//agents//webhooks/.
   *
   * @schema PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillment#webhook
   */
  readonly webhook?: string;

}

/**
 * Converts an object of type 'PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillment(obj: PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'messages': obj.messages?.map(y => toJson_PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillmentMessages(y)),
    'returnPartialResponses': obj.returnPartialResponses,
    'tag': obj.tag,
    'webhook': obj.webhook,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PageSpecForProviderTransitionRoutesTargetPageRefPolicyResolution
 */
export enum PageSpecForProviderTransitionRoutesTargetPageRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PageSpecForProviderTransitionRoutesTargetPageRefPolicyResolve
 */
export enum PageSpecForProviderTransitionRoutesTargetPageRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PageSpecForProviderTransitionRoutesTargetPageSelectorPolicyResolution
 */
export enum PageSpecForProviderTransitionRoutesTargetPageSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PageSpecForProviderTransitionRoutesTargetPageSelectorPolicyResolve
 */
export enum PageSpecForProviderTransitionRoutesTargetPageSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema PageSpecForProviderTransitionRoutesTriggerFulfillmentMessagesText
 */
export interface PageSpecForProviderTransitionRoutesTriggerFulfillmentMessagesText {
  /**
   * A collection of text responses.
   *
   * @schema PageSpecForProviderTransitionRoutesTriggerFulfillmentMessagesText#text
   */
  readonly text?: string[];

}

/**
 * Converts an object of type 'PageSpecForProviderTransitionRoutesTriggerFulfillmentMessagesText' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderTransitionRoutesTriggerFulfillmentMessagesText(obj: PageSpecForProviderTransitionRoutesTriggerFulfillmentMessagesText | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'text': obj.text?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillmentMessages
 */
export interface PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillmentMessages {
  /**
   * A collection of text responses.
   *
   * @schema PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillmentMessages#text
   */
  readonly text?: PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillmentMessagesText[];

}

/**
 * Converts an object of type 'PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillmentMessages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillmentMessages(obj: PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillmentMessages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'text': obj.text?.map(y => toJson_PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillmentMessagesText(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillmentMessagesText
 */
export interface PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillmentMessagesText {
  /**
   * A collection of text responses.
   *
   * @schema PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillmentMessagesText#text
   */
  readonly text?: string[];

}

/**
 * Converts an object of type 'PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillmentMessagesText' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillmentMessagesText(obj: PageSpecForProviderFormParametersFillBehaviorInitialPromptFulfillmentMessagesText | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'text': obj.text?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Version is the Schema for the Versions API. You can create multiple versions of your agent flows and deploy them to separate serving environments.
 *
 * @schema Version
 */
export class Version extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Version"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dialogflowcx.gcp.upbound.io/v1beta1',
    kind: 'Version',
  }

  /**
   * Renders a Kubernetes manifest for "Version".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VersionProps): any {
    return {
      ...Version.GVK,
      ...toJson_VersionProps(props),
    };
  }

  /**
   * Defines a "Version" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VersionProps) {
    super(scope, id, {
      ...Version.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Version.GVK,
      ...toJson_VersionProps(resolved),
    };
  }
}

/**
 * Version is the Schema for the Versions API. You can create multiple versions of your agent flows and deploy them to separate serving environments.
 *
 * @schema Version
 */
export interface VersionProps {
  /**
   * @schema Version#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VersionSpec defines the desired state of Version
   *
   * @schema Version#spec
   */
  readonly spec: VersionSpec;

}

/**
 * Converts an object of type 'VersionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VersionProps(obj: VersionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VersionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VersionSpec defines the desired state of Version
 *
 * @schema VersionSpec
 */
export interface VersionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema VersionSpec#deletionPolicy
   */
  readonly deletionPolicy?: VersionSpecDeletionPolicy;

  /**
   * @schema VersionSpec#forProvider
   */
  readonly forProvider: VersionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VersionSpec#providerConfigRef
   */
  readonly providerConfigRef?: VersionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema VersionSpec#providerRef
   */
  readonly providerRef?: VersionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VersionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VersionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VersionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VersionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VersionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VersionSpec(obj: VersionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VersionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_VersionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_VersionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_VersionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VersionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema VersionSpecDeletionPolicy
 */
export enum VersionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VersionSpecForProvider
 */
export interface VersionSpecForProvider {
  /**
   * The description of the version. The maximum length is 500 characters. If exceeded, the request is rejected.
   *
   * @schema VersionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The human-readable name of the version. Limit of 64 characters.
   *
   * @schema VersionSpecForProvider#displayName
   */
  readonly displayName: string;

  /**
   * The Flow to create an Version for. Format: projects//locations//agents//flows/.
   *
   * @schema VersionSpecForProvider#parent
   */
  readonly parent?: string;

  /**
   * Reference to a Agent in dialogflowcx to populate parent.
   *
   * @schema VersionSpecForProvider#parentRef
   */
  readonly parentRef?: VersionSpecForProviderParentRef;

  /**
   * Selector for a Agent in dialogflowcx to populate parent.
   *
   * @schema VersionSpecForProvider#parentSelector
   */
  readonly parentSelector?: VersionSpecForProviderParentSelector;

}

/**
 * Converts an object of type 'VersionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VersionSpecForProvider(obj: VersionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'parent': obj.parent,
    'parentRef': toJson_VersionSpecForProviderParentRef(obj.parentRef),
    'parentSelector': toJson_VersionSpecForProviderParentSelector(obj.parentSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VersionSpecProviderConfigRef
 */
export interface VersionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VersionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VersionSpecProviderConfigRef#policy
   */
  readonly policy?: VersionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VersionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VersionSpecProviderConfigRef(obj: VersionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VersionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema VersionSpecProviderRef
 */
export interface VersionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema VersionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VersionSpecProviderRef#policy
   */
  readonly policy?: VersionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'VersionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VersionSpecProviderRef(obj: VersionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VersionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VersionSpecPublishConnectionDetailsTo
 */
export interface VersionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VersionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VersionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VersionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VersionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VersionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VersionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VersionSpecPublishConnectionDetailsTo(obj: VersionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VersionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VersionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VersionSpecWriteConnectionSecretToRef
 */
export interface VersionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VersionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VersionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VersionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VersionSpecWriteConnectionSecretToRef(obj: VersionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Agent in dialogflowcx to populate parent.
 *
 * @schema VersionSpecForProviderParentRef
 */
export interface VersionSpecForProviderParentRef {
  /**
   * Name of the referenced object.
   *
   * @schema VersionSpecForProviderParentRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VersionSpecForProviderParentRef#policy
   */
  readonly policy?: VersionSpecForProviderParentRefPolicy;

}

/**
 * Converts an object of type 'VersionSpecForProviderParentRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VersionSpecForProviderParentRef(obj: VersionSpecForProviderParentRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VersionSpecForProviderParentRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Agent in dialogflowcx to populate parent.
 *
 * @schema VersionSpecForProviderParentSelector
 */
export interface VersionSpecForProviderParentSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VersionSpecForProviderParentSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VersionSpecForProviderParentSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VersionSpecForProviderParentSelector#policy
   */
  readonly policy?: VersionSpecForProviderParentSelectorPolicy;

}

/**
 * Converts an object of type 'VersionSpecForProviderParentSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VersionSpecForProviderParentSelector(obj: VersionSpecForProviderParentSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VersionSpecForProviderParentSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VersionSpecProviderConfigRefPolicy
 */
export interface VersionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VersionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VersionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VersionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VersionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VersionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VersionSpecProviderConfigRefPolicy(obj: VersionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VersionSpecProviderRefPolicy
 */
export interface VersionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VersionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: VersionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VersionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: VersionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'VersionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VersionSpecProviderRefPolicy(obj: VersionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VersionSpecPublishConnectionDetailsToConfigRef
 */
export interface VersionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VersionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VersionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VersionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VersionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VersionSpecPublishConnectionDetailsToConfigRef(obj: VersionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VersionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VersionSpecPublishConnectionDetailsToMetadata
 */
export interface VersionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VersionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VersionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VersionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VersionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VersionSpecPublishConnectionDetailsToMetadata(obj: VersionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VersionSpecForProviderParentRefPolicy
 */
export interface VersionSpecForProviderParentRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VersionSpecForProviderParentRefPolicy#resolution
   */
  readonly resolution?: VersionSpecForProviderParentRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VersionSpecForProviderParentRefPolicy#resolve
   */
  readonly resolve?: VersionSpecForProviderParentRefPolicyResolve;

}

/**
 * Converts an object of type 'VersionSpecForProviderParentRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VersionSpecForProviderParentRefPolicy(obj: VersionSpecForProviderParentRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VersionSpecForProviderParentSelectorPolicy
 */
export interface VersionSpecForProviderParentSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VersionSpecForProviderParentSelectorPolicy#resolution
   */
  readonly resolution?: VersionSpecForProviderParentSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VersionSpecForProviderParentSelectorPolicy#resolve
   */
  readonly resolve?: VersionSpecForProviderParentSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VersionSpecForProviderParentSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VersionSpecForProviderParentSelectorPolicy(obj: VersionSpecForProviderParentSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VersionSpecProviderConfigRefPolicyResolution
 */
export enum VersionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VersionSpecProviderConfigRefPolicyResolve
 */
export enum VersionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VersionSpecProviderRefPolicyResolution
 */
export enum VersionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VersionSpecProviderRefPolicyResolve
 */
export enum VersionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VersionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VersionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VersionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VersionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VersionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VersionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VersionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VersionSpecPublishConnectionDetailsToConfigRefPolicy(obj: VersionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VersionSpecForProviderParentRefPolicyResolution
 */
export enum VersionSpecForProviderParentRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VersionSpecForProviderParentRefPolicyResolve
 */
export enum VersionSpecForProviderParentRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VersionSpecForProviderParentSelectorPolicyResolution
 */
export enum VersionSpecForProviderParentSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VersionSpecForProviderParentSelectorPolicyResolve
 */
export enum VersionSpecForProviderParentSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VersionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VersionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VersionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VersionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Webhook is the Schema for the Webhooks API. Webhooks host the developer's business logic.
 *
 * @schema Webhook
 */
export class Webhook extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Webhook"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dialogflowcx.gcp.upbound.io/v1beta1',
    kind: 'Webhook',
  }

  /**
   * Renders a Kubernetes manifest for "Webhook".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WebhookProps): any {
    return {
      ...Webhook.GVK,
      ...toJson_WebhookProps(props),
    };
  }

  /**
   * Defines a "Webhook" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WebhookProps) {
    super(scope, id, {
      ...Webhook.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Webhook.GVK,
      ...toJson_WebhookProps(resolved),
    };
  }
}

/**
 * Webhook is the Schema for the Webhooks API. Webhooks host the developer's business logic.
 *
 * @schema Webhook
 */
export interface WebhookProps {
  /**
   * @schema Webhook#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WebhookSpec defines the desired state of Webhook
   *
   * @schema Webhook#spec
   */
  readonly spec: WebhookSpec;

}

/**
 * Converts an object of type 'WebhookProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookProps(obj: WebhookProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WebhookSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WebhookSpec defines the desired state of Webhook
 *
 * @schema WebhookSpec
 */
export interface WebhookSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema WebhookSpec#deletionPolicy
   */
  readonly deletionPolicy?: WebhookSpecDeletionPolicy;

  /**
   * @schema WebhookSpec#forProvider
   */
  readonly forProvider: WebhookSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WebhookSpec#providerConfigRef
   */
  readonly providerConfigRef?: WebhookSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema WebhookSpec#providerRef
   */
  readonly providerRef?: WebhookSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WebhookSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WebhookSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WebhookSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WebhookSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WebhookSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpec(obj: WebhookSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WebhookSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_WebhookSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_WebhookSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_WebhookSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WebhookSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema WebhookSpecDeletionPolicy
 */
export enum WebhookSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WebhookSpecForProvider
 */
export interface WebhookSpecForProvider {
  /**
   * Indicates whether the webhook is disabled.
   *
   * @schema WebhookSpecForProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * The human-readable name of the webhook, unique within the agent.
   *
   * @schema WebhookSpecForProvider#displayName
   */
  readonly displayName: string;

  /**
   * Indicates if automatic spell correction is enabled in detect intent requests.
   *
   * @schema WebhookSpecForProvider#enableSpellCorrection
   */
  readonly enableSpellCorrection?: boolean;

  /**
   * Determines whether this agent should log conversation queries.
   *
   * @schema WebhookSpecForProvider#enableStackdriverLogging
   */
  readonly enableStackdriverLogging?: boolean;

  /**
   * Configuration for a generic web service. Structure is documented below.
   *
   * @schema WebhookSpecForProvider#genericWebService
   */
  readonly genericWebService?: WebhookSpecForProviderGenericWebService[];

  /**
   * The agent to create a webhook for. Format: projects//locations//agents/.
   *
   * @schema WebhookSpecForProvider#parent
   */
  readonly parent?: string;

  /**
   * Reference to a Agent in dialogflowcx to populate parent.
   *
   * @schema WebhookSpecForProvider#parentRef
   */
  readonly parentRef?: WebhookSpecForProviderParentRef;

  /**
   * Selector for a Agent in dialogflowcx to populate parent.
   *
   * @schema WebhookSpecForProvider#parentSelector
   */
  readonly parentSelector?: WebhookSpecForProviderParentSelector;

  /**
   * Name of the SecuritySettings reference for the agent. Format: projects//locations//securitySettings/.
   *
   * @schema WebhookSpecForProvider#securitySettings
   */
  readonly securitySettings?: string;

  /**
   * Configuration for a Service Directory service. Structure is documented below.
   *
   * @schema WebhookSpecForProvider#serviceDirectory
   */
  readonly serviceDirectory?: WebhookSpecForProviderServiceDirectory[];

  /**
   * Webhook execution timeout.
   *
   * @schema WebhookSpecForProvider#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'WebhookSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProvider(obj: WebhookSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
    'displayName': obj.displayName,
    'enableSpellCorrection': obj.enableSpellCorrection,
    'enableStackdriverLogging': obj.enableStackdriverLogging,
    'genericWebService': obj.genericWebService?.map(y => toJson_WebhookSpecForProviderGenericWebService(y)),
    'parent': obj.parent,
    'parentRef': toJson_WebhookSpecForProviderParentRef(obj.parentRef),
    'parentSelector': toJson_WebhookSpecForProviderParentSelector(obj.parentSelector),
    'securitySettings': obj.securitySettings,
    'serviceDirectory': obj.serviceDirectory?.map(y => toJson_WebhookSpecForProviderServiceDirectory(y)),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WebhookSpecProviderConfigRef
 */
export interface WebhookSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebhookSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebhookSpecProviderConfigRef#policy
   */
  readonly policy?: WebhookSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WebhookSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecProviderConfigRef(obj: WebhookSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebhookSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema WebhookSpecProviderRef
 */
export interface WebhookSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebhookSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebhookSpecProviderRef#policy
   */
  readonly policy?: WebhookSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'WebhookSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecProviderRef(obj: WebhookSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebhookSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WebhookSpecPublishConnectionDetailsTo
 */
export interface WebhookSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WebhookSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WebhookSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WebhookSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WebhookSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WebhookSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WebhookSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecPublishConnectionDetailsTo(obj: WebhookSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WebhookSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WebhookSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WebhookSpecWriteConnectionSecretToRef
 */
export interface WebhookSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WebhookSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WebhookSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WebhookSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecWriteConnectionSecretToRef(obj: WebhookSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebhookSpecForProviderGenericWebService
 */
export interface WebhookSpecForProviderGenericWebService {
  /**
   * Specifies a list of allowed custom CA certificates (in DER format) for HTTPS verification.
   *
   * @schema WebhookSpecForProviderGenericWebService#allowedCaCerts
   */
  readonly allowedCaCerts?: string[];

  /**
   * The HTTP request headers to send together with webhook requests.
   *
   * @schema WebhookSpecForProviderGenericWebService#requestHeaders
   */
  readonly requestHeaders?: { [key: string]: string };

  /**
   * Whether to use speech adaptation for speech recognition.
   *
   * @schema WebhookSpecForProviderGenericWebService#uri
   */
  readonly uri: string;

}

/**
 * Converts an object of type 'WebhookSpecForProviderGenericWebService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderGenericWebService(obj: WebhookSpecForProviderGenericWebService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedCaCerts': obj.allowedCaCerts?.map(y => y),
    'requestHeaders': ((obj.requestHeaders) === undefined) ? undefined : (Object.entries(obj.requestHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Agent in dialogflowcx to populate parent.
 *
 * @schema WebhookSpecForProviderParentRef
 */
export interface WebhookSpecForProviderParentRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebhookSpecForProviderParentRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebhookSpecForProviderParentRef#policy
   */
  readonly policy?: WebhookSpecForProviderParentRefPolicy;

}

/**
 * Converts an object of type 'WebhookSpecForProviderParentRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderParentRef(obj: WebhookSpecForProviderParentRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebhookSpecForProviderParentRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Agent in dialogflowcx to populate parent.
 *
 * @schema WebhookSpecForProviderParentSelector
 */
export interface WebhookSpecForProviderParentSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WebhookSpecForProviderParentSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WebhookSpecForProviderParentSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WebhookSpecForProviderParentSelector#policy
   */
  readonly policy?: WebhookSpecForProviderParentSelectorPolicy;

}

/**
 * Converts an object of type 'WebhookSpecForProviderParentSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderParentSelector(obj: WebhookSpecForProviderParentSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WebhookSpecForProviderParentSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebhookSpecForProviderServiceDirectory
 */
export interface WebhookSpecForProviderServiceDirectory {
  /**
   * The name of Service Directory service. Structure is documented below.
   *
   * @schema WebhookSpecForProviderServiceDirectory#genericWebService
   */
  readonly genericWebService: WebhookSpecForProviderServiceDirectoryGenericWebService[];

  /**
   * The name of Service Directory service.
   *
   * @schema WebhookSpecForProviderServiceDirectory#service
   */
  readonly service: string;

}

/**
 * Converts an object of type 'WebhookSpecForProviderServiceDirectory' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderServiceDirectory(obj: WebhookSpecForProviderServiceDirectory | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'genericWebService': obj.genericWebService?.map(y => toJson_WebhookSpecForProviderServiceDirectoryGenericWebService(y)),
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebhookSpecProviderConfigRefPolicy
 */
export interface WebhookSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WebhookSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WebhookSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecProviderConfigRefPolicy(obj: WebhookSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebhookSpecProviderRefPolicy
 */
export interface WebhookSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecProviderRefPolicy#resolution
   */
  readonly resolution?: WebhookSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecProviderRefPolicy#resolve
   */
  readonly resolve?: WebhookSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecProviderRefPolicy(obj: WebhookSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WebhookSpecPublishConnectionDetailsToConfigRef
 */
export interface WebhookSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebhookSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebhookSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WebhookSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WebhookSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecPublishConnectionDetailsToConfigRef(obj: WebhookSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebhookSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WebhookSpecPublishConnectionDetailsToMetadata
 */
export interface WebhookSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebhookSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebhookSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WebhookSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WebhookSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecPublishConnectionDetailsToMetadata(obj: WebhookSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebhookSpecForProviderParentRefPolicy
 */
export interface WebhookSpecForProviderParentRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecForProviderParentRefPolicy#resolution
   */
  readonly resolution?: WebhookSpecForProviderParentRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecForProviderParentRefPolicy#resolve
   */
  readonly resolve?: WebhookSpecForProviderParentRefPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecForProviderParentRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderParentRefPolicy(obj: WebhookSpecForProviderParentRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WebhookSpecForProviderParentSelectorPolicy
 */
export interface WebhookSpecForProviderParentSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecForProviderParentSelectorPolicy#resolution
   */
  readonly resolution?: WebhookSpecForProviderParentSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecForProviderParentSelectorPolicy#resolve
   */
  readonly resolve?: WebhookSpecForProviderParentSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecForProviderParentSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderParentSelectorPolicy(obj: WebhookSpecForProviderParentSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebhookSpecForProviderServiceDirectoryGenericWebService
 */
export interface WebhookSpecForProviderServiceDirectoryGenericWebService {
  /**
   * Specifies a list of allowed custom CA certificates (in DER format) for HTTPS verification.
   *
   * @schema WebhookSpecForProviderServiceDirectoryGenericWebService#allowedCaCerts
   */
  readonly allowedCaCerts?: string[];

  /**
   * The HTTP request headers to send together with webhook requests.
   *
   * @schema WebhookSpecForProviderServiceDirectoryGenericWebService#requestHeaders
   */
  readonly requestHeaders?: { [key: string]: string };

  /**
   * Whether to use speech adaptation for speech recognition.
   *
   * @schema WebhookSpecForProviderServiceDirectoryGenericWebService#uri
   */
  readonly uri: string;

}

/**
 * Converts an object of type 'WebhookSpecForProviderServiceDirectoryGenericWebService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderServiceDirectoryGenericWebService(obj: WebhookSpecForProviderServiceDirectoryGenericWebService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedCaCerts': obj.allowedCaCerts?.map(y => y),
    'requestHeaders': ((obj.requestHeaders) === undefined) ? undefined : (Object.entries(obj.requestHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecProviderConfigRefPolicyResolution
 */
export enum WebhookSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecProviderConfigRefPolicyResolve
 */
export enum WebhookSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecProviderRefPolicyResolution
 */
export enum WebhookSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecProviderRefPolicyResolve
 */
export enum WebhookSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WebhookSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecPublishConnectionDetailsToConfigRefPolicy(obj: WebhookSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecForProviderParentRefPolicyResolution
 */
export enum WebhookSpecForProviderParentRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecForProviderParentRefPolicyResolve
 */
export enum WebhookSpecForProviderParentRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecForProviderParentSelectorPolicyResolution
 */
export enum WebhookSpecForProviderParentSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecForProviderParentSelectorPolicyResolve
 */
export enum WebhookSpecForProviderParentSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

