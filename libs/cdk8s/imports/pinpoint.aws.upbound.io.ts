// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * App is the Schema for the Apps API. Provides a Pinpoint App resource.
 *
 * @schema App
 */
export class App extends ApiObject {
  /**
   * Returns the apiVersion and kind for "App"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'pinpoint.aws.upbound.io/v1beta1',
    kind: 'App',
  }

  /**
   * Renders a Kubernetes manifest for "App".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AppProps): any {
    return {
      ...App.GVK,
      ...toJson_AppProps(props),
    };
  }

  /**
   * Defines a "App" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AppProps) {
    super(scope, id, {
      ...App.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...App.GVK,
      ...toJson_AppProps(resolved),
    };
  }
}

/**
 * App is the Schema for the Apps API. Provides a Pinpoint App resource.
 *
 * @schema App
 */
export interface AppProps {
  /**
   * @schema App#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AppSpec defines the desired state of App
   *
   * @schema App#spec
   */
  readonly spec: AppSpec;

}

/**
 * Converts an object of type 'AppProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppProps(obj: AppProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AppSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppSpec defines the desired state of App
 *
 * @schema AppSpec
 */
export interface AppSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema AppSpec#deletionPolicy
   */
  readonly deletionPolicy?: AppSpecDeletionPolicy;

  /**
   * @schema AppSpec#forProvider
   */
  readonly forProvider: AppSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AppSpec#providerConfigRef
   */
  readonly providerConfigRef?: AppSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AppSpec#providerRef
   */
  readonly providerRef?: AppSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AppSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AppSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AppSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AppSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AppSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpec(obj: AppSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AppSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_AppSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AppSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AppSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AppSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema AppSpecDeletionPolicy
 */
export enum AppSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AppSpecForProvider
 */
export interface AppSpecForProvider {
  /**
   * Specifies settings for invoking an AWS Lambda function that customizes a segment for a campaign
   *
   * @schema AppSpecForProvider#campaignHook
   */
  readonly campaignHook?: AppSpecForProviderCampaignHook[];

  /**
   * The default campaign limits for the app. These limits apply to each campaign for the app, unless the campaign overrides the default with limits of its own
   *
   * @schema AppSpecForProvider#limits
   */
  readonly limits?: AppSpecForProviderLimits[];

  /**
   * The application name
   *
   * @schema AppSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The default quiet time for the app. Each campaign for this app sends no messages during this time unless the campaign overrides the default with a quiet time of its own
   *
   * @schema AppSpecForProvider#quietTime
   */
  readonly quietTime?: AppSpecForProviderQuietTime[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AppSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema AppSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AppSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProvider(obj: AppSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'campaignHook': obj.campaignHook?.map(y => toJson_AppSpecForProviderCampaignHook(y)),
    'limits': obj.limits?.map(y => toJson_AppSpecForProviderLimits(y)),
    'name': obj.name,
    'quietTime': obj.quietTime?.map(y => toJson_AppSpecForProviderQuietTime(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AppSpecProviderConfigRef
 */
export interface AppSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppSpecProviderConfigRef#policy
   */
  readonly policy?: AppSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AppSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecProviderConfigRef(obj: AppSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AppSpecProviderRef
 */
export interface AppSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppSpecProviderRef#policy
   */
  readonly policy?: AppSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AppSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecProviderRef(obj: AppSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AppSpecPublishConnectionDetailsTo
 */
export interface AppSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AppSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AppSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AppSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AppSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AppSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsTo(obj: AppSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AppSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AppSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AppSpecWriteConnectionSecretToRef
 */
export interface AppSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AppSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AppSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AppSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecWriteConnectionSecretToRef(obj: AppSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppSpecForProviderCampaignHook
 */
export interface AppSpecForProviderCampaignHook {
  /**
   * Lambda function name or ARN to be called for delivery. Conflicts with web_url
   *
   * @schema AppSpecForProviderCampaignHook#lambdaFunctionName
   */
  readonly lambdaFunctionName?: string;

  /**
   * What mode Lambda should be invoked in. Valid values for this parameter are DELIVERY, FILTER.
   *
   * @schema AppSpecForProviderCampaignHook#mode
   */
  readonly mode?: string;

  /**
   * Web URL to call for hook. If the URL has authentication specified it will be added as authentication to the request. Conflicts with lambda_function_name
   *
   * @schema AppSpecForProviderCampaignHook#webUrl
   */
  readonly webUrl?: string;

}

/**
 * Converts an object of type 'AppSpecForProviderCampaignHook' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderCampaignHook(obj: AppSpecForProviderCampaignHook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lambdaFunctionName': obj.lambdaFunctionName,
    'mode': obj.mode,
    'webUrl': obj.webUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppSpecForProviderLimits
 */
export interface AppSpecForProviderLimits {
  /**
   * The maximum number of messages that the campaign can send daily.
   *
   * @schema AppSpecForProviderLimits#daily
   */
  readonly daily?: number;

  /**
   * The length of time (in seconds) that the campaign can run before it ends and message deliveries stop. This duration begins at the scheduled start time for the campaign. The minimum value is 60.
   *
   * @schema AppSpecForProviderLimits#maximumDuration
   */
  readonly maximumDuration?: number;

  /**
   * The number of messages that the campaign can send per second. The minimum value is 50, and the maximum is 20000.
   *
   * @schema AppSpecForProviderLimits#messagesPerSecond
   */
  readonly messagesPerSecond?: number;

  /**
   * The maximum total number of messages that the campaign can send.
   *
   * @schema AppSpecForProviderLimits#total
   */
  readonly total?: number;

}

/**
 * Converts an object of type 'AppSpecForProviderLimits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderLimits(obj: AppSpecForProviderLimits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'daily': obj.daily,
    'maximumDuration': obj.maximumDuration,
    'messagesPerSecond': obj.messagesPerSecond,
    'total': obj.total,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppSpecForProviderQuietTime
 */
export interface AppSpecForProviderQuietTime {
  /**
   * The default end time for quiet time in ISO 8601 format. Required if start is set
   *
   * @schema AppSpecForProviderQuietTime#end
   */
  readonly end?: string;

  /**
   * The default start time for quiet time in ISO 8601 format. Required if end is set
   *
   * @schema AppSpecForProviderQuietTime#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'AppSpecForProviderQuietTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderQuietTime(obj: AppSpecForProviderQuietTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppSpecProviderConfigRefPolicy
 */
export interface AppSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AppSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AppSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecProviderConfigRefPolicy(obj: AppSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppSpecProviderRefPolicy
 */
export interface AppSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AppSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AppSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecProviderRefPolicy(obj: AppSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRef
 */
export interface AppSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AppSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsToConfigRef(obj: AppSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AppSpecPublishConnectionDetailsToMetadata
 */
export interface AppSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AppSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsToMetadata(obj: AppSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecProviderConfigRefPolicyResolution
 */
export enum AppSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecProviderConfigRefPolicyResolve
 */
export enum AppSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecProviderRefPolicyResolution
 */
export enum AppSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecProviderRefPolicyResolve
 */
export enum AppSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AppSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AppSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AppSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsToConfigRefPolicy(obj: AppSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AppSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AppSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SMSChannel is the Schema for the SMSChannels API. Provides a Pinpoint SMS Channel resource.
 *
 * @schema SMSChannel
 */
export class SmsChannel extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SMSChannel"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'pinpoint.aws.upbound.io/v1beta1',
    kind: 'SMSChannel',
  }

  /**
   * Renders a Kubernetes manifest for "SMSChannel".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SmsChannelProps): any {
    return {
      ...SmsChannel.GVK,
      ...toJson_SmsChannelProps(props),
    };
  }

  /**
   * Defines a "SMSChannel" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SmsChannelProps) {
    super(scope, id, {
      ...SmsChannel.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SmsChannel.GVK,
      ...toJson_SmsChannelProps(resolved),
    };
  }
}

/**
 * SMSChannel is the Schema for the SMSChannels API. Provides a Pinpoint SMS Channel resource.
 *
 * @schema SMSChannel
 */
export interface SmsChannelProps {
  /**
   * @schema SMSChannel#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SMSChannelSpec defines the desired state of SMSChannel
   *
   * @schema SMSChannel#spec
   */
  readonly spec: SmsChannelSpec;

}

/**
 * Converts an object of type 'SmsChannelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelProps(obj: SmsChannelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SmsChannelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SMSChannelSpec defines the desired state of SMSChannel
 *
 * @schema SmsChannelSpec
 */
export interface SmsChannelSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema SmsChannelSpec#deletionPolicy
   */
  readonly deletionPolicy?: SmsChannelSpecDeletionPolicy;

  /**
   * @schema SmsChannelSpec#forProvider
   */
  readonly forProvider: SmsChannelSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SmsChannelSpec#providerConfigRef
   */
  readonly providerConfigRef?: SmsChannelSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SmsChannelSpec#providerRef
   */
  readonly providerRef?: SmsChannelSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SmsChannelSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SmsChannelSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SmsChannelSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SmsChannelSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SmsChannelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpec(obj: SmsChannelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SmsChannelSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_SmsChannelSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SmsChannelSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SmsChannelSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SmsChannelSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema SmsChannelSpecDeletionPolicy
 */
export enum SmsChannelSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SmsChannelSpecForProvider
 */
export interface SmsChannelSpecForProvider {
  /**
   * The application ID.
   *
   * @schema SmsChannelSpecForProvider#applicationId
   */
  readonly applicationId?: string;

  /**
   * Reference to a App in pinpoint to populate applicationId.
   *
   * @schema SmsChannelSpecForProvider#applicationIdRef
   */
  readonly applicationIdRef?: SmsChannelSpecForProviderApplicationIdRef;

  /**
   * Selector for a App in pinpoint to populate applicationId.
   *
   * @schema SmsChannelSpecForProvider#applicationIdSelector
   */
  readonly applicationIdSelector?: SmsChannelSpecForProviderApplicationIdSelector;

  /**
   * Whether the channel is enabled or disabled. Defaults to true.
   *
   * @default true.
   * @schema SmsChannelSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SmsChannelSpecForProvider#region
   */
  readonly region: string;

  /**
   * Sender identifier of your messages.
   *
   * @schema SmsChannelSpecForProvider#senderId
   */
  readonly senderId?: string;

  /**
   * The Short Code registered with the phone provider.
   *
   * @schema SmsChannelSpecForProvider#shortCode
   */
  readonly shortCode?: string;

}

/**
 * Converts an object of type 'SmsChannelSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecForProvider(obj: SmsChannelSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationId': obj.applicationId,
    'applicationIdRef': toJson_SmsChannelSpecForProviderApplicationIdRef(obj.applicationIdRef),
    'applicationIdSelector': toJson_SmsChannelSpecForProviderApplicationIdSelector(obj.applicationIdSelector),
    'enabled': obj.enabled,
    'region': obj.region,
    'senderId': obj.senderId,
    'shortCode': obj.shortCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SmsChannelSpecProviderConfigRef
 */
export interface SmsChannelSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SmsChannelSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SmsChannelSpecProviderConfigRef#policy
   */
  readonly policy?: SmsChannelSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SmsChannelSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecProviderConfigRef(obj: SmsChannelSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SmsChannelSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SmsChannelSpecProviderRef
 */
export interface SmsChannelSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SmsChannelSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SmsChannelSpecProviderRef#policy
   */
  readonly policy?: SmsChannelSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SmsChannelSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecProviderRef(obj: SmsChannelSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SmsChannelSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SmsChannelSpecPublishConnectionDetailsTo
 */
export interface SmsChannelSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SmsChannelSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SmsChannelSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SmsChannelSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecPublishConnectionDetailsTo(obj: SmsChannelSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SmsChannelSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SmsChannelSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SmsChannelSpecWriteConnectionSecretToRef
 */
export interface SmsChannelSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SmsChannelSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SmsChannelSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SmsChannelSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecWriteConnectionSecretToRef(obj: SmsChannelSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a App in pinpoint to populate applicationId.
 *
 * @schema SmsChannelSpecForProviderApplicationIdRef
 */
export interface SmsChannelSpecForProviderApplicationIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SmsChannelSpecForProviderApplicationIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SmsChannelSpecForProviderApplicationIdRef#policy
   */
  readonly policy?: SmsChannelSpecForProviderApplicationIdRefPolicy;

}

/**
 * Converts an object of type 'SmsChannelSpecForProviderApplicationIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecForProviderApplicationIdRef(obj: SmsChannelSpecForProviderApplicationIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SmsChannelSpecForProviderApplicationIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a App in pinpoint to populate applicationId.
 *
 * @schema SmsChannelSpecForProviderApplicationIdSelector
 */
export interface SmsChannelSpecForProviderApplicationIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SmsChannelSpecForProviderApplicationIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SmsChannelSpecForProviderApplicationIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SmsChannelSpecForProviderApplicationIdSelector#policy
   */
  readonly policy?: SmsChannelSpecForProviderApplicationIdSelectorPolicy;

}

/**
 * Converts an object of type 'SmsChannelSpecForProviderApplicationIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecForProviderApplicationIdSelector(obj: SmsChannelSpecForProviderApplicationIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SmsChannelSpecForProviderApplicationIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SmsChannelSpecProviderConfigRefPolicy
 */
export interface SmsChannelSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SmsChannelSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SmsChannelSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SmsChannelSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SmsChannelSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SmsChannelSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecProviderConfigRefPolicy(obj: SmsChannelSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SmsChannelSpecProviderRefPolicy
 */
export interface SmsChannelSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SmsChannelSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SmsChannelSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SmsChannelSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SmsChannelSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SmsChannelSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecProviderRefPolicy(obj: SmsChannelSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SmsChannelSpecPublishConnectionDetailsToConfigRef
 */
export interface SmsChannelSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SmsChannelSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecPublishConnectionDetailsToConfigRef(obj: SmsChannelSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SmsChannelSpecPublishConnectionDetailsToMetadata
 */
export interface SmsChannelSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SmsChannelSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecPublishConnectionDetailsToMetadata(obj: SmsChannelSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SmsChannelSpecForProviderApplicationIdRefPolicy
 */
export interface SmsChannelSpecForProviderApplicationIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SmsChannelSpecForProviderApplicationIdRefPolicy#resolution
   */
  readonly resolution?: SmsChannelSpecForProviderApplicationIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SmsChannelSpecForProviderApplicationIdRefPolicy#resolve
   */
  readonly resolve?: SmsChannelSpecForProviderApplicationIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SmsChannelSpecForProviderApplicationIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecForProviderApplicationIdRefPolicy(obj: SmsChannelSpecForProviderApplicationIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SmsChannelSpecForProviderApplicationIdSelectorPolicy
 */
export interface SmsChannelSpecForProviderApplicationIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SmsChannelSpecForProviderApplicationIdSelectorPolicy#resolution
   */
  readonly resolution?: SmsChannelSpecForProviderApplicationIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SmsChannelSpecForProviderApplicationIdSelectorPolicy#resolve
   */
  readonly resolve?: SmsChannelSpecForProviderApplicationIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SmsChannelSpecForProviderApplicationIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecForProviderApplicationIdSelectorPolicy(obj: SmsChannelSpecForProviderApplicationIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SmsChannelSpecProviderConfigRefPolicyResolution
 */
export enum SmsChannelSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SmsChannelSpecProviderConfigRefPolicyResolve
 */
export enum SmsChannelSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SmsChannelSpecProviderRefPolicyResolution
 */
export enum SmsChannelSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SmsChannelSpecProviderRefPolicyResolve
 */
export enum SmsChannelSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SmsChannelSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SmsChannelSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy(obj: SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SmsChannelSpecForProviderApplicationIdRefPolicyResolution
 */
export enum SmsChannelSpecForProviderApplicationIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SmsChannelSpecForProviderApplicationIdRefPolicyResolve
 */
export enum SmsChannelSpecForProviderApplicationIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SmsChannelSpecForProviderApplicationIdSelectorPolicyResolution
 */
export enum SmsChannelSpecForProviderApplicationIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SmsChannelSpecForProviderApplicationIdSelectorPolicyResolve
 */
export enum SmsChannelSpecForProviderApplicationIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SmsChannelSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SmsChannelSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SmsChannelSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SmsChannelSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

