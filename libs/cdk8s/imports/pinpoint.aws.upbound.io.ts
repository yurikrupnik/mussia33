// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * App is the Schema for the Apps API. Provides a Pinpoint App resource.
 *
 * @schema App
 */
export class App extends ApiObject {
  /**
   * Returns the apiVersion and kind for "App"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'pinpoint.aws.upbound.io/v1beta1',
    kind: 'App',
  }

  /**
   * Renders a Kubernetes manifest for "App".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AppProps): any {
    return {
      ...App.GVK,
      ...toJson_AppProps(props),
    };
  }

  /**
   * Defines a "App" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AppProps) {
    super(scope, id, {
      ...App.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...App.GVK,
      ...toJson_AppProps(resolved),
    };
  }
}

/**
 * App is the Schema for the Apps API. Provides a Pinpoint App resource.
 *
 * @schema App
 */
export interface AppProps {
  /**
   * @schema App#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AppSpec defines the desired state of App
   *
   * @schema App#spec
   */
  readonly spec: AppSpec;

}

/**
 * Converts an object of type 'AppProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppProps(obj: AppProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AppSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppSpec defines the desired state of App
 *
 * @schema AppSpec
 */
export interface AppSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AppSpec#deletionPolicy
   */
  readonly deletionPolicy?: AppSpecDeletionPolicy;

  /**
   * @schema AppSpec#forProvider
   */
  readonly forProvider: AppSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AppSpec#initProvider
   */
  readonly initProvider?: AppSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AppSpec#managementPolicies
   */
  readonly managementPolicies?: AppSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AppSpec#providerConfigRef
   */
  readonly providerConfigRef?: AppSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AppSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AppSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AppSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AppSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AppSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpec(obj: AppSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AppSpecForProvider(obj.forProvider),
    'initProvider': toJson_AppSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AppSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AppSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AppSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AppSpecDeletionPolicy
 */
export enum AppSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AppSpecForProvider
 */
export interface AppSpecForProvider {
  /**
   * Specifies settings for invoking an AWS Lambda function that customizes a segment for a campaign
   *
   * @schema AppSpecForProvider#campaignHook
   */
  readonly campaignHook?: AppSpecForProviderCampaignHook[];

  /**
   * The default campaign limits for the app. These limits apply to each campaign for the app, unless the campaign overrides the default with limits of its own
   *
   * @schema AppSpecForProvider#limits
   */
  readonly limits?: AppSpecForProviderLimits[];

  /**
   * The application name
   *
   * @schema AppSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The default quiet time for the app. Each campaign for this app sends no messages during this time unless the campaign overrides the default with a quiet time of its own
   *
   * @schema AppSpecForProvider#quietTime
   */
  readonly quietTime?: AppSpecForProviderQuietTime[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AppSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema AppSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AppSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProvider(obj: AppSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'campaignHook': obj.campaignHook?.map(y => toJson_AppSpecForProviderCampaignHook(y)),
    'limits': obj.limits?.map(y => toJson_AppSpecForProviderLimits(y)),
    'name': obj.name,
    'quietTime': obj.quietTime?.map(y => toJson_AppSpecForProviderQuietTime(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AppSpecInitProvider
 */
export interface AppSpecInitProvider {
  /**
   * Specifies settings for invoking an AWS Lambda function that customizes a segment for a campaign
   *
   * @schema AppSpecInitProvider#campaignHook
   */
  readonly campaignHook?: AppSpecInitProviderCampaignHook[];

  /**
   * The default campaign limits for the app. These limits apply to each campaign for the app, unless the campaign overrides the default with limits of its own
   *
   * @schema AppSpecInitProvider#limits
   */
  readonly limits?: AppSpecInitProviderLimits[];

  /**
   * The application name
   *
   * @schema AppSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The default quiet time for the app. Each campaign for this app sends no messages during this time unless the campaign overrides the default with a quiet time of its own
   *
   * @schema AppSpecInitProvider#quietTime
   */
  readonly quietTime?: AppSpecInitProviderQuietTime[];

  /**
   * Key-value map of resource tags.
   *
   * @schema AppSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AppSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecInitProvider(obj: AppSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'campaignHook': obj.campaignHook?.map(y => toJson_AppSpecInitProviderCampaignHook(y)),
    'limits': obj.limits?.map(y => toJson_AppSpecInitProviderLimits(y)),
    'name': obj.name,
    'quietTime': obj.quietTime?.map(y => toJson_AppSpecInitProviderQuietTime(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AppSpecManagementPolicies
 */
export enum AppSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AppSpecProviderConfigRef
 */
export interface AppSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppSpecProviderConfigRef#policy
   */
  readonly policy?: AppSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AppSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecProviderConfigRef(obj: AppSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AppSpecPublishConnectionDetailsTo
 */
export interface AppSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AppSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AppSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AppSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AppSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AppSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsTo(obj: AppSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AppSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AppSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AppSpecWriteConnectionSecretToRef
 */
export interface AppSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AppSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AppSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AppSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecWriteConnectionSecretToRef(obj: AppSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppSpecForProviderCampaignHook
 */
export interface AppSpecForProviderCampaignHook {
  /**
   * Lambda function name or ARN to be called for delivery. Conflicts with web_url
   *
   * @schema AppSpecForProviderCampaignHook#lambdaFunctionName
   */
  readonly lambdaFunctionName?: string;

  /**
   * What mode Lambda should be invoked in. Valid values for this parameter are DELIVERY, FILTER.
   *
   * @schema AppSpecForProviderCampaignHook#mode
   */
  readonly mode?: string;

  /**
   * Web URL to call for hook. If the URL has authentication specified it will be added as authentication to the request. Conflicts with lambda_function_name
   *
   * @schema AppSpecForProviderCampaignHook#webUrl
   */
  readonly webUrl?: string;

}

/**
 * Converts an object of type 'AppSpecForProviderCampaignHook' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderCampaignHook(obj: AppSpecForProviderCampaignHook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lambdaFunctionName': obj.lambdaFunctionName,
    'mode': obj.mode,
    'webUrl': obj.webUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppSpecForProviderLimits
 */
export interface AppSpecForProviderLimits {
  /**
   * The maximum number of messages that the campaign can send daily.
   *
   * @schema AppSpecForProviderLimits#daily
   */
  readonly daily?: number;

  /**
   * The length of time (in seconds) that the campaign can run before it ends and message deliveries stop. This duration begins at the scheduled start time for the campaign. The minimum value is 60.
   *
   * @schema AppSpecForProviderLimits#maximumDuration
   */
  readonly maximumDuration?: number;

  /**
   * The number of messages that the campaign can send per second. The minimum value is 50, and the maximum is 20000.
   *
   * @schema AppSpecForProviderLimits#messagesPerSecond
   */
  readonly messagesPerSecond?: number;

  /**
   * The maximum total number of messages that the campaign can send.
   *
   * @schema AppSpecForProviderLimits#total
   */
  readonly total?: number;

}

/**
 * Converts an object of type 'AppSpecForProviderLimits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderLimits(obj: AppSpecForProviderLimits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'daily': obj.daily,
    'maximumDuration': obj.maximumDuration,
    'messagesPerSecond': obj.messagesPerSecond,
    'total': obj.total,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppSpecForProviderQuietTime
 */
export interface AppSpecForProviderQuietTime {
  /**
   * The default end time for quiet time in ISO 8601 format. Required if start is set
   *
   * @schema AppSpecForProviderQuietTime#end
   */
  readonly end?: string;

  /**
   * The default start time for quiet time in ISO 8601 format. Required if end is set
   *
   * @schema AppSpecForProviderQuietTime#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'AppSpecForProviderQuietTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProviderQuietTime(obj: AppSpecForProviderQuietTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppSpecInitProviderCampaignHook
 */
export interface AppSpecInitProviderCampaignHook {
  /**
   * Lambda function name or ARN to be called for delivery. Conflicts with web_url
   *
   * @schema AppSpecInitProviderCampaignHook#lambdaFunctionName
   */
  readonly lambdaFunctionName?: string;

  /**
   * What mode Lambda should be invoked in. Valid values for this parameter are DELIVERY, FILTER.
   *
   * @schema AppSpecInitProviderCampaignHook#mode
   */
  readonly mode?: string;

  /**
   * Web URL to call for hook. If the URL has authentication specified it will be added as authentication to the request. Conflicts with lambda_function_name
   *
   * @schema AppSpecInitProviderCampaignHook#webUrl
   */
  readonly webUrl?: string;

}

/**
 * Converts an object of type 'AppSpecInitProviderCampaignHook' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecInitProviderCampaignHook(obj: AppSpecInitProviderCampaignHook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lambdaFunctionName': obj.lambdaFunctionName,
    'mode': obj.mode,
    'webUrl': obj.webUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppSpecInitProviderLimits
 */
export interface AppSpecInitProviderLimits {
  /**
   * The maximum number of messages that the campaign can send daily.
   *
   * @schema AppSpecInitProviderLimits#daily
   */
  readonly daily?: number;

  /**
   * The length of time (in seconds) that the campaign can run before it ends and message deliveries stop. This duration begins at the scheduled start time for the campaign. The minimum value is 60.
   *
   * @schema AppSpecInitProviderLimits#maximumDuration
   */
  readonly maximumDuration?: number;

  /**
   * The number of messages that the campaign can send per second. The minimum value is 50, and the maximum is 20000.
   *
   * @schema AppSpecInitProviderLimits#messagesPerSecond
   */
  readonly messagesPerSecond?: number;

  /**
   * The maximum total number of messages that the campaign can send.
   *
   * @schema AppSpecInitProviderLimits#total
   */
  readonly total?: number;

}

/**
 * Converts an object of type 'AppSpecInitProviderLimits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecInitProviderLimits(obj: AppSpecInitProviderLimits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'daily': obj.daily,
    'maximumDuration': obj.maximumDuration,
    'messagesPerSecond': obj.messagesPerSecond,
    'total': obj.total,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppSpecInitProviderQuietTime
 */
export interface AppSpecInitProviderQuietTime {
  /**
   * The default end time for quiet time in ISO 8601 format. Required if start is set
   *
   * @schema AppSpecInitProviderQuietTime#end
   */
  readonly end?: string;

  /**
   * The default start time for quiet time in ISO 8601 format. Required if end is set
   *
   * @schema AppSpecInitProviderQuietTime#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'AppSpecInitProviderQuietTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecInitProviderQuietTime(obj: AppSpecInitProviderQuietTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppSpecProviderConfigRefPolicy
 */
export interface AppSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AppSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AppSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecProviderConfigRefPolicy(obj: AppSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRef
 */
export interface AppSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AppSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsToConfigRef(obj: AppSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AppSpecPublishConnectionDetailsToMetadata
 */
export interface AppSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AppSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsToMetadata(obj: AppSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecProviderConfigRefPolicyResolution
 */
export enum AppSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecProviderConfigRefPolicyResolve
 */
export enum AppSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AppSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AppSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AppSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsToConfigRefPolicy(obj: AppSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AppSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AppSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SMSChannel is the Schema for the SMSChannels API. Provides a Pinpoint SMS Channel resource.
 *
 * @schema SMSChannel
 */
export class SmsChannel extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SMSChannel"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'pinpoint.aws.upbound.io/v1beta1',
    kind: 'SMSChannel',
  }

  /**
   * Renders a Kubernetes manifest for "SMSChannel".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SmsChannelProps): any {
    return {
      ...SmsChannel.GVK,
      ...toJson_SmsChannelProps(props),
    };
  }

  /**
   * Defines a "SMSChannel" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SmsChannelProps) {
    super(scope, id, {
      ...SmsChannel.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SmsChannel.GVK,
      ...toJson_SmsChannelProps(resolved),
    };
  }
}

/**
 * SMSChannel is the Schema for the SMSChannels API. Provides a Pinpoint SMS Channel resource.
 *
 * @schema SMSChannel
 */
export interface SmsChannelProps {
  /**
   * @schema SMSChannel#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SMSChannelSpec defines the desired state of SMSChannel
   *
   * @schema SMSChannel#spec
   */
  readonly spec: SmsChannelSpec;

}

/**
 * Converts an object of type 'SmsChannelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelProps(obj: SmsChannelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SmsChannelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SMSChannelSpec defines the desired state of SMSChannel
 *
 * @schema SmsChannelSpec
 */
export interface SmsChannelSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SmsChannelSpec#deletionPolicy
   */
  readonly deletionPolicy?: SmsChannelSpecDeletionPolicy;

  /**
   * @schema SmsChannelSpec#forProvider
   */
  readonly forProvider: SmsChannelSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SmsChannelSpec#initProvider
   */
  readonly initProvider?: SmsChannelSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SmsChannelSpec#managementPolicies
   */
  readonly managementPolicies?: SmsChannelSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SmsChannelSpec#providerConfigRef
   */
  readonly providerConfigRef?: SmsChannelSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SmsChannelSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SmsChannelSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SmsChannelSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SmsChannelSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SmsChannelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpec(obj: SmsChannelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SmsChannelSpecForProvider(obj.forProvider),
    'initProvider': toJson_SmsChannelSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SmsChannelSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SmsChannelSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SmsChannelSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SmsChannelSpecDeletionPolicy
 */
export enum SmsChannelSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SmsChannelSpecForProvider
 */
export interface SmsChannelSpecForProvider {
  /**
   * The application ID.
   *
   * @schema SmsChannelSpecForProvider#applicationId
   */
  readonly applicationId?: string;

  /**
   * Reference to a App in pinpoint to populate applicationId.
   *
   * @schema SmsChannelSpecForProvider#applicationIdRef
   */
  readonly applicationIdRef?: SmsChannelSpecForProviderApplicationIdRef;

  /**
   * Selector for a App in pinpoint to populate applicationId.
   *
   * @schema SmsChannelSpecForProvider#applicationIdSelector
   */
  readonly applicationIdSelector?: SmsChannelSpecForProviderApplicationIdSelector;

  /**
   * Whether the channel is enabled or disabled. Defaults to true.
   *
   * @default true.
   * @schema SmsChannelSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SmsChannelSpecForProvider#region
   */
  readonly region: string;

  /**
   * Sender identifier of your messages.
   *
   * @schema SmsChannelSpecForProvider#senderId
   */
  readonly senderId?: string;

  /**
   * The Short Code registered with the phone provider.
   *
   * @schema SmsChannelSpecForProvider#shortCode
   */
  readonly shortCode?: string;

}

/**
 * Converts an object of type 'SmsChannelSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecForProvider(obj: SmsChannelSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationId': obj.applicationId,
    'applicationIdRef': toJson_SmsChannelSpecForProviderApplicationIdRef(obj.applicationIdRef),
    'applicationIdSelector': toJson_SmsChannelSpecForProviderApplicationIdSelector(obj.applicationIdSelector),
    'enabled': obj.enabled,
    'region': obj.region,
    'senderId': obj.senderId,
    'shortCode': obj.shortCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SmsChannelSpecInitProvider
 */
export interface SmsChannelSpecInitProvider {
  /**
   * Whether the channel is enabled or disabled. Defaults to true.
   *
   * @default true.
   * @schema SmsChannelSpecInitProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Sender identifier of your messages.
   *
   * @schema SmsChannelSpecInitProvider#senderId
   */
  readonly senderId?: string;

  /**
   * The Short Code registered with the phone provider.
   *
   * @schema SmsChannelSpecInitProvider#shortCode
   */
  readonly shortCode?: string;

}

/**
 * Converts an object of type 'SmsChannelSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecInitProvider(obj: SmsChannelSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'senderId': obj.senderId,
    'shortCode': obj.shortCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SmsChannelSpecManagementPolicies
 */
export enum SmsChannelSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SmsChannelSpecProviderConfigRef
 */
export interface SmsChannelSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SmsChannelSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SmsChannelSpecProviderConfigRef#policy
   */
  readonly policy?: SmsChannelSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SmsChannelSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecProviderConfigRef(obj: SmsChannelSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SmsChannelSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SmsChannelSpecPublishConnectionDetailsTo
 */
export interface SmsChannelSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SmsChannelSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SmsChannelSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SmsChannelSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecPublishConnectionDetailsTo(obj: SmsChannelSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SmsChannelSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SmsChannelSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SmsChannelSpecWriteConnectionSecretToRef
 */
export interface SmsChannelSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SmsChannelSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SmsChannelSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SmsChannelSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecWriteConnectionSecretToRef(obj: SmsChannelSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a App in pinpoint to populate applicationId.
 *
 * @schema SmsChannelSpecForProviderApplicationIdRef
 */
export interface SmsChannelSpecForProviderApplicationIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SmsChannelSpecForProviderApplicationIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SmsChannelSpecForProviderApplicationIdRef#policy
   */
  readonly policy?: SmsChannelSpecForProviderApplicationIdRefPolicy;

}

/**
 * Converts an object of type 'SmsChannelSpecForProviderApplicationIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecForProviderApplicationIdRef(obj: SmsChannelSpecForProviderApplicationIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SmsChannelSpecForProviderApplicationIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a App in pinpoint to populate applicationId.
 *
 * @schema SmsChannelSpecForProviderApplicationIdSelector
 */
export interface SmsChannelSpecForProviderApplicationIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SmsChannelSpecForProviderApplicationIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SmsChannelSpecForProviderApplicationIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SmsChannelSpecForProviderApplicationIdSelector#policy
   */
  readonly policy?: SmsChannelSpecForProviderApplicationIdSelectorPolicy;

}

/**
 * Converts an object of type 'SmsChannelSpecForProviderApplicationIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecForProviderApplicationIdSelector(obj: SmsChannelSpecForProviderApplicationIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SmsChannelSpecForProviderApplicationIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SmsChannelSpecProviderConfigRefPolicy
 */
export interface SmsChannelSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SmsChannelSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SmsChannelSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SmsChannelSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SmsChannelSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SmsChannelSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecProviderConfigRefPolicy(obj: SmsChannelSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SmsChannelSpecPublishConnectionDetailsToConfigRef
 */
export interface SmsChannelSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SmsChannelSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecPublishConnectionDetailsToConfigRef(obj: SmsChannelSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SmsChannelSpecPublishConnectionDetailsToMetadata
 */
export interface SmsChannelSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SmsChannelSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecPublishConnectionDetailsToMetadata(obj: SmsChannelSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SmsChannelSpecForProviderApplicationIdRefPolicy
 */
export interface SmsChannelSpecForProviderApplicationIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SmsChannelSpecForProviderApplicationIdRefPolicy#resolution
   */
  readonly resolution?: SmsChannelSpecForProviderApplicationIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SmsChannelSpecForProviderApplicationIdRefPolicy#resolve
   */
  readonly resolve?: SmsChannelSpecForProviderApplicationIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SmsChannelSpecForProviderApplicationIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecForProviderApplicationIdRefPolicy(obj: SmsChannelSpecForProviderApplicationIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SmsChannelSpecForProviderApplicationIdSelectorPolicy
 */
export interface SmsChannelSpecForProviderApplicationIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SmsChannelSpecForProviderApplicationIdSelectorPolicy#resolution
   */
  readonly resolution?: SmsChannelSpecForProviderApplicationIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SmsChannelSpecForProviderApplicationIdSelectorPolicy#resolve
   */
  readonly resolve?: SmsChannelSpecForProviderApplicationIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SmsChannelSpecForProviderApplicationIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecForProviderApplicationIdSelectorPolicy(obj: SmsChannelSpecForProviderApplicationIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SmsChannelSpecProviderConfigRefPolicyResolution
 */
export enum SmsChannelSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SmsChannelSpecProviderConfigRefPolicyResolve
 */
export enum SmsChannelSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SmsChannelSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SmsChannelSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy(obj: SmsChannelSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SmsChannelSpecForProviderApplicationIdRefPolicyResolution
 */
export enum SmsChannelSpecForProviderApplicationIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SmsChannelSpecForProviderApplicationIdRefPolicyResolve
 */
export enum SmsChannelSpecForProviderApplicationIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SmsChannelSpecForProviderApplicationIdSelectorPolicyResolution
 */
export enum SmsChannelSpecForProviderApplicationIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SmsChannelSpecForProviderApplicationIdSelectorPolicyResolve
 */
export enum SmsChannelSpecForProviderApplicationIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SmsChannelSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SmsChannelSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SmsChannelSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SmsChannelSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

