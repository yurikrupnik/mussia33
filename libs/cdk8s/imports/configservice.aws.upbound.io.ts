// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AWSConfigurationRecorderStatus is the Schema for the AWSConfigurationRecorderStatuss API. Manages status of an AWS Config Configuration Recorder.
 *
 * @schema AWSConfigurationRecorderStatus
 */
export class AwsConfigurationRecorderStatus extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AWSConfigurationRecorderStatus"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'configservice.aws.upbound.io/v1beta1',
    kind: 'AWSConfigurationRecorderStatus',
  }

  /**
   * Renders a Kubernetes manifest for "AWSConfigurationRecorderStatus".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AwsConfigurationRecorderStatusProps): any {
    return {
      ...AwsConfigurationRecorderStatus.GVK,
      ...toJson_AwsConfigurationRecorderStatusProps(props),
    };
  }

  /**
   * Defines a "AWSConfigurationRecorderStatus" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AwsConfigurationRecorderStatusProps) {
    super(scope, id, {
      ...AwsConfigurationRecorderStatus.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AwsConfigurationRecorderStatus.GVK,
      ...toJson_AwsConfigurationRecorderStatusProps(resolved),
    };
  }
}

/**
 * AWSConfigurationRecorderStatus is the Schema for the AWSConfigurationRecorderStatuss API. Manages status of an AWS Config Configuration Recorder.
 *
 * @schema AWSConfigurationRecorderStatus
 */
export interface AwsConfigurationRecorderStatusProps {
  /**
   * @schema AWSConfigurationRecorderStatus#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AWSConfigurationRecorderStatusSpec defines the desired state of AWSConfigurationRecorderStatus
   *
   * @schema AWSConfigurationRecorderStatus#spec
   */
  readonly spec: AwsConfigurationRecorderStatusSpec;

}

/**
 * Converts an object of type 'AwsConfigurationRecorderStatusProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AwsConfigurationRecorderStatusProps(obj: AwsConfigurationRecorderStatusProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AwsConfigurationRecorderStatusSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSConfigurationRecorderStatusSpec defines the desired state of AWSConfigurationRecorderStatus
 *
 * @schema AwsConfigurationRecorderStatusSpec
 */
export interface AwsConfigurationRecorderStatusSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema AwsConfigurationRecorderStatusSpec#deletionPolicy
   */
  readonly deletionPolicy?: AwsConfigurationRecorderStatusSpecDeletionPolicy;

  /**
   * @schema AwsConfigurationRecorderStatusSpec#forProvider
   */
  readonly forProvider: AwsConfigurationRecorderStatusSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AwsConfigurationRecorderStatusSpec#providerConfigRef
   */
  readonly providerConfigRef?: AwsConfigurationRecorderStatusSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AwsConfigurationRecorderStatusSpec#providerRef
   */
  readonly providerRef?: AwsConfigurationRecorderStatusSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AwsConfigurationRecorderStatusSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AwsConfigurationRecorderStatusSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AwsConfigurationRecorderStatusSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AwsConfigurationRecorderStatusSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AwsConfigurationRecorderStatusSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AwsConfigurationRecorderStatusSpec(obj: AwsConfigurationRecorderStatusSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AwsConfigurationRecorderStatusSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_AwsConfigurationRecorderStatusSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AwsConfigurationRecorderStatusSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AwsConfigurationRecorderStatusSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AwsConfigurationRecorderStatusSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema AwsConfigurationRecorderStatusSpecDeletionPolicy
 */
export enum AwsConfigurationRecorderStatusSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AwsConfigurationRecorderStatusSpecForProvider
 */
export interface AwsConfigurationRecorderStatusSpecForProvider {
  /**
   * Whether the configuration recorder should be enabled or disabled.
   *
   * @schema AwsConfigurationRecorderStatusSpecForProvider#isEnabled
   */
  readonly isEnabled: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AwsConfigurationRecorderStatusSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'AwsConfigurationRecorderStatusSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AwsConfigurationRecorderStatusSpecForProvider(obj: AwsConfigurationRecorderStatusSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isEnabled': obj.isEnabled,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AwsConfigurationRecorderStatusSpecProviderConfigRef
 */
export interface AwsConfigurationRecorderStatusSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AwsConfigurationRecorderStatusSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AwsConfigurationRecorderStatusSpecProviderConfigRef#policy
   */
  readonly policy?: AwsConfigurationRecorderStatusSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AwsConfigurationRecorderStatusSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AwsConfigurationRecorderStatusSpecProviderConfigRef(obj: AwsConfigurationRecorderStatusSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AwsConfigurationRecorderStatusSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AwsConfigurationRecorderStatusSpecProviderRef
 */
export interface AwsConfigurationRecorderStatusSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AwsConfigurationRecorderStatusSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AwsConfigurationRecorderStatusSpecProviderRef#policy
   */
  readonly policy?: AwsConfigurationRecorderStatusSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AwsConfigurationRecorderStatusSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AwsConfigurationRecorderStatusSpecProviderRef(obj: AwsConfigurationRecorderStatusSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AwsConfigurationRecorderStatusSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AwsConfigurationRecorderStatusSpecPublishConnectionDetailsTo
 */
export interface AwsConfigurationRecorderStatusSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AwsConfigurationRecorderStatusSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AwsConfigurationRecorderStatusSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AwsConfigurationRecorderStatusSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AwsConfigurationRecorderStatusSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AwsConfigurationRecorderStatusSpecPublishConnectionDetailsTo(obj: AwsConfigurationRecorderStatusSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AwsConfigurationRecorderStatusSpecWriteConnectionSecretToRef
 */
export interface AwsConfigurationRecorderStatusSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AwsConfigurationRecorderStatusSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AwsConfigurationRecorderStatusSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AwsConfigurationRecorderStatusSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AwsConfigurationRecorderStatusSpecWriteConnectionSecretToRef(obj: AwsConfigurationRecorderStatusSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AwsConfigurationRecorderStatusSpecProviderConfigRefPolicy
 */
export interface AwsConfigurationRecorderStatusSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AwsConfigurationRecorderStatusSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AwsConfigurationRecorderStatusSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AwsConfigurationRecorderStatusSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AwsConfigurationRecorderStatusSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AwsConfigurationRecorderStatusSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AwsConfigurationRecorderStatusSpecProviderConfigRefPolicy(obj: AwsConfigurationRecorderStatusSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AwsConfigurationRecorderStatusSpecProviderRefPolicy
 */
export interface AwsConfigurationRecorderStatusSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AwsConfigurationRecorderStatusSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AwsConfigurationRecorderStatusSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AwsConfigurationRecorderStatusSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AwsConfigurationRecorderStatusSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AwsConfigurationRecorderStatusSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AwsConfigurationRecorderStatusSpecProviderRefPolicy(obj: AwsConfigurationRecorderStatusSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRef
 */
export interface AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRef(obj: AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToMetadata
 */
export interface AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToMetadata(obj: AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AwsConfigurationRecorderStatusSpecProviderConfigRefPolicyResolution
 */
export enum AwsConfigurationRecorderStatusSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AwsConfigurationRecorderStatusSpecProviderConfigRefPolicyResolve
 */
export enum AwsConfigurationRecorderStatusSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AwsConfigurationRecorderStatusSpecProviderRefPolicyResolution
 */
export enum AwsConfigurationRecorderStatusSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AwsConfigurationRecorderStatusSpecProviderRefPolicyResolve
 */
export enum AwsConfigurationRecorderStatusSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRefPolicy(obj: AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AwsConfigurationRecorderStatusSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ConfigRule is the Schema for the ConfigRules API. Provides an AWS Config Rule.
 *
 * @schema ConfigRule
 */
export class ConfigRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ConfigRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'configservice.aws.upbound.io/v1beta1',
    kind: 'ConfigRule',
  }

  /**
   * Renders a Kubernetes manifest for "ConfigRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConfigRuleProps): any {
    return {
      ...ConfigRule.GVK,
      ...toJson_ConfigRuleProps(props),
    };
  }

  /**
   * Defines a "ConfigRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConfigRuleProps) {
    super(scope, id, {
      ...ConfigRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ConfigRule.GVK,
      ...toJson_ConfigRuleProps(resolved),
    };
  }
}

/**
 * ConfigRule is the Schema for the ConfigRules API. Provides an AWS Config Rule.
 *
 * @schema ConfigRule
 */
export interface ConfigRuleProps {
  /**
   * @schema ConfigRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConfigRuleSpec defines the desired state of ConfigRule
   *
   * @schema ConfigRule#spec
   */
  readonly spec: ConfigRuleSpec;

}

/**
 * Converts an object of type 'ConfigRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleProps(obj: ConfigRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConfigRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigRuleSpec defines the desired state of ConfigRule
 *
 * @schema ConfigRuleSpec
 */
export interface ConfigRuleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ConfigRuleSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConfigRuleSpecDeletionPolicy;

  /**
   * @schema ConfigRuleSpec#forProvider
   */
  readonly forProvider: ConfigRuleSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConfigRuleSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConfigRuleSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ConfigRuleSpec#providerRef
   */
  readonly providerRef?: ConfigRuleSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConfigRuleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConfigRuleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConfigRuleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConfigRuleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConfigRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpec(obj: ConfigRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConfigRuleSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ConfigRuleSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ConfigRuleSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ConfigRuleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConfigRuleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ConfigRuleSpecDeletionPolicy
 */
export enum ConfigRuleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConfigRuleSpecForProvider
 */
export interface ConfigRuleSpecForProvider {
  /**
   * Description of the rule
   *
   * @schema ConfigRuleSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A string in JSON format that is passed to the AWS Config rule Lambda function.
   *
   * @schema ConfigRuleSpecForProvider#inputParameters
   */
  readonly inputParameters?: string;

  /**
   * The maximum frequency with which AWS Config runs evaluations for a rule.
   *
   * @schema ConfigRuleSpecForProvider#maximumExecutionFrequency
   */
  readonly maximumExecutionFrequency?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConfigRuleSpecForProvider#region
   */
  readonly region: string;

  /**
   * Scope defines which resources can trigger an evaluation for the rule. See Source Below.
   *
   * @schema ConfigRuleSpecForProvider#scope
   */
  readonly scope?: ConfigRuleSpecForProviderScope[];

  /**
   * Source specifies the rule owner, the rule identifier, and the notifications that cause the function to evaluate your AWS resources. See Scope Below.
   *
   * @schema ConfigRuleSpecForProvider#source
   */
  readonly source: ConfigRuleSpecForProviderSource[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ConfigRuleSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ConfigRuleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecForProvider(obj: ConfigRuleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'inputParameters': obj.inputParameters,
    'maximumExecutionFrequency': obj.maximumExecutionFrequency,
    'region': obj.region,
    'scope': obj.scope?.map(y => toJson_ConfigRuleSpecForProviderScope(y)),
    'source': obj.source?.map(y => toJson_ConfigRuleSpecForProviderSource(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConfigRuleSpecProviderConfigRef
 */
export interface ConfigRuleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigRuleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigRuleSpecProviderConfigRef#policy
   */
  readonly policy?: ConfigRuleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigRuleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecProviderConfigRef(obj: ConfigRuleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigRuleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ConfigRuleSpecProviderRef
 */
export interface ConfigRuleSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigRuleSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigRuleSpecProviderRef#policy
   */
  readonly policy?: ConfigRuleSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ConfigRuleSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecProviderRef(obj: ConfigRuleSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigRuleSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConfigRuleSpecPublishConnectionDetailsTo
 */
export interface ConfigRuleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConfigRuleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConfigRuleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConfigRuleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConfigRuleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConfigRuleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConfigRuleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecPublishConnectionDetailsTo(obj: ConfigRuleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConfigRuleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConfigRuleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConfigRuleSpecWriteConnectionSecretToRef
 */
export interface ConfigRuleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConfigRuleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConfigRuleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConfigRuleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecWriteConnectionSecretToRef(obj: ConfigRuleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigRuleSpecForProviderScope
 */
export interface ConfigRuleSpecForProviderScope {
  /**
   * The IDs of the only AWS resource that you want to trigger an evaluation for the rule. If you specify a resource ID, you must specify one resource type for compliance_resource_types.
   *
   * @schema ConfigRuleSpecForProviderScope#complianceResourceId
   */
  readonly complianceResourceId?: string;

  /**
   * A list of resource types of only those AWS resources that you want to trigger an evaluation for the ruleE.g., AWS::EC2::Instance. You can only specify one type if you also specify a resource ID for compliance_resource_id. See relevant part of AWS Docs for available types.
   *
   * @schema ConfigRuleSpecForProviderScope#complianceResourceTypes
   */
  readonly complianceResourceTypes?: string[];

  /**
   * The tag key that is applied to only those AWS resources that you want you want to trigger an evaluation for the rule.
   *
   * @schema ConfigRuleSpecForProviderScope#tagKey
   */
  readonly tagKey?: string;

  /**
   * The tag value applied to only those AWS resources that you want to trigger an evaluation for the rule.
   *
   * @schema ConfigRuleSpecForProviderScope#tagValue
   */
  readonly tagValue?: string;

}

/**
 * Converts an object of type 'ConfigRuleSpecForProviderScope' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecForProviderScope(obj: ConfigRuleSpecForProviderScope | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'complianceResourceId': obj.complianceResourceId,
    'complianceResourceTypes': obj.complianceResourceTypes?.map(y => y),
    'tagKey': obj.tagKey,
    'tagValue': obj.tagValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigRuleSpecForProviderSource
 */
export interface ConfigRuleSpecForProviderSource {
  /**
   * Provides the runtime system, policy definition, and whether debug logging is enabled. Required when owner is set to CUSTOM_POLICY. See Custom Policy Details Below.
   *
   * @schema ConfigRuleSpecForProviderSource#customPolicyDetails
   */
  readonly customPolicyDetails?: ConfigRuleSpecForProviderSourceCustomPolicyDetails[];

  /**
   * Indicates whether AWS or the customer owns and manages the AWS Config rule. Valid values are AWS, CUSTOM_LAMBDA or CUSTOM_POLICY. For more information about managed rules, see the AWS Config Managed Rules documentation. For more information about custom rules, see the AWS Config Custom Rules documentation. Custom Lambda Functions require permissions to allow the AWS Config service to invoke them, e.g., via the aws_lambda_permission resource.
   *
   * @schema ConfigRuleSpecForProviderSource#owner
   */
  readonly owner: string;

  /**
   * Provides the source and type of the event that causes AWS Config to evaluate your AWS resources. Only valid if owner is CUSTOM_LAMBDA or CUSTOM_POLICY. See Source Detail Below.
   *
   * @schema ConfigRuleSpecForProviderSource#sourceDetail
   */
  readonly sourceDetail?: ConfigRuleSpecForProviderSourceSourceDetail[];

  /**
   * For AWS Config managed rules, a predefined identifier, e.g IAM_PASSWORD_POLICY. For custom Lambda rules, the identifier is the ARN of the Lambda Function, such as arn:aws:lambda:us-east-1:123456789012:function:custom_rule_name or the arn attribute of the aws_lambda_function resource.
   *
   * @schema ConfigRuleSpecForProviderSource#sourceIdentifier
   */
  readonly sourceIdentifier?: string;

  /**
   * Reference to a Function in lambda to populate sourceIdentifier.
   *
   * @schema ConfigRuleSpecForProviderSource#sourceIdentifierRef
   */
  readonly sourceIdentifierRef?: ConfigRuleSpecForProviderSourceSourceIdentifierRef;

  /**
   * Selector for a Function in lambda to populate sourceIdentifier.
   *
   * @schema ConfigRuleSpecForProviderSource#sourceIdentifierSelector
   */
  readonly sourceIdentifierSelector?: ConfigRuleSpecForProviderSourceSourceIdentifierSelector;

}

/**
 * Converts an object of type 'ConfigRuleSpecForProviderSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecForProviderSource(obj: ConfigRuleSpecForProviderSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customPolicyDetails': obj.customPolicyDetails?.map(y => toJson_ConfigRuleSpecForProviderSourceCustomPolicyDetails(y)),
    'owner': obj.owner,
    'sourceDetail': obj.sourceDetail?.map(y => toJson_ConfigRuleSpecForProviderSourceSourceDetail(y)),
    'sourceIdentifier': obj.sourceIdentifier,
    'sourceIdentifierRef': toJson_ConfigRuleSpecForProviderSourceSourceIdentifierRef(obj.sourceIdentifierRef),
    'sourceIdentifierSelector': toJson_ConfigRuleSpecForProviderSourceSourceIdentifierSelector(obj.sourceIdentifierSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigRuleSpecProviderConfigRefPolicy
 */
export interface ConfigRuleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigRuleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigRuleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigRuleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigRuleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigRuleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecProviderConfigRefPolicy(obj: ConfigRuleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigRuleSpecProviderRefPolicy
 */
export interface ConfigRuleSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigRuleSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ConfigRuleSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigRuleSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ConfigRuleSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigRuleSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecProviderRefPolicy(obj: ConfigRuleSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConfigRuleSpecPublishConnectionDetailsToConfigRef
 */
export interface ConfigRuleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigRuleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigRuleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConfigRuleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigRuleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecPublishConnectionDetailsToConfigRef(obj: ConfigRuleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConfigRuleSpecPublishConnectionDetailsToMetadata
 */
export interface ConfigRuleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigRuleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigRuleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConfigRuleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConfigRuleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecPublishConnectionDetailsToMetadata(obj: ConfigRuleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigRuleSpecForProviderSourceCustomPolicyDetails
 */
export interface ConfigRuleSpecForProviderSourceCustomPolicyDetails {
  /**
   * The boolean expression for enabling debug logging for your Config Custom Policy rule. The default value is false.
   *
   * @schema ConfigRuleSpecForProviderSourceCustomPolicyDetails#enableDebugLogDelivery
   */
  readonly enableDebugLogDelivery?: boolean;

  /**
   * The runtime system for your Config Custom Policy rule. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the Guard GitHub Repository.
   *
   * @schema ConfigRuleSpecForProviderSourceCustomPolicyDetails#policyRuntime
   */
  readonly policyRuntime: string;

  /**
   * The policy definition containing the logic for your Config Custom Policy rule.
   *
   * @schema ConfigRuleSpecForProviderSourceCustomPolicyDetails#policyText
   */
  readonly policyText: string;

}

/**
 * Converts an object of type 'ConfigRuleSpecForProviderSourceCustomPolicyDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecForProviderSourceCustomPolicyDetails(obj: ConfigRuleSpecForProviderSourceCustomPolicyDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableDebugLogDelivery': obj.enableDebugLogDelivery,
    'policyRuntime': obj.policyRuntime,
    'policyText': obj.policyText,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigRuleSpecForProviderSourceSourceDetail
 */
export interface ConfigRuleSpecForProviderSourceSourceDetail {
  /**
   * The source of the event, such as an AWS service, that triggers AWS Config to evaluate your AWSresources. This defaults to aws.config and is the only valid value.
   *
   * @schema ConfigRuleSpecForProviderSourceSourceDetail#eventSource
   */
  readonly eventSource?: string;

  /**
   * The maximum frequency with which AWS Config runs evaluations for a rule.
   *
   * @schema ConfigRuleSpecForProviderSourceSourceDetail#maximumExecutionFrequency
   */
  readonly maximumExecutionFrequency?: string;

  /**
   * The type of notification that triggers AWS Config to run an evaluation for a rule. You canspecify the following notification types:
   *
   * @schema ConfigRuleSpecForProviderSourceSourceDetail#messageType
   */
  readonly messageType?: string;

}

/**
 * Converts an object of type 'ConfigRuleSpecForProviderSourceSourceDetail' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecForProviderSourceSourceDetail(obj: ConfigRuleSpecForProviderSourceSourceDetail | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventSource': obj.eventSource,
    'maximumExecutionFrequency': obj.maximumExecutionFrequency,
    'messageType': obj.messageType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function in lambda to populate sourceIdentifier.
 *
 * @schema ConfigRuleSpecForProviderSourceSourceIdentifierRef
 */
export interface ConfigRuleSpecForProviderSourceSourceIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigRuleSpecForProviderSourceSourceIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigRuleSpecForProviderSourceSourceIdentifierRef#policy
   */
  readonly policy?: ConfigRuleSpecForProviderSourceSourceIdentifierRefPolicy;

}

/**
 * Converts an object of type 'ConfigRuleSpecForProviderSourceSourceIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecForProviderSourceSourceIdentifierRef(obj: ConfigRuleSpecForProviderSourceSourceIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigRuleSpecForProviderSourceSourceIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function in lambda to populate sourceIdentifier.
 *
 * @schema ConfigRuleSpecForProviderSourceSourceIdentifierSelector
 */
export interface ConfigRuleSpecForProviderSourceSourceIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConfigRuleSpecForProviderSourceSourceIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConfigRuleSpecForProviderSourceSourceIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConfigRuleSpecForProviderSourceSourceIdentifierSelector#policy
   */
  readonly policy?: ConfigRuleSpecForProviderSourceSourceIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'ConfigRuleSpecForProviderSourceSourceIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecForProviderSourceSourceIdentifierSelector(obj: ConfigRuleSpecForProviderSourceSourceIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConfigRuleSpecForProviderSourceSourceIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigRuleSpecProviderConfigRefPolicyResolution
 */
export enum ConfigRuleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigRuleSpecProviderConfigRefPolicyResolve
 */
export enum ConfigRuleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigRuleSpecProviderRefPolicyResolution
 */
export enum ConfigRuleSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigRuleSpecProviderRefPolicyResolve
 */
export enum ConfigRuleSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConfigRuleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConfigRuleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigRuleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConfigRuleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigRuleSpecForProviderSourceSourceIdentifierRefPolicy
 */
export interface ConfigRuleSpecForProviderSourceSourceIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigRuleSpecForProviderSourceSourceIdentifierRefPolicy#resolution
   */
  readonly resolution?: ConfigRuleSpecForProviderSourceSourceIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigRuleSpecForProviderSourceSourceIdentifierRefPolicy#resolve
   */
  readonly resolve?: ConfigRuleSpecForProviderSourceSourceIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigRuleSpecForProviderSourceSourceIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecForProviderSourceSourceIdentifierRefPolicy(obj: ConfigRuleSpecForProviderSourceSourceIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConfigRuleSpecForProviderSourceSourceIdentifierSelectorPolicy
 */
export interface ConfigRuleSpecForProviderSourceSourceIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigRuleSpecForProviderSourceSourceIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: ConfigRuleSpecForProviderSourceSourceIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigRuleSpecForProviderSourceSourceIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: ConfigRuleSpecForProviderSourceSourceIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConfigRuleSpecForProviderSourceSourceIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigRuleSpecForProviderSourceSourceIdentifierSelectorPolicy(obj: ConfigRuleSpecForProviderSourceSourceIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConfigRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConfigRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigRuleSpecForProviderSourceSourceIdentifierRefPolicyResolution
 */
export enum ConfigRuleSpecForProviderSourceSourceIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigRuleSpecForProviderSourceSourceIdentifierRefPolicyResolve
 */
export enum ConfigRuleSpecForProviderSourceSourceIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigRuleSpecForProviderSourceSourceIdentifierSelectorPolicyResolution
 */
export enum ConfigRuleSpecForProviderSourceSourceIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigRuleSpecForProviderSourceSourceIdentifierSelectorPolicyResolve
 */
export enum ConfigRuleSpecForProviderSourceSourceIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ConfigurationAggregator is the Schema for the ConfigurationAggregators API. Manages an AWS Config Configuration Aggregator.
 *
 * @schema ConfigurationAggregator
 */
export class ConfigurationAggregator extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ConfigurationAggregator"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'configservice.aws.upbound.io/v1beta1',
    kind: 'ConfigurationAggregator',
  }

  /**
   * Renders a Kubernetes manifest for "ConfigurationAggregator".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConfigurationAggregatorProps): any {
    return {
      ...ConfigurationAggregator.GVK,
      ...toJson_ConfigurationAggregatorProps(props),
    };
  }

  /**
   * Defines a "ConfigurationAggregator" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConfigurationAggregatorProps) {
    super(scope, id, {
      ...ConfigurationAggregator.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ConfigurationAggregator.GVK,
      ...toJson_ConfigurationAggregatorProps(resolved),
    };
  }
}

/**
 * ConfigurationAggregator is the Schema for the ConfigurationAggregators API. Manages an AWS Config Configuration Aggregator.
 *
 * @schema ConfigurationAggregator
 */
export interface ConfigurationAggregatorProps {
  /**
   * @schema ConfigurationAggregator#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConfigurationAggregatorSpec defines the desired state of ConfigurationAggregator
   *
   * @schema ConfigurationAggregator#spec
   */
  readonly spec: ConfigurationAggregatorSpec;

}

/**
 * Converts an object of type 'ConfigurationAggregatorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorProps(obj: ConfigurationAggregatorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConfigurationAggregatorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigurationAggregatorSpec defines the desired state of ConfigurationAggregator
 *
 * @schema ConfigurationAggregatorSpec
 */
export interface ConfigurationAggregatorSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ConfigurationAggregatorSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConfigurationAggregatorSpecDeletionPolicy;

  /**
   * @schema ConfigurationAggregatorSpec#forProvider
   */
  readonly forProvider: ConfigurationAggregatorSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConfigurationAggregatorSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConfigurationAggregatorSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ConfigurationAggregatorSpec#providerRef
   */
  readonly providerRef?: ConfigurationAggregatorSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConfigurationAggregatorSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConfigurationAggregatorSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConfigurationAggregatorSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConfigurationAggregatorSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConfigurationAggregatorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorSpec(obj: ConfigurationAggregatorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConfigurationAggregatorSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ConfigurationAggregatorSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ConfigurationAggregatorSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ConfigurationAggregatorSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConfigurationAggregatorSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ConfigurationAggregatorSpecDeletionPolicy
 */
export enum ConfigurationAggregatorSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConfigurationAggregatorSpecForProvider
 */
export interface ConfigurationAggregatorSpecForProvider {
  /**
   * The account(s) to aggregate config data from as documented below.
   *
   * @schema ConfigurationAggregatorSpecForProvider#accountAggregationSource
   */
  readonly accountAggregationSource?: ConfigurationAggregatorSpecForProviderAccountAggregationSource[];

  /**
   * The organization to aggregate config data from as documented below.
   *
   * @schema ConfigurationAggregatorSpecForProvider#organizationAggregationSource
   */
  readonly organizationAggregationSource?: ConfigurationAggregatorSpecForProviderOrganizationAggregationSource[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConfigurationAggregatorSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ConfigurationAggregatorSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ConfigurationAggregatorSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorSpecForProvider(obj: ConfigurationAggregatorSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountAggregationSource': obj.accountAggregationSource?.map(y => toJson_ConfigurationAggregatorSpecForProviderAccountAggregationSource(y)),
    'organizationAggregationSource': obj.organizationAggregationSource?.map(y => toJson_ConfigurationAggregatorSpecForProviderOrganizationAggregationSource(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConfigurationAggregatorSpecProviderConfigRef
 */
export interface ConfigurationAggregatorSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationAggregatorSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationAggregatorSpecProviderConfigRef#policy
   */
  readonly policy?: ConfigurationAggregatorSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationAggregatorSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorSpecProviderConfigRef(obj: ConfigurationAggregatorSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationAggregatorSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ConfigurationAggregatorSpecProviderRef
 */
export interface ConfigurationAggregatorSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationAggregatorSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationAggregatorSpecProviderRef#policy
   */
  readonly policy?: ConfigurationAggregatorSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationAggregatorSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorSpecProviderRef(obj: ConfigurationAggregatorSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationAggregatorSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConfigurationAggregatorSpecPublishConnectionDetailsTo
 */
export interface ConfigurationAggregatorSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConfigurationAggregatorSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConfigurationAggregatorSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConfigurationAggregatorSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConfigurationAggregatorSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConfigurationAggregatorSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorSpecPublishConnectionDetailsTo(obj: ConfigurationAggregatorSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConfigurationAggregatorSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConfigurationAggregatorSpecWriteConnectionSecretToRef
 */
export interface ConfigurationAggregatorSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConfigurationAggregatorSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConfigurationAggregatorSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConfigurationAggregatorSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorSpecWriteConnectionSecretToRef(obj: ConfigurationAggregatorSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationAggregatorSpecForProviderAccountAggregationSource
 */
export interface ConfigurationAggregatorSpecForProviderAccountAggregationSource {
  /**
   * List of 12-digit account IDs of the account(s) being aggregated.
   *
   * @schema ConfigurationAggregatorSpecForProviderAccountAggregationSource#accountIds
   */
  readonly accountIds: string[];

  /**
   * If true, aggregate existing AWS Config regions and future regions.
   *
   * @schema ConfigurationAggregatorSpecForProviderAccountAggregationSource#allRegions
   */
  readonly allRegions?: boolean;

  /**
   * List of source regions being aggregated.
   *
   * @schema ConfigurationAggregatorSpecForProviderAccountAggregationSource#regions
   */
  readonly regions?: string[];

}

/**
 * Converts an object of type 'ConfigurationAggregatorSpecForProviderAccountAggregationSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorSpecForProviderAccountAggregationSource(obj: ConfigurationAggregatorSpecForProviderAccountAggregationSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountIds': obj.accountIds?.map(y => y),
    'allRegions': obj.allRegions,
    'regions': obj.regions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSource
 */
export interface ConfigurationAggregatorSpecForProviderOrganizationAggregationSource {
  /**
   * If true, aggregate existing AWS Config regions and future regions.
   *
   * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSource#allRegions
   */
  readonly allRegions?: boolean;

  /**
   * List of source regions being aggregated.
   *
   * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSource#regions
   */
  readonly regions?: string[];

  /**
   * ARN of the IAM role used to retrieve AWS Organization details associated with the aggregator account.
   *
   * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSource#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSource#roleArnRef
   */
  readonly roleArnRef?: ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSource#roleArnSelector
   */
  readonly roleArnSelector?: ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelector;

}

/**
 * Converts an object of type 'ConfigurationAggregatorSpecForProviderOrganizationAggregationSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorSpecForProviderOrganizationAggregationSource(obj: ConfigurationAggregatorSpecForProviderOrganizationAggregationSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allRegions': obj.allRegions,
    'regions': obj.regions?.map(y => y),
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelector(obj.roleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationAggregatorSpecProviderConfigRefPolicy
 */
export interface ConfigurationAggregatorSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationAggregatorSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationAggregatorSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationAggregatorSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationAggregatorSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationAggregatorSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorSpecProviderConfigRefPolicy(obj: ConfigurationAggregatorSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationAggregatorSpecProviderRefPolicy
 */
export interface ConfigurationAggregatorSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationAggregatorSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ConfigurationAggregatorSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationAggregatorSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ConfigurationAggregatorSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationAggregatorSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorSpecProviderRefPolicy(obj: ConfigurationAggregatorSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRef
 */
export interface ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRef(obj: ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConfigurationAggregatorSpecPublishConnectionDetailsToMetadata
 */
export interface ConfigurationAggregatorSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationAggregatorSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationAggregatorSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConfigurationAggregatorSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConfigurationAggregatorSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorSpecPublishConnectionDetailsToMetadata(obj: ConfigurationAggregatorSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRef
 */
export interface ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRef#policy
   */
  readonly policy?: ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRef(obj: ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelector
 */
export interface ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelector#policy
   */
  readonly policy?: ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelector(obj: ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationAggregatorSpecProviderConfigRefPolicyResolution
 */
export enum ConfigurationAggregatorSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationAggregatorSpecProviderConfigRefPolicyResolve
 */
export enum ConfigurationAggregatorSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationAggregatorSpecProviderRefPolicyResolution
 */
export enum ConfigurationAggregatorSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationAggregatorSpecProviderRefPolicyResolve
 */
export enum ConfigurationAggregatorSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRefPolicy
 */
export interface ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRefPolicy#resolution
   */
  readonly resolution?: ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRefPolicy#resolve
   */
  readonly resolve?: ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRefPolicy(obj: ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelectorPolicy
 */
export interface ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelectorPolicy(obj: ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConfigurationAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRefPolicyResolution
 */
export enum ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRefPolicyResolve
 */
export enum ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelectorPolicyResolution
 */
export enum ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelectorPolicyResolve
 */
export enum ConfigurationAggregatorSpecForProviderOrganizationAggregationSourceRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ConfigurationRecorder is the Schema for the ConfigurationRecorders API. Provides an AWS Config Configuration Recorder.
 *
 * @schema ConfigurationRecorder
 */
export class ConfigurationRecorder extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ConfigurationRecorder"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'configservice.aws.upbound.io/v1beta1',
    kind: 'ConfigurationRecorder',
  }

  /**
   * Renders a Kubernetes manifest for "ConfigurationRecorder".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConfigurationRecorderProps): any {
    return {
      ...ConfigurationRecorder.GVK,
      ...toJson_ConfigurationRecorderProps(props),
    };
  }

  /**
   * Defines a "ConfigurationRecorder" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConfigurationRecorderProps) {
    super(scope, id, {
      ...ConfigurationRecorder.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ConfigurationRecorder.GVK,
      ...toJson_ConfigurationRecorderProps(resolved),
    };
  }
}

/**
 * ConfigurationRecorder is the Schema for the ConfigurationRecorders API. Provides an AWS Config Configuration Recorder.
 *
 * @schema ConfigurationRecorder
 */
export interface ConfigurationRecorderProps {
  /**
   * @schema ConfigurationRecorder#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConfigurationRecorderSpec defines the desired state of ConfigurationRecorder
   *
   * @schema ConfigurationRecorder#spec
   */
  readonly spec: ConfigurationRecorderSpec;

}

/**
 * Converts an object of type 'ConfigurationRecorderProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationRecorderProps(obj: ConfigurationRecorderProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConfigurationRecorderSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigurationRecorderSpec defines the desired state of ConfigurationRecorder
 *
 * @schema ConfigurationRecorderSpec
 */
export interface ConfigurationRecorderSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ConfigurationRecorderSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConfigurationRecorderSpecDeletionPolicy;

  /**
   * @schema ConfigurationRecorderSpec#forProvider
   */
  readonly forProvider: ConfigurationRecorderSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConfigurationRecorderSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConfigurationRecorderSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ConfigurationRecorderSpec#providerRef
   */
  readonly providerRef?: ConfigurationRecorderSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConfigurationRecorderSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConfigurationRecorderSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConfigurationRecorderSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConfigurationRecorderSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConfigurationRecorderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationRecorderSpec(obj: ConfigurationRecorderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConfigurationRecorderSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ConfigurationRecorderSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ConfigurationRecorderSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ConfigurationRecorderSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConfigurationRecorderSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ConfigurationRecorderSpecDeletionPolicy
 */
export enum ConfigurationRecorderSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConfigurationRecorderSpecForProvider
 */
export interface ConfigurationRecorderSpecForProvider {
  /**
   * Recording group - see below.
   *
   * @schema ConfigurationRecorderSpecForProvider#recordingGroup
   */
  readonly recordingGroup?: ConfigurationRecorderSpecForProviderRecordingGroup[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConfigurationRecorderSpecForProvider#region
   */
  readonly region: string;

  /**
   * Amazon Resource Name (ARN) of the IAM role. Used to make read or write requests to the delivery channel and to describe the AWS resources associated with the account. See AWS Docs for more details.
   *
   * @schema ConfigurationRecorderSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ConfigurationRecorderSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: ConfigurationRecorderSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ConfigurationRecorderSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: ConfigurationRecorderSpecForProviderRoleArnSelector;

}

/**
 * Converts an object of type 'ConfigurationRecorderSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationRecorderSpecForProvider(obj: ConfigurationRecorderSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordingGroup': obj.recordingGroup?.map(y => toJson_ConfigurationRecorderSpecForProviderRecordingGroup(y)),
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ConfigurationRecorderSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ConfigurationRecorderSpecForProviderRoleArnSelector(obj.roleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConfigurationRecorderSpecProviderConfigRef
 */
export interface ConfigurationRecorderSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationRecorderSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationRecorderSpecProviderConfigRef#policy
   */
  readonly policy?: ConfigurationRecorderSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationRecorderSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationRecorderSpecProviderConfigRef(obj: ConfigurationRecorderSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationRecorderSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ConfigurationRecorderSpecProviderRef
 */
export interface ConfigurationRecorderSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationRecorderSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationRecorderSpecProviderRef#policy
   */
  readonly policy?: ConfigurationRecorderSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationRecorderSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationRecorderSpecProviderRef(obj: ConfigurationRecorderSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationRecorderSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConfigurationRecorderSpecPublishConnectionDetailsTo
 */
export interface ConfigurationRecorderSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConfigurationRecorderSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConfigurationRecorderSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConfigurationRecorderSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConfigurationRecorderSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConfigurationRecorderSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConfigurationRecorderSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationRecorderSpecPublishConnectionDetailsTo(obj: ConfigurationRecorderSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConfigurationRecorderSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConfigurationRecorderSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConfigurationRecorderSpecWriteConnectionSecretToRef
 */
export interface ConfigurationRecorderSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConfigurationRecorderSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConfigurationRecorderSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConfigurationRecorderSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationRecorderSpecWriteConnectionSecretToRef(obj: ConfigurationRecorderSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationRecorderSpecForProviderRecordingGroup
 */
export interface ConfigurationRecorderSpecForProviderRecordingGroup {
  /**
   * Specifies whether AWS Config records configuration changes for every supported type of regional resource (which includes any new type that will become supported in the future). Conflicts with resource_types. Defaults to true.
   *
   * @default true.
   * @schema ConfigurationRecorderSpecForProviderRecordingGroup#allSupported
   */
  readonly allSupported?: boolean;

  /**
   * Specifies whether AWS Config includes all supported types of global resources with the resources that it records. Requires all_supported = true. Conflicts with resource_types.
   *
   * @schema ConfigurationRecorderSpecForProviderRecordingGroup#includeGlobalResourceTypes
   */
  readonly includeGlobalResourceTypes?: boolean;

  /**
   * A list that specifies the types of AWS resources for which AWS Config records configuration changes (for example, AWS::EC2::Instance or AWS::CloudTrail::Trail). See relevant part of AWS Docs for available types. In order to use this attribute, all_supported must be set to false.
   *
   * @schema ConfigurationRecorderSpecForProviderRecordingGroup#resourceTypes
   */
  readonly resourceTypes?: string[];

}

/**
 * Converts an object of type 'ConfigurationRecorderSpecForProviderRecordingGroup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationRecorderSpecForProviderRecordingGroup(obj: ConfigurationRecorderSpecForProviderRecordingGroup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allSupported': obj.allSupported,
    'includeGlobalResourceTypes': obj.includeGlobalResourceTypes,
    'resourceTypes': obj.resourceTypes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ConfigurationRecorderSpecForProviderRoleArnRef
 */
export interface ConfigurationRecorderSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationRecorderSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationRecorderSpecForProviderRoleArnRef#policy
   */
  readonly policy?: ConfigurationRecorderSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationRecorderSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationRecorderSpecForProviderRoleArnRef(obj: ConfigurationRecorderSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationRecorderSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ConfigurationRecorderSpecForProviderRoleArnSelector
 */
export interface ConfigurationRecorderSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConfigurationRecorderSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConfigurationRecorderSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConfigurationRecorderSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: ConfigurationRecorderSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ConfigurationRecorderSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationRecorderSpecForProviderRoleArnSelector(obj: ConfigurationRecorderSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConfigurationRecorderSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationRecorderSpecProviderConfigRefPolicy
 */
export interface ConfigurationRecorderSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationRecorderSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationRecorderSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationRecorderSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationRecorderSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationRecorderSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationRecorderSpecProviderConfigRefPolicy(obj: ConfigurationRecorderSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationRecorderSpecProviderRefPolicy
 */
export interface ConfigurationRecorderSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationRecorderSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ConfigurationRecorderSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationRecorderSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ConfigurationRecorderSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationRecorderSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationRecorderSpecProviderRefPolicy(obj: ConfigurationRecorderSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConfigurationRecorderSpecPublishConnectionDetailsToConfigRef
 */
export interface ConfigurationRecorderSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationRecorderSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationRecorderSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConfigurationRecorderSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationRecorderSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationRecorderSpecPublishConnectionDetailsToConfigRef(obj: ConfigurationRecorderSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationRecorderSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConfigurationRecorderSpecPublishConnectionDetailsToMetadata
 */
export interface ConfigurationRecorderSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationRecorderSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationRecorderSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConfigurationRecorderSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConfigurationRecorderSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationRecorderSpecPublishConnectionDetailsToMetadata(obj: ConfigurationRecorderSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationRecorderSpecForProviderRoleArnRefPolicy
 */
export interface ConfigurationRecorderSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationRecorderSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: ConfigurationRecorderSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationRecorderSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: ConfigurationRecorderSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationRecorderSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationRecorderSpecForProviderRoleArnRefPolicy(obj: ConfigurationRecorderSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConfigurationRecorderSpecForProviderRoleArnSelectorPolicy
 */
export interface ConfigurationRecorderSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationRecorderSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ConfigurationRecorderSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationRecorderSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ConfigurationRecorderSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationRecorderSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationRecorderSpecForProviderRoleArnSelectorPolicy(obj: ConfigurationRecorderSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationRecorderSpecProviderConfigRefPolicyResolution
 */
export enum ConfigurationRecorderSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationRecorderSpecProviderConfigRefPolicyResolve
 */
export enum ConfigurationRecorderSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationRecorderSpecProviderRefPolicyResolution
 */
export enum ConfigurationRecorderSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationRecorderSpecProviderRefPolicyResolve
 */
export enum ConfigurationRecorderSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConfigurationRecorderSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConfigurationRecorderSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationRecorderSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationRecorderSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationRecorderSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationRecorderSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationRecorderSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationRecorderSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConfigurationRecorderSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationRecorderSpecForProviderRoleArnRefPolicyResolution
 */
export enum ConfigurationRecorderSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationRecorderSpecForProviderRoleArnRefPolicyResolve
 */
export enum ConfigurationRecorderSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationRecorderSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum ConfigurationRecorderSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationRecorderSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum ConfigurationRecorderSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationRecorderSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConfigurationRecorderSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationRecorderSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConfigurationRecorderSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ConformancePack is the Schema for the ConformancePacks API. Manages a Config Conformance Pack
 *
 * @schema ConformancePack
 */
export class ConformancePack extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ConformancePack"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'configservice.aws.upbound.io/v1beta1',
    kind: 'ConformancePack',
  }

  /**
   * Renders a Kubernetes manifest for "ConformancePack".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConformancePackProps): any {
    return {
      ...ConformancePack.GVK,
      ...toJson_ConformancePackProps(props),
    };
  }

  /**
   * Defines a "ConformancePack" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConformancePackProps) {
    super(scope, id, {
      ...ConformancePack.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ConformancePack.GVK,
      ...toJson_ConformancePackProps(resolved),
    };
  }
}

/**
 * ConformancePack is the Schema for the ConformancePacks API. Manages a Config Conformance Pack
 *
 * @schema ConformancePack
 */
export interface ConformancePackProps {
  /**
   * @schema ConformancePack#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConformancePackSpec defines the desired state of ConformancePack
   *
   * @schema ConformancePack#spec
   */
  readonly spec: ConformancePackSpec;

}

/**
 * Converts an object of type 'ConformancePackProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConformancePackProps(obj: ConformancePackProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConformancePackSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConformancePackSpec defines the desired state of ConformancePack
 *
 * @schema ConformancePackSpec
 */
export interface ConformancePackSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ConformancePackSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConformancePackSpecDeletionPolicy;

  /**
   * @schema ConformancePackSpec#forProvider
   */
  readonly forProvider: ConformancePackSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConformancePackSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConformancePackSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ConformancePackSpec#providerRef
   */
  readonly providerRef?: ConformancePackSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConformancePackSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConformancePackSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConformancePackSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConformancePackSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConformancePackSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConformancePackSpec(obj: ConformancePackSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConformancePackSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ConformancePackSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ConformancePackSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ConformancePackSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConformancePackSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ConformancePackSpecDeletionPolicy
 */
export enum ConformancePackSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConformancePackSpecForProvider
 */
export interface ConformancePackSpecForProvider {
  /**
   * Amazon S3 bucket where AWS Config stores conformance pack templates. Maximum length of 63.
   *
   * @schema ConformancePackSpecForProvider#deliveryS3Bucket
   */
  readonly deliveryS3Bucket?: string;

  /**
   * The prefix for the Amazon S3 bucket. Maximum length of 1024.
   *
   * @schema ConformancePackSpecForProvider#deliveryS3KeyPrefix
   */
  readonly deliveryS3KeyPrefix?: string;

  /**
   * Set of configuration blocks describing input parameters passed to the conformance pack template. Documented below. When configured, the parameters must also be included in the template_body or in the template stored in Amazon S3 if using template_s3_uri.
   *
   * @schema ConformancePackSpecForProvider#inputParameter
   */
  readonly inputParameter?: ConformancePackSpecForProviderInputParameter[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConformancePackSpecForProvider#region
   */
  readonly region: string;

  /**
   * A string containing full conformance pack template body. Maximum length of 51200. Drift detection is not possible with this argument.
   *
   * @schema ConformancePackSpecForProvider#templateBody
   */
  readonly templateBody?: string;

  /**
   * Location of file, e.g., s3://bucketname/prefix, containing the template body. The uri must point to the conformance pack template that is located in an Amazon S3 bucket in the same region as the conformance pack. Maximum length of 1024. Drift detection is not possible with this argument.
   *
   * @schema ConformancePackSpecForProvider#templateS3Uri
   */
  readonly templateS3Uri?: string;

}

/**
 * Converts an object of type 'ConformancePackSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConformancePackSpecForProvider(obj: ConformancePackSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deliveryS3Bucket': obj.deliveryS3Bucket,
    'deliveryS3KeyPrefix': obj.deliveryS3KeyPrefix,
    'inputParameter': obj.inputParameter?.map(y => toJson_ConformancePackSpecForProviderInputParameter(y)),
    'region': obj.region,
    'templateBody': obj.templateBody,
    'templateS3Uri': obj.templateS3Uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConformancePackSpecProviderConfigRef
 */
export interface ConformancePackSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConformancePackSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConformancePackSpecProviderConfigRef#policy
   */
  readonly policy?: ConformancePackSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConformancePackSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConformancePackSpecProviderConfigRef(obj: ConformancePackSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConformancePackSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ConformancePackSpecProviderRef
 */
export interface ConformancePackSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConformancePackSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConformancePackSpecProviderRef#policy
   */
  readonly policy?: ConformancePackSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ConformancePackSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConformancePackSpecProviderRef(obj: ConformancePackSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConformancePackSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConformancePackSpecPublishConnectionDetailsTo
 */
export interface ConformancePackSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConformancePackSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConformancePackSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConformancePackSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConformancePackSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConformancePackSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConformancePackSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConformancePackSpecPublishConnectionDetailsTo(obj: ConformancePackSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConformancePackSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConformancePackSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConformancePackSpecWriteConnectionSecretToRef
 */
export interface ConformancePackSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConformancePackSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConformancePackSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConformancePackSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConformancePackSpecWriteConnectionSecretToRef(obj: ConformancePackSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConformancePackSpecForProviderInputParameter
 */
export interface ConformancePackSpecForProviderInputParameter {
  /**
   * The input key.
   *
   * @schema ConformancePackSpecForProviderInputParameter#parameterName
   */
  readonly parameterName: string;

  /**
   * The input value.
   *
   * @schema ConformancePackSpecForProviderInputParameter#parameterValue
   */
  readonly parameterValue: string;

}

/**
 * Converts an object of type 'ConformancePackSpecForProviderInputParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConformancePackSpecForProviderInputParameter(obj: ConformancePackSpecForProviderInputParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConformancePackSpecProviderConfigRefPolicy
 */
export interface ConformancePackSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConformancePackSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConformancePackSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConformancePackSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConformancePackSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConformancePackSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConformancePackSpecProviderConfigRefPolicy(obj: ConformancePackSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConformancePackSpecProviderRefPolicy
 */
export interface ConformancePackSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConformancePackSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ConformancePackSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConformancePackSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ConformancePackSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ConformancePackSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConformancePackSpecProviderRefPolicy(obj: ConformancePackSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConformancePackSpecPublishConnectionDetailsToConfigRef
 */
export interface ConformancePackSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConformancePackSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConformancePackSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConformancePackSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConformancePackSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConformancePackSpecPublishConnectionDetailsToConfigRef(obj: ConformancePackSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConformancePackSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConformancePackSpecPublishConnectionDetailsToMetadata
 */
export interface ConformancePackSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConformancePackSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConformancePackSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConformancePackSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConformancePackSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConformancePackSpecPublishConnectionDetailsToMetadata(obj: ConformancePackSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConformancePackSpecProviderConfigRefPolicyResolution
 */
export enum ConformancePackSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConformancePackSpecProviderConfigRefPolicyResolve
 */
export enum ConformancePackSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConformancePackSpecProviderRefPolicyResolution
 */
export enum ConformancePackSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConformancePackSpecProviderRefPolicyResolve
 */
export enum ConformancePackSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConformancePackSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConformancePackSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConformancePackSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConformancePackSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConformancePackSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConformancePackSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConformancePackSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConformancePackSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConformancePackSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConformancePackSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConformancePackSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConformancePackSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConformancePackSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DeliveryChannel is the Schema for the DeliveryChannels API. Provides an AWS Config Delivery Channel.
 *
 * @schema DeliveryChannel
 */
export class DeliveryChannel extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DeliveryChannel"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'configservice.aws.upbound.io/v1beta1',
    kind: 'DeliveryChannel',
  }

  /**
   * Renders a Kubernetes manifest for "DeliveryChannel".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DeliveryChannelProps): any {
    return {
      ...DeliveryChannel.GVK,
      ...toJson_DeliveryChannelProps(props),
    };
  }

  /**
   * Defines a "DeliveryChannel" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DeliveryChannelProps) {
    super(scope, id, {
      ...DeliveryChannel.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DeliveryChannel.GVK,
      ...toJson_DeliveryChannelProps(resolved),
    };
  }
}

/**
 * DeliveryChannel is the Schema for the DeliveryChannels API. Provides an AWS Config Delivery Channel.
 *
 * @schema DeliveryChannel
 */
export interface DeliveryChannelProps {
  /**
   * @schema DeliveryChannel#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeliveryChannelSpec defines the desired state of DeliveryChannel
   *
   * @schema DeliveryChannel#spec
   */
  readonly spec: DeliveryChannelSpec;

}

/**
 * Converts an object of type 'DeliveryChannelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryChannelProps(obj: DeliveryChannelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DeliveryChannelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeliveryChannelSpec defines the desired state of DeliveryChannel
 *
 * @schema DeliveryChannelSpec
 */
export interface DeliveryChannelSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DeliveryChannelSpec#deletionPolicy
   */
  readonly deletionPolicy?: DeliveryChannelSpecDeletionPolicy;

  /**
   * @schema DeliveryChannelSpec#forProvider
   */
  readonly forProvider: DeliveryChannelSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DeliveryChannelSpec#providerConfigRef
   */
  readonly providerConfigRef?: DeliveryChannelSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DeliveryChannelSpec#providerRef
   */
  readonly providerRef?: DeliveryChannelSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DeliveryChannelSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DeliveryChannelSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DeliveryChannelSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DeliveryChannelSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DeliveryChannelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryChannelSpec(obj: DeliveryChannelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DeliveryChannelSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DeliveryChannelSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DeliveryChannelSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DeliveryChannelSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DeliveryChannelSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DeliveryChannelSpecDeletionPolicy
 */
export enum DeliveryChannelSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DeliveryChannelSpecForProvider
 */
export interface DeliveryChannelSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DeliveryChannelSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name of the S3 bucket used to store the configuration history.
   *
   * @schema DeliveryChannelSpecForProvider#s3BucketName
   */
  readonly s3BucketName?: string;

  /**
   * Reference to a Bucket in s3 to populate s3BucketName.
   *
   * @schema DeliveryChannelSpecForProvider#s3BucketNameRef
   */
  readonly s3BucketNameRef?: DeliveryChannelSpecForProviderS3BucketNameRef;

  /**
   * Selector for a Bucket in s3 to populate s3BucketName.
   *
   * @schema DeliveryChannelSpecForProvider#s3BucketNameSelector
   */
  readonly s3BucketNameSelector?: DeliveryChannelSpecForProviderS3BucketNameSelector;

  /**
   * The prefix for the specified S3 bucket.
   *
   * @schema DeliveryChannelSpecForProvider#s3KeyPrefix
   */
  readonly s3KeyPrefix?: string;

  /**
   * The ARN of the AWS KMS key used to encrypt objects delivered by AWS Config. Must belong to the same Region as the destination S3 bucket.
   *
   * @schema DeliveryChannelSpecForProvider#s3KmsKeyArn
   */
  readonly s3KmsKeyArn?: string;

  /**
   * Options for how AWS Config delivers configuration snapshots. See below
   *
   * @schema DeliveryChannelSpecForProvider#snapshotDeliveryProperties
   */
  readonly snapshotDeliveryProperties?: DeliveryChannelSpecForProviderSnapshotDeliveryProperties[];

  /**
   * The ARN of the SNS topic that AWS Config delivers notifications to.
   *
   * @schema DeliveryChannelSpecForProvider#snsTopicArn
   */
  readonly snsTopicArn?: string;

}

/**
 * Converts an object of type 'DeliveryChannelSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryChannelSpecForProvider(obj: DeliveryChannelSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    's3BucketName': obj.s3BucketName,
    's3BucketNameRef': toJson_DeliveryChannelSpecForProviderS3BucketNameRef(obj.s3BucketNameRef),
    's3BucketNameSelector': toJson_DeliveryChannelSpecForProviderS3BucketNameSelector(obj.s3BucketNameSelector),
    's3KeyPrefix': obj.s3KeyPrefix,
    's3KmsKeyArn': obj.s3KmsKeyArn,
    'snapshotDeliveryProperties': obj.snapshotDeliveryProperties?.map(y => toJson_DeliveryChannelSpecForProviderSnapshotDeliveryProperties(y)),
    'snsTopicArn': obj.snsTopicArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DeliveryChannelSpecProviderConfigRef
 */
export interface DeliveryChannelSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryChannelSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryChannelSpecProviderConfigRef#policy
   */
  readonly policy?: DeliveryChannelSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DeliveryChannelSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryChannelSpecProviderConfigRef(obj: DeliveryChannelSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryChannelSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DeliveryChannelSpecProviderRef
 */
export interface DeliveryChannelSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryChannelSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryChannelSpecProviderRef#policy
   */
  readonly policy?: DeliveryChannelSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DeliveryChannelSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryChannelSpecProviderRef(obj: DeliveryChannelSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryChannelSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DeliveryChannelSpecPublishConnectionDetailsTo
 */
export interface DeliveryChannelSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DeliveryChannelSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DeliveryChannelSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DeliveryChannelSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DeliveryChannelSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DeliveryChannelSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeliveryChannelSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryChannelSpecPublishConnectionDetailsTo(obj: DeliveryChannelSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DeliveryChannelSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DeliveryChannelSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DeliveryChannelSpecWriteConnectionSecretToRef
 */
export interface DeliveryChannelSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DeliveryChannelSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeliveryChannelSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeliveryChannelSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryChannelSpecWriteConnectionSecretToRef(obj: DeliveryChannelSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate s3BucketName.
 *
 * @schema DeliveryChannelSpecForProviderS3BucketNameRef
 */
export interface DeliveryChannelSpecForProviderS3BucketNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryChannelSpecForProviderS3BucketNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryChannelSpecForProviderS3BucketNameRef#policy
   */
  readonly policy?: DeliveryChannelSpecForProviderS3BucketNameRefPolicy;

}

/**
 * Converts an object of type 'DeliveryChannelSpecForProviderS3BucketNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryChannelSpecForProviderS3BucketNameRef(obj: DeliveryChannelSpecForProviderS3BucketNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryChannelSpecForProviderS3BucketNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate s3BucketName.
 *
 * @schema DeliveryChannelSpecForProviderS3BucketNameSelector
 */
export interface DeliveryChannelSpecForProviderS3BucketNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeliveryChannelSpecForProviderS3BucketNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeliveryChannelSpecForProviderS3BucketNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeliveryChannelSpecForProviderS3BucketNameSelector#policy
   */
  readonly policy?: DeliveryChannelSpecForProviderS3BucketNameSelectorPolicy;

}

/**
 * Converts an object of type 'DeliveryChannelSpecForProviderS3BucketNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryChannelSpecForProviderS3BucketNameSelector(obj: DeliveryChannelSpecForProviderS3BucketNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeliveryChannelSpecForProviderS3BucketNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeliveryChannelSpecForProviderSnapshotDeliveryProperties
 */
export interface DeliveryChannelSpecForProviderSnapshotDeliveryProperties {
  /**
   * - The frequency with which AWS Config recurringly delivers configuration snapshotsE.g., One_Hour or Three_Hours. Valid values are listed here.
   *
   * @schema DeliveryChannelSpecForProviderSnapshotDeliveryProperties#deliveryFrequency
   */
  readonly deliveryFrequency?: string;

}

/**
 * Converts an object of type 'DeliveryChannelSpecForProviderSnapshotDeliveryProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryChannelSpecForProviderSnapshotDeliveryProperties(obj: DeliveryChannelSpecForProviderSnapshotDeliveryProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deliveryFrequency': obj.deliveryFrequency,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeliveryChannelSpecProviderConfigRefPolicy
 */
export interface DeliveryChannelSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryChannelSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DeliveryChannelSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryChannelSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DeliveryChannelSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryChannelSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryChannelSpecProviderConfigRefPolicy(obj: DeliveryChannelSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeliveryChannelSpecProviderRefPolicy
 */
export interface DeliveryChannelSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryChannelSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DeliveryChannelSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryChannelSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DeliveryChannelSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryChannelSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryChannelSpecProviderRefPolicy(obj: DeliveryChannelSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DeliveryChannelSpecPublishConnectionDetailsToConfigRef
 */
export interface DeliveryChannelSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeliveryChannelSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeliveryChannelSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DeliveryChannelSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DeliveryChannelSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryChannelSpecPublishConnectionDetailsToConfigRef(obj: DeliveryChannelSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeliveryChannelSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DeliveryChannelSpecPublishConnectionDetailsToMetadata
 */
export interface DeliveryChannelSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeliveryChannelSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeliveryChannelSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DeliveryChannelSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeliveryChannelSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryChannelSpecPublishConnectionDetailsToMetadata(obj: DeliveryChannelSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeliveryChannelSpecForProviderS3BucketNameRefPolicy
 */
export interface DeliveryChannelSpecForProviderS3BucketNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryChannelSpecForProviderS3BucketNameRefPolicy#resolution
   */
  readonly resolution?: DeliveryChannelSpecForProviderS3BucketNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryChannelSpecForProviderS3BucketNameRefPolicy#resolve
   */
  readonly resolve?: DeliveryChannelSpecForProviderS3BucketNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryChannelSpecForProviderS3BucketNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryChannelSpecForProviderS3BucketNameRefPolicy(obj: DeliveryChannelSpecForProviderS3BucketNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeliveryChannelSpecForProviderS3BucketNameSelectorPolicy
 */
export interface DeliveryChannelSpecForProviderS3BucketNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryChannelSpecForProviderS3BucketNameSelectorPolicy#resolution
   */
  readonly resolution?: DeliveryChannelSpecForProviderS3BucketNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryChannelSpecForProviderS3BucketNameSelectorPolicy#resolve
   */
  readonly resolve?: DeliveryChannelSpecForProviderS3BucketNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryChannelSpecForProviderS3BucketNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryChannelSpecForProviderS3BucketNameSelectorPolicy(obj: DeliveryChannelSpecForProviderS3BucketNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryChannelSpecProviderConfigRefPolicyResolution
 */
export enum DeliveryChannelSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryChannelSpecProviderConfigRefPolicyResolve
 */
export enum DeliveryChannelSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryChannelSpecProviderRefPolicyResolution
 */
export enum DeliveryChannelSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryChannelSpecProviderRefPolicyResolve
 */
export enum DeliveryChannelSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeliveryChannelSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DeliveryChannelSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeliveryChannelSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DeliveryChannelSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeliveryChannelSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DeliveryChannelSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeliveryChannelSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeliveryChannelSpecPublishConnectionDetailsToConfigRefPolicy(obj: DeliveryChannelSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryChannelSpecForProviderS3BucketNameRefPolicyResolution
 */
export enum DeliveryChannelSpecForProviderS3BucketNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryChannelSpecForProviderS3BucketNameRefPolicyResolve
 */
export enum DeliveryChannelSpecForProviderS3BucketNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryChannelSpecForProviderS3BucketNameSelectorPolicyResolution
 */
export enum DeliveryChannelSpecForProviderS3BucketNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryChannelSpecForProviderS3BucketNameSelectorPolicyResolve
 */
export enum DeliveryChannelSpecForProviderS3BucketNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeliveryChannelSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DeliveryChannelSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeliveryChannelSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DeliveryChannelSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RemediationConfiguration is the Schema for the RemediationConfigurations API. Provides an AWS Config Remediation Configuration.
 *
 * @schema RemediationConfiguration
 */
export class RemediationConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RemediationConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'configservice.aws.upbound.io/v1beta1',
    kind: 'RemediationConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "RemediationConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RemediationConfigurationProps): any {
    return {
      ...RemediationConfiguration.GVK,
      ...toJson_RemediationConfigurationProps(props),
    };
  }

  /**
   * Defines a "RemediationConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RemediationConfigurationProps) {
    super(scope, id, {
      ...RemediationConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RemediationConfiguration.GVK,
      ...toJson_RemediationConfigurationProps(resolved),
    };
  }
}

/**
 * RemediationConfiguration is the Schema for the RemediationConfigurations API. Provides an AWS Config Remediation Configuration.
 *
 * @schema RemediationConfiguration
 */
export interface RemediationConfigurationProps {
  /**
   * @schema RemediationConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RemediationConfigurationSpec defines the desired state of RemediationConfiguration
   *
   * @schema RemediationConfiguration#spec
   */
  readonly spec: RemediationConfigurationSpec;

}

/**
 * Converts an object of type 'RemediationConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RemediationConfigurationProps(obj: RemediationConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RemediationConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RemediationConfigurationSpec defines the desired state of RemediationConfiguration
 *
 * @schema RemediationConfigurationSpec
 */
export interface RemediationConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema RemediationConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: RemediationConfigurationSpecDeletionPolicy;

  /**
   * @schema RemediationConfigurationSpec#forProvider
   */
  readonly forProvider: RemediationConfigurationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RemediationConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: RemediationConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RemediationConfigurationSpec#providerRef
   */
  readonly providerRef?: RemediationConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RemediationConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RemediationConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RemediationConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RemediationConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RemediationConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RemediationConfigurationSpec(obj: RemediationConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RemediationConfigurationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_RemediationConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RemediationConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RemediationConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RemediationConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema RemediationConfigurationSpecDeletionPolicy
 */
export enum RemediationConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RemediationConfigurationSpecForProvider
 */
export interface RemediationConfigurationSpecForProvider {
  /**
   * Remediation is triggered automatically if true.
   *
   * @schema RemediationConfigurationSpecForProvider#automatic
   */
  readonly automatic?: boolean;

  /**
   * Configuration block for execution controls. See below.
   *
   * @schema RemediationConfigurationSpecForProvider#executionControls
   */
  readonly executionControls?: RemediationConfigurationSpecForProviderExecutionControls[];

  /**
   * Maximum number of failed attempts for auto-remediation. If you do not select a number, the default is 5.
   *
   * @schema RemediationConfigurationSpecForProvider#maximumAutomaticAttempts
   */
  readonly maximumAutomaticAttempts?: number;

  /**
   * Can be specified multiple times for each parameter. Each parameter block supports arguments below.
   *
   * @schema RemediationConfigurationSpecForProvider#parameter
   */
  readonly parameter?: RemediationConfigurationSpecForProviderParameter[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RemediationConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Type of resource.
   *
   * @schema RemediationConfigurationSpecForProvider#resourceType
   */
  readonly resourceType?: string;

  /**
   * Maximum time in seconds that AWS Config runs auto-remediation. If you do not select a number, the default is 60 seconds.
   *
   * @schema RemediationConfigurationSpecForProvider#retryAttemptSeconds
   */
  readonly retryAttemptSeconds?: number;

  /**
   * Target ID is the name of the public document.
   *
   * @schema RemediationConfigurationSpecForProvider#targetId
   */
  readonly targetId: string;

  /**
   * Type of the target. Target executes remediation. For example, SSM document.
   *
   * @schema RemediationConfigurationSpecForProvider#targetType
   */
  readonly targetType: string;

  /**
   * Version of the target. For example, version of the SSM document
   *
   * @schema RemediationConfigurationSpecForProvider#targetVersion
   */
  readonly targetVersion?: string;

}

/**
 * Converts an object of type 'RemediationConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RemediationConfigurationSpecForProvider(obj: RemediationConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'automatic': obj.automatic,
    'executionControls': obj.executionControls?.map(y => toJson_RemediationConfigurationSpecForProviderExecutionControls(y)),
    'maximumAutomaticAttempts': obj.maximumAutomaticAttempts,
    'parameter': obj.parameter?.map(y => toJson_RemediationConfigurationSpecForProviderParameter(y)),
    'region': obj.region,
    'resourceType': obj.resourceType,
    'retryAttemptSeconds': obj.retryAttemptSeconds,
    'targetId': obj.targetId,
    'targetType': obj.targetType,
    'targetVersion': obj.targetVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RemediationConfigurationSpecProviderConfigRef
 */
export interface RemediationConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RemediationConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RemediationConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: RemediationConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RemediationConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RemediationConfigurationSpecProviderConfigRef(obj: RemediationConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RemediationConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RemediationConfigurationSpecProviderRef
 */
export interface RemediationConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RemediationConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RemediationConfigurationSpecProviderRef#policy
   */
  readonly policy?: RemediationConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RemediationConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RemediationConfigurationSpecProviderRef(obj: RemediationConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RemediationConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RemediationConfigurationSpecPublishConnectionDetailsTo
 */
export interface RemediationConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RemediationConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RemediationConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RemediationConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RemediationConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RemediationConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RemediationConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RemediationConfigurationSpecPublishConnectionDetailsTo(obj: RemediationConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RemediationConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RemediationConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RemediationConfigurationSpecWriteConnectionSecretToRef
 */
export interface RemediationConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RemediationConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RemediationConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RemediationConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RemediationConfigurationSpecWriteConnectionSecretToRef(obj: RemediationConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RemediationConfigurationSpecForProviderExecutionControls
 */
export interface RemediationConfigurationSpecForProviderExecutionControls {
  /**
   * Configuration block for SSM controls. See below.
   *
   * @schema RemediationConfigurationSpecForProviderExecutionControls#ssmControls
   */
  readonly ssmControls?: RemediationConfigurationSpecForProviderExecutionControlsSsmControls[];

}

/**
 * Converts an object of type 'RemediationConfigurationSpecForProviderExecutionControls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RemediationConfigurationSpecForProviderExecutionControls(obj: RemediationConfigurationSpecForProviderExecutionControls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ssmControls': obj.ssmControls?.map(y => toJson_RemediationConfigurationSpecForProviderExecutionControlsSsmControls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RemediationConfigurationSpecForProviderParameter
 */
export interface RemediationConfigurationSpecForProviderParameter {
  /**
   * Name of the attribute.
   *
   * @schema RemediationConfigurationSpecForProviderParameter#name
   */
  readonly name: string;

  /**
   * Value is dynamic and changes at run-time.
   *
   * @schema RemediationConfigurationSpecForProviderParameter#resourceValue
   */
  readonly resourceValue?: string;

  /**
   * Value is static and does not change at run-time.
   *
   * @schema RemediationConfigurationSpecForProviderParameter#staticValue
   */
  readonly staticValue?: string;

  /**
   * List of static values.
   *
   * @schema RemediationConfigurationSpecForProviderParameter#staticValues
   */
  readonly staticValues?: string[];

}

/**
 * Converts an object of type 'RemediationConfigurationSpecForProviderParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RemediationConfigurationSpecForProviderParameter(obj: RemediationConfigurationSpecForProviderParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'resourceValue': obj.resourceValue,
    'staticValue': obj.staticValue,
    'staticValues': obj.staticValues?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RemediationConfigurationSpecProviderConfigRefPolicy
 */
export interface RemediationConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RemediationConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RemediationConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RemediationConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RemediationConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RemediationConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RemediationConfigurationSpecProviderConfigRefPolicy(obj: RemediationConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RemediationConfigurationSpecProviderRefPolicy
 */
export interface RemediationConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RemediationConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RemediationConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RemediationConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RemediationConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RemediationConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RemediationConfigurationSpecProviderRefPolicy(obj: RemediationConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RemediationConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface RemediationConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RemediationConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RemediationConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RemediationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RemediationConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RemediationConfigurationSpecPublishConnectionDetailsToConfigRef(obj: RemediationConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RemediationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RemediationConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface RemediationConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RemediationConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RemediationConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RemediationConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RemediationConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RemediationConfigurationSpecPublishConnectionDetailsToMetadata(obj: RemediationConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RemediationConfigurationSpecForProviderExecutionControlsSsmControls
 */
export interface RemediationConfigurationSpecForProviderExecutionControlsSsmControls {
  /**
   * Maximum percentage of remediation actions allowed to run in parallel on the non-compliant resources for that specific rule. The default value is 10%.
   *
   * @schema RemediationConfigurationSpecForProviderExecutionControlsSsmControls#concurrentExecutionRatePercentage
   */
  readonly concurrentExecutionRatePercentage?: number;

  /**
   * Percentage of errors that are allowed before SSM stops running automations on non-compliant resources for that specific rule. The default is 50%.
   *
   * @schema RemediationConfigurationSpecForProviderExecutionControlsSsmControls#errorPercentage
   */
  readonly errorPercentage?: number;

}

/**
 * Converts an object of type 'RemediationConfigurationSpecForProviderExecutionControlsSsmControls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RemediationConfigurationSpecForProviderExecutionControlsSsmControls(obj: RemediationConfigurationSpecForProviderExecutionControlsSsmControls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'concurrentExecutionRatePercentage': obj.concurrentExecutionRatePercentage,
    'errorPercentage': obj.errorPercentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RemediationConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum RemediationConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RemediationConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum RemediationConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RemediationConfigurationSpecProviderRefPolicyResolution
 */
export enum RemediationConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RemediationConfigurationSpecProviderRefPolicyResolve
 */
export enum RemediationConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RemediationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RemediationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RemediationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RemediationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RemediationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RemediationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RemediationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RemediationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: RemediationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RemediationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RemediationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RemediationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RemediationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

