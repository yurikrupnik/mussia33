// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Addon is the Schema for the Addons API. Manages an EKS add-on
 *
 * @schema Addon
 */
export class Addon extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Addon"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'eks.aws.upbound.io/v1beta1',
    kind: 'Addon',
  }

  /**
   * Renders a Kubernetes manifest for "Addon".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AddonProps): any {
    return {
      ...Addon.GVK,
      ...toJson_AddonProps(props),
    };
  }

  /**
   * Defines a "Addon" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AddonProps) {
    super(scope, id, {
      ...Addon.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Addon.GVK,
      ...toJson_AddonProps(resolved),
    };
  }
}

/**
 * Addon is the Schema for the Addons API. Manages an EKS add-on
 *
 * @schema Addon
 */
export interface AddonProps {
  /**
   * @schema Addon#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AddonSpec defines the desired state of Addon
   *
   * @schema Addon#spec
   */
  readonly spec: AddonSpec;

}

/**
 * Converts an object of type 'AddonProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonProps(obj: AddonProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AddonSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AddonSpec defines the desired state of Addon
 *
 * @schema AddonSpec
 */
export interface AddonSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AddonSpec#deletionPolicy
   */
  readonly deletionPolicy?: AddonSpecDeletionPolicy;

  /**
   * @schema AddonSpec#forProvider
   */
  readonly forProvider: AddonSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AddonSpec#initProvider
   */
  readonly initProvider?: AddonSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AddonSpec#managementPolicies
   */
  readonly managementPolicies?: AddonSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AddonSpec#providerConfigRef
   */
  readonly providerConfigRef?: AddonSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AddonSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AddonSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AddonSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AddonSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AddonSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpec(obj: AddonSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AddonSpecForProvider(obj.forProvider),
    'initProvider': toJson_AddonSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AddonSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AddonSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AddonSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AddonSpecDeletionPolicy
 */
export enum AddonSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AddonSpecForProvider
 */
export interface AddonSpecForProvider {
  /**
   * on. The name must match one of the names returned by describe-addon-versions.
   *
   * @schema AddonSpecForProvider#addonName
   */
  readonly addonName?: string;

  /**
   * on. The version must match one of the versions returned by describe-addon-versions.
   *
   * @schema AddonSpecForProvider#addonVersion
   */
  readonly addonVersion?: string;

  /**
   * 100 characters in length. Must begin with an alphanumeric character, and must only contain alphanumeric characters, dashes and underscores (^[0-9A-Za-z][A-Za-z0-9\-_]+$).
   *
   * @schema AddonSpecForProvider#clusterName
   */
  readonly clusterName?: string;

  /**
   * Reference to a Cluster to populate clusterName.
   *
   * @schema AddonSpecForProvider#clusterNameRef
   */
  readonly clusterNameRef?: AddonSpecForProviderClusterNameRef;

  /**
   * Selector for a Cluster to populate clusterName.
   *
   * @schema AddonSpecForProvider#clusterNameSelector
   */
  readonly clusterNameSelector?: AddonSpecForProviderClusterNameSelector;

  /**
   * custom configuration values for addons with single JSON string. This JSON string value must match the JSON schema derived from describe-addon-configuration.
   *
   * @schema AddonSpecForProvider#configurationValues
   */
  readonly configurationValues?: string;

  /**
   * Indicates if you want to preserve the created resources when deleting the EKS add-on.
   *
   * @schema AddonSpecForProvider#preserve
   */
  readonly preserve?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AddonSpecForProvider#region
   */
  readonly region: string;

  /**
   * Define how to resolve parameter value conflicts when migrating an existing add-on to an Amazon EKS add-on or when applying version updates to the add-on. Valid values are NONE, OVERWRITE and PRESERVE. For more details check UpdateAddon API Docs.
   *
   * @schema AddonSpecForProvider#resolveConflicts
   */
  readonly resolveConflicts?: string;

  /**
   * The Amazon Resource Name (ARN) of an existing IAM role to bind to the add-on's service account. The role must be assigned the IAM permissions required by the add-on. If you don't specify an existing IAM role, then the add-on uses the permissions assigned to the node IAM role. For more information, see Amazon EKS node IAM role in the Amazon EKS User Guide.
   *
   * @schema AddonSpecForProvider#serviceAccountRoleArn
   */
  readonly serviceAccountRoleArn?: string;

  /**
   * Reference to a Role in iam to populate serviceAccountRoleArn.
   *
   * @schema AddonSpecForProvider#serviceAccountRoleArnRef
   */
  readonly serviceAccountRoleArnRef?: AddonSpecForProviderServiceAccountRoleArnRef;

  /**
   * Selector for a Role in iam to populate serviceAccountRoleArn.
   *
   * @schema AddonSpecForProvider#serviceAccountRoleArnSelector
   */
  readonly serviceAccountRoleArnSelector?: AddonSpecForProviderServiceAccountRoleArnSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema AddonSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AddonSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecForProvider(obj: AddonSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addonName': obj.addonName,
    'addonVersion': obj.addonVersion,
    'clusterName': obj.clusterName,
    'clusterNameRef': toJson_AddonSpecForProviderClusterNameRef(obj.clusterNameRef),
    'clusterNameSelector': toJson_AddonSpecForProviderClusterNameSelector(obj.clusterNameSelector),
    'configurationValues': obj.configurationValues,
    'preserve': obj.preserve,
    'region': obj.region,
    'resolveConflicts': obj.resolveConflicts,
    'serviceAccountRoleArn': obj.serviceAccountRoleArn,
    'serviceAccountRoleArnRef': toJson_AddonSpecForProviderServiceAccountRoleArnRef(obj.serviceAccountRoleArnRef),
    'serviceAccountRoleArnSelector': toJson_AddonSpecForProviderServiceAccountRoleArnSelector(obj.serviceAccountRoleArnSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AddonSpecInitProvider
 */
export interface AddonSpecInitProvider {
  /**
   * on. The name must match one of the names returned by describe-addon-versions.
   *
   * @schema AddonSpecInitProvider#addonName
   */
  readonly addonName?: string;

  /**
   * on. The version must match one of the versions returned by describe-addon-versions.
   *
   * @schema AddonSpecInitProvider#addonVersion
   */
  readonly addonVersion?: string;

  /**
   * custom configuration values for addons with single JSON string. This JSON string value must match the JSON schema derived from describe-addon-configuration.
   *
   * @schema AddonSpecInitProvider#configurationValues
   */
  readonly configurationValues?: string;

  /**
   * Indicates if you want to preserve the created resources when deleting the EKS add-on.
   *
   * @schema AddonSpecInitProvider#preserve
   */
  readonly preserve?: boolean;

  /**
   * Define how to resolve parameter value conflicts when migrating an existing add-on to an Amazon EKS add-on or when applying version updates to the add-on. Valid values are NONE, OVERWRITE and PRESERVE. For more details check UpdateAddon API Docs.
   *
   * @schema AddonSpecInitProvider#resolveConflicts
   */
  readonly resolveConflicts?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema AddonSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AddonSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecInitProvider(obj: AddonSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addonName': obj.addonName,
    'addonVersion': obj.addonVersion,
    'configurationValues': obj.configurationValues,
    'preserve': obj.preserve,
    'resolveConflicts': obj.resolveConflicts,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AddonSpecManagementPolicies
 */
export enum AddonSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AddonSpecProviderConfigRef
 */
export interface AddonSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AddonSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AddonSpecProviderConfigRef#policy
   */
  readonly policy?: AddonSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AddonSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecProviderConfigRef(obj: AddonSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AddonSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AddonSpecPublishConnectionDetailsTo
 */
export interface AddonSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AddonSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AddonSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AddonSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AddonSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AddonSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AddonSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecPublishConnectionDetailsTo(obj: AddonSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AddonSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AddonSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AddonSpecWriteConnectionSecretToRef
 */
export interface AddonSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AddonSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AddonSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AddonSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecWriteConnectionSecretToRef(obj: AddonSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster to populate clusterName.
 *
 * @schema AddonSpecForProviderClusterNameRef
 */
export interface AddonSpecForProviderClusterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema AddonSpecForProviderClusterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AddonSpecForProviderClusterNameRef#policy
   */
  readonly policy?: AddonSpecForProviderClusterNameRefPolicy;

}

/**
 * Converts an object of type 'AddonSpecForProviderClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecForProviderClusterNameRef(obj: AddonSpecForProviderClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AddonSpecForProviderClusterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster to populate clusterName.
 *
 * @schema AddonSpecForProviderClusterNameSelector
 */
export interface AddonSpecForProviderClusterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AddonSpecForProviderClusterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AddonSpecForProviderClusterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AddonSpecForProviderClusterNameSelector#policy
   */
  readonly policy?: AddonSpecForProviderClusterNameSelectorPolicy;

}

/**
 * Converts an object of type 'AddonSpecForProviderClusterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecForProviderClusterNameSelector(obj: AddonSpecForProviderClusterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AddonSpecForProviderClusterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate serviceAccountRoleArn.
 *
 * @schema AddonSpecForProviderServiceAccountRoleArnRef
 */
export interface AddonSpecForProviderServiceAccountRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema AddonSpecForProviderServiceAccountRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AddonSpecForProviderServiceAccountRoleArnRef#policy
   */
  readonly policy?: AddonSpecForProviderServiceAccountRoleArnRefPolicy;

}

/**
 * Converts an object of type 'AddonSpecForProviderServiceAccountRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecForProviderServiceAccountRoleArnRef(obj: AddonSpecForProviderServiceAccountRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AddonSpecForProviderServiceAccountRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate serviceAccountRoleArn.
 *
 * @schema AddonSpecForProviderServiceAccountRoleArnSelector
 */
export interface AddonSpecForProviderServiceAccountRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AddonSpecForProviderServiceAccountRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AddonSpecForProviderServiceAccountRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AddonSpecForProviderServiceAccountRoleArnSelector#policy
   */
  readonly policy?: AddonSpecForProviderServiceAccountRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'AddonSpecForProviderServiceAccountRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecForProviderServiceAccountRoleArnSelector(obj: AddonSpecForProviderServiceAccountRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AddonSpecForProviderServiceAccountRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AddonSpecProviderConfigRefPolicy
 */
export interface AddonSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AddonSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AddonSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AddonSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AddonSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AddonSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecProviderConfigRefPolicy(obj: AddonSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AddonSpecPublishConnectionDetailsToConfigRef
 */
export interface AddonSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AddonSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AddonSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AddonSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AddonSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecPublishConnectionDetailsToConfigRef(obj: AddonSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AddonSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AddonSpecPublishConnectionDetailsToMetadata
 */
export interface AddonSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AddonSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AddonSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AddonSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AddonSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecPublishConnectionDetailsToMetadata(obj: AddonSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AddonSpecForProviderClusterNameRefPolicy
 */
export interface AddonSpecForProviderClusterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AddonSpecForProviderClusterNameRefPolicy#resolution
   */
  readonly resolution?: AddonSpecForProviderClusterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AddonSpecForProviderClusterNameRefPolicy#resolve
   */
  readonly resolve?: AddonSpecForProviderClusterNameRefPolicyResolve;

}

/**
 * Converts an object of type 'AddonSpecForProviderClusterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecForProviderClusterNameRefPolicy(obj: AddonSpecForProviderClusterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AddonSpecForProviderClusterNameSelectorPolicy
 */
export interface AddonSpecForProviderClusterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AddonSpecForProviderClusterNameSelectorPolicy#resolution
   */
  readonly resolution?: AddonSpecForProviderClusterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AddonSpecForProviderClusterNameSelectorPolicy#resolve
   */
  readonly resolve?: AddonSpecForProviderClusterNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AddonSpecForProviderClusterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecForProviderClusterNameSelectorPolicy(obj: AddonSpecForProviderClusterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AddonSpecForProviderServiceAccountRoleArnRefPolicy
 */
export interface AddonSpecForProviderServiceAccountRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AddonSpecForProviderServiceAccountRoleArnRefPolicy#resolution
   */
  readonly resolution?: AddonSpecForProviderServiceAccountRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AddonSpecForProviderServiceAccountRoleArnRefPolicy#resolve
   */
  readonly resolve?: AddonSpecForProviderServiceAccountRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'AddonSpecForProviderServiceAccountRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecForProviderServiceAccountRoleArnRefPolicy(obj: AddonSpecForProviderServiceAccountRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AddonSpecForProviderServiceAccountRoleArnSelectorPolicy
 */
export interface AddonSpecForProviderServiceAccountRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AddonSpecForProviderServiceAccountRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: AddonSpecForProviderServiceAccountRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AddonSpecForProviderServiceAccountRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: AddonSpecForProviderServiceAccountRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AddonSpecForProviderServiceAccountRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecForProviderServiceAccountRoleArnSelectorPolicy(obj: AddonSpecForProviderServiceAccountRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AddonSpecProviderConfigRefPolicyResolution
 */
export enum AddonSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AddonSpecProviderConfigRefPolicyResolve
 */
export enum AddonSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AddonSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AddonSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AddonSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AddonSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AddonSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AddonSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AddonSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddonSpecPublishConnectionDetailsToConfigRefPolicy(obj: AddonSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AddonSpecForProviderClusterNameRefPolicyResolution
 */
export enum AddonSpecForProviderClusterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AddonSpecForProviderClusterNameRefPolicyResolve
 */
export enum AddonSpecForProviderClusterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AddonSpecForProviderClusterNameSelectorPolicyResolution
 */
export enum AddonSpecForProviderClusterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AddonSpecForProviderClusterNameSelectorPolicyResolve
 */
export enum AddonSpecForProviderClusterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AddonSpecForProviderServiceAccountRoleArnRefPolicyResolution
 */
export enum AddonSpecForProviderServiceAccountRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AddonSpecForProviderServiceAccountRoleArnRefPolicyResolve
 */
export enum AddonSpecForProviderServiceAccountRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AddonSpecForProviderServiceAccountRoleArnSelectorPolicyResolution
 */
export enum AddonSpecForProviderServiceAccountRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AddonSpecForProviderServiceAccountRoleArnSelectorPolicyResolve
 */
export enum AddonSpecForProviderServiceAccountRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AddonSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AddonSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AddonSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AddonSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Cluster is the Schema for the Clusters API. Manages an EKS Cluster
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'eks.aws.upbound.io/v1beta1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * Cluster is the Schema for the Clusters API. Manages an EKS Cluster
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSpec defines the desired state of Cluster
   *
   * @schema Cluster#spec
   */
  readonly spec: ClusterSpec;

}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSpec defines the desired state of Cluster
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSpecDeletionPolicy;

  /**
   * @schema ClusterSpec#forProvider
   */
  readonly forProvider: ClusterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ClusterSpec#initProvider
   */
  readonly initProvider?: ClusterSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterSpec#managementPolicies
   */
  readonly managementPolicies?: ClusterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSpecForProvider(obj.forProvider),
    'initProvider': toJson_ClusterSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterSpecDeletionPolicy
 */
export enum ClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterSpecForProvider
 */
export interface ClusterSpecForProvider {
  /**
   * List of the desired control plane logging to enable. For more information, see Amazon EKS Control Plane Logging.
   *
   * @schema ClusterSpecForProvider#enabledClusterLogTypes
   */
  readonly enabledClusterLogTypes?: string[];

  /**
   * Configuration block with encryption configuration for the cluster. Only available on Kubernetes 1.13 and above clusters created after March 6, 2020. Detailed below.
   *
   * @schema ClusterSpecForProvider#encryptionConfig
   */
  readonly encryptionConfig?: ClusterSpecForProviderEncryptionConfig[];

  /**
   * Configuration block with kubernetes network configuration for the cluster. Detailed below.
   *
   * @schema ClusterSpecForProvider#kubernetesNetworkConfig
   */
  readonly kubernetesNetworkConfig?: ClusterSpecForProviderKubernetesNetworkConfig[];

  /**
   * Configuration block representing the configuration of your local Amazon EKS cluster on an AWS Outpost. This block isn't available for creating Amazon EKS clusters on the AWS cloud.
   *
   * @schema ClusterSpecForProvider#outpostConfig
   */
  readonly outpostConfig?: ClusterSpecForProviderOutpostConfig[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterSpecForProvider#region
   */
  readonly region: string;

  /**
   * ARN of the IAM role that provides permissions for the Kubernetes control plane to make calls to AWS API operations on your behalf. Ensure the resource configuration includes explicit dependencies on the IAM Role permissions by adding depends_on if using the aws_iam_role_policy resource or aws_iam_role_policy_attachment resource, otherwise EKS cannot delete EKS managed EC2 infrastructure such as Security Groups on EKS Cluster deletion.
   *
   * @schema ClusterSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ClusterSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: ClusterSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ClusterSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: ClusterSpecForProviderRoleArnSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   *   Desired Kubernetes master version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except those automatically triggered by EKS. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by EKS.
   *
   * @schema ClusterSpecForProvider#version
   */
  readonly version?: string;

  /**
   * Configuration block for the VPC associated with your cluster. Amazon EKS VPC resources have specific requirements to work properly with Kubernetes. For more information, see Cluster VPC Considerations and Cluster Security Group Considerations in the Amazon EKS User Guide. Detailed below. Also contains attributes detailed in the Attributes section.
   *
   * @schema ClusterSpecForProvider#vpcConfig
   */
  readonly vpcConfig?: ClusterSpecForProviderVpcConfig[];

}

/**
 * Converts an object of type 'ClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProvider(obj: ClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabledClusterLogTypes': obj.enabledClusterLogTypes?.map(y => y),
    'encryptionConfig': obj.encryptionConfig?.map(y => toJson_ClusterSpecForProviderEncryptionConfig(y)),
    'kubernetesNetworkConfig': obj.kubernetesNetworkConfig?.map(y => toJson_ClusterSpecForProviderKubernetesNetworkConfig(y)),
    'outpostConfig': obj.outpostConfig?.map(y => toJson_ClusterSpecForProviderOutpostConfig(y)),
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ClusterSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ClusterSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'version': obj.version,
    'vpcConfig': obj.vpcConfig?.map(y => toJson_ClusterSpecForProviderVpcConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ClusterSpecInitProvider
 */
export interface ClusterSpecInitProvider {
  /**
   * List of the desired control plane logging to enable. For more information, see Amazon EKS Control Plane Logging.
   *
   * @schema ClusterSpecInitProvider#enabledClusterLogTypes
   */
  readonly enabledClusterLogTypes?: string[];

  /**
   * Configuration block with encryption configuration for the cluster. Only available on Kubernetes 1.13 and above clusters created after March 6, 2020. Detailed below.
   *
   * @schema ClusterSpecInitProvider#encryptionConfig
   */
  readonly encryptionConfig?: ClusterSpecInitProviderEncryptionConfig[];

  /**
   * Configuration block with kubernetes network configuration for the cluster. Detailed below.
   *
   * @schema ClusterSpecInitProvider#kubernetesNetworkConfig
   */
  readonly kubernetesNetworkConfig?: ClusterSpecInitProviderKubernetesNetworkConfig[];

  /**
   * Configuration block representing the configuration of your local Amazon EKS cluster on an AWS Outpost. This block isn't available for creating Amazon EKS clusters on the AWS cloud.
   *
   * @schema ClusterSpecInitProvider#outpostConfig
   */
  readonly outpostConfig?: ClusterSpecInitProviderOutpostConfig[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   *   Desired Kubernetes master version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except those automatically triggered by EKS. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by EKS.
   *
   * @schema ClusterSpecInitProvider#version
   */
  readonly version?: string;

  /**
   * Configuration block for the VPC associated with your cluster. Amazon EKS VPC resources have specific requirements to work properly with Kubernetes. For more information, see Cluster VPC Considerations and Cluster Security Group Considerations in the Amazon EKS User Guide. Detailed below. Also contains attributes detailed in the Attributes section.
   *
   * @schema ClusterSpecInitProvider#vpcConfig
   */
  readonly vpcConfig?: ClusterSpecInitProviderVpcConfig[];

}

/**
 * Converts an object of type 'ClusterSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProvider(obj: ClusterSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabledClusterLogTypes': obj.enabledClusterLogTypes?.map(y => y),
    'encryptionConfig': obj.encryptionConfig?.map(y => toJson_ClusterSpecInitProviderEncryptionConfig(y)),
    'kubernetesNetworkConfig': obj.kubernetesNetworkConfig?.map(y => toJson_ClusterSpecInitProviderKubernetesNetworkConfig(y)),
    'outpostConfig': obj.outpostConfig?.map(y => toJson_ClusterSpecInitProviderOutpostConfig(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'version': obj.version,
    'vpcConfig': obj.vpcConfig?.map(y => toJson_ClusterSpecInitProviderVpcConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClusterSpecManagementPolicies
 */
export enum ClusterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterSpecProviderConfigRef
 */
export interface ClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRef(obj: ClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterSpecPublishConnectionDetailsTo
 */
export interface ClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsTo(obj: ClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterSpecWriteConnectionSecretToRef
 */
export interface ClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWriteConnectionSecretToRef(obj: ClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderEncryptionConfig
 */
export interface ClusterSpecForProviderEncryptionConfig {
  /**
   * Configuration block with provider for encryption. Detailed below.
   *
   * @schema ClusterSpecForProviderEncryptionConfig#provider
   */
  readonly provider?: ClusterSpecForProviderEncryptionConfigProvider[];

  /**
   * List of strings with resources to be encrypted. Valid values: secrets.
   *
   * @schema ClusterSpecForProviderEncryptionConfig#resources
   */
  readonly resources?: string[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderEncryptionConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderEncryptionConfig(obj: ClusterSpecForProviderEncryptionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'provider': obj.provider?.map(y => toJson_ClusterSpecForProviderEncryptionConfigProvider(y)),
    'resources': obj.resources?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderKubernetesNetworkConfig
 */
export interface ClusterSpecForProviderKubernetesNetworkConfig {
  /**
   * The IP family used to assign Kubernetes pod and service addresses. Valid values are ipv4 (default) and ipv6. You can only specify an IP family when you create a cluster, changing this value will force a new cluster to be created.
   *
   * @schema ClusterSpecForProviderKubernetesNetworkConfig#ipFamily
   */
  readonly ipFamily?: string;

  /**
   * The CIDR block to assign Kubernetes pod and service IP addresses from. If you don't specify a block, Kubernetes assigns addresses from either the 10.100.0.0/16 or 172.20.0.0/16 CIDR blocks. We recommend that you specify a block that does not overlap with resources in other networks that are peered or connected to your VPC. You can only specify a custom CIDR block when you create a cluster, changing this value will force a new cluster to be created. The block must meet the following requirements:
   *
   * @schema ClusterSpecForProviderKubernetesNetworkConfig#serviceIpv4Cidr
   */
  readonly serviceIpv4Cidr?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKubernetesNetworkConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKubernetesNetworkConfig(obj: ClusterSpecForProviderKubernetesNetworkConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipFamily': obj.ipFamily,
    'serviceIpv4Cidr': obj.serviceIpv4Cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderOutpostConfig
 */
export interface ClusterSpecForProviderOutpostConfig {
  /**
   * The Amazon EC2 instance type that you want to use for your local Amazon EKS cluster on Outposts. The instance type that you specify is used for all Kubernetes control plane instances. The instance type can't be changed after cluster creation. Choose an instance type based on the number of nodes that your cluster will have. If your cluster will have:
   *
   * @schema ClusterSpecForProviderOutpostConfig#controlPlaneInstanceType
   */
  readonly controlPlaneInstanceType?: string;

  /**
   * An object representing the placement configuration for all the control plane instances of your local Amazon EKS cluster on AWS Outpost. The following arguments are supported in the control_plane_placement configuration block:
   *
   * @schema ClusterSpecForProviderOutpostConfig#controlPlanePlacement
   */
  readonly controlPlanePlacement?: ClusterSpecForProviderOutpostConfigControlPlanePlacement[];

  /**
   * The ARN of the Outpost that you want to use for your local Amazon EKS cluster on Outposts. This argument is a list of arns, but only a single Outpost ARN is supported currently.
   *
   * @schema ClusterSpecForProviderOutpostConfig#outpostArns
   */
  readonly outpostArns?: string[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderOutpostConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderOutpostConfig(obj: ClusterSpecForProviderOutpostConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'controlPlaneInstanceType': obj.controlPlaneInstanceType,
    'controlPlanePlacement': obj.controlPlanePlacement?.map(y => toJson_ClusterSpecForProviderOutpostConfigControlPlanePlacement(y)),
    'outpostArns': obj.outpostArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ClusterSpecForProviderRoleArnRef
 */
export interface ClusterSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderRoleArnRef#policy
   */
  readonly policy?: ClusterSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderRoleArnRef(obj: ClusterSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ClusterSpecForProviderRoleArnSelector
 */
export interface ClusterSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: ClusterSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderRoleArnSelector(obj: ClusterSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderVpcConfig
 */
export interface ClusterSpecForProviderVpcConfig {
  /**
   * Whether the Amazon EKS private API server endpoint is enabled. Default is false.
   *
   * @default false.
   * @schema ClusterSpecForProviderVpcConfig#endpointPrivateAccess
   */
  readonly endpointPrivateAccess?: boolean;

  /**
   * Whether the Amazon EKS public API server endpoint is enabled. Default is true.
   *
   * @default true.
   * @schema ClusterSpecForProviderVpcConfig#endpointPublicAccess
   */
  readonly endpointPublicAccess?: boolean;

  /**
   * List of CIDR blocks. Indicates which CIDR blocks can access the Amazon EKS public API server endpoint when enabled. EKS defaults this to a list with 0.0.0.0/0.
   *
   * @schema ClusterSpecForProviderVpcConfig#publicAccessCidrs
   */
  readonly publicAccessCidrs?: string[];

  /**
   * References to SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema ClusterSpecForProviderVpcConfig#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: ClusterSpecForProviderVpcConfigSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema ClusterSpecForProviderVpcConfig#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: ClusterSpecForProviderVpcConfigSecurityGroupIdSelector;

  /**
   * account elastic network interfaces that Amazon EKS creates to use to allow communication between your worker nodes and the Kubernetes control plane.
   *
   * @schema ClusterSpecForProviderVpcConfig#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema ClusterSpecForProviderVpcConfig#subnetIdRefs
   */
  readonly subnetIdRefs?: ClusterSpecForProviderVpcConfigSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema ClusterSpecForProviderVpcConfig#subnetIdSelector
   */
  readonly subnetIdSelector?: ClusterSpecForProviderVpcConfigSubnetIdSelector;

  /**
   * account elastic network interfaces in these subnets to allow communication between your worker nodes and the Kubernetes control plane.
   *
   * @schema ClusterSpecForProviderVpcConfig#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcConfig(obj: ClusterSpecForProviderVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpointPrivateAccess': obj.endpointPrivateAccess,
    'endpointPublicAccess': obj.endpointPublicAccess,
    'publicAccessCidrs': obj.publicAccessCidrs?.map(y => y),
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_ClusterSpecForProviderVpcConfigSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_ClusterSpecForProviderVpcConfigSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_ClusterSpecForProviderVpcConfigSubnetIdRefs(y)),
    'subnetIdSelector': toJson_ClusterSpecForProviderVpcConfigSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderEncryptionConfig
 */
export interface ClusterSpecInitProviderEncryptionConfig {
  /**
   * Configuration block with provider for encryption. Detailed below.
   *
   * @schema ClusterSpecInitProviderEncryptionConfig#provider
   */
  readonly provider?: ClusterSpecInitProviderEncryptionConfigProvider[];

  /**
   * List of strings with resources to be encrypted. Valid values: secrets.
   *
   * @schema ClusterSpecInitProviderEncryptionConfig#resources
   */
  readonly resources?: string[];

}

/**
 * Converts an object of type 'ClusterSpecInitProviderEncryptionConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderEncryptionConfig(obj: ClusterSpecInitProviderEncryptionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'provider': obj.provider?.map(y => toJson_ClusterSpecInitProviderEncryptionConfigProvider(y)),
    'resources': obj.resources?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderKubernetesNetworkConfig
 */
export interface ClusterSpecInitProviderKubernetesNetworkConfig {
  /**
   * The IP family used to assign Kubernetes pod and service addresses. Valid values are ipv4 (default) and ipv6. You can only specify an IP family when you create a cluster, changing this value will force a new cluster to be created.
   *
   * @schema ClusterSpecInitProviderKubernetesNetworkConfig#ipFamily
   */
  readonly ipFamily?: string;

  /**
   * The CIDR block to assign Kubernetes pod and service IP addresses from. If you don't specify a block, Kubernetes assigns addresses from either the 10.100.0.0/16 or 172.20.0.0/16 CIDR blocks. We recommend that you specify a block that does not overlap with resources in other networks that are peered or connected to your VPC. You can only specify a custom CIDR block when you create a cluster, changing this value will force a new cluster to be created. The block must meet the following requirements:
   *
   * @schema ClusterSpecInitProviderKubernetesNetworkConfig#serviceIpv4Cidr
   */
  readonly serviceIpv4Cidr?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderKubernetesNetworkConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderKubernetesNetworkConfig(obj: ClusterSpecInitProviderKubernetesNetworkConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipFamily': obj.ipFamily,
    'serviceIpv4Cidr': obj.serviceIpv4Cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderOutpostConfig
 */
export interface ClusterSpecInitProviderOutpostConfig {
  /**
   * The Amazon EC2 instance type that you want to use for your local Amazon EKS cluster on Outposts. The instance type that you specify is used for all Kubernetes control plane instances. The instance type can't be changed after cluster creation. Choose an instance type based on the number of nodes that your cluster will have. If your cluster will have:
   *
   * @schema ClusterSpecInitProviderOutpostConfig#controlPlaneInstanceType
   */
  readonly controlPlaneInstanceType?: string;

  /**
   * An object representing the placement configuration for all the control plane instances of your local Amazon EKS cluster on AWS Outpost. The following arguments are supported in the control_plane_placement configuration block:
   *
   * @schema ClusterSpecInitProviderOutpostConfig#controlPlanePlacement
   */
  readonly controlPlanePlacement?: ClusterSpecInitProviderOutpostConfigControlPlanePlacement[];

  /**
   * The ARN of the Outpost that you want to use for your local Amazon EKS cluster on Outposts. This argument is a list of arns, but only a single Outpost ARN is supported currently.
   *
   * @schema ClusterSpecInitProviderOutpostConfig#outpostArns
   */
  readonly outpostArns?: string[];

}

/**
 * Converts an object of type 'ClusterSpecInitProviderOutpostConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderOutpostConfig(obj: ClusterSpecInitProviderOutpostConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'controlPlaneInstanceType': obj.controlPlaneInstanceType,
    'controlPlanePlacement': obj.controlPlanePlacement?.map(y => toJson_ClusterSpecInitProviderOutpostConfigControlPlanePlacement(y)),
    'outpostArns': obj.outpostArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderVpcConfig
 */
export interface ClusterSpecInitProviderVpcConfig {
  /**
   * Whether the Amazon EKS private API server endpoint is enabled. Default is false.
   *
   * @default false.
   * @schema ClusterSpecInitProviderVpcConfig#endpointPrivateAccess
   */
  readonly endpointPrivateAccess?: boolean;

  /**
   * Whether the Amazon EKS public API server endpoint is enabled. Default is true.
   *
   * @default true.
   * @schema ClusterSpecInitProviderVpcConfig#endpointPublicAccess
   */
  readonly endpointPublicAccess?: boolean;

  /**
   * List of CIDR blocks. Indicates which CIDR blocks can access the Amazon EKS public API server endpoint when enabled. EKS defaults this to a list with 0.0.0.0/0.
   *
   * @schema ClusterSpecInitProviderVpcConfig#publicAccessCidrs
   */
  readonly publicAccessCidrs?: string[];

}

/**
 * Converts an object of type 'ClusterSpecInitProviderVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderVpcConfig(obj: ClusterSpecInitProviderVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpointPrivateAccess': obj.endpointPrivateAccess,
    'endpointPublicAccess': obj.endpointPublicAccess,
    'publicAccessCidrs': obj.publicAccessCidrs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderConfigRefPolicy
 */
export interface ClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRefPolicy(obj: ClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj: ClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj: ClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderEncryptionConfigProvider
 */
export interface ClusterSpecForProviderEncryptionConfigProvider {
  /**
   * ARN of the Key Management Service (KMS) customer master key (CMK). The CMK must be symmetric, created in the same region as the cluster, and if the CMK was created in a different account, the user must have access to the CMK. For more information, see Allowing Users in Other Accounts to Use a CMK in the AWS Key Management Service Developer Guide.
   *
   * @schema ClusterSpecForProviderEncryptionConfigProvider#keyArn
   */
  readonly keyArn?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderEncryptionConfigProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderEncryptionConfigProvider(obj: ClusterSpecForProviderEncryptionConfigProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyArn': obj.keyArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderOutpostConfigControlPlanePlacement
 */
export interface ClusterSpecForProviderOutpostConfigControlPlanePlacement {
  /**
   * The name of the placement group for the Kubernetes control plane instances. This setting can't be changed after cluster creation.
   *
   * @schema ClusterSpecForProviderOutpostConfigControlPlanePlacement#groupName
   */
  readonly groupName?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderOutpostConfigControlPlanePlacement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderOutpostConfigControlPlanePlacement(obj: ClusterSpecForProviderOutpostConfigControlPlanePlacement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupName': obj.groupName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderRoleArnRefPolicy
 */
export interface ClusterSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderRoleArnRefPolicy(obj: ClusterSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderRoleArnSelectorPolicy
 */
export interface ClusterSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderRoleArnSelectorPolicy(obj: ClusterSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ClusterSpecForProviderVpcConfigSecurityGroupIdRefs
 */
export interface ClusterSpecForProviderVpcConfigSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderVpcConfigSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderVpcConfigSecurityGroupIdRefs#policy
   */
  readonly policy?: ClusterSpecForProviderVpcConfigSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcConfigSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcConfigSecurityGroupIdRefs(obj: ClusterSpecForProviderVpcConfigSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderVpcConfigSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
 *
 * @schema ClusterSpecForProviderVpcConfigSecurityGroupIdSelector
 */
export interface ClusterSpecForProviderVpcConfigSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderVpcConfigSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderVpcConfigSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderVpcConfigSecurityGroupIdSelector#policy
   */
  readonly policy?: ClusterSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcConfigSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcConfigSecurityGroupIdSelector(obj: ClusterSpecForProviderVpcConfigSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ClusterSpecForProviderVpcConfigSubnetIdRefs
 */
export interface ClusterSpecForProviderVpcConfigSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderVpcConfigSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderVpcConfigSubnetIdRefs#policy
   */
  readonly policy?: ClusterSpecForProviderVpcConfigSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcConfigSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcConfigSubnetIdRefs(obj: ClusterSpecForProviderVpcConfigSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderVpcConfigSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema ClusterSpecForProviderVpcConfigSubnetIdSelector
 */
export interface ClusterSpecForProviderVpcConfigSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderVpcConfigSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderVpcConfigSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderVpcConfigSubnetIdSelector#policy
   */
  readonly policy?: ClusterSpecForProviderVpcConfigSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcConfigSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcConfigSubnetIdSelector(obj: ClusterSpecForProviderVpcConfigSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderVpcConfigSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderEncryptionConfigProvider
 */
export interface ClusterSpecInitProviderEncryptionConfigProvider {
  /**
   * ARN of the Key Management Service (KMS) customer master key (CMK). The CMK must be symmetric, created in the same region as the cluster, and if the CMK was created in a different account, the user must have access to the CMK. For more information, see Allowing Users in Other Accounts to Use a CMK in the AWS Key Management Service Developer Guide.
   *
   * @schema ClusterSpecInitProviderEncryptionConfigProvider#keyArn
   */
  readonly keyArn?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderEncryptionConfigProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderEncryptionConfigProvider(obj: ClusterSpecInitProviderEncryptionConfigProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyArn': obj.keyArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderOutpostConfigControlPlanePlacement
 */
export interface ClusterSpecInitProviderOutpostConfigControlPlanePlacement {
  /**
   * The name of the placement group for the Kubernetes control plane instances. This setting can't be changed after cluster creation.
   *
   * @schema ClusterSpecInitProviderOutpostConfigControlPlanePlacement#groupName
   */
  readonly groupName?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderOutpostConfigControlPlanePlacement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderOutpostConfigControlPlanePlacement(obj: ClusterSpecInitProviderOutpostConfigControlPlanePlacement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupName': obj.groupName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderRoleArnRefPolicyResolution
 */
export enum ClusterSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderRoleArnRefPolicyResolve
 */
export enum ClusterSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum ClusterSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum ClusterSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderVpcConfigSecurityGroupIdRefsPolicy
 */
export interface ClusterSpecForProviderVpcConfigSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderVpcConfigSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderVpcConfigSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcConfigSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcConfigSecurityGroupIdRefsPolicy(obj: ClusterSpecForProviderVpcConfigSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy
 */
export interface ClusterSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy(obj: ClusterSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderVpcConfigSubnetIdRefsPolicy
 */
export interface ClusterSpecForProviderVpcConfigSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderVpcConfigSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderVpcConfigSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderVpcConfigSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderVpcConfigSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcConfigSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcConfigSubnetIdRefsPolicy(obj: ClusterSpecForProviderVpcConfigSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderVpcConfigSubnetIdSelectorPolicy
 */
export interface ClusterSpecForProviderVpcConfigSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderVpcConfigSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderVpcConfigSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcConfigSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcConfigSubnetIdSelectorPolicy(obj: ClusterSpecForProviderVpcConfigSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolution
 */
export enum ClusterSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolve
 */
export enum ClusterSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolution
 */
export enum ClusterSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolve
 */
export enum ClusterSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderVpcConfigSubnetIdRefsPolicyResolution
 */
export enum ClusterSpecForProviderVpcConfigSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderVpcConfigSubnetIdRefsPolicyResolve
 */
export enum ClusterSpecForProviderVpcConfigSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution
 */
export enum ClusterSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve
 */
export enum ClusterSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ClusterAuth is used to retrieve Kubeconfig of given EKS cluster.
 *
 * @schema ClusterAuth
 */
export class ClusterAuth extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterAuth"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'eks.aws.upbound.io/v1beta1',
    kind: 'ClusterAuth',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterAuth".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterAuthProps): any {
    return {
      ...ClusterAuth.GVK,
      ...toJson_ClusterAuthProps(props),
    };
  }

  /**
   * Defines a "ClusterAuth" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterAuthProps) {
    super(scope, id, {
      ...ClusterAuth.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterAuth.GVK,
      ...toJson_ClusterAuthProps(resolved),
    };
  }
}

/**
 * ClusterAuth is used to retrieve Kubeconfig of given EKS cluster.
 *
 * @schema ClusterAuth
 */
export interface ClusterAuthProps {
  /**
   * @schema ClusterAuth#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterAuthSpec defines the desired state of ClusterAuth
   *
   * @schema ClusterAuth#spec
   */
  readonly spec: ClusterAuthSpec;

}

/**
 * Converts an object of type 'ClusterAuthProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterAuthProps(obj: ClusterAuthProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterAuthSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterAuthSpec defines the desired state of ClusterAuth
 *
 * @schema ClusterAuthSpec
 */
export interface ClusterAuthSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterAuthSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterAuthSpecDeletionPolicy;

  /**
   * @schema ClusterAuthSpec#forProvider
   */
  readonly forProvider: ClusterAuthSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterAuthSpec#managementPolicies
   */
  readonly managementPolicies?: ClusterAuthSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterAuthSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterAuthSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterAuthSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterAuthSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterAuthSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterAuthSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterAuthSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterAuthSpec(obj: ClusterAuthSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterAuthSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterAuthSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClusterAuthSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterAuthSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterAuthSpecDeletionPolicy
 */
export enum ClusterAuthSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterAuthSpecForProvider
 */
export interface ClusterAuthSpecForProvider {
  /**
   * ClusterName is the name of the cluster you'd like to fetch Kubeconfig of. Either ClusterName, ClusterNameRef or ClusterNameSelector has to be given.
   *
   * @schema ClusterAuthSpecForProvider#clusterName
   */
  readonly clusterName?: string;

  /**
   * Reference to a Cluster to populate clusterName. Either ClusterName, ClusterNameRef or ClusterNameSelector has to be given.
   *
   * @schema ClusterAuthSpecForProvider#clusterNameRef
   */
  readonly clusterNameRef?: ClusterAuthSpecForProviderClusterNameRef;

  /**
   * Selector for a Cluster to populate clusterName. Either ClusterName, ClusterNameRef or ClusterNameSelector has to be given.
   *
   * @schema ClusterAuthSpecForProvider#clusterNameSelector
   */
  readonly clusterNameSelector?: ClusterAuthSpecForProviderClusterNameSelector;

  /**
   * RefreshPeriod is how frequently you'd like the token in the published Kubeconfig to be refreshed. The maximum is 10m0s. The default is 10m0s.
   *
   * @schema ClusterAuthSpecForProvider#refreshPeriod
   */
  readonly refreshPeriod?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterAuthSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ClusterAuthSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterAuthSpecForProvider(obj: ClusterAuthSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterName': obj.clusterName,
    'clusterNameRef': toJson_ClusterAuthSpecForProviderClusterNameRef(obj.clusterNameRef),
    'clusterNameSelector': toJson_ClusterAuthSpecForProviderClusterNameSelector(obj.clusterNameSelector),
    'refreshPeriod': obj.refreshPeriod,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClusterAuthSpecManagementPolicies
 */
export enum ClusterAuthSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterAuthSpecProviderConfigRef
 */
export interface ClusterAuthSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterAuthSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterAuthSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterAuthSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterAuthSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterAuthSpecProviderConfigRef(obj: ClusterAuthSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterAuthSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterAuthSpecPublishConnectionDetailsTo
 */
export interface ClusterAuthSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterAuthSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterAuthSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterAuthSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterAuthSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterAuthSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterAuthSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterAuthSpecPublishConnectionDetailsTo(obj: ClusterAuthSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterAuthSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterAuthSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterAuthSpecWriteConnectionSecretToRef
 */
export interface ClusterAuthSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterAuthSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterAuthSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterAuthSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterAuthSpecWriteConnectionSecretToRef(obj: ClusterAuthSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster to populate clusterName. Either ClusterName, ClusterNameRef or ClusterNameSelector has to be given.
 *
 * @schema ClusterAuthSpecForProviderClusterNameRef
 */
export interface ClusterAuthSpecForProviderClusterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterAuthSpecForProviderClusterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterAuthSpecForProviderClusterNameRef#policy
   */
  readonly policy?: ClusterAuthSpecForProviderClusterNameRefPolicy;

}

/**
 * Converts an object of type 'ClusterAuthSpecForProviderClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterAuthSpecForProviderClusterNameRef(obj: ClusterAuthSpecForProviderClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterAuthSpecForProviderClusterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster to populate clusterName. Either ClusterName, ClusterNameRef or ClusterNameSelector has to be given.
 *
 * @schema ClusterAuthSpecForProviderClusterNameSelector
 */
export interface ClusterAuthSpecForProviderClusterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterAuthSpecForProviderClusterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterAuthSpecForProviderClusterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterAuthSpecForProviderClusterNameSelector#policy
   */
  readonly policy?: ClusterAuthSpecForProviderClusterNameSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterAuthSpecForProviderClusterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterAuthSpecForProviderClusterNameSelector(obj: ClusterAuthSpecForProviderClusterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterAuthSpecForProviderClusterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterAuthSpecProviderConfigRefPolicy
 */
export interface ClusterAuthSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterAuthSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterAuthSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterAuthSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterAuthSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterAuthSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterAuthSpecProviderConfigRefPolicy(obj: ClusterAuthSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterAuthSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterAuthSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterAuthSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterAuthSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterAuthSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterAuthSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterAuthSpecPublishConnectionDetailsToConfigRef(obj: ClusterAuthSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterAuthSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterAuthSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterAuthSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterAuthSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterAuthSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterAuthSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterAuthSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterAuthSpecPublishConnectionDetailsToMetadata(obj: ClusterAuthSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterAuthSpecForProviderClusterNameRefPolicy
 */
export interface ClusterAuthSpecForProviderClusterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterAuthSpecForProviderClusterNameRefPolicy#resolution
   */
  readonly resolution?: ClusterAuthSpecForProviderClusterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterAuthSpecForProviderClusterNameRefPolicy#resolve
   */
  readonly resolve?: ClusterAuthSpecForProviderClusterNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterAuthSpecForProviderClusterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterAuthSpecForProviderClusterNameRefPolicy(obj: ClusterAuthSpecForProviderClusterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterAuthSpecForProviderClusterNameSelectorPolicy
 */
export interface ClusterAuthSpecForProviderClusterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterAuthSpecForProviderClusterNameSelectorPolicy#resolution
   */
  readonly resolution?: ClusterAuthSpecForProviderClusterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterAuthSpecForProviderClusterNameSelectorPolicy#resolve
   */
  readonly resolve?: ClusterAuthSpecForProviderClusterNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterAuthSpecForProviderClusterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterAuthSpecForProviderClusterNameSelectorPolicy(obj: ClusterAuthSpecForProviderClusterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterAuthSpecProviderConfigRefPolicyResolution
 */
export enum ClusterAuthSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterAuthSpecProviderConfigRefPolicyResolve
 */
export enum ClusterAuthSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterAuthSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterAuthSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterAuthSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterAuthSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterAuthSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterAuthSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterAuthSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterAuthSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterAuthSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterAuthSpecForProviderClusterNameRefPolicyResolution
 */
export enum ClusterAuthSpecForProviderClusterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterAuthSpecForProviderClusterNameRefPolicyResolve
 */
export enum ClusterAuthSpecForProviderClusterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterAuthSpecForProviderClusterNameSelectorPolicyResolution
 */
export enum ClusterAuthSpecForProviderClusterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterAuthSpecForProviderClusterNameSelectorPolicyResolve
 */
export enum ClusterAuthSpecForProviderClusterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterAuthSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterAuthSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterAuthSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterAuthSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FargateProfile is the Schema for the FargateProfiles API. Manages an EKS Fargate Profile
 *
 * @schema FargateProfile
 */
export class FargateProfile extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FargateProfile"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'eks.aws.upbound.io/v1beta1',
    kind: 'FargateProfile',
  }

  /**
   * Renders a Kubernetes manifest for "FargateProfile".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FargateProfileProps): any {
    return {
      ...FargateProfile.GVK,
      ...toJson_FargateProfileProps(props),
    };
  }

  /**
   * Defines a "FargateProfile" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FargateProfileProps) {
    super(scope, id, {
      ...FargateProfile.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FargateProfile.GVK,
      ...toJson_FargateProfileProps(resolved),
    };
  }
}

/**
 * FargateProfile is the Schema for the FargateProfiles API. Manages an EKS Fargate Profile
 *
 * @schema FargateProfile
 */
export interface FargateProfileProps {
  /**
   * @schema FargateProfile#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FargateProfileSpec defines the desired state of FargateProfile
   *
   * @schema FargateProfile#spec
   */
  readonly spec: FargateProfileSpec;

}

/**
 * Converts an object of type 'FargateProfileProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileProps(obj: FargateProfileProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FargateProfileSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FargateProfileSpec defines the desired state of FargateProfile
 *
 * @schema FargateProfileSpec
 */
export interface FargateProfileSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FargateProfileSpec#deletionPolicy
   */
  readonly deletionPolicy?: FargateProfileSpecDeletionPolicy;

  /**
   * @schema FargateProfileSpec#forProvider
   */
  readonly forProvider: FargateProfileSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema FargateProfileSpec#initProvider
   */
  readonly initProvider?: FargateProfileSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FargateProfileSpec#managementPolicies
   */
  readonly managementPolicies?: FargateProfileSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FargateProfileSpec#providerConfigRef
   */
  readonly providerConfigRef?: FargateProfileSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FargateProfileSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FargateProfileSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FargateProfileSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FargateProfileSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FargateProfileSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpec(obj: FargateProfileSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FargateProfileSpecForProvider(obj.forProvider),
    'initProvider': toJson_FargateProfileSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FargateProfileSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FargateProfileSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FargateProfileSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FargateProfileSpecDeletionPolicy
 */
export enum FargateProfileSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FargateProfileSpecForProvider
 */
export interface FargateProfileSpecForProvider {
  /**
   * 100 characters in length. Must begin with an alphanumeric character, and must only contain alphanumeric characters, dashes and underscores (^[0-9A-Za-z][A-Za-z0-9\-_]+$).
   *
   * @schema FargateProfileSpecForProvider#clusterName
   */
  readonly clusterName?: string;

  /**
   * Reference to a Cluster to populate clusterName.
   *
   * @schema FargateProfileSpecForProvider#clusterNameRef
   */
  readonly clusterNameRef?: FargateProfileSpecForProviderClusterNameRef;

  /**
   * Selector for a Cluster to populate clusterName.
   *
   * @schema FargateProfileSpecForProvider#clusterNameSelector
   */
  readonly clusterNameSelector?: FargateProfileSpecForProviderClusterNameSelector;

  /**
   *   Amazon Resource Name (ARN) of the IAM Role that provides permissions for the EKS Fargate Profile.
   *
   * @schema FargateProfileSpecForProvider#podExecutionRoleArn
   */
  readonly podExecutionRoleArn?: string;

  /**
   * Reference to a Role in iam to populate podExecutionRoleArn.
   *
   * @schema FargateProfileSpecForProvider#podExecutionRoleArnRef
   */
  readonly podExecutionRoleArnRef?: FargateProfileSpecForProviderPodExecutionRoleArnRef;

  /**
   * Selector for a Role in iam to populate podExecutionRoleArn.
   *
   * @schema FargateProfileSpecForProvider#podExecutionRoleArnSelector
   */
  readonly podExecutionRoleArnSelector?: FargateProfileSpecForProviderPodExecutionRoleArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FargateProfileSpecForProvider#region
   */
  readonly region: string;

  /**
   * Configuration block(s) for selecting Kubernetes Pods to execute with this EKS Fargate Profile. Detailed below.
   *
   * @schema FargateProfileSpecForProvider#selector
   */
  readonly selector?: FargateProfileSpecForProviderSelector[];

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema FargateProfileSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: FargateProfileSpecForProviderSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema FargateProfileSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: FargateProfileSpecForProviderSubnetIdSelector;

  /**
   *   Identifiers of private EC2 Subnets to associate with the EKS Fargate Profile. These subnets must have the following resource tag: kubernetes.io/cluster/CLUSTER_NAME (where CLUSTER_NAME is replaced with the name of the EKS Cluster).
   *
   * @schema FargateProfileSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema FargateProfileSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FargateProfileSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProvider(obj: FargateProfileSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterName': obj.clusterName,
    'clusterNameRef': toJson_FargateProfileSpecForProviderClusterNameRef(obj.clusterNameRef),
    'clusterNameSelector': toJson_FargateProfileSpecForProviderClusterNameSelector(obj.clusterNameSelector),
    'podExecutionRoleArn': obj.podExecutionRoleArn,
    'podExecutionRoleArnRef': toJson_FargateProfileSpecForProviderPodExecutionRoleArnRef(obj.podExecutionRoleArnRef),
    'podExecutionRoleArnSelector': toJson_FargateProfileSpecForProviderPodExecutionRoleArnSelector(obj.podExecutionRoleArnSelector),
    'region': obj.region,
    'selector': obj.selector?.map(y => toJson_FargateProfileSpecForProviderSelector(y)),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_FargateProfileSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_FargateProfileSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema FargateProfileSpecInitProvider
 */
export interface FargateProfileSpecInitProvider {
  /**
   * Configuration block(s) for selecting Kubernetes Pods to execute with this EKS Fargate Profile. Detailed below.
   *
   * @schema FargateProfileSpecInitProvider#selector
   */
  readonly selector?: FargateProfileSpecInitProviderSelector[];

  /**
   * Key-value map of resource tags.
   *
   * @schema FargateProfileSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FargateProfileSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecInitProvider(obj: FargateProfileSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'selector': obj.selector?.map(y => toJson_FargateProfileSpecInitProviderSelector(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FargateProfileSpecManagementPolicies
 */
export enum FargateProfileSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FargateProfileSpecProviderConfigRef
 */
export interface FargateProfileSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FargateProfileSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FargateProfileSpecProviderConfigRef#policy
   */
  readonly policy?: FargateProfileSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FargateProfileSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecProviderConfigRef(obj: FargateProfileSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FargateProfileSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FargateProfileSpecPublishConnectionDetailsTo
 */
export interface FargateProfileSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FargateProfileSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FargateProfileSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FargateProfileSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecPublishConnectionDetailsTo(obj: FargateProfileSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FargateProfileSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FargateProfileSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FargateProfileSpecWriteConnectionSecretToRef
 */
export interface FargateProfileSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FargateProfileSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FargateProfileSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FargateProfileSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecWriteConnectionSecretToRef(obj: FargateProfileSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster to populate clusterName.
 *
 * @schema FargateProfileSpecForProviderClusterNameRef
 */
export interface FargateProfileSpecForProviderClusterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema FargateProfileSpecForProviderClusterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FargateProfileSpecForProviderClusterNameRef#policy
   */
  readonly policy?: FargateProfileSpecForProviderClusterNameRefPolicy;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderClusterNameRef(obj: FargateProfileSpecForProviderClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FargateProfileSpecForProviderClusterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster to populate clusterName.
 *
 * @schema FargateProfileSpecForProviderClusterNameSelector
 */
export interface FargateProfileSpecForProviderClusterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FargateProfileSpecForProviderClusterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FargateProfileSpecForProviderClusterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FargateProfileSpecForProviderClusterNameSelector#policy
   */
  readonly policy?: FargateProfileSpecForProviderClusterNameSelectorPolicy;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderClusterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderClusterNameSelector(obj: FargateProfileSpecForProviderClusterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FargateProfileSpecForProviderClusterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate podExecutionRoleArn.
 *
 * @schema FargateProfileSpecForProviderPodExecutionRoleArnRef
 */
export interface FargateProfileSpecForProviderPodExecutionRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnRef#policy
   */
  readonly policy?: FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderPodExecutionRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderPodExecutionRoleArnRef(obj: FargateProfileSpecForProviderPodExecutionRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate podExecutionRoleArn.
 *
 * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelector
 */
export interface FargateProfileSpecForProviderPodExecutionRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelector#policy
   */
  readonly policy?: FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderPodExecutionRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderPodExecutionRoleArnSelector(obj: FargateProfileSpecForProviderPodExecutionRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FargateProfileSpecForProviderSelector
 */
export interface FargateProfileSpecForProviderSelector {
  /**
   * Key-value map of Kubernetes labels for selection.
   *
   * @schema FargateProfileSpecForProviderSelector#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Kubernetes namespace for selection.
   *
   * @schema FargateProfileSpecForProviderSelector#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderSelector(obj: FargateProfileSpecForProviderSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema FargateProfileSpecForProviderSubnetIdRefs
 */
export interface FargateProfileSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema FargateProfileSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FargateProfileSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: FargateProfileSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderSubnetIdRefs(obj: FargateProfileSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FargateProfileSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema FargateProfileSpecForProviderSubnetIdSelector
 */
export interface FargateProfileSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FargateProfileSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FargateProfileSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FargateProfileSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: FargateProfileSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderSubnetIdSelector(obj: FargateProfileSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FargateProfileSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FargateProfileSpecInitProviderSelector
 */
export interface FargateProfileSpecInitProviderSelector {
  /**
   * Key-value map of Kubernetes labels for selection.
   *
   * @schema FargateProfileSpecInitProviderSelector#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Kubernetes namespace for selection.
   *
   * @schema FargateProfileSpecInitProviderSelector#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'FargateProfileSpecInitProviderSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecInitProviderSelector(obj: FargateProfileSpecInitProviderSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FargateProfileSpecProviderConfigRefPolicy
 */
export interface FargateProfileSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FargateProfileSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FargateProfileSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecProviderConfigRefPolicy(obj: FargateProfileSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FargateProfileSpecPublishConnectionDetailsToConfigRef
 */
export interface FargateProfileSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FargateProfileSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecPublishConnectionDetailsToConfigRef(obj: FargateProfileSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FargateProfileSpecPublishConnectionDetailsToMetadata
 */
export interface FargateProfileSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FargateProfileSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecPublishConnectionDetailsToMetadata(obj: FargateProfileSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FargateProfileSpecForProviderClusterNameRefPolicy
 */
export interface FargateProfileSpecForProviderClusterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileSpecForProviderClusterNameRefPolicy#resolution
   */
  readonly resolution?: FargateProfileSpecForProviderClusterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileSpecForProviderClusterNameRefPolicy#resolve
   */
  readonly resolve?: FargateProfileSpecForProviderClusterNameRefPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderClusterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderClusterNameRefPolicy(obj: FargateProfileSpecForProviderClusterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FargateProfileSpecForProviderClusterNameSelectorPolicy
 */
export interface FargateProfileSpecForProviderClusterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileSpecForProviderClusterNameSelectorPolicy#resolution
   */
  readonly resolution?: FargateProfileSpecForProviderClusterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileSpecForProviderClusterNameSelectorPolicy#resolve
   */
  readonly resolve?: FargateProfileSpecForProviderClusterNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderClusterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderClusterNameSelectorPolicy(obj: FargateProfileSpecForProviderClusterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy
 */
export interface FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy#resolution
   */
  readonly resolution?: FargateProfileSpecForProviderPodExecutionRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy#resolve
   */
  readonly resolve?: FargateProfileSpecForProviderPodExecutionRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy(obj: FargateProfileSpecForProviderPodExecutionRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy
 */
export interface FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy(obj: FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FargateProfileSpecForProviderSubnetIdRefsPolicy
 */
export interface FargateProfileSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: FargateProfileSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: FargateProfileSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderSubnetIdRefsPolicy(obj: FargateProfileSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FargateProfileSpecForProviderSubnetIdSelectorPolicy
 */
export interface FargateProfileSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: FargateProfileSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: FargateProfileSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecForProviderSubnetIdSelectorPolicy(obj: FargateProfileSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileSpecProviderConfigRefPolicyResolution
 */
export enum FargateProfileSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileSpecProviderConfigRefPolicyResolve
 */
export enum FargateProfileSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FargateProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FargateProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj: FargateProfileSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileSpecForProviderClusterNameRefPolicyResolution
 */
export enum FargateProfileSpecForProviderClusterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileSpecForProviderClusterNameRefPolicyResolve
 */
export enum FargateProfileSpecForProviderClusterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileSpecForProviderClusterNameSelectorPolicyResolution
 */
export enum FargateProfileSpecForProviderClusterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileSpecForProviderClusterNameSelectorPolicyResolve
 */
export enum FargateProfileSpecForProviderClusterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileSpecForProviderPodExecutionRoleArnRefPolicyResolution
 */
export enum FargateProfileSpecForProviderPodExecutionRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileSpecForProviderPodExecutionRoleArnRefPolicyResolve
 */
export enum FargateProfileSpecForProviderPodExecutionRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicyResolution
 */
export enum FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicyResolve
 */
export enum FargateProfileSpecForProviderPodExecutionRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum FargateProfileSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum FargateProfileSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum FargateProfileSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum FargateProfileSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FargateProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FargateProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FargateProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FargateProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * IdentityProviderConfig is the Schema for the IdentityProviderConfigs API. Manages an EKS Identity Provider Configuration.
 *
 * @schema IdentityProviderConfig
 */
export class IdentityProviderConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IdentityProviderConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'eks.aws.upbound.io/v1beta1',
    kind: 'IdentityProviderConfig',
  }

  /**
   * Renders a Kubernetes manifest for "IdentityProviderConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IdentityProviderConfigProps): any {
    return {
      ...IdentityProviderConfig.GVK,
      ...toJson_IdentityProviderConfigProps(props),
    };
  }

  /**
   * Defines a "IdentityProviderConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IdentityProviderConfigProps) {
    super(scope, id, {
      ...IdentityProviderConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IdentityProviderConfig.GVK,
      ...toJson_IdentityProviderConfigProps(resolved),
    };
  }
}

/**
 * IdentityProviderConfig is the Schema for the IdentityProviderConfigs API. Manages an EKS Identity Provider Configuration.
 *
 * @schema IdentityProviderConfig
 */
export interface IdentityProviderConfigProps {
  /**
   * @schema IdentityProviderConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IdentityProviderConfigSpec defines the desired state of IdentityProviderConfig
   *
   * @schema IdentityProviderConfig#spec
   */
  readonly spec: IdentityProviderConfigSpec;

}

/**
 * Converts an object of type 'IdentityProviderConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigProps(obj: IdentityProviderConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IdentityProviderConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IdentityProviderConfigSpec defines the desired state of IdentityProviderConfig
 *
 * @schema IdentityProviderConfigSpec
 */
export interface IdentityProviderConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IdentityProviderConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: IdentityProviderConfigSpecDeletionPolicy;

  /**
   * @schema IdentityProviderConfigSpec#forProvider
   */
  readonly forProvider: IdentityProviderConfigSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema IdentityProviderConfigSpec#initProvider
   */
  readonly initProvider?: IdentityProviderConfigSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema IdentityProviderConfigSpec#managementPolicies
   */
  readonly managementPolicies?: IdentityProviderConfigSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IdentityProviderConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: IdentityProviderConfigSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IdentityProviderConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IdentityProviderConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IdentityProviderConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IdentityProviderConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpec(obj: IdentityProviderConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IdentityProviderConfigSpecForProvider(obj.forProvider),
    'initProvider': toJson_IdentityProviderConfigSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_IdentityProviderConfigSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_IdentityProviderConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IdentityProviderConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IdentityProviderConfigSpecDeletionPolicy
 */
export enum IdentityProviderConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema IdentityProviderConfigSpecForProvider
 */
export interface IdentityProviderConfigSpecForProvider {
  /**
   *   Name of the EKS Cluster.
   *
   * @schema IdentityProviderConfigSpecForProvider#clusterName
   */
  readonly clusterName?: string;

  /**
   * Reference to a Cluster to populate clusterName.
   *
   * @schema IdentityProviderConfigSpecForProvider#clusterNameRef
   */
  readonly clusterNameRef?: IdentityProviderConfigSpecForProviderClusterNameRef;

  /**
   * Selector for a Cluster to populate clusterName.
   *
   * @schema IdentityProviderConfigSpecForProvider#clusterNameSelector
   */
  readonly clusterNameSelector?: IdentityProviderConfigSpecForProviderClusterNameSelector;

  /**
   * Nested attribute containing OpenID Connect identity provider information for the cluster. Detailed below.
   *
   * @schema IdentityProviderConfigSpecForProvider#oidc
   */
  readonly oidc?: IdentityProviderConfigSpecForProviderOidc[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema IdentityProviderConfigSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema IdentityProviderConfigSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecForProvider(obj: IdentityProviderConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterName': obj.clusterName,
    'clusterNameRef': toJson_IdentityProviderConfigSpecForProviderClusterNameRef(obj.clusterNameRef),
    'clusterNameSelector': toJson_IdentityProviderConfigSpecForProviderClusterNameSelector(obj.clusterNameSelector),
    'oidc': obj.oidc?.map(y => toJson_IdentityProviderConfigSpecForProviderOidc(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema IdentityProviderConfigSpecInitProvider
 */
export interface IdentityProviderConfigSpecInitProvider {
  /**
   * Nested attribute containing OpenID Connect identity provider information for the cluster. Detailed below.
   *
   * @schema IdentityProviderConfigSpecInitProvider#oidc
   */
  readonly oidc?: IdentityProviderConfigSpecInitProviderOidc[];

  /**
   * Key-value map of resource tags.
   *
   * @schema IdentityProviderConfigSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecInitProvider(obj: IdentityProviderConfigSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'oidc': obj.oidc?.map(y => toJson_IdentityProviderConfigSpecInitProviderOidc(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema IdentityProviderConfigSpecManagementPolicies
 */
export enum IdentityProviderConfigSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IdentityProviderConfigSpecProviderConfigRef
 */
export interface IdentityProviderConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityProviderConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityProviderConfigSpecProviderConfigRef#policy
   */
  readonly policy?: IdentityProviderConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecProviderConfigRef(obj: IdentityProviderConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityProviderConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IdentityProviderConfigSpecPublishConnectionDetailsTo
 */
export interface IdentityProviderConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IdentityProviderConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecPublishConnectionDetailsTo(obj: IdentityProviderConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IdentityProviderConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IdentityProviderConfigSpecWriteConnectionSecretToRef
 */
export interface IdentityProviderConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IdentityProviderConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IdentityProviderConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecWriteConnectionSecretToRef(obj: IdentityProviderConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster to populate clusterName.
 *
 * @schema IdentityProviderConfigSpecForProviderClusterNameRef
 */
export interface IdentityProviderConfigSpecForProviderClusterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameRef#policy
   */
  readonly policy?: IdentityProviderConfigSpecForProviderClusterNameRefPolicy;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecForProviderClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecForProviderClusterNameRef(obj: IdentityProviderConfigSpecForProviderClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityProviderConfigSpecForProviderClusterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster to populate clusterName.
 *
 * @schema IdentityProviderConfigSpecForProviderClusterNameSelector
 */
export interface IdentityProviderConfigSpecForProviderClusterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameSelector#policy
   */
  readonly policy?: IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecForProviderClusterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecForProviderClusterNameSelector(obj: IdentityProviderConfigSpecForProviderClusterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IdentityProviderConfigSpecForProviderOidc
 */
export interface IdentityProviderConfigSpecForProviderOidc {
  /**
   *   Client ID for the OpenID Connect identity provider.
   *
   * @schema IdentityProviderConfigSpecForProviderOidc#clientId
   */
  readonly clientId?: string;

  /**
   * The JWT claim that the provider will use to return groups.
   *
   * @schema IdentityProviderConfigSpecForProviderOidc#groupsClaim
   */
  readonly groupsClaim?: string;

  /**
   * A prefix that is prepended to group claims e.g., oidc:.
   *
   * @schema IdentityProviderConfigSpecForProviderOidc#groupsPrefix
   */
  readonly groupsPrefix?: string;

  /**
   * Issuer URL for the OpenID Connect identity provider.
   *
   * @schema IdentityProviderConfigSpecForProviderOidc#issuerUrl
   */
  readonly issuerUrl?: string;

  /**
   * The key value pairs that describe required claims in the identity token.
   *
   * @schema IdentityProviderConfigSpecForProviderOidc#requiredClaims
   */
  readonly requiredClaims?: { [key: string]: string };

  /**
   * The JWT claim that the provider will use as the username.
   *
   * @schema IdentityProviderConfigSpecForProviderOidc#usernameClaim
   */
  readonly usernameClaim?: string;

  /**
   * A prefix that is prepended to username claims.
   *
   * @schema IdentityProviderConfigSpecForProviderOidc#usernamePrefix
   */
  readonly usernamePrefix?: string;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecForProviderOidc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecForProviderOidc(obj: IdentityProviderConfigSpecForProviderOidc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': obj.clientId,
    'groupsClaim': obj.groupsClaim,
    'groupsPrefix': obj.groupsPrefix,
    'issuerUrl': obj.issuerUrl,
    'requiredClaims': ((obj.requiredClaims) === undefined) ? undefined : (Object.entries(obj.requiredClaims).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'usernameClaim': obj.usernameClaim,
    'usernamePrefix': obj.usernamePrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IdentityProviderConfigSpecInitProviderOidc
 */
export interface IdentityProviderConfigSpecInitProviderOidc {
  /**
   *   Client ID for the OpenID Connect identity provider.
   *
   * @schema IdentityProviderConfigSpecInitProviderOidc#clientId
   */
  readonly clientId?: string;

  /**
   * The JWT claim that the provider will use to return groups.
   *
   * @schema IdentityProviderConfigSpecInitProviderOidc#groupsClaim
   */
  readonly groupsClaim?: string;

  /**
   * A prefix that is prepended to group claims e.g., oidc:.
   *
   * @schema IdentityProviderConfigSpecInitProviderOidc#groupsPrefix
   */
  readonly groupsPrefix?: string;

  /**
   * Issuer URL for the OpenID Connect identity provider.
   *
   * @schema IdentityProviderConfigSpecInitProviderOidc#issuerUrl
   */
  readonly issuerUrl?: string;

  /**
   * The key value pairs that describe required claims in the identity token.
   *
   * @schema IdentityProviderConfigSpecInitProviderOidc#requiredClaims
   */
  readonly requiredClaims?: { [key: string]: string };

  /**
   * The JWT claim that the provider will use as the username.
   *
   * @schema IdentityProviderConfigSpecInitProviderOidc#usernameClaim
   */
  readonly usernameClaim?: string;

  /**
   * A prefix that is prepended to username claims.
   *
   * @schema IdentityProviderConfigSpecInitProviderOidc#usernamePrefix
   */
  readonly usernamePrefix?: string;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecInitProviderOidc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecInitProviderOidc(obj: IdentityProviderConfigSpecInitProviderOidc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': obj.clientId,
    'groupsClaim': obj.groupsClaim,
    'groupsPrefix': obj.groupsPrefix,
    'issuerUrl': obj.issuerUrl,
    'requiredClaims': ((obj.requiredClaims) === undefined) ? undefined : (Object.entries(obj.requiredClaims).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'usernameClaim': obj.usernameClaim,
    'usernamePrefix': obj.usernamePrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IdentityProviderConfigSpecProviderConfigRefPolicy
 */
export interface IdentityProviderConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityProviderConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IdentityProviderConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityProviderConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IdentityProviderConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecProviderConfigRefPolicy(obj: IdentityProviderConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef(obj: IdentityProviderConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IdentityProviderConfigSpecPublishConnectionDetailsToMetadata
 */
export interface IdentityProviderConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecPublishConnectionDetailsToMetadata(obj: IdentityProviderConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IdentityProviderConfigSpecForProviderClusterNameRefPolicy
 */
export interface IdentityProviderConfigSpecForProviderClusterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameRefPolicy#resolution
   */
  readonly resolution?: IdentityProviderConfigSpecForProviderClusterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameRefPolicy#resolve
   */
  readonly resolve?: IdentityProviderConfigSpecForProviderClusterNameRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecForProviderClusterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecForProviderClusterNameRefPolicy(obj: IdentityProviderConfigSpecForProviderClusterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy
 */
export interface IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy#resolution
   */
  readonly resolution?: IdentityProviderConfigSpecForProviderClusterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy#resolve
   */
  readonly resolve?: IdentityProviderConfigSpecForProviderClusterNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy(obj: IdentityProviderConfigSpecForProviderClusterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityProviderConfigSpecProviderConfigRefPolicyResolution
 */
export enum IdentityProviderConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityProviderConfigSpecProviderConfigRefPolicyResolve
 */
export enum IdentityProviderConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityProviderConfigSpecForProviderClusterNameRefPolicyResolution
 */
export enum IdentityProviderConfigSpecForProviderClusterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityProviderConfigSpecForProviderClusterNameRefPolicyResolve
 */
export enum IdentityProviderConfigSpecForProviderClusterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityProviderConfigSpecForProviderClusterNameSelectorPolicyResolution
 */
export enum IdentityProviderConfigSpecForProviderClusterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityProviderConfigSpecForProviderClusterNameSelectorPolicyResolve
 */
export enum IdentityProviderConfigSpecForProviderClusterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IdentityProviderConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * NodeGroup is the Schema for the NodeGroups API. Manages an EKS Node Group
 *
 * @schema NodeGroup
 */
export class NodeGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NodeGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'eks.aws.upbound.io/v1beta1',
    kind: 'NodeGroup',
  }

  /**
   * Renders a Kubernetes manifest for "NodeGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NodeGroupProps): any {
    return {
      ...NodeGroup.GVK,
      ...toJson_NodeGroupProps(props),
    };
  }

  /**
   * Defines a "NodeGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NodeGroupProps) {
    super(scope, id, {
      ...NodeGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NodeGroup.GVK,
      ...toJson_NodeGroupProps(resolved),
    };
  }
}

/**
 * NodeGroup is the Schema for the NodeGroups API. Manages an EKS Node Group
 *
 * @schema NodeGroup
 */
export interface NodeGroupProps {
  /**
   * @schema NodeGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NodeGroupSpec defines the desired state of NodeGroup
   *
   * @schema NodeGroup#spec
   */
  readonly spec: NodeGroupSpec;

}

/**
 * Converts an object of type 'NodeGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupProps(obj: NodeGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NodeGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeGroupSpec defines the desired state of NodeGroup
 *
 * @schema NodeGroupSpec
 */
export interface NodeGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NodeGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: NodeGroupSpecDeletionPolicy;

  /**
   * @schema NodeGroupSpec#forProvider
   */
  readonly forProvider: NodeGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema NodeGroupSpec#initProvider
   */
  readonly initProvider?: NodeGroupSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema NodeGroupSpec#managementPolicies
   */
  readonly managementPolicies?: NodeGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema NodeGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: NodeGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema NodeGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: NodeGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema NodeGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NodeGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'NodeGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpec(obj: NodeGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NodeGroupSpecForProvider(obj.forProvider),
    'initProvider': toJson_NodeGroupSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_NodeGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_NodeGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_NodeGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NodeGroupSpecDeletionPolicy
 */
export enum NodeGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema NodeGroupSpecForProvider
 */
export interface NodeGroupSpecForProvider {
  /**
   * Type of Amazon Machine Image (AMI) associated with the EKS Node Group. See the AWS documentation for valid values.
   *
   * @schema NodeGroupSpecForProvider#amiType
   */
  readonly amiType?: string;

  /**
   * Type of capacity associated with the EKS Node Group. Valid values: ON_DEMAND, SPOT.
   *
   * @schema NodeGroupSpecForProvider#capacityType
   */
  readonly capacityType?: string;

  /**
   * 100 characters in length. Must begin with an alphanumeric character, and must only contain alphanumeric characters, dashes and underscores (^[0-9A-Za-z][A-Za-z0-9\-_]+$).
   *
   * @schema NodeGroupSpecForProvider#clusterName
   */
  readonly clusterName?: string;

  /**
   * Reference to a Cluster to populate clusterName.
   *
   * @schema NodeGroupSpecForProvider#clusterNameRef
   */
  readonly clusterNameRef?: NodeGroupSpecForProviderClusterNameRef;

  /**
   * Selector for a Cluster to populate clusterName.
   *
   * @schema NodeGroupSpecForProvider#clusterNameSelector
   */
  readonly clusterNameSelector?: NodeGroupSpecForProviderClusterNameSelector;

  /**
   * Disk size in GiB for worker nodes. Defaults to 50 for Windows, 20 all other node groups.
   *
   * @default 50 for Windows, 20 all other node groups.
   * @schema NodeGroupSpecForProvider#diskSize
   */
  readonly diskSize?: number;

  /**
   * Force version update if existing pods are unable to be drained due to a pod disruption budget issue.
   *
   * @schema NodeGroupSpecForProvider#forceUpdateVersion
   */
  readonly forceUpdateVersion?: boolean;

  /**
   * List of instance types associated with the EKS Node Group. Defaults to ["t3.medium"].
   *
   * @default t3.medium"].
   * @schema NodeGroupSpecForProvider#instanceTypes
   */
  readonly instanceTypes?: string[];

  /**
   * Key-value map of Kubernetes labels. Only labels that are applied with the EKS API are managed by this argument. Other Kubernetes labels applied to the EKS Node Group will not be managed.
   *
   * @schema NodeGroupSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Configuration block with Launch Template settings. Detailed below.
   *
   * @schema NodeGroupSpecForProvider#launchTemplate
   */
  readonly launchTemplate?: NodeGroupSpecForProviderLaunchTemplate[];

  /**
   *   Amazon Resource Name (ARN) of the IAM Role that provides permissions for the EKS Node Group.
   *
   * @schema NodeGroupSpecForProvider#nodeRoleArn
   */
  readonly nodeRoleArn?: string;

  /**
   * Reference to a Role in iam to populate nodeRoleArn.
   *
   * @schema NodeGroupSpecForProvider#nodeRoleArnRef
   */
  readonly nodeRoleArnRef?: NodeGroupSpecForProviderNodeRoleArnRef;

  /**
   * Selector for a Role in iam to populate nodeRoleArn.
   *
   * @schema NodeGroupSpecForProvider#nodeRoleArnSelector
   */
  readonly nodeRoleArnSelector?: NodeGroupSpecForProviderNodeRoleArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema NodeGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   *   AMI version of the EKS Node Group. Defaults to latest version for Kubernetes version.
   *
   * @default latest version for Kubernetes version.
   * @schema NodeGroupSpecForProvider#releaseVersion
   */
  readonly releaseVersion?: string;

  /**
   * Configuration block with remote access settings. Detailed below.
   *
   * @schema NodeGroupSpecForProvider#remoteAccess
   */
  readonly remoteAccess?: NodeGroupSpecForProviderRemoteAccess[];

  /**
   * Configuration block with scaling settings. Detailed below.
   *
   * @schema NodeGroupSpecForProvider#scalingConfig
   */
  readonly scalingConfig?: NodeGroupSpecForProviderScalingConfig[];

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema NodeGroupSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: NodeGroupSpecForProviderSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema NodeGroupSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: NodeGroupSpecForProviderSubnetIdSelector;

  /**
   * Identifiers of EC2 Subnets to associate with the EKS Node Group. Amazon EKS managed node groups can be launched in both public and private subnets. If you plan to deploy load balancers to a subnet, the private subnet must have tag kubernetes.io/role/internal-elb, the public subnet must have tag kubernetes.io/role/elb.
   *
   * @schema NodeGroupSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema NodeGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The Kubernetes taints to be applied to the nodes in the node group. Maximum of 50 taints per node group. Detailed below.
   *
   * @schema NodeGroupSpecForProvider#taint
   */
  readonly taint?: NodeGroupSpecForProviderTaint[];

  /**
   * @schema NodeGroupSpecForProvider#updateConfig
   */
  readonly updateConfig?: NodeGroupSpecForProviderUpdateConfig[];

  /**
   *   Kubernetes version. Defaults to EKS Cluster Kubernetes version.
   *
   * @default EKS Cluster Kubernetes version.
   * @schema NodeGroupSpecForProvider#version
   */
  readonly version?: string;

  /**
   * Reference to a Cluster in eks to populate version.
   *
   * @schema NodeGroupSpecForProvider#versionRef
   */
  readonly versionRef?: NodeGroupSpecForProviderVersionRef;

  /**
   * Selector for a Cluster in eks to populate version.
   *
   * @schema NodeGroupSpecForProvider#versionSelector
   */
  readonly versionSelector?: NodeGroupSpecForProviderVersionSelector;

}

/**
 * Converts an object of type 'NodeGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProvider(obj: NodeGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amiType': obj.amiType,
    'capacityType': obj.capacityType,
    'clusterName': obj.clusterName,
    'clusterNameRef': toJson_NodeGroupSpecForProviderClusterNameRef(obj.clusterNameRef),
    'clusterNameSelector': toJson_NodeGroupSpecForProviderClusterNameSelector(obj.clusterNameSelector),
    'diskSize': obj.diskSize,
    'forceUpdateVersion': obj.forceUpdateVersion,
    'instanceTypes': obj.instanceTypes?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'launchTemplate': obj.launchTemplate?.map(y => toJson_NodeGroupSpecForProviderLaunchTemplate(y)),
    'nodeRoleArn': obj.nodeRoleArn,
    'nodeRoleArnRef': toJson_NodeGroupSpecForProviderNodeRoleArnRef(obj.nodeRoleArnRef),
    'nodeRoleArnSelector': toJson_NodeGroupSpecForProviderNodeRoleArnSelector(obj.nodeRoleArnSelector),
    'region': obj.region,
    'releaseVersion': obj.releaseVersion,
    'remoteAccess': obj.remoteAccess?.map(y => toJson_NodeGroupSpecForProviderRemoteAccess(y)),
    'scalingConfig': obj.scalingConfig?.map(y => toJson_NodeGroupSpecForProviderScalingConfig(y)),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_NodeGroupSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_NodeGroupSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'taint': obj.taint?.map(y => toJson_NodeGroupSpecForProviderTaint(y)),
    'updateConfig': obj.updateConfig?.map(y => toJson_NodeGroupSpecForProviderUpdateConfig(y)),
    'version': obj.version,
    'versionRef': toJson_NodeGroupSpecForProviderVersionRef(obj.versionRef),
    'versionSelector': toJson_NodeGroupSpecForProviderVersionSelector(obj.versionSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema NodeGroupSpecInitProvider
 */
export interface NodeGroupSpecInitProvider {
  /**
   * Type of Amazon Machine Image (AMI) associated with the EKS Node Group. See the AWS documentation for valid values.
   *
   * @schema NodeGroupSpecInitProvider#amiType
   */
  readonly amiType?: string;

  /**
   * Type of capacity associated with the EKS Node Group. Valid values: ON_DEMAND, SPOT.
   *
   * @schema NodeGroupSpecInitProvider#capacityType
   */
  readonly capacityType?: string;

  /**
   * Disk size in GiB for worker nodes. Defaults to 50 for Windows, 20 all other node groups.
   *
   * @default 50 for Windows, 20 all other node groups.
   * @schema NodeGroupSpecInitProvider#diskSize
   */
  readonly diskSize?: number;

  /**
   * Force version update if existing pods are unable to be drained due to a pod disruption budget issue.
   *
   * @schema NodeGroupSpecInitProvider#forceUpdateVersion
   */
  readonly forceUpdateVersion?: boolean;

  /**
   * List of instance types associated with the EKS Node Group. Defaults to ["t3.medium"].
   *
   * @default t3.medium"].
   * @schema NodeGroupSpecInitProvider#instanceTypes
   */
  readonly instanceTypes?: string[];

  /**
   * Key-value map of Kubernetes labels. Only labels that are applied with the EKS API are managed by this argument. Other Kubernetes labels applied to the EKS Node Group will not be managed.
   *
   * @schema NodeGroupSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Configuration block with Launch Template settings. Detailed below.
   *
   * @schema NodeGroupSpecInitProvider#launchTemplate
   */
  readonly launchTemplate?: NodeGroupSpecInitProviderLaunchTemplate[];

  /**
   *   AMI version of the EKS Node Group. Defaults to latest version for Kubernetes version.
   *
   * @default latest version for Kubernetes version.
   * @schema NodeGroupSpecInitProvider#releaseVersion
   */
  readonly releaseVersion?: string;

  /**
   * Configuration block with remote access settings. Detailed below.
   *
   * @schema NodeGroupSpecInitProvider#remoteAccess
   */
  readonly remoteAccess?: NodeGroupSpecInitProviderRemoteAccess[];

  /**
   * Configuration block with scaling settings. Detailed below.
   *
   * @schema NodeGroupSpecInitProvider#scalingConfig
   */
  readonly scalingConfig?: NodeGroupSpecInitProviderScalingConfig[];

  /**
   * Key-value map of resource tags.
   *
   * @schema NodeGroupSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The Kubernetes taints to be applied to the nodes in the node group. Maximum of 50 taints per node group. Detailed below.
   *
   * @schema NodeGroupSpecInitProvider#taint
   */
  readonly taint?: NodeGroupSpecInitProviderTaint[];

  /**
   * @schema NodeGroupSpecInitProvider#updateConfig
   */
  readonly updateConfig?: NodeGroupSpecInitProviderUpdateConfig[];

}

/**
 * Converts an object of type 'NodeGroupSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecInitProvider(obj: NodeGroupSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amiType': obj.amiType,
    'capacityType': obj.capacityType,
    'diskSize': obj.diskSize,
    'forceUpdateVersion': obj.forceUpdateVersion,
    'instanceTypes': obj.instanceTypes?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'launchTemplate': obj.launchTemplate?.map(y => toJson_NodeGroupSpecInitProviderLaunchTemplate(y)),
    'releaseVersion': obj.releaseVersion,
    'remoteAccess': obj.remoteAccess?.map(y => toJson_NodeGroupSpecInitProviderRemoteAccess(y)),
    'scalingConfig': obj.scalingConfig?.map(y => toJson_NodeGroupSpecInitProviderScalingConfig(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'taint': obj.taint?.map(y => toJson_NodeGroupSpecInitProviderTaint(y)),
    'updateConfig': obj.updateConfig?.map(y => toJson_NodeGroupSpecInitProviderUpdateConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema NodeGroupSpecManagementPolicies
 */
export enum NodeGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema NodeGroupSpecProviderConfigRef
 */
export interface NodeGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeGroupSpecProviderConfigRef#policy
   */
  readonly policy?: NodeGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecProviderConfigRef(obj: NodeGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema NodeGroupSpecPublishConnectionDetailsTo
 */
export interface NodeGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: NodeGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: NodeGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'NodeGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecPublishConnectionDetailsTo(obj: NodeGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_NodeGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_NodeGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema NodeGroupSpecWriteConnectionSecretToRef
 */
export interface NodeGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NodeGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NodeGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NodeGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecWriteConnectionSecretToRef(obj: NodeGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster to populate clusterName.
 *
 * @schema NodeGroupSpecForProviderClusterNameRef
 */
export interface NodeGroupSpecForProviderClusterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeGroupSpecForProviderClusterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeGroupSpecForProviderClusterNameRef#policy
   */
  readonly policy?: NodeGroupSpecForProviderClusterNameRefPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderClusterNameRef(obj: NodeGroupSpecForProviderClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeGroupSpecForProviderClusterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster to populate clusterName.
 *
 * @schema NodeGroupSpecForProviderClusterNameSelector
 */
export interface NodeGroupSpecForProviderClusterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NodeGroupSpecForProviderClusterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodeGroupSpecForProviderClusterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodeGroupSpecForProviderClusterNameSelector#policy
   */
  readonly policy?: NodeGroupSpecForProviderClusterNameSelectorPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderClusterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderClusterNameSelector(obj: NodeGroupSpecForProviderClusterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodeGroupSpecForProviderClusterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeGroupSpecForProviderLaunchTemplate
 */
export interface NodeGroupSpecForProviderLaunchTemplate {
  /**
   * Identifier of the EC2 Launch Template. Conflicts with name.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplate#id
   */
  readonly id?: string;

  /**
   * Name of the EC2 Launch Template. Conflicts with id.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplate#name
   */
  readonly name?: string;

  /**
   * EC2 Launch Template version number. While the API accepts values like $Default and $Latest, the API will convert the value to the associated version number (e.g., 1). Using the default_version or latest_version attribute of the aws_launch_template resource or data source is recommended for this argument.
   *
   * @schema NodeGroupSpecForProviderLaunchTemplate#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderLaunchTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderLaunchTemplate(obj: NodeGroupSpecForProviderLaunchTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate nodeRoleArn.
 *
 * @schema NodeGroupSpecForProviderNodeRoleArnRef
 */
export interface NodeGroupSpecForProviderNodeRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeGroupSpecForProviderNodeRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeGroupSpecForProviderNodeRoleArnRef#policy
   */
  readonly policy?: NodeGroupSpecForProviderNodeRoleArnRefPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderNodeRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderNodeRoleArnRef(obj: NodeGroupSpecForProviderNodeRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeGroupSpecForProviderNodeRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate nodeRoleArn.
 *
 * @schema NodeGroupSpecForProviderNodeRoleArnSelector
 */
export interface NodeGroupSpecForProviderNodeRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NodeGroupSpecForProviderNodeRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodeGroupSpecForProviderNodeRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodeGroupSpecForProviderNodeRoleArnSelector#policy
   */
  readonly policy?: NodeGroupSpecForProviderNodeRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderNodeRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderNodeRoleArnSelector(obj: NodeGroupSpecForProviderNodeRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodeGroupSpecForProviderNodeRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeGroupSpecForProviderRemoteAccess
 */
export interface NodeGroupSpecForProviderRemoteAccess {
  /**
   * EC2 Key Pair name that provides access for remote communication with the worker nodes in the EKS Node Group. If you specify this configuration, but do not specify source_security_group_ids when you create an EKS Node Group, either port 3389 for Windows, or port 22 for all other operating systems is opened on the worker nodes to the Internet (0.0.0.0/0). For Windows nodes, this will allow you to use RDP, for all others this allows you to SSH into the worker nodes.
   *
   * @schema NodeGroupSpecForProviderRemoteAccess#ec2SshKey
   */
  readonly ec2SshKey?: string;

  /**
   * References to SecurityGroup in ec2 to populate sourceSecurityGroupIds.
   *
   * @schema NodeGroupSpecForProviderRemoteAccess#sourceSecurityGroupIdRefs
   */
  readonly sourceSecurityGroupIdRefs?: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate sourceSecurityGroupIds.
   *
   * @schema NodeGroupSpecForProviderRemoteAccess#sourceSecurityGroupIdSelector
   */
  readonly sourceSecurityGroupIdSelector?: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelector;

  /**
   * Set of EC2 Security Group IDs to allow SSH access (port 22) from on the worker nodes. If you specify ec2_ssh_key, but do not specify this configuration when you create an EKS Node Group, port 22 on the worker nodes is opened to the Internet (0.0.0.0/0).
   *
   * @schema NodeGroupSpecForProviderRemoteAccess#sourceSecurityGroupIds
   */
  readonly sourceSecurityGroupIds?: string[];

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderRemoteAccess' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderRemoteAccess(obj: NodeGroupSpecForProviderRemoteAccess | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ec2SshKey': obj.ec2SshKey,
    'sourceSecurityGroupIdRefs': obj.sourceSecurityGroupIdRefs?.map(y => toJson_NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefs(y)),
    'sourceSecurityGroupIdSelector': toJson_NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelector(obj.sourceSecurityGroupIdSelector),
    'sourceSecurityGroupIds': obj.sourceSecurityGroupIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeGroupSpecForProviderScalingConfig
 */
export interface NodeGroupSpecForProviderScalingConfig {
  /**
   * Desired number of worker nodes.
   *
   * @schema NodeGroupSpecForProviderScalingConfig#desiredSize
   */
  readonly desiredSize?: number;

  /**
   * Maximum number of worker nodes.
   *
   * @schema NodeGroupSpecForProviderScalingConfig#maxSize
   */
  readonly maxSize?: number;

  /**
   * Minimum number of worker nodes.
   *
   * @schema NodeGroupSpecForProviderScalingConfig#minSize
   */
  readonly minSize?: number;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderScalingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderScalingConfig(obj: NodeGroupSpecForProviderScalingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'desiredSize': obj.desiredSize,
    'maxSize': obj.maxSize,
    'minSize': obj.minSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema NodeGroupSpecForProviderSubnetIdRefs
 */
export interface NodeGroupSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema NodeGroupSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeGroupSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: NodeGroupSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderSubnetIdRefs(obj: NodeGroupSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeGroupSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema NodeGroupSpecForProviderSubnetIdSelector
 */
export interface NodeGroupSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NodeGroupSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodeGroupSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodeGroupSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: NodeGroupSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderSubnetIdSelector(obj: NodeGroupSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodeGroupSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeGroupSpecForProviderTaint
 */
export interface NodeGroupSpecForProviderTaint {
  /**
   * The effect of the taint. Valid values: NO_SCHEDULE, NO_EXECUTE, PREFER_NO_SCHEDULE.
   *
   * @schema NodeGroupSpecForProviderTaint#effect
   */
  readonly effect?: string;

  /**
   * The key of the taint. Maximum length of 63.
   *
   * @schema NodeGroupSpecForProviderTaint#key
   */
  readonly key?: string;

  /**
   * The value of the taint. Maximum length of 63.
   *
   * @schema NodeGroupSpecForProviderTaint#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderTaint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderTaint(obj: NodeGroupSpecForProviderTaint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeGroupSpecForProviderUpdateConfig
 */
export interface NodeGroupSpecForProviderUpdateConfig {
  /**
   * Desired max number of unavailable worker nodes during node group update.
   *
   * @schema NodeGroupSpecForProviderUpdateConfig#maxUnavailable
   */
  readonly maxUnavailable?: number;

  /**
   * Desired max percentage of unavailable worker nodes during node group update.
   *
   * @schema NodeGroupSpecForProviderUpdateConfig#maxUnavailablePercentage
   */
  readonly maxUnavailablePercentage?: number;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderUpdateConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderUpdateConfig(obj: NodeGroupSpecForProviderUpdateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable,
    'maxUnavailablePercentage': obj.maxUnavailablePercentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in eks to populate version.
 *
 * @schema NodeGroupSpecForProviderVersionRef
 */
export interface NodeGroupSpecForProviderVersionRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeGroupSpecForProviderVersionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeGroupSpecForProviderVersionRef#policy
   */
  readonly policy?: NodeGroupSpecForProviderVersionRefPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderVersionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderVersionRef(obj: NodeGroupSpecForProviderVersionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeGroupSpecForProviderVersionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in eks to populate version.
 *
 * @schema NodeGroupSpecForProviderVersionSelector
 */
export interface NodeGroupSpecForProviderVersionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NodeGroupSpecForProviderVersionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodeGroupSpecForProviderVersionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodeGroupSpecForProviderVersionSelector#policy
   */
  readonly policy?: NodeGroupSpecForProviderVersionSelectorPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderVersionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderVersionSelector(obj: NodeGroupSpecForProviderVersionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodeGroupSpecForProviderVersionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeGroupSpecInitProviderLaunchTemplate
 */
export interface NodeGroupSpecInitProviderLaunchTemplate {
  /**
   * Identifier of the EC2 Launch Template. Conflicts with name.
   *
   * @schema NodeGroupSpecInitProviderLaunchTemplate#id
   */
  readonly id?: string;

  /**
   * Name of the EC2 Launch Template. Conflicts with id.
   *
   * @schema NodeGroupSpecInitProviderLaunchTemplate#name
   */
  readonly name?: string;

  /**
   * EC2 Launch Template version number. While the API accepts values like $Default and $Latest, the API will convert the value to the associated version number (e.g., 1). Using the default_version or latest_version attribute of the aws_launch_template resource or data source is recommended for this argument.
   *
   * @schema NodeGroupSpecInitProviderLaunchTemplate#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'NodeGroupSpecInitProviderLaunchTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecInitProviderLaunchTemplate(obj: NodeGroupSpecInitProviderLaunchTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeGroupSpecInitProviderRemoteAccess
 */
export interface NodeGroupSpecInitProviderRemoteAccess {
  /**
   * EC2 Key Pair name that provides access for remote communication with the worker nodes in the EKS Node Group. If you specify this configuration, but do not specify source_security_group_ids when you create an EKS Node Group, either port 3389 for Windows, or port 22 for all other operating systems is opened on the worker nodes to the Internet (0.0.0.0/0). For Windows nodes, this will allow you to use RDP, for all others this allows you to SSH into the worker nodes.
   *
   * @schema NodeGroupSpecInitProviderRemoteAccess#ec2SshKey
   */
  readonly ec2SshKey?: string;

}

/**
 * Converts an object of type 'NodeGroupSpecInitProviderRemoteAccess' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecInitProviderRemoteAccess(obj: NodeGroupSpecInitProviderRemoteAccess | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ec2SshKey': obj.ec2SshKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeGroupSpecInitProviderScalingConfig
 */
export interface NodeGroupSpecInitProviderScalingConfig {
  /**
   * Desired number of worker nodes.
   *
   * @schema NodeGroupSpecInitProviderScalingConfig#desiredSize
   */
  readonly desiredSize?: number;

  /**
   * Maximum number of worker nodes.
   *
   * @schema NodeGroupSpecInitProviderScalingConfig#maxSize
   */
  readonly maxSize?: number;

  /**
   * Minimum number of worker nodes.
   *
   * @schema NodeGroupSpecInitProviderScalingConfig#minSize
   */
  readonly minSize?: number;

}

/**
 * Converts an object of type 'NodeGroupSpecInitProviderScalingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecInitProviderScalingConfig(obj: NodeGroupSpecInitProviderScalingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'desiredSize': obj.desiredSize,
    'maxSize': obj.maxSize,
    'minSize': obj.minSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeGroupSpecInitProviderTaint
 */
export interface NodeGroupSpecInitProviderTaint {
  /**
   * The effect of the taint. Valid values: NO_SCHEDULE, NO_EXECUTE, PREFER_NO_SCHEDULE.
   *
   * @schema NodeGroupSpecInitProviderTaint#effect
   */
  readonly effect?: string;

  /**
   * The key of the taint. Maximum length of 63.
   *
   * @schema NodeGroupSpecInitProviderTaint#key
   */
  readonly key?: string;

  /**
   * The value of the taint. Maximum length of 63.
   *
   * @schema NodeGroupSpecInitProviderTaint#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'NodeGroupSpecInitProviderTaint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecInitProviderTaint(obj: NodeGroupSpecInitProviderTaint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeGroupSpecInitProviderUpdateConfig
 */
export interface NodeGroupSpecInitProviderUpdateConfig {
  /**
   * Desired max number of unavailable worker nodes during node group update.
   *
   * @schema NodeGroupSpecInitProviderUpdateConfig#maxUnavailable
   */
  readonly maxUnavailable?: number;

  /**
   * Desired max percentage of unavailable worker nodes during node group update.
   *
   * @schema NodeGroupSpecInitProviderUpdateConfig#maxUnavailablePercentage
   */
  readonly maxUnavailablePercentage?: number;

}

/**
 * Converts an object of type 'NodeGroupSpecInitProviderUpdateConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecInitProviderUpdateConfig(obj: NodeGroupSpecInitProviderUpdateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable,
    'maxUnavailablePercentage': obj.maxUnavailablePercentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodeGroupSpecProviderConfigRefPolicy
 */
export interface NodeGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecProviderConfigRefPolicy(obj: NodeGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema NodeGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface NodeGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecPublishConnectionDetailsToConfigRef(obj: NodeGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema NodeGroupSpecPublishConnectionDetailsToMetadata
 */
export interface NodeGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NodeGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecPublishConnectionDetailsToMetadata(obj: NodeGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodeGroupSpecForProviderClusterNameRefPolicy
 */
export interface NodeGroupSpecForProviderClusterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderClusterNameRefPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderClusterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderClusterNameRefPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderClusterNameRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderClusterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderClusterNameRefPolicy(obj: NodeGroupSpecForProviderClusterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NodeGroupSpecForProviderClusterNameSelectorPolicy
 */
export interface NodeGroupSpecForProviderClusterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderClusterNameSelectorPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderClusterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderClusterNameSelectorPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderClusterNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderClusterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderClusterNameSelectorPolicy(obj: NodeGroupSpecForProviderClusterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodeGroupSpecForProviderNodeRoleArnRefPolicy
 */
export interface NodeGroupSpecForProviderNodeRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderNodeRoleArnRefPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderNodeRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderNodeRoleArnRefPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderNodeRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderNodeRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderNodeRoleArnRefPolicy(obj: NodeGroupSpecForProviderNodeRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NodeGroupSpecForProviderNodeRoleArnSelectorPolicy
 */
export interface NodeGroupSpecForProviderNodeRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderNodeRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderNodeRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderNodeRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderNodeRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderNodeRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderNodeRoleArnSelectorPolicy(obj: NodeGroupSpecForProviderNodeRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefs
 */
export interface NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefs#policy
   */
  readonly policy?: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefs(obj: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate sourceSecurityGroupIds.
 *
 * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelector
 */
export interface NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelector#policy
   */
  readonly policy?: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelector(obj: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodeGroupSpecForProviderSubnetIdRefsPolicy
 */
export interface NodeGroupSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderSubnetIdRefsPolicy(obj: NodeGroupSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NodeGroupSpecForProviderSubnetIdSelectorPolicy
 */
export interface NodeGroupSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderSubnetIdSelectorPolicy(obj: NodeGroupSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodeGroupSpecForProviderVersionRefPolicy
 */
export interface NodeGroupSpecForProviderVersionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderVersionRefPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderVersionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderVersionRefPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderVersionRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderVersionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderVersionRefPolicy(obj: NodeGroupSpecForProviderVersionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NodeGroupSpecForProviderVersionSelectorPolicy
 */
export interface NodeGroupSpecForProviderVersionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderVersionSelectorPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderVersionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderVersionSelectorPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderVersionSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderVersionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderVersionSelectorPolicy(obj: NodeGroupSpecForProviderVersionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecProviderConfigRefPolicyResolution
 */
export enum NodeGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecProviderConfigRefPolicyResolve
 */
export enum NodeGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: NodeGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderClusterNameRefPolicyResolution
 */
export enum NodeGroupSpecForProviderClusterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderClusterNameRefPolicyResolve
 */
export enum NodeGroupSpecForProviderClusterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderClusterNameSelectorPolicyResolution
 */
export enum NodeGroupSpecForProviderClusterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderClusterNameSelectorPolicyResolve
 */
export enum NodeGroupSpecForProviderClusterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderNodeRoleArnRefPolicyResolution
 */
export enum NodeGroupSpecForProviderNodeRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderNodeRoleArnRefPolicyResolve
 */
export enum NodeGroupSpecForProviderNodeRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderNodeRoleArnSelectorPolicyResolution
 */
export enum NodeGroupSpecForProviderNodeRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderNodeRoleArnSelectorPolicyResolve
 */
export enum NodeGroupSpecForProviderNodeRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefsPolicy
 */
export interface NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefsPolicy(obj: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelectorPolicy
 */
export interface NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelectorPolicy(obj: NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum NodeGroupSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum NodeGroupSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum NodeGroupSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum NodeGroupSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderVersionRefPolicyResolution
 */
export enum NodeGroupSpecForProviderVersionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderVersionRefPolicyResolve
 */
export enum NodeGroupSpecForProviderVersionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderVersionSelectorPolicyResolution
 */
export enum NodeGroupSpecForProviderVersionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderVersionSelectorPolicyResolve
 */
export enum NodeGroupSpecForProviderVersionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum NodeGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum NodeGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefsPolicyResolution
 */
export enum NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefsPolicyResolve
 */
export enum NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelectorPolicyResolution
 */
export enum NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelectorPolicyResolve
 */
export enum NodeGroupSpecForProviderRemoteAccessSourceSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

