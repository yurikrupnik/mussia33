// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * A ProviderConfig configures how argocd controller should connect to argocd API.
 *
 * @schema ProviderConfig
 */
export class ProviderConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProviderConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'argocd.crossplane.io/v1alpha1',
    kind: 'ProviderConfig',
  }

  /**
   * Renders a Kubernetes manifest for "ProviderConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProviderConfigProps): any {
    return {
      ...ProviderConfig.GVK,
      ...toJson_ProviderConfigProps(props),
    };
  }

  /**
   * Defines a "ProviderConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProviderConfigProps) {
    super(scope, id, {
      ...ProviderConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProviderConfig.GVK,
      ...toJson_ProviderConfigProps(resolved),
    };
  }
}

/**
 * A ProviderConfig configures how argocd controller should connect to argocd API.
 *
 * @schema ProviderConfig
 */
export interface ProviderConfigProps {
  /**
   * @schema ProviderConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A ProviderConfigSpec defines the desired state of a ProviderConfig.
   *
   * @schema ProviderConfig#spec
   */
  readonly spec: ProviderConfigSpec;

}

/**
 * Converts an object of type 'ProviderConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigProps(obj: ProviderConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProviderConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ProviderConfigSpec defines the desired state of a ProviderConfig.
 *
 * @schema ProviderConfigSpec
 */
export interface ProviderConfigSpec {
  /**
   * Credentials required to authenticate to this provider.
   *
   * @schema ProviderConfigSpec#credentials
   */
  readonly credentials: ProviderConfigSpecCredentials;

  /**
   * Insecure specifies whether to disable strict tls validation. Default: false.
   *
   * @schema ProviderConfigSpec#insecure
   */
  readonly insecure?: boolean;

  /**
   * PlainText specifies whether to use http vs https. Default: false.
   *
   * @schema ProviderConfigSpec#plainText
   */
  readonly plainText?: boolean;

  /**
   * ServerAddr is the hostname or IP of the argocd instance
   *
   * @schema ProviderConfigSpec#serverAddr
   */
  readonly serverAddr: string;

}

/**
 * Converts an object of type 'ProviderConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpec(obj: ProviderConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ProviderConfigSpecCredentials(obj.credentials),
    'insecure': obj.insecure,
    'plainText': obj.plainText,
    'serverAddr': obj.serverAddr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Credentials required to authenticate to this provider.
 *
 * @schema ProviderConfigSpecCredentials
 */
export interface ProviderConfigSpecCredentials {
  /**
   * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecCredentials#env
   */
  readonly env?: ProviderConfigSpecCredentialsEnv;

  /**
   * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecCredentials#fs
   */
  readonly fs?: ProviderConfigSpecCredentialsFs;

  /**
   * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecCredentials#secretRef
   */
  readonly secretRef?: ProviderConfigSpecCredentialsSecretRef;

  /**
   * Source of the provider credentials.
   *
   * @schema ProviderConfigSpecCredentials#source
   */
  readonly source: ProviderConfigSpecCredentialsSource;

}

/**
 * Converts an object of type 'ProviderConfigSpecCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecCredentials(obj: ProviderConfigSpecCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': toJson_ProviderConfigSpecCredentialsEnv(obj.env),
    'fs': toJson_ProviderConfigSpecCredentialsFs(obj.fs),
    'secretRef': toJson_ProviderConfigSpecCredentialsSecretRef(obj.secretRef),
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecCredentialsEnv
 */
export interface ProviderConfigSpecCredentialsEnv {
  /**
   * Name is the name of an environment variable.
   *
   * @schema ProviderConfigSpecCredentialsEnv#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProviderConfigSpecCredentialsEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecCredentialsEnv(obj: ProviderConfigSpecCredentialsEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecCredentialsFs
 */
export interface ProviderConfigSpecCredentialsFs {
  /**
   * Path is a filesystem path.
   *
   * @schema ProviderConfigSpecCredentialsFs#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ProviderConfigSpecCredentialsFs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecCredentialsFs(obj: ProviderConfigSpecCredentialsFs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecCredentialsSecretRef
 */
export interface ProviderConfigSpecCredentialsSecretRef {
  /**
   * The key to select.
   *
   * @schema ProviderConfigSpecCredentialsSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ProviderConfigSpecCredentialsSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProviderConfigSpecCredentialsSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProviderConfigSpecCredentialsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecCredentialsSecretRef(obj: ProviderConfigSpecCredentialsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source of the provider credentials.
 *
 * @schema ProviderConfigSpecCredentialsSource
 */
export enum ProviderConfigSpecCredentialsSource {
  /** None */
  NONE = "None",
  /** Secret */
  SECRET = "Secret",
  /** Environment */
  ENVIRONMENT = "Environment",
  /** Filesystem */
  FILESYSTEM = "Filesystem",
}


/**
 * A ProviderConfigUsage indicates that a resource is using a ProviderConfig.
 *
 * @schema ProviderConfigUsage
 */
export class ProviderConfigUsage extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProviderConfigUsage"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'argocd.crossplane.io/v1alpha1',
    kind: 'ProviderConfigUsage',
  }

  /**
   * Renders a Kubernetes manifest for "ProviderConfigUsage".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProviderConfigUsageProps): any {
    return {
      ...ProviderConfigUsage.GVK,
      ...toJson_ProviderConfigUsageProps(props),
    };
  }

  /**
   * Defines a "ProviderConfigUsage" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProviderConfigUsageProps) {
    super(scope, id, {
      ...ProviderConfigUsage.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProviderConfigUsage.GVK,
      ...toJson_ProviderConfigUsageProps(resolved),
    };
  }
}

/**
 * A ProviderConfigUsage indicates that a resource is using a ProviderConfig.
 *
 * @schema ProviderConfigUsage
 */
export interface ProviderConfigUsageProps {
  /**
   * @schema ProviderConfigUsage#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProviderConfigReference to the provider config being used.
   *
   * @schema ProviderConfigUsage#providerConfigRef
   */
  readonly providerConfigRef: ProviderConfigUsageProviderConfigRef;

  /**
   * ResourceReference to the managed resource using the provider config.
   *
   * @schema ProviderConfigUsage#resourceRef
   */
  readonly resourceRef: ProviderConfigUsageResourceRef;

}

/**
 * Converts an object of type 'ProviderConfigUsageProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigUsageProps(obj: ProviderConfigUsageProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'providerConfigRef': toJson_ProviderConfigUsageProviderConfigRef(obj.providerConfigRef),
    'resourceRef': toJson_ProviderConfigUsageResourceRef(obj.resourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference to the provider config being used.
 *
 * @schema ProviderConfigUsageProviderConfigRef
 */
export interface ProviderConfigUsageProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProviderConfigUsageProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProviderConfigUsageProviderConfigRef#policy
   */
  readonly policy?: ProviderConfigUsageProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProviderConfigUsageProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigUsageProviderConfigRef(obj: ProviderConfigUsageProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProviderConfigUsageProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceReference to the managed resource using the provider config.
 *
 * @schema ProviderConfigUsageResourceRef
 */
export interface ProviderConfigUsageResourceRef {
  /**
   * APIVersion of the referenced object.
   *
   * @schema ProviderConfigUsageResourceRef#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind of the referenced object.
   *
   * @schema ProviderConfigUsageResourceRef#kind
   */
  readonly kind: string;

  /**
   * Name of the referenced object.
   *
   * @schema ProviderConfigUsageResourceRef#name
   */
  readonly name: string;

  /**
   * UID of the referenced object.
   *
   * @schema ProviderConfigUsageResourceRef#uid
   */
  readonly uid?: string;

}

/**
 * Converts an object of type 'ProviderConfigUsageResourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigUsageResourceRef(obj: ProviderConfigUsageResourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProviderConfigUsageProviderConfigRefPolicy
 */
export interface ProviderConfigUsageProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProviderConfigUsageProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProviderConfigUsageProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProviderConfigUsageProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProviderConfigUsageProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProviderConfigUsageProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigUsageProviderConfigRefPolicy(obj: ProviderConfigUsageProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProviderConfigUsageProviderConfigRefPolicyResolution
 */
export enum ProviderConfigUsageProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProviderConfigUsageProviderConfigRefPolicyResolve
 */
export enum ProviderConfigUsageProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

