// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * CachePolicy is the Schema for the CachePolicys API. Provides a cache policy for a CloudFront ditribution. When it’s attached to a cache behavior, the cache policy determines the values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer. It also determines the default, minimum, and maximum time to live (TTL) values that you want objects to stay in the CloudFront cache.
 *
 * @schema CachePolicy
 */
export class CachePolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CachePolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudfront.aws.upbound.io/v1beta1',
    kind: 'CachePolicy',
  }

  /**
   * Renders a Kubernetes manifest for "CachePolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CachePolicyProps): any {
    return {
      ...CachePolicy.GVK,
      ...toJson_CachePolicyProps(props),
    };
  }

  /**
   * Defines a "CachePolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CachePolicyProps) {
    super(scope, id, {
      ...CachePolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CachePolicy.GVK,
      ...toJson_CachePolicyProps(resolved),
    };
  }
}

/**
 * CachePolicy is the Schema for the CachePolicys API. Provides a cache policy for a CloudFront ditribution. When it’s attached to a cache behavior, the cache policy determines the values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer. It also determines the default, minimum, and maximum time to live (TTL) values that you want objects to stay in the CloudFront cache.
 *
 * @schema CachePolicy
 */
export interface CachePolicyProps {
  /**
   * @schema CachePolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CachePolicySpec defines the desired state of CachePolicy
   *
   * @schema CachePolicy#spec
   */
  readonly spec: CachePolicySpec;

}

/**
 * Converts an object of type 'CachePolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicyProps(obj: CachePolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CachePolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CachePolicySpec defines the desired state of CachePolicy
 *
 * @schema CachePolicySpec
 */
export interface CachePolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CachePolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: CachePolicySpecDeletionPolicy;

  /**
   * @schema CachePolicySpec#forProvider
   */
  readonly forProvider: CachePolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CachePolicySpec#initProvider
   */
  readonly initProvider?: CachePolicySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CachePolicySpec#managementPolicies
   */
  readonly managementPolicies?: CachePolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CachePolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: CachePolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CachePolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CachePolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CachePolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CachePolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CachePolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpec(obj: CachePolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CachePolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_CachePolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CachePolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CachePolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CachePolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CachePolicySpecDeletionPolicy
 */
export enum CachePolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CachePolicySpecForProvider
 */
export interface CachePolicySpecForProvider {
  /**
   * A comment to describe the cache policy.
   *
   * @schema CachePolicySpecForProvider#comment
   */
  readonly comment?: string;

  /**
   * The default amount of time, in seconds, that you want objects to stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated.
   *
   * @schema CachePolicySpecForProvider#defaultTtl
   */
  readonly defaultTtl?: number;

  /**
   * The maximum amount of time, in seconds, that objects stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated.
   *
   * @schema CachePolicySpecForProvider#maxTtl
   */
  readonly maxTtl?: number;

  /**
   * The minimum amount of time, in seconds, that you want objects to stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated.
   *
   * @schema CachePolicySpecForProvider#minTtl
   */
  readonly minTtl?: number;

  /**
   * A unique name to identify the cache policy.
   *
   * @schema CachePolicySpecForProvider#name
   */
  readonly name?: string;

  /**
   * The HTTP headers, cookies, and URL query strings to include in the cache key. See Parameters In Cache Key And Forwarded To Origin for more information.
   *
   * @schema CachePolicySpecForProvider#parametersInCacheKeyAndForwardedToOrigin
   */
  readonly parametersInCacheKeyAndForwardedToOrigin?: CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOrigin[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CachePolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'CachePolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecForProvider(obj: CachePolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'defaultTtl': obj.defaultTtl,
    'maxTtl': obj.maxTtl,
    'minTtl': obj.minTtl,
    'name': obj.name,
    'parametersInCacheKeyAndForwardedToOrigin': obj.parametersInCacheKeyAndForwardedToOrigin?.map(y => toJson_CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOrigin(y)),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CachePolicySpecInitProvider
 */
export interface CachePolicySpecInitProvider {
  /**
   * A comment to describe the cache policy.
   *
   * @schema CachePolicySpecInitProvider#comment
   */
  readonly comment?: string;

  /**
   * The default amount of time, in seconds, that you want objects to stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated.
   *
   * @schema CachePolicySpecInitProvider#defaultTtl
   */
  readonly defaultTtl?: number;

  /**
   * The maximum amount of time, in seconds, that objects stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated.
   *
   * @schema CachePolicySpecInitProvider#maxTtl
   */
  readonly maxTtl?: number;

  /**
   * The minimum amount of time, in seconds, that you want objects to stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated.
   *
   * @schema CachePolicySpecInitProvider#minTtl
   */
  readonly minTtl?: number;

  /**
   * A unique name to identify the cache policy.
   *
   * @schema CachePolicySpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The HTTP headers, cookies, and URL query strings to include in the cache key. See Parameters In Cache Key And Forwarded To Origin for more information.
   *
   * @schema CachePolicySpecInitProvider#parametersInCacheKeyAndForwardedToOrigin
   */
  readonly parametersInCacheKeyAndForwardedToOrigin?: CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOrigin[];

}

/**
 * Converts an object of type 'CachePolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecInitProvider(obj: CachePolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'defaultTtl': obj.defaultTtl,
    'maxTtl': obj.maxTtl,
    'minTtl': obj.minTtl,
    'name': obj.name,
    'parametersInCacheKeyAndForwardedToOrigin': obj.parametersInCacheKeyAndForwardedToOrigin?.map(y => toJson_CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOrigin(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CachePolicySpecManagementPolicies
 */
export enum CachePolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CachePolicySpecProviderConfigRef
 */
export interface CachePolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CachePolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CachePolicySpecProviderConfigRef#policy
   */
  readonly policy?: CachePolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CachePolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecProviderConfigRef(obj: CachePolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CachePolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CachePolicySpecPublishConnectionDetailsTo
 */
export interface CachePolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CachePolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CachePolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CachePolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CachePolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CachePolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CachePolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecPublishConnectionDetailsTo(obj: CachePolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CachePolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CachePolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CachePolicySpecWriteConnectionSecretToRef
 */
export interface CachePolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CachePolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CachePolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CachePolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecWriteConnectionSecretToRef(obj: CachePolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOrigin
 */
export interface CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOrigin {
  /**
   * Object that determines whether any cookies in viewer requests (and if so, which cookies) are included in the cache key and automatically included in requests that CloudFront sends to the origin. See Cookies Config for more information.
   *
   * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOrigin#cookiesConfig
   */
  readonly cookiesConfig?: CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig[];

  /**
   * A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin.
   *
   * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOrigin#enableAcceptEncodingBrotli
   */
  readonly enableAcceptEncodingBrotli?: boolean;

  /**
   * A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin.
   *
   * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOrigin#enableAcceptEncodingGzip
   */
  readonly enableAcceptEncodingGzip?: boolean;

  /**
   * Object that determines whether any HTTP headers (and if so, which headers) are included in the cache key and automatically included in requests that CloudFront sends to the origin. See Headers Config for more information.
   *
   * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOrigin#headersConfig
   */
  readonly headersConfig?: CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig[];

  /**
   * Object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in the cache key and automatically included in requests that CloudFront sends to the origin. See Query String Config for more information.
   *
   * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOrigin#queryStringsConfig
   */
  readonly queryStringsConfig?: CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig[];

}

/**
 * Converts an object of type 'CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOrigin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOrigin(obj: CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOrigin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookiesConfig': obj.cookiesConfig?.map(y => toJson_CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig(y)),
    'enableAcceptEncodingBrotli': obj.enableAcceptEncodingBrotli,
    'enableAcceptEncodingGzip': obj.enableAcceptEncodingGzip,
    'headersConfig': obj.headersConfig?.map(y => toJson_CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig(y)),
    'queryStringsConfig': obj.queryStringsConfig?.map(y => toJson_CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOrigin
 */
export interface CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOrigin {
  /**
   * Object that determines whether any cookies in viewer requests (and if so, which cookies) are included in the cache key and automatically included in requests that CloudFront sends to the origin. See Cookies Config for more information.
   *
   * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOrigin#cookiesConfig
   */
  readonly cookiesConfig?: CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig[];

  /**
   * A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin.
   *
   * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOrigin#enableAcceptEncodingBrotli
   */
  readonly enableAcceptEncodingBrotli?: boolean;

  /**
   * A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin.
   *
   * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOrigin#enableAcceptEncodingGzip
   */
  readonly enableAcceptEncodingGzip?: boolean;

  /**
   * Object that determines whether any HTTP headers (and if so, which headers) are included in the cache key and automatically included in requests that CloudFront sends to the origin. See Headers Config for more information.
   *
   * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOrigin#headersConfig
   */
  readonly headersConfig?: CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig[];

  /**
   * Object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in the cache key and automatically included in requests that CloudFront sends to the origin. See Query String Config for more information.
   *
   * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOrigin#queryStringsConfig
   */
  readonly queryStringsConfig?: CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig[];

}

/**
 * Converts an object of type 'CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOrigin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOrigin(obj: CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOrigin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookiesConfig': obj.cookiesConfig?.map(y => toJson_CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig(y)),
    'enableAcceptEncodingBrotli': obj.enableAcceptEncodingBrotli,
    'enableAcceptEncodingGzip': obj.enableAcceptEncodingGzip,
    'headersConfig': obj.headersConfig?.map(y => toJson_CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig(y)),
    'queryStringsConfig': obj.queryStringsConfig?.map(y => toJson_CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CachePolicySpecProviderConfigRefPolicy
 */
export interface CachePolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CachePolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CachePolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CachePolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CachePolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CachePolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecProviderConfigRefPolicy(obj: CachePolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CachePolicySpecPublishConnectionDetailsToConfigRef
 */
export interface CachePolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CachePolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CachePolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CachePolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CachePolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecPublishConnectionDetailsToConfigRef(obj: CachePolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CachePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CachePolicySpecPublishConnectionDetailsToMetadata
 */
export interface CachePolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CachePolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CachePolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CachePolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CachePolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecPublishConnectionDetailsToMetadata(obj: CachePolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig
 */
export interface CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig {
  /**
   * Determines whether any cookies in viewer requests are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are none, whitelist, allExcept, all.
   *
   * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig#cookieBehavior
   */
  readonly cookieBehavior?: string;

  /**
   * Object that contains a list of cookie names. See Items for more information.
   *
   * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig#cookies
   */
  readonly cookies?: CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies[];

}

/**
 * Converts an object of type 'CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig(obj: CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookieBehavior': obj.cookieBehavior,
    'cookies': obj.cookies?.map(y => toJson_CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig
 */
export interface CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig {
  /**
   * Determines whether any HTTP headers are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are none, whitelist.
   *
   * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig#headerBehavior
   */
  readonly headerBehavior?: string;

  /**
   * Object that contains a list of header names. See Items for more information.
   *
   * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig#headers
   */
  readonly headers?: CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders[];

}

/**
 * Converts an object of type 'CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig(obj: CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerBehavior': obj.headerBehavior,
    'headers': obj.headers?.map(y => toJson_CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig
 */
export interface CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig {
  /**
   * Determines whether any URL query strings in viewer requests are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are none, whitelist, allExcept, all.
   *
   * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig#queryStringBehavior
   */
  readonly queryStringBehavior?: string;

  /**
   * Object that contains a list of query string names. See Items for more information.
   *
   * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig#queryStrings
   */
  readonly queryStrings?: CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings[];

}

/**
 * Converts an object of type 'CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig(obj: CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'queryStringBehavior': obj.queryStringBehavior,
    'queryStrings': obj.queryStrings?.map(y => toJson_CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig
 */
export interface CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig {
  /**
   * Determines whether any cookies in viewer requests are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are none, whitelist, allExcept, all.
   *
   * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig#cookieBehavior
   */
  readonly cookieBehavior?: string;

  /**
   * Object that contains a list of cookie names. See Items for more information.
   *
   * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig#cookies
   */
  readonly cookies?: CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies[];

}

/**
 * Converts an object of type 'CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig(obj: CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginCookiesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookieBehavior': obj.cookieBehavior,
    'cookies': obj.cookies?.map(y => toJson_CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig
 */
export interface CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig {
  /**
   * Determines whether any HTTP headers are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are none, whitelist.
   *
   * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig#headerBehavior
   */
  readonly headerBehavior?: string;

  /**
   * Object that contains a list of header names. See Items for more information.
   *
   * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig#headers
   */
  readonly headers?: CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders[];

}

/**
 * Converts an object of type 'CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig(obj: CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginHeadersConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerBehavior': obj.headerBehavior,
    'headers': obj.headers?.map(y => toJson_CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig
 */
export interface CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig {
  /**
   * Determines whether any URL query strings in viewer requests are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are none, whitelist, allExcept, all.
   *
   * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig#queryStringBehavior
   */
  readonly queryStringBehavior?: string;

  /**
   * Object that contains a list of query string names. See Items for more information.
   *
   * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig#queryStrings
   */
  readonly queryStrings?: CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings[];

}

/**
 * Converts an object of type 'CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig(obj: CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'queryStringBehavior': obj.queryStringBehavior,
    'queryStrings': obj.queryStrings?.map(y => toJson_CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CachePolicySpecProviderConfigRefPolicyResolution
 */
export enum CachePolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CachePolicySpecProviderConfigRefPolicyResolve
 */
export enum CachePolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CachePolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CachePolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CachePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CachePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CachePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CachePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CachePolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: CachePolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies
 */
export interface CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies {
  /**
   * A list of item names (cookies, headers, or query strings).
   *
   * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies(obj: CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders
 */
export interface CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders {
  /**
   * A list of item names (cookies, headers, or query strings).
   *
   * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders(obj: CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings
 */
export interface CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings {
  /**
   * A list of item names (cookies, headers, or query strings).
   *
   * @schema CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings(obj: CachePolicySpecForProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies
 */
export interface CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies {
  /**
   * A list of item names (cookies, headers, or query strings).
   *
   * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies(obj: CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders
 */
export interface CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders {
  /**
   * A list of item names (cookies, headers, or query strings).
   *
   * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders(obj: CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings
 */
export interface CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings {
  /**
   * A list of item names (cookies, headers, or query strings).
   *
   * @schema CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings(obj: CachePolicySpecInitProviderParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CachePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CachePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CachePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CachePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Distribution is the Schema for the Distributions API. Provides a CloudFront web distribution resource.
 *
 * @schema Distribution
 */
export class Distribution extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Distribution"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudfront.aws.upbound.io/v1beta1',
    kind: 'Distribution',
  }

  /**
   * Renders a Kubernetes manifest for "Distribution".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DistributionProps): any {
    return {
      ...Distribution.GVK,
      ...toJson_DistributionProps(props),
    };
  }

  /**
   * Defines a "Distribution" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DistributionProps) {
    super(scope, id, {
      ...Distribution.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Distribution.GVK,
      ...toJson_DistributionProps(resolved),
    };
  }
}

/**
 * Distribution is the Schema for the Distributions API. Provides a CloudFront web distribution resource.
 *
 * @schema Distribution
 */
export interface DistributionProps {
  /**
   * @schema Distribution#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DistributionSpec defines the desired state of Distribution
   *
   * @schema Distribution#spec
   */
  readonly spec: DistributionSpec;

}

/**
 * Converts an object of type 'DistributionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionProps(obj: DistributionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DistributionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DistributionSpec defines the desired state of Distribution
 *
 * @schema DistributionSpec
 */
export interface DistributionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DistributionSpec#deletionPolicy
   */
  readonly deletionPolicy?: DistributionSpecDeletionPolicy;

  /**
   * @schema DistributionSpec#forProvider
   */
  readonly forProvider: DistributionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DistributionSpec#initProvider
   */
  readonly initProvider?: DistributionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DistributionSpec#managementPolicies
   */
  readonly managementPolicies?: DistributionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DistributionSpec#providerConfigRef
   */
  readonly providerConfigRef?: DistributionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DistributionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DistributionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DistributionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DistributionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DistributionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpec(obj: DistributionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DistributionSpecForProvider(obj.forProvider),
    'initProvider': toJson_DistributionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DistributionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DistributionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DistributionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DistributionSpecDeletionPolicy
 */
export enum DistributionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DistributionSpecForProvider
 */
export interface DistributionSpecForProvider {
  /**
   * Extra CNAMEs (alternate domain names), if any, for this distribution.
   *
   * @schema DistributionSpecForProvider#aliases
   */
  readonly aliases?: string[];

  /**
   * Any comments you want to include about the distribution.
   *
   * @schema DistributionSpecForProvider#comment
   */
  readonly comment?: string;

  /**
   * One or more custom error response elements (multiples allowed).
   *
   * @schema DistributionSpecForProvider#customErrorResponse
   */
  readonly customErrorResponse?: DistributionSpecForProviderCustomErrorResponse[];

  /**
   * Default cache behavior for this distribution (maximum one). Requires either cache_policy_id (preferred) or forwarded_values (deprecated) be set.
   *
   * @schema DistributionSpecForProvider#defaultCacheBehavior
   */
  readonly defaultCacheBehavior?: DistributionSpecForProviderDefaultCacheBehavior[];

  /**
   * Object that you want CloudFront to return (for example, index.html) when an end user requests the root URL.
   *
   * @schema DistributionSpecForProvider#defaultRootObject
   */
  readonly defaultRootObject?: string;

  /**
   * Whether the distribution is enabled to accept end user requests for content.
   *
   * @schema DistributionSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Maximum HTTP version to support on the distribution. Allowed values are http1.1, http2, http2and3 and http3. The default is http2.
   *
   * @schema DistributionSpecForProvider#httpVersion
   */
  readonly httpVersion?: string;

  /**
   * Whether the IPv6 is enabled for the distribution.
   *
   * @schema DistributionSpecForProvider#isIpv6Enabled
   */
  readonly isIpv6Enabled?: boolean;

  /**
   * The logging configuration that controls how logs are written to your distribution (maximum one).
   *
   * @schema DistributionSpecForProvider#loggingConfig
   */
  readonly loggingConfig?: DistributionSpecForProviderLoggingConfig[];

  /**
   * Ordered list of cache behaviors resource for this distribution. List from top to bottom in order of precedence. The topmost cache behavior will have precedence 0.
   *
   * @schema DistributionSpecForProvider#orderedCacheBehavior
   */
  readonly orderedCacheBehavior?: DistributionSpecForProviderOrderedCacheBehavior[];

  /**
   * One or more origins for this distribution (multiples allowed).
   *
   * @schema DistributionSpecForProvider#origin
   */
  readonly origin?: DistributionSpecForProviderOrigin[];

  /**
   * One or more origin_group for this distribution (multiples allowed).
   *
   * @schema DistributionSpecForProvider#originGroup
   */
  readonly originGroup?: DistributionSpecForProviderOriginGroup[];

  /**
   * Price class for this distribution. One of PriceClass_All, PriceClass_200, PriceClass_100.
   *
   * @schema DistributionSpecForProvider#priceClass
   */
  readonly priceClass?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DistributionSpecForProvider#region
   */
  readonly region: string;

  /**
   * The restriction configuration for this distribution (maximum one).
   *
   * @schema DistributionSpecForProvider#restrictions
   */
  readonly restrictions?: DistributionSpecForProviderRestrictions[];

  /**
   * If this is set, the distribution needs to be deleted manually afterwards. Default: false.
   *
   * @schema DistributionSpecForProvider#retainOnDelete
   */
  readonly retainOnDelete?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema DistributionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The SSL configuration for this distribution (maximum one).
   *
   * @schema DistributionSpecForProvider#viewerCertificate
   */
  readonly viewerCertificate?: DistributionSpecForProviderViewerCertificate[];

  /**
   * If enabled, the resource will wait for the distribution status to change from InProgress to Deployed. Setting this tofalse will skip the process. Default: true.
   *
   * @schema DistributionSpecForProvider#waitForDeployment
   */
  readonly waitForDeployment?: boolean;

  /**
   * Unique identifier that specifies the AWS WAF web ACL, if any, to associate with this distribution. To specify a web ACL created using the latest version of AWS WAF (WAFv2), use the ACL ARN, for example aws_wafv2_web_acl.example.arn. To specify a web ACL created using AWS WAF Classic, use the ACL ID, for example aws_waf_web_acl.example.id. The WAF Web ACL must exist in the WAF Global (CloudFront) region and the credentials configuring this argument must have waf:GetWebACL permissions assigned.
   *
   * @schema DistributionSpecForProvider#webAclId
   */
  readonly webAclId?: string;

}

/**
 * Converts an object of type 'DistributionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProvider(obj: DistributionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aliases': obj.aliases?.map(y => y),
    'comment': obj.comment,
    'customErrorResponse': obj.customErrorResponse?.map(y => toJson_DistributionSpecForProviderCustomErrorResponse(y)),
    'defaultCacheBehavior': obj.defaultCacheBehavior?.map(y => toJson_DistributionSpecForProviderDefaultCacheBehavior(y)),
    'defaultRootObject': obj.defaultRootObject,
    'enabled': obj.enabled,
    'httpVersion': obj.httpVersion,
    'isIpv6Enabled': obj.isIpv6Enabled,
    'loggingConfig': obj.loggingConfig?.map(y => toJson_DistributionSpecForProviderLoggingConfig(y)),
    'orderedCacheBehavior': obj.orderedCacheBehavior?.map(y => toJson_DistributionSpecForProviderOrderedCacheBehavior(y)),
    'origin': obj.origin?.map(y => toJson_DistributionSpecForProviderOrigin(y)),
    'originGroup': obj.originGroup?.map(y => toJson_DistributionSpecForProviderOriginGroup(y)),
    'priceClass': obj.priceClass,
    'region': obj.region,
    'restrictions': obj.restrictions?.map(y => toJson_DistributionSpecForProviderRestrictions(y)),
    'retainOnDelete': obj.retainOnDelete,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'viewerCertificate': obj.viewerCertificate?.map(y => toJson_DistributionSpecForProviderViewerCertificate(y)),
    'waitForDeployment': obj.waitForDeployment,
    'webAclId': obj.webAclId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DistributionSpecInitProvider
 */
export interface DistributionSpecInitProvider {
  /**
   * Extra CNAMEs (alternate domain names), if any, for this distribution.
   *
   * @schema DistributionSpecInitProvider#aliases
   */
  readonly aliases?: string[];

  /**
   * Any comments you want to include about the distribution.
   *
   * @schema DistributionSpecInitProvider#comment
   */
  readonly comment?: string;

  /**
   * One or more custom error response elements (multiples allowed).
   *
   * @schema DistributionSpecInitProvider#customErrorResponse
   */
  readonly customErrorResponse?: DistributionSpecInitProviderCustomErrorResponse[];

  /**
   * Default cache behavior for this distribution (maximum one). Requires either cache_policy_id (preferred) or forwarded_values (deprecated) be set.
   *
   * @schema DistributionSpecInitProvider#defaultCacheBehavior
   */
  readonly defaultCacheBehavior?: DistributionSpecInitProviderDefaultCacheBehavior[];

  /**
   * Object that you want CloudFront to return (for example, index.html) when an end user requests the root URL.
   *
   * @schema DistributionSpecInitProvider#defaultRootObject
   */
  readonly defaultRootObject?: string;

  /**
   * Whether the distribution is enabled to accept end user requests for content.
   *
   * @schema DistributionSpecInitProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Maximum HTTP version to support on the distribution. Allowed values are http1.1, http2, http2and3 and http3. The default is http2.
   *
   * @schema DistributionSpecInitProvider#httpVersion
   */
  readonly httpVersion?: string;

  /**
   * Whether the IPv6 is enabled for the distribution.
   *
   * @schema DistributionSpecInitProvider#isIpv6Enabled
   */
  readonly isIpv6Enabled?: boolean;

  /**
   * The logging configuration that controls how logs are written to your distribution (maximum one).
   *
   * @schema DistributionSpecInitProvider#loggingConfig
   */
  readonly loggingConfig?: DistributionSpecInitProviderLoggingConfig[];

  /**
   * Ordered list of cache behaviors resource for this distribution. List from top to bottom in order of precedence. The topmost cache behavior will have precedence 0.
   *
   * @schema DistributionSpecInitProvider#orderedCacheBehavior
   */
  readonly orderedCacheBehavior?: DistributionSpecInitProviderOrderedCacheBehavior[];

  /**
   * One or more origins for this distribution (multiples allowed).
   *
   * @schema DistributionSpecInitProvider#origin
   */
  readonly origin?: DistributionSpecInitProviderOrigin[];

  /**
   * One or more origin_group for this distribution (multiples allowed).
   *
   * @schema DistributionSpecInitProvider#originGroup
   */
  readonly originGroup?: DistributionSpecInitProviderOriginGroup[];

  /**
   * Price class for this distribution. One of PriceClass_All, PriceClass_200, PriceClass_100.
   *
   * @schema DistributionSpecInitProvider#priceClass
   */
  readonly priceClass?: string;

  /**
   * The restriction configuration for this distribution (maximum one).
   *
   * @schema DistributionSpecInitProvider#restrictions
   */
  readonly restrictions?: DistributionSpecInitProviderRestrictions[];

  /**
   * If this is set, the distribution needs to be deleted manually afterwards. Default: false.
   *
   * @schema DistributionSpecInitProvider#retainOnDelete
   */
  readonly retainOnDelete?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema DistributionSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The SSL configuration for this distribution (maximum one).
   *
   * @schema DistributionSpecInitProvider#viewerCertificate
   */
  readonly viewerCertificate?: DistributionSpecInitProviderViewerCertificate[];

  /**
   * If enabled, the resource will wait for the distribution status to change from InProgress to Deployed. Setting this tofalse will skip the process. Default: true.
   *
   * @schema DistributionSpecInitProvider#waitForDeployment
   */
  readonly waitForDeployment?: boolean;

  /**
   * Unique identifier that specifies the AWS WAF web ACL, if any, to associate with this distribution. To specify a web ACL created using the latest version of AWS WAF (WAFv2), use the ACL ARN, for example aws_wafv2_web_acl.example.arn. To specify a web ACL created using AWS WAF Classic, use the ACL ID, for example aws_waf_web_acl.example.id. The WAF Web ACL must exist in the WAF Global (CloudFront) region and the credentials configuring this argument must have waf:GetWebACL permissions assigned.
   *
   * @schema DistributionSpecInitProvider#webAclId
   */
  readonly webAclId?: string;

}

/**
 * Converts an object of type 'DistributionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProvider(obj: DistributionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aliases': obj.aliases?.map(y => y),
    'comment': obj.comment,
    'customErrorResponse': obj.customErrorResponse?.map(y => toJson_DistributionSpecInitProviderCustomErrorResponse(y)),
    'defaultCacheBehavior': obj.defaultCacheBehavior?.map(y => toJson_DistributionSpecInitProviderDefaultCacheBehavior(y)),
    'defaultRootObject': obj.defaultRootObject,
    'enabled': obj.enabled,
    'httpVersion': obj.httpVersion,
    'isIpv6Enabled': obj.isIpv6Enabled,
    'loggingConfig': obj.loggingConfig?.map(y => toJson_DistributionSpecInitProviderLoggingConfig(y)),
    'orderedCacheBehavior': obj.orderedCacheBehavior?.map(y => toJson_DistributionSpecInitProviderOrderedCacheBehavior(y)),
    'origin': obj.origin?.map(y => toJson_DistributionSpecInitProviderOrigin(y)),
    'originGroup': obj.originGroup?.map(y => toJson_DistributionSpecInitProviderOriginGroup(y)),
    'priceClass': obj.priceClass,
    'restrictions': obj.restrictions?.map(y => toJson_DistributionSpecInitProviderRestrictions(y)),
    'retainOnDelete': obj.retainOnDelete,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'viewerCertificate': obj.viewerCertificate?.map(y => toJson_DistributionSpecInitProviderViewerCertificate(y)),
    'waitForDeployment': obj.waitForDeployment,
    'webAclId': obj.webAclId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DistributionSpecManagementPolicies
 */
export enum DistributionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DistributionSpecProviderConfigRef
 */
export interface DistributionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DistributionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DistributionSpecProviderConfigRef#policy
   */
  readonly policy?: DistributionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DistributionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecProviderConfigRef(obj: DistributionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DistributionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DistributionSpecPublishConnectionDetailsTo
 */
export interface DistributionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DistributionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DistributionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DistributionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DistributionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DistributionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DistributionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecPublishConnectionDetailsTo(obj: DistributionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DistributionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DistributionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DistributionSpecWriteConnectionSecretToRef
 */
export interface DistributionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DistributionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DistributionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DistributionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecWriteConnectionSecretToRef(obj: DistributionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderCustomErrorResponse
 */
export interface DistributionSpecForProviderCustomErrorResponse {
  /**
   * Minimum amount of time you want HTTP error codes to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated.
   *
   * @schema DistributionSpecForProviderCustomErrorResponse#errorCachingMinTtl
   */
  readonly errorCachingMinTtl?: number;

  /**
   * 4xx or 5xx HTTP status code that you want to customize.
   *
   * @schema DistributionSpecForProviderCustomErrorResponse#errorCode
   */
  readonly errorCode?: number;

  /**
   * HTTP status code that you want CloudFront to return with the custom error page to the viewer.
   *
   * @schema DistributionSpecForProviderCustomErrorResponse#responseCode
   */
  readonly responseCode?: number;

  /**
   * Path of the custom error page (for example, /custom_404.html).
   *
   * @schema DistributionSpecForProviderCustomErrorResponse#responsePagePath
   */
  readonly responsePagePath?: string;

}

/**
 * Converts an object of type 'DistributionSpecForProviderCustomErrorResponse' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderCustomErrorResponse(obj: DistributionSpecForProviderCustomErrorResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'errorCachingMinTtl': obj.errorCachingMinTtl,
    'errorCode': obj.errorCode,
    'responseCode': obj.responseCode,
    'responsePagePath': obj.responsePagePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderDefaultCacheBehavior
 */
export interface DistributionSpecForProviderDefaultCacheBehavior {
  /**
   * Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#allowedMethods
   */
  readonly allowedMethods?: string[];

  /**
   * Unique identifier of the cache policy that is attached to the cache behavior. If configuring the default_cache_behavior either cache_policy_id or forwarded_values must be set.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#cachePolicyId
   */
  readonly cachePolicyId?: string;

  /**
   * Controls whether CloudFront caches the response to requests using the specified HTTP methods.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#cachedMethods
   */
  readonly cachedMethods?: string[];

  /**
   * Whether you want CloudFront to automatically compress content for web requests that include Accept-Encoding: gzip in the request header (default: false).
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#compress
   */
  readonly compress?: boolean;

  /**
   * Default amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request in the absence of an Cache-Control max-age or Expires header.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#defaultTtl
   */
  readonly defaultTtl?: number;

  /**
   * Field level encryption configuration ID.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#fieldLevelEncryptionId
   */
  readonly fieldLevelEncryptionId?: string;

  /**
   * The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#forwardedValues
   */
  readonly forwardedValues?: DistributionSpecForProviderDefaultCacheBehaviorForwardedValues[];

  /**
   * A config block that triggers a cloudfront function with specific actions (maximum 2).
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#functionAssociation
   */
  readonly functionAssociation?: DistributionSpecForProviderDefaultCacheBehaviorFunctionAssociation[];

  /**
   * A config block that triggers a lambda function with specific actions (maximum 4).
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#lambdaFunctionAssociation
   */
  readonly lambdaFunctionAssociation?: DistributionSpecForProviderDefaultCacheBehaviorLambdaFunctionAssociation[];

  /**
   * Maximum amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request to your origin to determine whether the object has been updated. Only effective in the presence of Cache-Control max-age, Cache-Control s-maxage, and Expires headers.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#maxTtl
   */
  readonly maxTtl?: number;

  /**
   * Minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. Defaults to 0 seconds.
   *
   * @default 0 seconds.
   * @schema DistributionSpecForProviderDefaultCacheBehavior#minTtl
   */
  readonly minTtl?: number;

  /**
   * Unique identifier of the origin request policy that is attached to the behavior.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#originRequestPolicyId
   */
  readonly originRequestPolicyId?: string;

  /**
   * ARN of the real-time log configuration that is attached to this cache behavior.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#realtimeLogConfigArn
   */
  readonly realtimeLogConfigArn?: string;

  /**
   * Identifier for a response headers policy.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#responseHeadersPolicyId
   */
  readonly responseHeadersPolicyId?: string;

  /**
   * Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#smoothStreaming
   */
  readonly smoothStreaming?: boolean;

  /**
   * Value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#targetOriginId
   */
  readonly targetOriginId?: string;

  /**
   * List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#trustedKeyGroups
   */
  readonly trustedKeyGroups?: string[];

  /**
   * List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#trustedSigners
   */
  readonly trustedSigners?: string[];

  /**
   * Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. One of allow-all, https-only, or redirect-to-https.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehavior#viewerProtocolPolicy
   */
  readonly viewerProtocolPolicy?: string;

}

/**
 * Converts an object of type 'DistributionSpecForProviderDefaultCacheBehavior' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderDefaultCacheBehavior(obj: DistributionSpecForProviderDefaultCacheBehavior | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedMethods': obj.allowedMethods?.map(y => y),
    'cachePolicyId': obj.cachePolicyId,
    'cachedMethods': obj.cachedMethods?.map(y => y),
    'compress': obj.compress,
    'defaultTtl': obj.defaultTtl,
    'fieldLevelEncryptionId': obj.fieldLevelEncryptionId,
    'forwardedValues': obj.forwardedValues?.map(y => toJson_DistributionSpecForProviderDefaultCacheBehaviorForwardedValues(y)),
    'functionAssociation': obj.functionAssociation?.map(y => toJson_DistributionSpecForProviderDefaultCacheBehaviorFunctionAssociation(y)),
    'lambdaFunctionAssociation': obj.lambdaFunctionAssociation?.map(y => toJson_DistributionSpecForProviderDefaultCacheBehaviorLambdaFunctionAssociation(y)),
    'maxTtl': obj.maxTtl,
    'minTtl': obj.minTtl,
    'originRequestPolicyId': obj.originRequestPolicyId,
    'realtimeLogConfigArn': obj.realtimeLogConfigArn,
    'responseHeadersPolicyId': obj.responseHeadersPolicyId,
    'smoothStreaming': obj.smoothStreaming,
    'targetOriginId': obj.targetOriginId,
    'trustedKeyGroups': obj.trustedKeyGroups?.map(y => y),
    'trustedSigners': obj.trustedSigners?.map(y => y),
    'viewerProtocolPolicy': obj.viewerProtocolPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderLoggingConfig
 */
export interface DistributionSpecForProviderLoggingConfig {
  /**
   * Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com.
   *
   * @schema DistributionSpecForProviderLoggingConfig#bucket
   */
  readonly bucket?: string;

  /**
   * Whether to include cookies in access logs (default: false).
   *
   * @schema DistributionSpecForProviderLoggingConfig#includeCookies
   */
  readonly includeCookies?: boolean;

  /**
   * Prefix to the access log filenames for this distribution, for example, myprefix/.
   *
   * @schema DistributionSpecForProviderLoggingConfig#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'DistributionSpecForProviderLoggingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderLoggingConfig(obj: DistributionSpecForProviderLoggingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'includeCookies': obj.includeCookies,
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderOrderedCacheBehavior
 */
export interface DistributionSpecForProviderOrderedCacheBehavior {
  /**
   * Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#allowedMethods
   */
  readonly allowedMethods?: string[];

  /**
   * Unique identifier of the cache policy that is attached to the cache behavior. If configuring the default_cache_behavior either cache_policy_id or forwarded_values must be set.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#cachePolicyId
   */
  readonly cachePolicyId?: string;

  /**
   * Controls whether CloudFront caches the response to requests using the specified HTTP methods.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#cachedMethods
   */
  readonly cachedMethods?: string[];

  /**
   * Whether you want CloudFront to automatically compress content for web requests that include Accept-Encoding: gzip in the request header (default: false).
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#compress
   */
  readonly compress?: boolean;

  /**
   * Default amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request in the absence of an Cache-Control max-age or Expires header.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#defaultTtl
   */
  readonly defaultTtl?: number;

  /**
   * Field level encryption configuration ID.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#fieldLevelEncryptionId
   */
  readonly fieldLevelEncryptionId?: string;

  /**
   * The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#forwardedValues
   */
  readonly forwardedValues?: DistributionSpecForProviderOrderedCacheBehaviorForwardedValues[];

  /**
   * A config block that triggers a cloudfront function with specific actions (maximum 2).
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#functionAssociation
   */
  readonly functionAssociation?: DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociation[];

  /**
   * A config block that triggers a lambda function with specific actions (maximum 4).
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#lambdaFunctionAssociation
   */
  readonly lambdaFunctionAssociation?: DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociation[];

  /**
   * Maximum amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request to your origin to determine whether the object has been updated. Only effective in the presence of Cache-Control max-age, Cache-Control s-maxage, and Expires headers.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#maxTtl
   */
  readonly maxTtl?: number;

  /**
   * Minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. Defaults to 0 seconds.
   *
   * @default 0 seconds.
   * @schema DistributionSpecForProviderOrderedCacheBehavior#minTtl
   */
  readonly minTtl?: number;

  /**
   * Unique identifier of the origin request policy that is attached to the behavior.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#originRequestPolicyId
   */
  readonly originRequestPolicyId?: string;

  /**
   * Pattern (for example, images/*.jpg) that specifies which requests you want this cache behavior to apply to.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#pathPattern
   */
  readonly pathPattern?: string;

  /**
   * ARN of the real-time log configuration that is attached to this cache behavior.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#realtimeLogConfigArn
   */
  readonly realtimeLogConfigArn?: string;

  /**
   * Identifier for a response headers policy.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#responseHeadersPolicyId
   */
  readonly responseHeadersPolicyId?: string;

  /**
   * Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#smoothStreaming
   */
  readonly smoothStreaming?: boolean;

  /**
   * Value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#targetOriginId
   */
  readonly targetOriginId?: string;

  /**
   * List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#trustedKeyGroups
   */
  readonly trustedKeyGroups?: string[];

  /**
   * List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#trustedSigners
   */
  readonly trustedSigners?: string[];

  /**
   * Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. One of allow-all, https-only, or redirect-to-https.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehavior#viewerProtocolPolicy
   */
  readonly viewerProtocolPolicy?: string;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOrderedCacheBehavior' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOrderedCacheBehavior(obj: DistributionSpecForProviderOrderedCacheBehavior | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedMethods': obj.allowedMethods?.map(y => y),
    'cachePolicyId': obj.cachePolicyId,
    'cachedMethods': obj.cachedMethods?.map(y => y),
    'compress': obj.compress,
    'defaultTtl': obj.defaultTtl,
    'fieldLevelEncryptionId': obj.fieldLevelEncryptionId,
    'forwardedValues': obj.forwardedValues?.map(y => toJson_DistributionSpecForProviderOrderedCacheBehaviorForwardedValues(y)),
    'functionAssociation': obj.functionAssociation?.map(y => toJson_DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociation(y)),
    'lambdaFunctionAssociation': obj.lambdaFunctionAssociation?.map(y => toJson_DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociation(y)),
    'maxTtl': obj.maxTtl,
    'minTtl': obj.minTtl,
    'originRequestPolicyId': obj.originRequestPolicyId,
    'pathPattern': obj.pathPattern,
    'realtimeLogConfigArn': obj.realtimeLogConfigArn,
    'responseHeadersPolicyId': obj.responseHeadersPolicyId,
    'smoothStreaming': obj.smoothStreaming,
    'targetOriginId': obj.targetOriginId,
    'trustedKeyGroups': obj.trustedKeyGroups?.map(y => y),
    'trustedSigners': obj.trustedSigners?.map(y => y),
    'viewerProtocolPolicy': obj.viewerProtocolPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderOrigin
 */
export interface DistributionSpecForProviderOrigin {
  /**
   * Number of times that CloudFront attempts to connect to the origin. Must be between 1-3. Defaults to 3.
   *
   * @default 3.
   * @schema DistributionSpecForProviderOrigin#connectionAttempts
   */
  readonly connectionAttempts?: number;

  /**
   * Number of seconds that CloudFront waits when trying to establish a connection to the origin. Must be between 1-10. Defaults to 10.
   *
   * @default 10.
   * @schema DistributionSpecForProviderOrigin#connectionTimeout
   */
  readonly connectionTimeout?: number;

  /**
   * One or more sub-resources with name and value parameters that specify header data that will be sent to the origin (multiples allowed).
   *
   * @schema DistributionSpecForProviderOrigin#customHeader
   */
  readonly customHeader?: DistributionSpecForProviderOriginCustomHeader[];

  /**
   * The CloudFront custom origin configuration information. If an S3 origin is required, use origin_access_control_id or s3_origin_config instead.
   *
   * @schema DistributionSpecForProviderOrigin#customOriginConfig
   */
  readonly customOriginConfig?: DistributionSpecForProviderOriginCustomOriginConfig[];

  /**
   * DNS domain name of either the S3 bucket, or web site of your custom origin.
   *
   * @schema DistributionSpecForProviderOrigin#domainName
   */
  readonly domainName?: string;

  /**
   * Unique identifier of a CloudFront origin access control for this origin.
   *
   * @schema DistributionSpecForProviderOrigin#originAccessControlId
   */
  readonly originAccessControlId?: string;

  /**
   * Reference to a OriginAccessControl in cloudfront to populate originAccessControlId.
   *
   * @schema DistributionSpecForProviderOrigin#originAccessControlIdRef
   */
  readonly originAccessControlIdRef?: DistributionSpecForProviderOriginOriginAccessControlIdRef;

  /**
   * Selector for a OriginAccessControl in cloudfront to populate originAccessControlId.
   *
   * @schema DistributionSpecForProviderOrigin#originAccessControlIdSelector
   */
  readonly originAccessControlIdSelector?: DistributionSpecForProviderOriginOriginAccessControlIdSelector;

  /**
   * Unique identifier for the origin.
   *
   * @schema DistributionSpecForProviderOrigin#originId
   */
  readonly originId?: string;

  /**
   * Optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin.
   *
   * @schema DistributionSpecForProviderOrigin#originPath
   */
  readonly originPath?: string;

  /**
   * The CloudFront Origin Shield configuration information. Using Origin Shield can help reduce the load on your origin. For more information, see Using Origin Shield in the Amazon CloudFront Developer Guide.
   *
   * @schema DistributionSpecForProviderOrigin#originShield
   */
  readonly originShield?: DistributionSpecForProviderOriginOriginShield[];

  /**
   * The CloudFront S3 origin configuration information. If a custom origin is required, use custom_origin_config instead.
   *
   * @schema DistributionSpecForProviderOrigin#s3OriginConfig
   */
  readonly s3OriginConfig?: DistributionSpecForProviderOriginS3OriginConfig[];

}

/**
 * Converts an object of type 'DistributionSpecForProviderOrigin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOrigin(obj: DistributionSpecForProviderOrigin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionAttempts': obj.connectionAttempts,
    'connectionTimeout': obj.connectionTimeout,
    'customHeader': obj.customHeader?.map(y => toJson_DistributionSpecForProviderOriginCustomHeader(y)),
    'customOriginConfig': obj.customOriginConfig?.map(y => toJson_DistributionSpecForProviderOriginCustomOriginConfig(y)),
    'domainName': obj.domainName,
    'originAccessControlId': obj.originAccessControlId,
    'originAccessControlIdRef': toJson_DistributionSpecForProviderOriginOriginAccessControlIdRef(obj.originAccessControlIdRef),
    'originAccessControlIdSelector': toJson_DistributionSpecForProviderOriginOriginAccessControlIdSelector(obj.originAccessControlIdSelector),
    'originId': obj.originId,
    'originPath': obj.originPath,
    'originShield': obj.originShield?.map(y => toJson_DistributionSpecForProviderOriginOriginShield(y)),
    's3OriginConfig': obj.s3OriginConfig?.map(y => toJson_DistributionSpecForProviderOriginS3OriginConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderOriginGroup
 */
export interface DistributionSpecForProviderOriginGroup {
  /**
   * The failover criteria for when to failover to the secondary origin.
   *
   * @schema DistributionSpecForProviderOriginGroup#failoverCriteria
   */
  readonly failoverCriteria?: DistributionSpecForProviderOriginGroupFailoverCriteria[];

  /**
   * Ordered member configuration blocks assigned to the origin group, where the first member is the primary origin. You must specify two members.
   *
   * @schema DistributionSpecForProviderOriginGroup#member
   */
  readonly member?: DistributionSpecForProviderOriginGroupMember[];

  /**
   * Unique identifier for the origin.
   *
   * @schema DistributionSpecForProviderOriginGroup#originId
   */
  readonly originId?: string;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOriginGroup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOriginGroup(obj: DistributionSpecForProviderOriginGroup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failoverCriteria': obj.failoverCriteria?.map(y => toJson_DistributionSpecForProviderOriginGroupFailoverCriteria(y)),
    'member': obj.member?.map(y => toJson_DistributionSpecForProviderOriginGroupMember(y)),
    'originId': obj.originId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderRestrictions
 */
export interface DistributionSpecForProviderRestrictions {
  /**
   * @schema DistributionSpecForProviderRestrictions#geoRestriction
   */
  readonly geoRestriction?: DistributionSpecForProviderRestrictionsGeoRestriction[];

}

/**
 * Converts an object of type 'DistributionSpecForProviderRestrictions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderRestrictions(obj: DistributionSpecForProviderRestrictions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'geoRestriction': obj.geoRestriction?.map(y => toJson_DistributionSpecForProviderRestrictionsGeoRestriction(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderViewerCertificate
 */
export interface DistributionSpecForProviderViewerCertificate {
  /**
   * ARN of the AWS Certificate Manager certificate that you wish to use with this distribution. Specify this, cloudfront_default_certificate, or iam_certificate_id.  The ACM certificate must be in  US-EAST-1.
   *
   * @schema DistributionSpecForProviderViewerCertificate#acmCertificateArn
   */
  readonly acmCertificateArn?: string;

  /**
   * true if you want viewers to use HTTPS to request your objects and you're using the CloudFront domain name for your distribution. Specify this, acm_certificate_arn, or iam_certificate_id.
   *
   * @schema DistributionSpecForProviderViewerCertificate#cloudfrontDefaultCertificate
   */
  readonly cloudfrontDefaultCertificate?: boolean;

  /**
   * IAM certificate identifier of the custom viewer certificate for this distribution if you are using a custom domain. Specify this, acm_certificate_arn, or cloudfront_default_certificate.
   *
   * @schema DistributionSpecForProviderViewerCertificate#iamCertificateId
   */
  readonly iamCertificateId?: string;

  /**
   * Minimum version of the SSL protocol that you want CloudFront to use for HTTPS connections. Can only be set if cloudfront_default_certificate = false. See all possible values in this table under "Security policy." Some examples include: TLSv1.2_2019 and TLSv1.2_2021. Default: TLSv1. NOTE: If you are using a custom certificate (specified with acm_certificate_arn or iam_certificate_id), and have specified sni-only in ssl_support_method, TLSv1 or later must be specified. If you have specified vip in ssl_support_method, only SSLv3 or TLSv1 can be specified. If you have specified cloudfront_default_certificate, TLSv1 must be specified.
   *
   * @schema DistributionSpecForProviderViewerCertificate#minimumProtocolVersion
   */
  readonly minimumProtocolVersion?: string;

  /**
   * How you want CloudFront to serve HTTPS requests. One of vip or sni-only. Required if you specify acm_certificate_arn or iam_certificate_id. NOTE: vip causes CloudFront to use a dedicated IP address and may incur extra charges.
   *
   * @schema DistributionSpecForProviderViewerCertificate#sslSupportMethod
   */
  readonly sslSupportMethod?: string;

}

/**
 * Converts an object of type 'DistributionSpecForProviderViewerCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderViewerCertificate(obj: DistributionSpecForProviderViewerCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acmCertificateArn': obj.acmCertificateArn,
    'cloudfrontDefaultCertificate': obj.cloudfrontDefaultCertificate,
    'iamCertificateId': obj.iamCertificateId,
    'minimumProtocolVersion': obj.minimumProtocolVersion,
    'sslSupportMethod': obj.sslSupportMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderCustomErrorResponse
 */
export interface DistributionSpecInitProviderCustomErrorResponse {
  /**
   * Minimum amount of time you want HTTP error codes to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated.
   *
   * @schema DistributionSpecInitProviderCustomErrorResponse#errorCachingMinTtl
   */
  readonly errorCachingMinTtl?: number;

  /**
   * 4xx or 5xx HTTP status code that you want to customize.
   *
   * @schema DistributionSpecInitProviderCustomErrorResponse#errorCode
   */
  readonly errorCode?: number;

  /**
   * HTTP status code that you want CloudFront to return with the custom error page to the viewer.
   *
   * @schema DistributionSpecInitProviderCustomErrorResponse#responseCode
   */
  readonly responseCode?: number;

  /**
   * Path of the custom error page (for example, /custom_404.html).
   *
   * @schema DistributionSpecInitProviderCustomErrorResponse#responsePagePath
   */
  readonly responsePagePath?: string;

}

/**
 * Converts an object of type 'DistributionSpecInitProviderCustomErrorResponse' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderCustomErrorResponse(obj: DistributionSpecInitProviderCustomErrorResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'errorCachingMinTtl': obj.errorCachingMinTtl,
    'errorCode': obj.errorCode,
    'responseCode': obj.responseCode,
    'responsePagePath': obj.responsePagePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderDefaultCacheBehavior
 */
export interface DistributionSpecInitProviderDefaultCacheBehavior {
  /**
   * Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#allowedMethods
   */
  readonly allowedMethods?: string[];

  /**
   * Unique identifier of the cache policy that is attached to the cache behavior. If configuring the default_cache_behavior either cache_policy_id or forwarded_values must be set.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#cachePolicyId
   */
  readonly cachePolicyId?: string;

  /**
   * Controls whether CloudFront caches the response to requests using the specified HTTP methods.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#cachedMethods
   */
  readonly cachedMethods?: string[];

  /**
   * Whether you want CloudFront to automatically compress content for web requests that include Accept-Encoding: gzip in the request header (default: false).
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#compress
   */
  readonly compress?: boolean;

  /**
   * Default amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request in the absence of an Cache-Control max-age or Expires header.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#defaultTtl
   */
  readonly defaultTtl?: number;

  /**
   * Field level encryption configuration ID.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#fieldLevelEncryptionId
   */
  readonly fieldLevelEncryptionId?: string;

  /**
   * The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#forwardedValues
   */
  readonly forwardedValues?: DistributionSpecInitProviderDefaultCacheBehaviorForwardedValues[];

  /**
   * A config block that triggers a cloudfront function with specific actions (maximum 2).
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#functionAssociation
   */
  readonly functionAssociation?: DistributionSpecInitProviderDefaultCacheBehaviorFunctionAssociation[];

  /**
   * A config block that triggers a lambda function with specific actions (maximum 4).
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#lambdaFunctionAssociation
   */
  readonly lambdaFunctionAssociation?: DistributionSpecInitProviderDefaultCacheBehaviorLambdaFunctionAssociation[];

  /**
   * Maximum amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request to your origin to determine whether the object has been updated. Only effective in the presence of Cache-Control max-age, Cache-Control s-maxage, and Expires headers.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#maxTtl
   */
  readonly maxTtl?: number;

  /**
   * Minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. Defaults to 0 seconds.
   *
   * @default 0 seconds.
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#minTtl
   */
  readonly minTtl?: number;

  /**
   * Unique identifier of the origin request policy that is attached to the behavior.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#originRequestPolicyId
   */
  readonly originRequestPolicyId?: string;

  /**
   * ARN of the real-time log configuration that is attached to this cache behavior.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#realtimeLogConfigArn
   */
  readonly realtimeLogConfigArn?: string;

  /**
   * Identifier for a response headers policy.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#responseHeadersPolicyId
   */
  readonly responseHeadersPolicyId?: string;

  /**
   * Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#smoothStreaming
   */
  readonly smoothStreaming?: boolean;

  /**
   * Value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#targetOriginId
   */
  readonly targetOriginId?: string;

  /**
   * List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#trustedKeyGroups
   */
  readonly trustedKeyGroups?: string[];

  /**
   * List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#trustedSigners
   */
  readonly trustedSigners?: string[];

  /**
   * Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. One of allow-all, https-only, or redirect-to-https.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehavior#viewerProtocolPolicy
   */
  readonly viewerProtocolPolicy?: string;

}

/**
 * Converts an object of type 'DistributionSpecInitProviderDefaultCacheBehavior' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderDefaultCacheBehavior(obj: DistributionSpecInitProviderDefaultCacheBehavior | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedMethods': obj.allowedMethods?.map(y => y),
    'cachePolicyId': obj.cachePolicyId,
    'cachedMethods': obj.cachedMethods?.map(y => y),
    'compress': obj.compress,
    'defaultTtl': obj.defaultTtl,
    'fieldLevelEncryptionId': obj.fieldLevelEncryptionId,
    'forwardedValues': obj.forwardedValues?.map(y => toJson_DistributionSpecInitProviderDefaultCacheBehaviorForwardedValues(y)),
    'functionAssociation': obj.functionAssociation?.map(y => toJson_DistributionSpecInitProviderDefaultCacheBehaviorFunctionAssociation(y)),
    'lambdaFunctionAssociation': obj.lambdaFunctionAssociation?.map(y => toJson_DistributionSpecInitProviderDefaultCacheBehaviorLambdaFunctionAssociation(y)),
    'maxTtl': obj.maxTtl,
    'minTtl': obj.minTtl,
    'originRequestPolicyId': obj.originRequestPolicyId,
    'realtimeLogConfigArn': obj.realtimeLogConfigArn,
    'responseHeadersPolicyId': obj.responseHeadersPolicyId,
    'smoothStreaming': obj.smoothStreaming,
    'targetOriginId': obj.targetOriginId,
    'trustedKeyGroups': obj.trustedKeyGroups?.map(y => y),
    'trustedSigners': obj.trustedSigners?.map(y => y),
    'viewerProtocolPolicy': obj.viewerProtocolPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderLoggingConfig
 */
export interface DistributionSpecInitProviderLoggingConfig {
  /**
   * Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com.
   *
   * @schema DistributionSpecInitProviderLoggingConfig#bucket
   */
  readonly bucket?: string;

  /**
   * Whether to include cookies in access logs (default: false).
   *
   * @schema DistributionSpecInitProviderLoggingConfig#includeCookies
   */
  readonly includeCookies?: boolean;

  /**
   * Prefix to the access log filenames for this distribution, for example, myprefix/.
   *
   * @schema DistributionSpecInitProviderLoggingConfig#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'DistributionSpecInitProviderLoggingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderLoggingConfig(obj: DistributionSpecInitProviderLoggingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'includeCookies': obj.includeCookies,
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderOrderedCacheBehavior
 */
export interface DistributionSpecInitProviderOrderedCacheBehavior {
  /**
   * Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#allowedMethods
   */
  readonly allowedMethods?: string[];

  /**
   * Unique identifier of the cache policy that is attached to the cache behavior. If configuring the default_cache_behavior either cache_policy_id or forwarded_values must be set.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#cachePolicyId
   */
  readonly cachePolicyId?: string;

  /**
   * Controls whether CloudFront caches the response to requests using the specified HTTP methods.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#cachedMethods
   */
  readonly cachedMethods?: string[];

  /**
   * Whether you want CloudFront to automatically compress content for web requests that include Accept-Encoding: gzip in the request header (default: false).
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#compress
   */
  readonly compress?: boolean;

  /**
   * Default amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request in the absence of an Cache-Control max-age or Expires header.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#defaultTtl
   */
  readonly defaultTtl?: number;

  /**
   * Field level encryption configuration ID.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#fieldLevelEncryptionId
   */
  readonly fieldLevelEncryptionId?: string;

  /**
   * The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one).
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#forwardedValues
   */
  readonly forwardedValues?: DistributionSpecInitProviderOrderedCacheBehaviorForwardedValues[];

  /**
   * A config block that triggers a cloudfront function with specific actions (maximum 2).
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#functionAssociation
   */
  readonly functionAssociation?: DistributionSpecInitProviderOrderedCacheBehaviorFunctionAssociation[];

  /**
   * A config block that triggers a lambda function with specific actions (maximum 4).
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#lambdaFunctionAssociation
   */
  readonly lambdaFunctionAssociation?: DistributionSpecInitProviderOrderedCacheBehaviorLambdaFunctionAssociation[];

  /**
   * Maximum amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request to your origin to determine whether the object has been updated. Only effective in the presence of Cache-Control max-age, Cache-Control s-maxage, and Expires headers.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#maxTtl
   */
  readonly maxTtl?: number;

  /**
   * Minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. Defaults to 0 seconds.
   *
   * @default 0 seconds.
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#minTtl
   */
  readonly minTtl?: number;

  /**
   * Unique identifier of the origin request policy that is attached to the behavior.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#originRequestPolicyId
   */
  readonly originRequestPolicyId?: string;

  /**
   * Pattern (for example, images/*.jpg) that specifies which requests you want this cache behavior to apply to.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#pathPattern
   */
  readonly pathPattern?: string;

  /**
   * ARN of the real-time log configuration that is attached to this cache behavior.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#realtimeLogConfigArn
   */
  readonly realtimeLogConfigArn?: string;

  /**
   * Identifier for a response headers policy.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#responseHeadersPolicyId
   */
  readonly responseHeadersPolicyId?: string;

  /**
   * Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#smoothStreaming
   */
  readonly smoothStreaming?: boolean;

  /**
   * Value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#targetOriginId
   */
  readonly targetOriginId?: string;

  /**
   * List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#trustedKeyGroups
   */
  readonly trustedKeyGroups?: string[];

  /**
   * List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#trustedSigners
   */
  readonly trustedSigners?: string[];

  /**
   * Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. One of allow-all, https-only, or redirect-to-https.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehavior#viewerProtocolPolicy
   */
  readonly viewerProtocolPolicy?: string;

}

/**
 * Converts an object of type 'DistributionSpecInitProviderOrderedCacheBehavior' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderOrderedCacheBehavior(obj: DistributionSpecInitProviderOrderedCacheBehavior | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedMethods': obj.allowedMethods?.map(y => y),
    'cachePolicyId': obj.cachePolicyId,
    'cachedMethods': obj.cachedMethods?.map(y => y),
    'compress': obj.compress,
    'defaultTtl': obj.defaultTtl,
    'fieldLevelEncryptionId': obj.fieldLevelEncryptionId,
    'forwardedValues': obj.forwardedValues?.map(y => toJson_DistributionSpecInitProviderOrderedCacheBehaviorForwardedValues(y)),
    'functionAssociation': obj.functionAssociation?.map(y => toJson_DistributionSpecInitProviderOrderedCacheBehaviorFunctionAssociation(y)),
    'lambdaFunctionAssociation': obj.lambdaFunctionAssociation?.map(y => toJson_DistributionSpecInitProviderOrderedCacheBehaviorLambdaFunctionAssociation(y)),
    'maxTtl': obj.maxTtl,
    'minTtl': obj.minTtl,
    'originRequestPolicyId': obj.originRequestPolicyId,
    'pathPattern': obj.pathPattern,
    'realtimeLogConfigArn': obj.realtimeLogConfigArn,
    'responseHeadersPolicyId': obj.responseHeadersPolicyId,
    'smoothStreaming': obj.smoothStreaming,
    'targetOriginId': obj.targetOriginId,
    'trustedKeyGroups': obj.trustedKeyGroups?.map(y => y),
    'trustedSigners': obj.trustedSigners?.map(y => y),
    'viewerProtocolPolicy': obj.viewerProtocolPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderOrigin
 */
export interface DistributionSpecInitProviderOrigin {
  /**
   * Number of times that CloudFront attempts to connect to the origin. Must be between 1-3. Defaults to 3.
   *
   * @default 3.
   * @schema DistributionSpecInitProviderOrigin#connectionAttempts
   */
  readonly connectionAttempts?: number;

  /**
   * Number of seconds that CloudFront waits when trying to establish a connection to the origin. Must be between 1-10. Defaults to 10.
   *
   * @default 10.
   * @schema DistributionSpecInitProviderOrigin#connectionTimeout
   */
  readonly connectionTimeout?: number;

  /**
   * One or more sub-resources with name and value parameters that specify header data that will be sent to the origin (multiples allowed).
   *
   * @schema DistributionSpecInitProviderOrigin#customHeader
   */
  readonly customHeader?: DistributionSpecInitProviderOriginCustomHeader[];

  /**
   * The CloudFront custom origin configuration information. If an S3 origin is required, use origin_access_control_id or s3_origin_config instead.
   *
   * @schema DistributionSpecInitProviderOrigin#customOriginConfig
   */
  readonly customOriginConfig?: DistributionSpecInitProviderOriginCustomOriginConfig[];

  /**
   * DNS domain name of either the S3 bucket, or web site of your custom origin.
   *
   * @schema DistributionSpecInitProviderOrigin#domainName
   */
  readonly domainName?: string;

  /**
   * Unique identifier for the origin.
   *
   * @schema DistributionSpecInitProviderOrigin#originId
   */
  readonly originId?: string;

  /**
   * Optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin.
   *
   * @schema DistributionSpecInitProviderOrigin#originPath
   */
  readonly originPath?: string;

  /**
   * The CloudFront Origin Shield configuration information. Using Origin Shield can help reduce the load on your origin. For more information, see Using Origin Shield in the Amazon CloudFront Developer Guide.
   *
   * @schema DistributionSpecInitProviderOrigin#originShield
   */
  readonly originShield?: DistributionSpecInitProviderOriginOriginShield[];

  /**
   * The CloudFront S3 origin configuration information. If a custom origin is required, use custom_origin_config instead.
   *
   * @schema DistributionSpecInitProviderOrigin#s3OriginConfig
   */
  readonly s3OriginConfig?: any[];

}

/**
 * Converts an object of type 'DistributionSpecInitProviderOrigin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderOrigin(obj: DistributionSpecInitProviderOrigin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionAttempts': obj.connectionAttempts,
    'connectionTimeout': obj.connectionTimeout,
    'customHeader': obj.customHeader?.map(y => toJson_DistributionSpecInitProviderOriginCustomHeader(y)),
    'customOriginConfig': obj.customOriginConfig?.map(y => toJson_DistributionSpecInitProviderOriginCustomOriginConfig(y)),
    'domainName': obj.domainName,
    'originId': obj.originId,
    'originPath': obj.originPath,
    'originShield': obj.originShield?.map(y => toJson_DistributionSpecInitProviderOriginOriginShield(y)),
    's3OriginConfig': obj.s3OriginConfig?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderOriginGroup
 */
export interface DistributionSpecInitProviderOriginGroup {
  /**
   * The failover criteria for when to failover to the secondary origin.
   *
   * @schema DistributionSpecInitProviderOriginGroup#failoverCriteria
   */
  readonly failoverCriteria?: DistributionSpecInitProviderOriginGroupFailoverCriteria[];

  /**
   * Ordered member configuration blocks assigned to the origin group, where the first member is the primary origin. You must specify two members.
   *
   * @schema DistributionSpecInitProviderOriginGroup#member
   */
  readonly member?: DistributionSpecInitProviderOriginGroupMember[];

  /**
   * Unique identifier for the origin.
   *
   * @schema DistributionSpecInitProviderOriginGroup#originId
   */
  readonly originId?: string;

}

/**
 * Converts an object of type 'DistributionSpecInitProviderOriginGroup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderOriginGroup(obj: DistributionSpecInitProviderOriginGroup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failoverCriteria': obj.failoverCriteria?.map(y => toJson_DistributionSpecInitProviderOriginGroupFailoverCriteria(y)),
    'member': obj.member?.map(y => toJson_DistributionSpecInitProviderOriginGroupMember(y)),
    'originId': obj.originId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderRestrictions
 */
export interface DistributionSpecInitProviderRestrictions {
  /**
   * @schema DistributionSpecInitProviderRestrictions#geoRestriction
   */
  readonly geoRestriction?: DistributionSpecInitProviderRestrictionsGeoRestriction[];

}

/**
 * Converts an object of type 'DistributionSpecInitProviderRestrictions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderRestrictions(obj: DistributionSpecInitProviderRestrictions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'geoRestriction': obj.geoRestriction?.map(y => toJson_DistributionSpecInitProviderRestrictionsGeoRestriction(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderViewerCertificate
 */
export interface DistributionSpecInitProviderViewerCertificate {
  /**
   * ARN of the AWS Certificate Manager certificate that you wish to use with this distribution. Specify this, cloudfront_default_certificate, or iam_certificate_id.  The ACM certificate must be in  US-EAST-1.
   *
   * @schema DistributionSpecInitProviderViewerCertificate#acmCertificateArn
   */
  readonly acmCertificateArn?: string;

  /**
   * true if you want viewers to use HTTPS to request your objects and you're using the CloudFront domain name for your distribution. Specify this, acm_certificate_arn, or iam_certificate_id.
   *
   * @schema DistributionSpecInitProviderViewerCertificate#cloudfrontDefaultCertificate
   */
  readonly cloudfrontDefaultCertificate?: boolean;

  /**
   * IAM certificate identifier of the custom viewer certificate for this distribution if you are using a custom domain. Specify this, acm_certificate_arn, or cloudfront_default_certificate.
   *
   * @schema DistributionSpecInitProviderViewerCertificate#iamCertificateId
   */
  readonly iamCertificateId?: string;

  /**
   * Minimum version of the SSL protocol that you want CloudFront to use for HTTPS connections. Can only be set if cloudfront_default_certificate = false. See all possible values in this table under "Security policy." Some examples include: TLSv1.2_2019 and TLSv1.2_2021. Default: TLSv1. NOTE: If you are using a custom certificate (specified with acm_certificate_arn or iam_certificate_id), and have specified sni-only in ssl_support_method, TLSv1 or later must be specified. If you have specified vip in ssl_support_method, only SSLv3 or TLSv1 can be specified. If you have specified cloudfront_default_certificate, TLSv1 must be specified.
   *
   * @schema DistributionSpecInitProviderViewerCertificate#minimumProtocolVersion
   */
  readonly minimumProtocolVersion?: string;

  /**
   * How you want CloudFront to serve HTTPS requests. One of vip or sni-only. Required if you specify acm_certificate_arn or iam_certificate_id. NOTE: vip causes CloudFront to use a dedicated IP address and may incur extra charges.
   *
   * @schema DistributionSpecInitProviderViewerCertificate#sslSupportMethod
   */
  readonly sslSupportMethod?: string;

}

/**
 * Converts an object of type 'DistributionSpecInitProviderViewerCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderViewerCertificate(obj: DistributionSpecInitProviderViewerCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acmCertificateArn': obj.acmCertificateArn,
    'cloudfrontDefaultCertificate': obj.cloudfrontDefaultCertificate,
    'iamCertificateId': obj.iamCertificateId,
    'minimumProtocolVersion': obj.minimumProtocolVersion,
    'sslSupportMethod': obj.sslSupportMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DistributionSpecProviderConfigRefPolicy
 */
export interface DistributionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DistributionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DistributionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DistributionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DistributionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DistributionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecProviderConfigRefPolicy(obj: DistributionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DistributionSpecPublishConnectionDetailsToConfigRef
 */
export interface DistributionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DistributionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DistributionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DistributionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DistributionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecPublishConnectionDetailsToConfigRef(obj: DistributionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DistributionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DistributionSpecPublishConnectionDetailsToMetadata
 */
export interface DistributionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DistributionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DistributionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DistributionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DistributionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecPublishConnectionDetailsToMetadata(obj: DistributionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderDefaultCacheBehaviorForwardedValues
 */
export interface DistributionSpecForProviderDefaultCacheBehaviorForwardedValues {
  /**
   * The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
   *
   * @schema DistributionSpecForProviderDefaultCacheBehaviorForwardedValues#cookies
   */
  readonly cookies?: DistributionSpecForProviderDefaultCacheBehaviorForwardedValuesCookies[];

  /**
   * Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehaviorForwardedValues#headers
   */
  readonly headers?: string[];

  /**
   * Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehaviorForwardedValues#queryString
   */
  readonly queryString?: boolean;

  /**
   * When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehaviorForwardedValues#queryStringCacheKeys
   */
  readonly queryStringCacheKeys?: string[];

}

/**
 * Converts an object of type 'DistributionSpecForProviderDefaultCacheBehaviorForwardedValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderDefaultCacheBehaviorForwardedValues(obj: DistributionSpecForProviderDefaultCacheBehaviorForwardedValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookies': obj.cookies?.map(y => toJson_DistributionSpecForProviderDefaultCacheBehaviorForwardedValuesCookies(y)),
    'headers': obj.headers?.map(y => y),
    'queryString': obj.queryString,
    'queryStringCacheKeys': obj.queryStringCacheKeys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderDefaultCacheBehaviorFunctionAssociation
 */
export interface DistributionSpecForProviderDefaultCacheBehaviorFunctionAssociation {
  /**
   * Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehaviorFunctionAssociation#eventType
   */
  readonly eventType?: string;

  /**
   * ARN of the CloudFront function.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehaviorFunctionAssociation#functionArn
   */
  readonly functionArn?: string;

}

/**
 * Converts an object of type 'DistributionSpecForProviderDefaultCacheBehaviorFunctionAssociation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderDefaultCacheBehaviorFunctionAssociation(obj: DistributionSpecForProviderDefaultCacheBehaviorFunctionAssociation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventType': obj.eventType,
    'functionArn': obj.functionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderDefaultCacheBehaviorLambdaFunctionAssociation
 */
export interface DistributionSpecForProviderDefaultCacheBehaviorLambdaFunctionAssociation {
  /**
   * Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehaviorLambdaFunctionAssociation#eventType
   */
  readonly eventType?: string;

  /**
   * When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: true, false.
   *
   * @default false. Valid values: true, false.
   * @schema DistributionSpecForProviderDefaultCacheBehaviorLambdaFunctionAssociation#includeBody
   */
  readonly includeBody?: boolean;

  /**
   * ARN of the Lambda function.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehaviorLambdaFunctionAssociation#lambdaArn
   */
  readonly lambdaArn?: string;

}

/**
 * Converts an object of type 'DistributionSpecForProviderDefaultCacheBehaviorLambdaFunctionAssociation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderDefaultCacheBehaviorLambdaFunctionAssociation(obj: DistributionSpecForProviderDefaultCacheBehaviorLambdaFunctionAssociation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventType': obj.eventType,
    'includeBody': obj.includeBody,
    'lambdaArn': obj.lambdaArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderOrderedCacheBehaviorForwardedValues
 */
export interface DistributionSpecForProviderOrderedCacheBehaviorForwardedValues {
  /**
   * The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorForwardedValues#cookies
   */
  readonly cookies?: DistributionSpecForProviderOrderedCacheBehaviorForwardedValuesCookies[];

  /**
   * Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorForwardedValues#headers
   */
  readonly headers?: string[];

  /**
   * Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorForwardedValues#queryString
   */
  readonly queryString?: boolean;

  /**
   * When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorForwardedValues#queryStringCacheKeys
   */
  readonly queryStringCacheKeys?: string[];

}

/**
 * Converts an object of type 'DistributionSpecForProviderOrderedCacheBehaviorForwardedValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOrderedCacheBehaviorForwardedValues(obj: DistributionSpecForProviderOrderedCacheBehaviorForwardedValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookies': obj.cookies?.map(y => toJson_DistributionSpecForProviderOrderedCacheBehaviorForwardedValuesCookies(y)),
    'headers': obj.headers?.map(y => y),
    'queryString': obj.queryString,
    'queryStringCacheKeys': obj.queryStringCacheKeys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociation
 */
export interface DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociation {
  /**
   * Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociation#eventType
   */
  readonly eventType?: string;

  /**
   * ARN of the CloudFront function.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociation#functionArn
   */
  readonly functionArn?: string;

  /**
   * Reference to a Function in cloudfront to populate functionArn.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociation#functionArnRef
   */
  readonly functionArnRef?: DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRef;

  /**
   * Selector for a Function in cloudfront to populate functionArn.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociation#functionArnSelector
   */
  readonly functionArnSelector?: DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelector;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociation(obj: DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventType': obj.eventType,
    'functionArn': obj.functionArn,
    'functionArnRef': toJson_DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRef(obj.functionArnRef),
    'functionArnSelector': toJson_DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelector(obj.functionArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociation
 */
export interface DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociation {
  /**
   * Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociation#eventType
   */
  readonly eventType?: string;

  /**
   * When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: true, false.
   *
   * @default false. Valid values: true, false.
   * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociation#includeBody
   */
  readonly includeBody?: boolean;

  /**
   * ARN of the Lambda function.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociation#lambdaArn
   */
  readonly lambdaArn?: string;

  /**
   * Reference to a Function in lambda to populate lambdaArn.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociation#lambdaArnRef
   */
  readonly lambdaArnRef?: DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRef;

  /**
   * Selector for a Function in lambda to populate lambdaArn.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociation#lambdaArnSelector
   */
  readonly lambdaArnSelector?: DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelector;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociation(obj: DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventType': obj.eventType,
    'includeBody': obj.includeBody,
    'lambdaArn': obj.lambdaArn,
    'lambdaArnRef': toJson_DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRef(obj.lambdaArnRef),
    'lambdaArnSelector': toJson_DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelector(obj.lambdaArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderOriginCustomHeader
 */
export interface DistributionSpecForProviderOriginCustomHeader {
  /**
   * @schema DistributionSpecForProviderOriginCustomHeader#name
   */
  readonly name?: string;

  /**
   * @schema DistributionSpecForProviderOriginCustomHeader#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOriginCustomHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOriginCustomHeader(obj: DistributionSpecForProviderOriginCustomHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderOriginCustomOriginConfig
 */
export interface DistributionSpecForProviderOriginCustomOriginConfig {
  /**
   * HTTP port the custom origin listens on.
   *
   * @schema DistributionSpecForProviderOriginCustomOriginConfig#httpPort
   */
  readonly httpPort?: number;

  /**
   * HTTPS port the custom origin listens on.
   *
   * @schema DistributionSpecForProviderOriginCustomOriginConfig#httpsPort
   */
  readonly httpsPort?: number;

  /**
   * The Custom KeepAlive timeout, in seconds. By default, AWS enforces a limit of 60. But you can request an increase.
   *
   * @schema DistributionSpecForProviderOriginCustomOriginConfig#originKeepaliveTimeout
   */
  readonly originKeepaliveTimeout?: number;

  /**
   * Origin protocol policy to apply to your origin. One of http-only, https-only, or match-viewer.
   *
   * @schema DistributionSpecForProviderOriginCustomOriginConfig#originProtocolPolicy
   */
  readonly originProtocolPolicy?: string;

  /**
   * The Custom Read timeout, in seconds. By default, AWS enforces a limit of 60. But you can request an increase.
   *
   * @schema DistributionSpecForProviderOriginCustomOriginConfig#originReadTimeout
   */
  readonly originReadTimeout?: number;

  /**
   * SSL/TLS protocols that you want CloudFront to use when communicating with your origin over HTTPS. A list of one or more of SSLv3, TLSv1, TLSv1.1, and TLSv1.2.
   *
   * @schema DistributionSpecForProviderOriginCustomOriginConfig#originSslProtocols
   */
  readonly originSslProtocols?: string[];

}

/**
 * Converts an object of type 'DistributionSpecForProviderOriginCustomOriginConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOriginCustomOriginConfig(obj: DistributionSpecForProviderOriginCustomOriginConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpPort': obj.httpPort,
    'httpsPort': obj.httpsPort,
    'originKeepaliveTimeout': obj.originKeepaliveTimeout,
    'originProtocolPolicy': obj.originProtocolPolicy,
    'originReadTimeout': obj.originReadTimeout,
    'originSslProtocols': obj.originSslProtocols?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a OriginAccessControl in cloudfront to populate originAccessControlId.
 *
 * @schema DistributionSpecForProviderOriginOriginAccessControlIdRef
 */
export interface DistributionSpecForProviderOriginOriginAccessControlIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DistributionSpecForProviderOriginOriginAccessControlIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DistributionSpecForProviderOriginOriginAccessControlIdRef#policy
   */
  readonly policy?: DistributionSpecForProviderOriginOriginAccessControlIdRefPolicy;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOriginOriginAccessControlIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOriginOriginAccessControlIdRef(obj: DistributionSpecForProviderOriginOriginAccessControlIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DistributionSpecForProviderOriginOriginAccessControlIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a OriginAccessControl in cloudfront to populate originAccessControlId.
 *
 * @schema DistributionSpecForProviderOriginOriginAccessControlIdSelector
 */
export interface DistributionSpecForProviderOriginOriginAccessControlIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DistributionSpecForProviderOriginOriginAccessControlIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DistributionSpecForProviderOriginOriginAccessControlIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DistributionSpecForProviderOriginOriginAccessControlIdSelector#policy
   */
  readonly policy?: DistributionSpecForProviderOriginOriginAccessControlIdSelectorPolicy;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOriginOriginAccessControlIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOriginOriginAccessControlIdSelector(obj: DistributionSpecForProviderOriginOriginAccessControlIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DistributionSpecForProviderOriginOriginAccessControlIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderOriginOriginShield
 */
export interface DistributionSpecForProviderOriginOriginShield {
  /**
   * Whether the distribution is enabled to accept end user requests for content.
   *
   * @schema DistributionSpecForProviderOriginOriginShield#enabled
   */
  readonly enabled?: boolean;

  /**
   * AWS Region for Origin Shield. To specify a region, use the region code, not the region name. For example, specify the US East (Ohio) region as us-east-2.
   *
   * @schema DistributionSpecForProviderOriginOriginShield#originShieldRegion
   */
  readonly originShieldRegion?: string;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOriginOriginShield' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOriginOriginShield(obj: DistributionSpecForProviderOriginOriginShield | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'originShieldRegion': obj.originShieldRegion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderOriginS3OriginConfig
 */
export interface DistributionSpecForProviderOriginS3OriginConfig {
  /**
   * The CloudFront origin access identity to associate with the origin.
   *
   * @schema DistributionSpecForProviderOriginS3OriginConfig#originAccessIdentity
   */
  readonly originAccessIdentity?: string;

  /**
   * Reference to a OriginAccessIdentity in cloudfront to populate originAccessIdentity.
   *
   * @schema DistributionSpecForProviderOriginS3OriginConfig#originAccessIdentityRef
   */
  readonly originAccessIdentityRef?: DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRef;

  /**
   * Selector for a OriginAccessIdentity in cloudfront to populate originAccessIdentity.
   *
   * @schema DistributionSpecForProviderOriginS3OriginConfig#originAccessIdentitySelector
   */
  readonly originAccessIdentitySelector?: DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelector;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOriginS3OriginConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOriginS3OriginConfig(obj: DistributionSpecForProviderOriginS3OriginConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'originAccessIdentity': obj.originAccessIdentity,
    'originAccessIdentityRef': toJson_DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRef(obj.originAccessIdentityRef),
    'originAccessIdentitySelector': toJson_DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelector(obj.originAccessIdentitySelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderOriginGroupFailoverCriteria
 */
export interface DistributionSpecForProviderOriginGroupFailoverCriteria {
  /**
   * List of HTTP status codes for the origin group.
   *
   * @schema DistributionSpecForProviderOriginGroupFailoverCriteria#statusCodes
   */
  readonly statusCodes?: number[];

}

/**
 * Converts an object of type 'DistributionSpecForProviderOriginGroupFailoverCriteria' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOriginGroupFailoverCriteria(obj: DistributionSpecForProviderOriginGroupFailoverCriteria | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'statusCodes': obj.statusCodes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderOriginGroupMember
 */
export interface DistributionSpecForProviderOriginGroupMember {
  /**
   * Unique identifier for the origin.
   *
   * @schema DistributionSpecForProviderOriginGroupMember#originId
   */
  readonly originId?: string;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOriginGroupMember' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOriginGroupMember(obj: DistributionSpecForProviderOriginGroupMember | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'originId': obj.originId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderRestrictionsGeoRestriction
 */
export interface DistributionSpecForProviderRestrictionsGeoRestriction {
  /**
   * ISO 3166-1-alpha-2 codes for which you want CloudFront either to distribute your content (whitelist) or not distribute your content (blacklist). If the type is specified as none an empty array can be used.
   *
   * @schema DistributionSpecForProviderRestrictionsGeoRestriction#locations
   */
  readonly locations?: string[];

  /**
   * Method that you want to use to restrict distribution of your content by country: none, whitelist, or blacklist.
   *
   * @schema DistributionSpecForProviderRestrictionsGeoRestriction#restrictionType
   */
  readonly restrictionType?: string;

}

/**
 * Converts an object of type 'DistributionSpecForProviderRestrictionsGeoRestriction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderRestrictionsGeoRestriction(obj: DistributionSpecForProviderRestrictionsGeoRestriction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'locations': obj.locations?.map(y => y),
    'restrictionType': obj.restrictionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderDefaultCacheBehaviorForwardedValues
 */
export interface DistributionSpecInitProviderDefaultCacheBehaviorForwardedValues {
  /**
   * The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehaviorForwardedValues#cookies
   */
  readonly cookies?: DistributionSpecInitProviderDefaultCacheBehaviorForwardedValuesCookies[];

  /**
   * Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehaviorForwardedValues#headers
   */
  readonly headers?: string[];

  /**
   * Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehaviorForwardedValues#queryString
   */
  readonly queryString?: boolean;

  /**
   * When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehaviorForwardedValues#queryStringCacheKeys
   */
  readonly queryStringCacheKeys?: string[];

}

/**
 * Converts an object of type 'DistributionSpecInitProviderDefaultCacheBehaviorForwardedValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderDefaultCacheBehaviorForwardedValues(obj: DistributionSpecInitProviderDefaultCacheBehaviorForwardedValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookies': obj.cookies?.map(y => toJson_DistributionSpecInitProviderDefaultCacheBehaviorForwardedValuesCookies(y)),
    'headers': obj.headers?.map(y => y),
    'queryString': obj.queryString,
    'queryStringCacheKeys': obj.queryStringCacheKeys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderDefaultCacheBehaviorFunctionAssociation
 */
export interface DistributionSpecInitProviderDefaultCacheBehaviorFunctionAssociation {
  /**
   * Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehaviorFunctionAssociation#eventType
   */
  readonly eventType?: string;

  /**
   * ARN of the CloudFront function.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehaviorFunctionAssociation#functionArn
   */
  readonly functionArn?: string;

}

/**
 * Converts an object of type 'DistributionSpecInitProviderDefaultCacheBehaviorFunctionAssociation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderDefaultCacheBehaviorFunctionAssociation(obj: DistributionSpecInitProviderDefaultCacheBehaviorFunctionAssociation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventType': obj.eventType,
    'functionArn': obj.functionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderDefaultCacheBehaviorLambdaFunctionAssociation
 */
export interface DistributionSpecInitProviderDefaultCacheBehaviorLambdaFunctionAssociation {
  /**
   * Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehaviorLambdaFunctionAssociation#eventType
   */
  readonly eventType?: string;

  /**
   * When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: true, false.
   *
   * @default false. Valid values: true, false.
   * @schema DistributionSpecInitProviderDefaultCacheBehaviorLambdaFunctionAssociation#includeBody
   */
  readonly includeBody?: boolean;

  /**
   * ARN of the Lambda function.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehaviorLambdaFunctionAssociation#lambdaArn
   */
  readonly lambdaArn?: string;

}

/**
 * Converts an object of type 'DistributionSpecInitProviderDefaultCacheBehaviorLambdaFunctionAssociation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderDefaultCacheBehaviorLambdaFunctionAssociation(obj: DistributionSpecInitProviderDefaultCacheBehaviorLambdaFunctionAssociation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventType': obj.eventType,
    'includeBody': obj.includeBody,
    'lambdaArn': obj.lambdaArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderOrderedCacheBehaviorForwardedValues
 */
export interface DistributionSpecInitProviderOrderedCacheBehaviorForwardedValues {
  /**
   * The forwarded values cookies that specifies how CloudFront handles cookies (maximum one).
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehaviorForwardedValues#cookies
   */
  readonly cookies?: DistributionSpecInitProviderOrderedCacheBehaviorForwardedValuesCookies[];

  /**
   * Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehaviorForwardedValues#headers
   */
  readonly headers?: string[];

  /**
   * Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehaviorForwardedValues#queryString
   */
  readonly queryString?: boolean;

  /**
   * When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehaviorForwardedValues#queryStringCacheKeys
   */
  readonly queryStringCacheKeys?: string[];

}

/**
 * Converts an object of type 'DistributionSpecInitProviderOrderedCacheBehaviorForwardedValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderOrderedCacheBehaviorForwardedValues(obj: DistributionSpecInitProviderOrderedCacheBehaviorForwardedValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookies': obj.cookies?.map(y => toJson_DistributionSpecInitProviderOrderedCacheBehaviorForwardedValuesCookies(y)),
    'headers': obj.headers?.map(y => y),
    'queryString': obj.queryString,
    'queryStringCacheKeys': obj.queryStringCacheKeys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderOrderedCacheBehaviorFunctionAssociation
 */
export interface DistributionSpecInitProviderOrderedCacheBehaviorFunctionAssociation {
  /**
   * Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehaviorFunctionAssociation#eventType
   */
  readonly eventType?: string;

}

/**
 * Converts an object of type 'DistributionSpecInitProviderOrderedCacheBehaviorFunctionAssociation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderOrderedCacheBehaviorFunctionAssociation(obj: DistributionSpecInitProviderOrderedCacheBehaviorFunctionAssociation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventType': obj.eventType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderOrderedCacheBehaviorLambdaFunctionAssociation
 */
export interface DistributionSpecInitProviderOrderedCacheBehaviorLambdaFunctionAssociation {
  /**
   * Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehaviorLambdaFunctionAssociation#eventType
   */
  readonly eventType?: string;

  /**
   * When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: true, false.
   *
   * @default false. Valid values: true, false.
   * @schema DistributionSpecInitProviderOrderedCacheBehaviorLambdaFunctionAssociation#includeBody
   */
  readonly includeBody?: boolean;

}

/**
 * Converts an object of type 'DistributionSpecInitProviderOrderedCacheBehaviorLambdaFunctionAssociation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderOrderedCacheBehaviorLambdaFunctionAssociation(obj: DistributionSpecInitProviderOrderedCacheBehaviorLambdaFunctionAssociation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventType': obj.eventType,
    'includeBody': obj.includeBody,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderOriginCustomHeader
 */
export interface DistributionSpecInitProviderOriginCustomHeader {
  /**
   * @schema DistributionSpecInitProviderOriginCustomHeader#name
   */
  readonly name?: string;

  /**
   * @schema DistributionSpecInitProviderOriginCustomHeader#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DistributionSpecInitProviderOriginCustomHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderOriginCustomHeader(obj: DistributionSpecInitProviderOriginCustomHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderOriginCustomOriginConfig
 */
export interface DistributionSpecInitProviderOriginCustomOriginConfig {
  /**
   * HTTP port the custom origin listens on.
   *
   * @schema DistributionSpecInitProviderOriginCustomOriginConfig#httpPort
   */
  readonly httpPort?: number;

  /**
   * HTTPS port the custom origin listens on.
   *
   * @schema DistributionSpecInitProviderOriginCustomOriginConfig#httpsPort
   */
  readonly httpsPort?: number;

  /**
   * The Custom KeepAlive timeout, in seconds. By default, AWS enforces a limit of 60. But you can request an increase.
   *
   * @schema DistributionSpecInitProviderOriginCustomOriginConfig#originKeepaliveTimeout
   */
  readonly originKeepaliveTimeout?: number;

  /**
   * Origin protocol policy to apply to your origin. One of http-only, https-only, or match-viewer.
   *
   * @schema DistributionSpecInitProviderOriginCustomOriginConfig#originProtocolPolicy
   */
  readonly originProtocolPolicy?: string;

  /**
   * The Custom Read timeout, in seconds. By default, AWS enforces a limit of 60. But you can request an increase.
   *
   * @schema DistributionSpecInitProviderOriginCustomOriginConfig#originReadTimeout
   */
  readonly originReadTimeout?: number;

  /**
   * SSL/TLS protocols that you want CloudFront to use when communicating with your origin over HTTPS. A list of one or more of SSLv3, TLSv1, TLSv1.1, and TLSv1.2.
   *
   * @schema DistributionSpecInitProviderOriginCustomOriginConfig#originSslProtocols
   */
  readonly originSslProtocols?: string[];

}

/**
 * Converts an object of type 'DistributionSpecInitProviderOriginCustomOriginConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderOriginCustomOriginConfig(obj: DistributionSpecInitProviderOriginCustomOriginConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpPort': obj.httpPort,
    'httpsPort': obj.httpsPort,
    'originKeepaliveTimeout': obj.originKeepaliveTimeout,
    'originProtocolPolicy': obj.originProtocolPolicy,
    'originReadTimeout': obj.originReadTimeout,
    'originSslProtocols': obj.originSslProtocols?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderOriginOriginShield
 */
export interface DistributionSpecInitProviderOriginOriginShield {
  /**
   * Whether the distribution is enabled to accept end user requests for content.
   *
   * @schema DistributionSpecInitProviderOriginOriginShield#enabled
   */
  readonly enabled?: boolean;

  /**
   * AWS Region for Origin Shield. To specify a region, use the region code, not the region name. For example, specify the US East (Ohio) region as us-east-2.
   *
   * @schema DistributionSpecInitProviderOriginOriginShield#originShieldRegion
   */
  readonly originShieldRegion?: string;

}

/**
 * Converts an object of type 'DistributionSpecInitProviderOriginOriginShield' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderOriginOriginShield(obj: DistributionSpecInitProviderOriginOriginShield | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'originShieldRegion': obj.originShieldRegion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderOriginGroupFailoverCriteria
 */
export interface DistributionSpecInitProviderOriginGroupFailoverCriteria {
  /**
   * List of HTTP status codes for the origin group.
   *
   * @schema DistributionSpecInitProviderOriginGroupFailoverCriteria#statusCodes
   */
  readonly statusCodes?: number[];

}

/**
 * Converts an object of type 'DistributionSpecInitProviderOriginGroupFailoverCriteria' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderOriginGroupFailoverCriteria(obj: DistributionSpecInitProviderOriginGroupFailoverCriteria | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'statusCodes': obj.statusCodes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderOriginGroupMember
 */
export interface DistributionSpecInitProviderOriginGroupMember {
  /**
   * Unique identifier for the origin.
   *
   * @schema DistributionSpecInitProviderOriginGroupMember#originId
   */
  readonly originId?: string;

}

/**
 * Converts an object of type 'DistributionSpecInitProviderOriginGroupMember' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderOriginGroupMember(obj: DistributionSpecInitProviderOriginGroupMember | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'originId': obj.originId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderRestrictionsGeoRestriction
 */
export interface DistributionSpecInitProviderRestrictionsGeoRestriction {
  /**
   * ISO 3166-1-alpha-2 codes for which you want CloudFront either to distribute your content (whitelist) or not distribute your content (blacklist). If the type is specified as none an empty array can be used.
   *
   * @schema DistributionSpecInitProviderRestrictionsGeoRestriction#locations
   */
  readonly locations?: string[];

  /**
   * Method that you want to use to restrict distribution of your content by country: none, whitelist, or blacklist.
   *
   * @schema DistributionSpecInitProviderRestrictionsGeoRestriction#restrictionType
   */
  readonly restrictionType?: string;

}

/**
 * Converts an object of type 'DistributionSpecInitProviderRestrictionsGeoRestriction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderRestrictionsGeoRestriction(obj: DistributionSpecInitProviderRestrictionsGeoRestriction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'locations': obj.locations?.map(y => y),
    'restrictionType': obj.restrictionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DistributionSpecProviderConfigRefPolicyResolution
 */
export enum DistributionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DistributionSpecProviderConfigRefPolicyResolve
 */
export enum DistributionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DistributionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DistributionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DistributionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DistributionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DistributionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DistributionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DistributionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecPublishConnectionDetailsToConfigRefPolicy(obj: DistributionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderDefaultCacheBehaviorForwardedValuesCookies
 */
export interface DistributionSpecForProviderDefaultCacheBehaviorForwardedValuesCookies {
  /**
   * Whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify all, none or whitelist. If whitelist, you must include the subsequent whitelisted_names.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehaviorForwardedValuesCookies#forward
   */
  readonly forward?: string;

  /**
   * If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin.
   *
   * @schema DistributionSpecForProviderDefaultCacheBehaviorForwardedValuesCookies#whitelistedNames
   */
  readonly whitelistedNames?: string[];

}

/**
 * Converts an object of type 'DistributionSpecForProviderDefaultCacheBehaviorForwardedValuesCookies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderDefaultCacheBehaviorForwardedValuesCookies(obj: DistributionSpecForProviderDefaultCacheBehaviorForwardedValuesCookies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forward': obj.forward,
    'whitelistedNames': obj.whitelistedNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecForProviderOrderedCacheBehaviorForwardedValuesCookies
 */
export interface DistributionSpecForProviderOrderedCacheBehaviorForwardedValuesCookies {
  /**
   * Whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify all, none or whitelist. If whitelist, you must include the subsequent whitelisted_names.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorForwardedValuesCookies#forward
   */
  readonly forward?: string;

  /**
   * If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorForwardedValuesCookies#whitelistedNames
   */
  readonly whitelistedNames?: string[];

}

/**
 * Converts an object of type 'DistributionSpecForProviderOrderedCacheBehaviorForwardedValuesCookies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOrderedCacheBehaviorForwardedValuesCookies(obj: DistributionSpecForProviderOrderedCacheBehaviorForwardedValuesCookies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forward': obj.forward,
    'whitelistedNames': obj.whitelistedNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function in cloudfront to populate functionArn.
 *
 * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRef
 */
export interface DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRef#policy
   */
  readonly policy?: DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicy;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRef(obj: DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function in cloudfront to populate functionArn.
 *
 * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelector
 */
export interface DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelector#policy
   */
  readonly policy?: DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicy;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelector(obj: DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function in lambda to populate lambdaArn.
 *
 * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRef
 */
export interface DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRef#policy
   */
  readonly policy?: DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicy;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRef(obj: DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function in lambda to populate lambdaArn.
 *
 * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelector
 */
export interface DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelector#policy
   */
  readonly policy?: DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicy;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelector(obj: DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DistributionSpecForProviderOriginOriginAccessControlIdRefPolicy
 */
export interface DistributionSpecForProviderOriginOriginAccessControlIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DistributionSpecForProviderOriginOriginAccessControlIdRefPolicy#resolution
   */
  readonly resolution?: DistributionSpecForProviderOriginOriginAccessControlIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DistributionSpecForProviderOriginOriginAccessControlIdRefPolicy#resolve
   */
  readonly resolve?: DistributionSpecForProviderOriginOriginAccessControlIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOriginOriginAccessControlIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOriginOriginAccessControlIdRefPolicy(obj: DistributionSpecForProviderOriginOriginAccessControlIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DistributionSpecForProviderOriginOriginAccessControlIdSelectorPolicy
 */
export interface DistributionSpecForProviderOriginOriginAccessControlIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DistributionSpecForProviderOriginOriginAccessControlIdSelectorPolicy#resolution
   */
  readonly resolution?: DistributionSpecForProviderOriginOriginAccessControlIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DistributionSpecForProviderOriginOriginAccessControlIdSelectorPolicy#resolve
   */
  readonly resolve?: DistributionSpecForProviderOriginOriginAccessControlIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOriginOriginAccessControlIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOriginOriginAccessControlIdSelectorPolicy(obj: DistributionSpecForProviderOriginOriginAccessControlIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a OriginAccessIdentity in cloudfront to populate originAccessIdentity.
 *
 * @schema DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRef
 */
export interface DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRef {
  /**
   * Name of the referenced object.
   *
   * @schema DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRef#policy
   */
  readonly policy?: DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicy;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRef(obj: DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a OriginAccessIdentity in cloudfront to populate originAccessIdentity.
 *
 * @schema DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelector
 */
export interface DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelector#policy
   */
  readonly policy?: DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicy;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelector(obj: DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderDefaultCacheBehaviorForwardedValuesCookies
 */
export interface DistributionSpecInitProviderDefaultCacheBehaviorForwardedValuesCookies {
  /**
   * Whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify all, none or whitelist. If whitelist, you must include the subsequent whitelisted_names.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehaviorForwardedValuesCookies#forward
   */
  readonly forward?: string;

  /**
   * If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin.
   *
   * @schema DistributionSpecInitProviderDefaultCacheBehaviorForwardedValuesCookies#whitelistedNames
   */
  readonly whitelistedNames?: string[];

}

/**
 * Converts an object of type 'DistributionSpecInitProviderDefaultCacheBehaviorForwardedValuesCookies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderDefaultCacheBehaviorForwardedValuesCookies(obj: DistributionSpecInitProviderDefaultCacheBehaviorForwardedValuesCookies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forward': obj.forward,
    'whitelistedNames': obj.whitelistedNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DistributionSpecInitProviderOrderedCacheBehaviorForwardedValuesCookies
 */
export interface DistributionSpecInitProviderOrderedCacheBehaviorForwardedValuesCookies {
  /**
   * Whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify all, none or whitelist. If whitelist, you must include the subsequent whitelisted_names.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehaviorForwardedValuesCookies#forward
   */
  readonly forward?: string;

  /**
   * If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin.
   *
   * @schema DistributionSpecInitProviderOrderedCacheBehaviorForwardedValuesCookies#whitelistedNames
   */
  readonly whitelistedNames?: string[];

}

/**
 * Converts an object of type 'DistributionSpecInitProviderOrderedCacheBehaviorForwardedValuesCookies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecInitProviderOrderedCacheBehaviorForwardedValuesCookies(obj: DistributionSpecInitProviderOrderedCacheBehaviorForwardedValuesCookies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forward': obj.forward,
    'whitelistedNames': obj.whitelistedNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DistributionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DistributionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DistributionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DistributionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicy
 */
export interface DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicy#resolution
   */
  readonly resolution?: DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicy#resolve
   */
  readonly resolve?: DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicy(obj: DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicy
 */
export interface DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicy#resolution
   */
  readonly resolution?: DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicy#resolve
   */
  readonly resolve?: DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicy(obj: DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicy
 */
export interface DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicy#resolution
   */
  readonly resolution?: DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicy#resolve
   */
  readonly resolve?: DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicy(obj: DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicy
 */
export interface DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicy#resolution
   */
  readonly resolution?: DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicy#resolve
   */
  readonly resolve?: DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicy(obj: DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DistributionSpecForProviderOriginOriginAccessControlIdRefPolicyResolution
 */
export enum DistributionSpecForProviderOriginOriginAccessControlIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DistributionSpecForProviderOriginOriginAccessControlIdRefPolicyResolve
 */
export enum DistributionSpecForProviderOriginOriginAccessControlIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DistributionSpecForProviderOriginOriginAccessControlIdSelectorPolicyResolution
 */
export enum DistributionSpecForProviderOriginOriginAccessControlIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DistributionSpecForProviderOriginOriginAccessControlIdSelectorPolicyResolve
 */
export enum DistributionSpecForProviderOriginOriginAccessControlIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicy
 */
export interface DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicy#resolution
   */
  readonly resolution?: DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicy#resolve
   */
  readonly resolve?: DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicyResolve;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicy(obj: DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicy
 */
export interface DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicy#resolution
   */
  readonly resolution?: DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicy#resolve
   */
  readonly resolve?: DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicyResolve;

}

/**
 * Converts an object of type 'DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicy(obj: DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicyResolution
 */
export enum DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicyResolve
 */
export enum DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicyResolution
 */
export enum DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicyResolve
 */
export enum DistributionSpecForProviderOrderedCacheBehaviorFunctionAssociationFunctionArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicyResolution
 */
export enum DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicyResolve
 */
export enum DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicyResolution
 */
export enum DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicyResolve
 */
export enum DistributionSpecForProviderOrderedCacheBehaviorLambdaFunctionAssociationLambdaArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicyResolution
 */
export enum DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicyResolve
 */
export enum DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentityRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicyResolution
 */
export enum DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicyResolve
 */
export enum DistributionSpecForProviderOriginS3OriginConfigOriginAccessIdentitySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FieldLevelEncryptionConfig is the Schema for the FieldLevelEncryptionConfigs API. Provides a CloudFront Field-level Encryption Config resource.
 *
 * @schema FieldLevelEncryptionConfig
 */
export class FieldLevelEncryptionConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FieldLevelEncryptionConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudfront.aws.upbound.io/v1beta1',
    kind: 'FieldLevelEncryptionConfig',
  }

  /**
   * Renders a Kubernetes manifest for "FieldLevelEncryptionConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FieldLevelEncryptionConfigProps): any {
    return {
      ...FieldLevelEncryptionConfig.GVK,
      ...toJson_FieldLevelEncryptionConfigProps(props),
    };
  }

  /**
   * Defines a "FieldLevelEncryptionConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FieldLevelEncryptionConfigProps) {
    super(scope, id, {
      ...FieldLevelEncryptionConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FieldLevelEncryptionConfig.GVK,
      ...toJson_FieldLevelEncryptionConfigProps(resolved),
    };
  }
}

/**
 * FieldLevelEncryptionConfig is the Schema for the FieldLevelEncryptionConfigs API. Provides a CloudFront Field-level Encryption Config resource.
 *
 * @schema FieldLevelEncryptionConfig
 */
export interface FieldLevelEncryptionConfigProps {
  /**
   * @schema FieldLevelEncryptionConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FieldLevelEncryptionConfigSpec defines the desired state of FieldLevelEncryptionConfig
   *
   * @schema FieldLevelEncryptionConfig#spec
   */
  readonly spec: FieldLevelEncryptionConfigSpec;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigProps(obj: FieldLevelEncryptionConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FieldLevelEncryptionConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FieldLevelEncryptionConfigSpec defines the desired state of FieldLevelEncryptionConfig
 *
 * @schema FieldLevelEncryptionConfigSpec
 */
export interface FieldLevelEncryptionConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FieldLevelEncryptionConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: FieldLevelEncryptionConfigSpecDeletionPolicy;

  /**
   * @schema FieldLevelEncryptionConfigSpec#forProvider
   */
  readonly forProvider: FieldLevelEncryptionConfigSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema FieldLevelEncryptionConfigSpec#initProvider
   */
  readonly initProvider?: FieldLevelEncryptionConfigSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FieldLevelEncryptionConfigSpec#managementPolicies
   */
  readonly managementPolicies?: FieldLevelEncryptionConfigSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FieldLevelEncryptionConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: FieldLevelEncryptionConfigSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FieldLevelEncryptionConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FieldLevelEncryptionConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FieldLevelEncryptionConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FieldLevelEncryptionConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpec(obj: FieldLevelEncryptionConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FieldLevelEncryptionConfigSpecForProvider(obj.forProvider),
    'initProvider': toJson_FieldLevelEncryptionConfigSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FieldLevelEncryptionConfigSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FieldLevelEncryptionConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FieldLevelEncryptionConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FieldLevelEncryptionConfigSpecDeletionPolicy
 */
export enum FieldLevelEncryptionConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FieldLevelEncryptionConfigSpecForProvider
 */
export interface FieldLevelEncryptionConfigSpecForProvider {
  /**
   * An optional comment about the Field Level Encryption Config.
   *
   * @schema FieldLevelEncryptionConfigSpecForProvider#comment
   */
  readonly comment?: string;

  /**
   * Content Type Profile Config specifies when to forward content if a content type isn't recognized and profiles to use as by default in a request if a query argument doesn't specify a profile to use.
   *
   * @schema FieldLevelEncryptionConfigSpecForProvider#contentTypeProfileConfig
   */
  readonly contentTypeProfileConfig?: FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfig[];

  /**
   * Query Arg Profile Config that specifies when to forward content if a profile isn't found and the profile that can be provided as a query argument in a request.
   *
   * @schema FieldLevelEncryptionConfigSpecForProvider#queryArgProfileConfig
   */
  readonly queryArgProfileConfig?: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfig[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FieldLevelEncryptionConfigSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecForProvider(obj: FieldLevelEncryptionConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'contentTypeProfileConfig': obj.contentTypeProfileConfig?.map(y => toJson_FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfig(y)),
    'queryArgProfileConfig': obj.queryArgProfileConfig?.map(y => toJson_FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfig(y)),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema FieldLevelEncryptionConfigSpecInitProvider
 */
export interface FieldLevelEncryptionConfigSpecInitProvider {
  /**
   * An optional comment about the Field Level Encryption Config.
   *
   * @schema FieldLevelEncryptionConfigSpecInitProvider#comment
   */
  readonly comment?: string;

  /**
   * Content Type Profile Config specifies when to forward content if a content type isn't recognized and profiles to use as by default in a request if a query argument doesn't specify a profile to use.
   *
   * @schema FieldLevelEncryptionConfigSpecInitProvider#contentTypeProfileConfig
   */
  readonly contentTypeProfileConfig?: FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfig[];

  /**
   * Query Arg Profile Config that specifies when to forward content if a profile isn't found and the profile that can be provided as a query argument in a request.
   *
   * @schema FieldLevelEncryptionConfigSpecInitProvider#queryArgProfileConfig
   */
  readonly queryArgProfileConfig?: FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfig[];

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecInitProvider(obj: FieldLevelEncryptionConfigSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'contentTypeProfileConfig': obj.contentTypeProfileConfig?.map(y => toJson_FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfig(y)),
    'queryArgProfileConfig': obj.queryArgProfileConfig?.map(y => toJson_FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FieldLevelEncryptionConfigSpecManagementPolicies
 */
export enum FieldLevelEncryptionConfigSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FieldLevelEncryptionConfigSpecProviderConfigRef
 */
export interface FieldLevelEncryptionConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FieldLevelEncryptionConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FieldLevelEncryptionConfigSpecProviderConfigRef#policy
   */
  readonly policy?: FieldLevelEncryptionConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecProviderConfigRef(obj: FieldLevelEncryptionConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FieldLevelEncryptionConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FieldLevelEncryptionConfigSpecPublishConnectionDetailsTo
 */
export interface FieldLevelEncryptionConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FieldLevelEncryptionConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FieldLevelEncryptionConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FieldLevelEncryptionConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FieldLevelEncryptionConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecPublishConnectionDetailsTo(obj: FieldLevelEncryptionConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FieldLevelEncryptionConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FieldLevelEncryptionConfigSpecWriteConnectionSecretToRef
 */
export interface FieldLevelEncryptionConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FieldLevelEncryptionConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FieldLevelEncryptionConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecWriteConnectionSecretToRef(obj: FieldLevelEncryptionConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfig
 */
export interface FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfig {
  /**
   * Object that contains an attribute items that contains the list of configurations for a field-level encryption content type-profile. See Content Type Profile.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfig#contentTypeProfiles
   */
  readonly contentTypeProfiles?: FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfiles[];

  /**
   * specifies what to do when an unknown content type is provided for the profile. If true, content is forwarded without being encrypted when the content type is unknown. If false (the default), an error is returned when the content type is unknown.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfig#forwardWhenContentTypeIsUnknown
   */
  readonly forwardWhenContentTypeIsUnknown?: boolean;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfig(obj: FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentTypeProfiles': obj.contentTypeProfiles?.map(y => toJson_FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfiles(y)),
    'forwardWhenContentTypeIsUnknown': obj.forwardWhenContentTypeIsUnknown,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfig
 */
export interface FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfig {
  /**
   * Flag to set if you want a request to be forwarded to the origin even if the profile specified by the field-level encryption query argument, fle-profile, is unknown.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfig#forwardWhenQueryArgProfileIsUnknown
   */
  readonly forwardWhenQueryArgProfileIsUnknown?: boolean;

  /**
   * Object that contains an attribute items that contains the list ofrofiles specified for query argument-profile mapping for field-level encryption. see Query Arg Profile.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfig#queryArgProfiles
   */
  readonly queryArgProfiles?: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfiles[];

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfig(obj: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forwardWhenQueryArgProfileIsUnknown': obj.forwardWhenQueryArgProfileIsUnknown,
    'queryArgProfiles': obj.queryArgProfiles?.map(y => toJson_FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfiles(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfig
 */
export interface FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfig {
  /**
   * Object that contains an attribute items that contains the list of configurations for a field-level encryption content type-profile. See Content Type Profile.
   *
   * @schema FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfig#contentTypeProfiles
   */
  readonly contentTypeProfiles?: FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfiles[];

  /**
   * specifies what to do when an unknown content type is provided for the profile. If true, content is forwarded without being encrypted when the content type is unknown. If false (the default), an error is returned when the content type is unknown.
   *
   * @schema FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfig#forwardWhenContentTypeIsUnknown
   */
  readonly forwardWhenContentTypeIsUnknown?: boolean;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfig(obj: FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentTypeProfiles': obj.contentTypeProfiles?.map(y => toJson_FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfiles(y)),
    'forwardWhenContentTypeIsUnknown': obj.forwardWhenContentTypeIsUnknown,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfig
 */
export interface FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfig {
  /**
   * Flag to set if you want a request to be forwarded to the origin even if the profile specified by the field-level encryption query argument, fle-profile, is unknown.
   *
   * @schema FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfig#forwardWhenQueryArgProfileIsUnknown
   */
  readonly forwardWhenQueryArgProfileIsUnknown?: boolean;

  /**
   * Object that contains an attribute items that contains the list ofrofiles specified for query argument-profile mapping for field-level encryption. see Query Arg Profile.
   *
   * @schema FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfig#queryArgProfiles
   */
  readonly queryArgProfiles?: FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfigQueryArgProfiles[];

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfig(obj: FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forwardWhenQueryArgProfileIsUnknown': obj.forwardWhenQueryArgProfileIsUnknown,
    'queryArgProfiles': obj.queryArgProfiles?.map(y => toJson_FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfigQueryArgProfiles(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FieldLevelEncryptionConfigSpecProviderConfigRefPolicy
 */
export interface FieldLevelEncryptionConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FieldLevelEncryptionConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FieldLevelEncryptionConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FieldLevelEncryptionConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FieldLevelEncryptionConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecProviderConfigRefPolicy(obj: FieldLevelEncryptionConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRef(obj: FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FieldLevelEncryptionConfigSpecPublishConnectionDetailsToMetadata
 */
export interface FieldLevelEncryptionConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FieldLevelEncryptionConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FieldLevelEncryptionConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FieldLevelEncryptionConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecPublishConnectionDetailsToMetadata(obj: FieldLevelEncryptionConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfiles
 */
export interface FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfiles {
  /**
   * @schema FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfiles#items
   */
  readonly items?: FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfilesItems[];

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfiles' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfiles(obj: FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfiles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfilesItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfiles
 */
export interface FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfiles {
  /**
   * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfiles#items
   */
  readonly items?: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItems[];

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfiles' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfiles(obj: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfiles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfiles
 */
export interface FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfiles {
  /**
   * @schema FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfiles#items
   */
  readonly items?: FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfilesItems[];

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfiles' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfiles(obj: FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfiles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfilesItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfigQueryArgProfiles
 */
export interface FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfigQueryArgProfiles {
  /**
   * @schema FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfigQueryArgProfiles#items
   */
  readonly items?: FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfigQueryArgProfilesItems[];

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfigQueryArgProfiles' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfigQueryArgProfiles(obj: FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfigQueryArgProfiles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfigQueryArgProfilesItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FieldLevelEncryptionConfigSpecProviderConfigRefPolicyResolution
 */
export enum FieldLevelEncryptionConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FieldLevelEncryptionConfigSpecProviderConfigRefPolicyResolve
 */
export enum FieldLevelEncryptionConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfilesItems
 */
export interface FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfilesItems {
  /**
   * he content type for a field-level encryption content type-profile mapping. Valid value is application/x-www-form-urlencoded.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfilesItems#contentType
   */
  readonly contentType?: string;

  /**
   * The format for a field-level encryption content type-profile mapping. Valid value is URLEncoded.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfilesItems#format
   */
  readonly format?: string;

  /**
   * The profile ID for a field-level encryption content type-profile mapping.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfilesItems#profileId
   */
  readonly profileId?: string;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfilesItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfilesItems(obj: FieldLevelEncryptionConfigSpecForProviderContentTypeProfileConfigContentTypeProfilesItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentType': obj.contentType,
    'format': obj.format,
    'profileId': obj.profileId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItems
 */
export interface FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItems {
  /**
   * The profile ID for a field-level encryption content type-profile mapping.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItems#profileId
   */
  readonly profileId?: string;

  /**
   * Reference to a FieldLevelEncryptionProfile in cloudfront to populate profileId.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItems#profileIdRef
   */
  readonly profileIdRef?: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRef;

  /**
   * Selector for a FieldLevelEncryptionProfile in cloudfront to populate profileId.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItems#profileIdSelector
   */
  readonly profileIdSelector?: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelector;

  /**
   * Query argument for field-level encryption query argument-profile mapping.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItems#queryArg
   */
  readonly queryArg?: string;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItems(obj: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'profileId': obj.profileId,
    'profileIdRef': toJson_FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRef(obj.profileIdRef),
    'profileIdSelector': toJson_FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelector(obj.profileIdSelector),
    'queryArg': obj.queryArg,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfilesItems
 */
export interface FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfilesItems {
  /**
   * he content type for a field-level encryption content type-profile mapping. Valid value is application/x-www-form-urlencoded.
   *
   * @schema FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfilesItems#contentType
   */
  readonly contentType?: string;

  /**
   * The format for a field-level encryption content type-profile mapping. Valid value is URLEncoded.
   *
   * @schema FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfilesItems#format
   */
  readonly format?: string;

  /**
   * The profile ID for a field-level encryption content type-profile mapping.
   *
   * @schema FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfilesItems#profileId
   */
  readonly profileId?: string;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfilesItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfilesItems(obj: FieldLevelEncryptionConfigSpecInitProviderContentTypeProfileConfigContentTypeProfilesItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentType': obj.contentType,
    'format': obj.format,
    'profileId': obj.profileId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfigQueryArgProfilesItems
 */
export interface FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfigQueryArgProfilesItems {
  /**
   * Query argument for field-level encryption query argument-profile mapping.
   *
   * @schema FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfigQueryArgProfilesItems#queryArg
   */
  readonly queryArg?: string;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfigQueryArgProfilesItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfigQueryArgProfilesItems(obj: FieldLevelEncryptionConfigSpecInitProviderQueryArgProfileConfigQueryArgProfilesItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'queryArg': obj.queryArg,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FieldLevelEncryptionConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a FieldLevelEncryptionProfile in cloudfront to populate profileId.
 *
 * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRef
 */
export interface FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRef#policy
   */
  readonly policy?: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRefPolicy;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRef(obj: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a FieldLevelEncryptionProfile in cloudfront to populate profileId.
 *
 * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelector
 */
export interface FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelector#policy
   */
  readonly policy?: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelectorPolicy;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelector(obj: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRefPolicy
 */
export interface FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRefPolicy#resolution
   */
  readonly resolution?: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRefPolicy#resolve
   */
  readonly resolve?: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRefPolicyResolve;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRefPolicy(obj: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelectorPolicy
 */
export interface FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelectorPolicy#resolution
   */
  readonly resolution?: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelectorPolicy#resolve
   */
  readonly resolve?: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelectorPolicy(obj: FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRefPolicyResolution
 */
export enum FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRefPolicyResolve
 */
export enum FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelectorPolicyResolution
 */
export enum FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelectorPolicyResolve
 */
export enum FieldLevelEncryptionConfigSpecForProviderQueryArgProfileConfigQueryArgProfilesItemsProfileIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FieldLevelEncryptionProfile is the Schema for the FieldLevelEncryptionProfiles API. Provides a CloudFront Field-level Encryption Profile resource.
 *
 * @schema FieldLevelEncryptionProfile
 */
export class FieldLevelEncryptionProfile extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FieldLevelEncryptionProfile"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudfront.aws.upbound.io/v1beta1',
    kind: 'FieldLevelEncryptionProfile',
  }

  /**
   * Renders a Kubernetes manifest for "FieldLevelEncryptionProfile".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FieldLevelEncryptionProfileProps): any {
    return {
      ...FieldLevelEncryptionProfile.GVK,
      ...toJson_FieldLevelEncryptionProfileProps(props),
    };
  }

  /**
   * Defines a "FieldLevelEncryptionProfile" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FieldLevelEncryptionProfileProps) {
    super(scope, id, {
      ...FieldLevelEncryptionProfile.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FieldLevelEncryptionProfile.GVK,
      ...toJson_FieldLevelEncryptionProfileProps(resolved),
    };
  }
}

/**
 * FieldLevelEncryptionProfile is the Schema for the FieldLevelEncryptionProfiles API. Provides a CloudFront Field-level Encryption Profile resource.
 *
 * @schema FieldLevelEncryptionProfile
 */
export interface FieldLevelEncryptionProfileProps {
  /**
   * @schema FieldLevelEncryptionProfile#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FieldLevelEncryptionProfileSpec defines the desired state of FieldLevelEncryptionProfile
   *
   * @schema FieldLevelEncryptionProfile#spec
   */
  readonly spec: FieldLevelEncryptionProfileSpec;

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileProps(obj: FieldLevelEncryptionProfileProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FieldLevelEncryptionProfileSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FieldLevelEncryptionProfileSpec defines the desired state of FieldLevelEncryptionProfile
 *
 * @schema FieldLevelEncryptionProfileSpec
 */
export interface FieldLevelEncryptionProfileSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FieldLevelEncryptionProfileSpec#deletionPolicy
   */
  readonly deletionPolicy?: FieldLevelEncryptionProfileSpecDeletionPolicy;

  /**
   * @schema FieldLevelEncryptionProfileSpec#forProvider
   */
  readonly forProvider: FieldLevelEncryptionProfileSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema FieldLevelEncryptionProfileSpec#initProvider
   */
  readonly initProvider?: FieldLevelEncryptionProfileSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FieldLevelEncryptionProfileSpec#managementPolicies
   */
  readonly managementPolicies?: FieldLevelEncryptionProfileSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FieldLevelEncryptionProfileSpec#providerConfigRef
   */
  readonly providerConfigRef?: FieldLevelEncryptionProfileSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FieldLevelEncryptionProfileSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FieldLevelEncryptionProfileSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FieldLevelEncryptionProfileSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FieldLevelEncryptionProfileSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpec(obj: FieldLevelEncryptionProfileSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FieldLevelEncryptionProfileSpecForProvider(obj.forProvider),
    'initProvider': toJson_FieldLevelEncryptionProfileSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FieldLevelEncryptionProfileSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FieldLevelEncryptionProfileSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FieldLevelEncryptionProfileSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FieldLevelEncryptionProfileSpecDeletionPolicy
 */
export enum FieldLevelEncryptionProfileSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FieldLevelEncryptionProfileSpecForProvider
 */
export interface FieldLevelEncryptionProfileSpecForProvider {
  /**
   * An optional comment about the Field Level Encryption Profile.
   *
   * @schema FieldLevelEncryptionProfileSpecForProvider#comment
   */
  readonly comment?: string;

  /**
   * The encryption entities config block for field-level encryption profiles that contains an attribute items which includes the encryption key and field pattern specifications.
   *
   * @schema FieldLevelEncryptionProfileSpecForProvider#encryptionEntities
   */
  readonly encryptionEntities?: FieldLevelEncryptionProfileSpecForProviderEncryptionEntities[];

  /**
   * The name of the Field Level Encryption Profile.
   *
   * @schema FieldLevelEncryptionProfileSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FieldLevelEncryptionProfileSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecForProvider(obj: FieldLevelEncryptionProfileSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'encryptionEntities': obj.encryptionEntities?.map(y => toJson_FieldLevelEncryptionProfileSpecForProviderEncryptionEntities(y)),
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema FieldLevelEncryptionProfileSpecInitProvider
 */
export interface FieldLevelEncryptionProfileSpecInitProvider {
  /**
   * An optional comment about the Field Level Encryption Profile.
   *
   * @schema FieldLevelEncryptionProfileSpecInitProvider#comment
   */
  readonly comment?: string;

  /**
   * The encryption entities config block for field-level encryption profiles that contains an attribute items which includes the encryption key and field pattern specifications.
   *
   * @schema FieldLevelEncryptionProfileSpecInitProvider#encryptionEntities
   */
  readonly encryptionEntities?: FieldLevelEncryptionProfileSpecInitProviderEncryptionEntities[];

  /**
   * The name of the Field Level Encryption Profile.
   *
   * @schema FieldLevelEncryptionProfileSpecInitProvider#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecInitProvider(obj: FieldLevelEncryptionProfileSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'encryptionEntities': obj.encryptionEntities?.map(y => toJson_FieldLevelEncryptionProfileSpecInitProviderEncryptionEntities(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FieldLevelEncryptionProfileSpecManagementPolicies
 */
export enum FieldLevelEncryptionProfileSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FieldLevelEncryptionProfileSpecProviderConfigRef
 */
export interface FieldLevelEncryptionProfileSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FieldLevelEncryptionProfileSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FieldLevelEncryptionProfileSpecProviderConfigRef#policy
   */
  readonly policy?: FieldLevelEncryptionProfileSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecProviderConfigRef(obj: FieldLevelEncryptionProfileSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FieldLevelEncryptionProfileSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FieldLevelEncryptionProfileSpecPublishConnectionDetailsTo
 */
export interface FieldLevelEncryptionProfileSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FieldLevelEncryptionProfileSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FieldLevelEncryptionProfileSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FieldLevelEncryptionProfileSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FieldLevelEncryptionProfileSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecPublishConnectionDetailsTo(obj: FieldLevelEncryptionProfileSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FieldLevelEncryptionProfileSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FieldLevelEncryptionProfileSpecWriteConnectionSecretToRef
 */
export interface FieldLevelEncryptionProfileSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FieldLevelEncryptionProfileSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FieldLevelEncryptionProfileSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecWriteConnectionSecretToRef(obj: FieldLevelEncryptionProfileSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntities
 */
export interface FieldLevelEncryptionProfileSpecForProviderEncryptionEntities {
  /**
   * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntities#items
   */
  readonly items?: FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItems[];

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecForProviderEncryptionEntities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecForProviderEncryptionEntities(obj: FieldLevelEncryptionProfileSpecForProviderEncryptionEntities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionProfileSpecInitProviderEncryptionEntities
 */
export interface FieldLevelEncryptionProfileSpecInitProviderEncryptionEntities {
  /**
   * @schema FieldLevelEncryptionProfileSpecInitProviderEncryptionEntities#items
   */
  readonly items?: FieldLevelEncryptionProfileSpecInitProviderEncryptionEntitiesItems[];

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecInitProviderEncryptionEntities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecInitProviderEncryptionEntities(obj: FieldLevelEncryptionProfileSpecInitProviderEncryptionEntities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_FieldLevelEncryptionProfileSpecInitProviderEncryptionEntitiesItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FieldLevelEncryptionProfileSpecProviderConfigRefPolicy
 */
export interface FieldLevelEncryptionProfileSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FieldLevelEncryptionProfileSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FieldLevelEncryptionProfileSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FieldLevelEncryptionProfileSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FieldLevelEncryptionProfileSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecProviderConfigRefPolicy(obj: FieldLevelEncryptionProfileSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRef
 */
export interface FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRef(obj: FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FieldLevelEncryptionProfileSpecPublishConnectionDetailsToMetadata
 */
export interface FieldLevelEncryptionProfileSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FieldLevelEncryptionProfileSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FieldLevelEncryptionProfileSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FieldLevelEncryptionProfileSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecPublishConnectionDetailsToMetadata(obj: FieldLevelEncryptionProfileSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItems
 */
export interface FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItems {
  /**
   * Object that contains an attribute items that contains the list of field patterns in a field-level encryption content type profile specify the fields that you want to be encrypted.
   *
   * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItems#fieldPatterns
   */
  readonly fieldPatterns?: FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsFieldPatterns[];

  /**
   * The provider associated with the public key being used for encryption.
   *
   * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItems#providerId
   */
  readonly providerId?: string;

  /**
   * The public key associated with a set of field-level encryption patterns, to be used when encrypting the fields that match the patterns.
   *
   * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItems#publicKeyId
   */
  readonly publicKeyId?: string;

  /**
   * Reference to a PublicKey in cloudfront to populate publicKeyId.
   *
   * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItems#publicKeyIdRef
   */
  readonly publicKeyIdRef?: FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRef;

  /**
   * Selector for a PublicKey in cloudfront to populate publicKeyId.
   *
   * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItems#publicKeyIdSelector
   */
  readonly publicKeyIdSelector?: FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelector;

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItems(obj: FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldPatterns': obj.fieldPatterns?.map(y => toJson_FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsFieldPatterns(y)),
    'providerId': obj.providerId,
    'publicKeyId': obj.publicKeyId,
    'publicKeyIdRef': toJson_FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRef(obj.publicKeyIdRef),
    'publicKeyIdSelector': toJson_FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelector(obj.publicKeyIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionProfileSpecInitProviderEncryptionEntitiesItems
 */
export interface FieldLevelEncryptionProfileSpecInitProviderEncryptionEntitiesItems {
  /**
   * Object that contains an attribute items that contains the list of field patterns in a field-level encryption content type profile specify the fields that you want to be encrypted.
   *
   * @schema FieldLevelEncryptionProfileSpecInitProviderEncryptionEntitiesItems#fieldPatterns
   */
  readonly fieldPatterns?: FieldLevelEncryptionProfileSpecInitProviderEncryptionEntitiesItemsFieldPatterns[];

  /**
   * The provider associated with the public key being used for encryption.
   *
   * @schema FieldLevelEncryptionProfileSpecInitProviderEncryptionEntitiesItems#providerId
   */
  readonly providerId?: string;

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecInitProviderEncryptionEntitiesItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecInitProviderEncryptionEntitiesItems(obj: FieldLevelEncryptionProfileSpecInitProviderEncryptionEntitiesItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldPatterns': obj.fieldPatterns?.map(y => toJson_FieldLevelEncryptionProfileSpecInitProviderEncryptionEntitiesItemsFieldPatterns(y)),
    'providerId': obj.providerId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FieldLevelEncryptionProfileSpecProviderConfigRefPolicyResolution
 */
export enum FieldLevelEncryptionProfileSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FieldLevelEncryptionProfileSpecProviderConfigRefPolicyResolve
 */
export enum FieldLevelEncryptionProfileSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj: FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsFieldPatterns
 */
export interface FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsFieldPatterns {
  /**
   * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsFieldPatterns#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsFieldPatterns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsFieldPatterns(obj: FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsFieldPatterns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a PublicKey in cloudfront to populate publicKeyId.
 *
 * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRef
 */
export interface FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRef#policy
   */
  readonly policy?: FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRefPolicy;

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRef(obj: FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a PublicKey in cloudfront to populate publicKeyId.
 *
 * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelector
 */
export interface FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelector#policy
   */
  readonly policy?: FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelector(obj: FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FieldLevelEncryptionProfileSpecInitProviderEncryptionEntitiesItemsFieldPatterns
 */
export interface FieldLevelEncryptionProfileSpecInitProviderEncryptionEntitiesItemsFieldPatterns {
  /**
   * @schema FieldLevelEncryptionProfileSpecInitProviderEncryptionEntitiesItemsFieldPatterns#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecInitProviderEncryptionEntitiesItemsFieldPatterns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecInitProviderEncryptionEntitiesItemsFieldPatterns(obj: FieldLevelEncryptionProfileSpecInitProviderEncryptionEntitiesItemsFieldPatterns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FieldLevelEncryptionProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRefPolicy
 */
export interface FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRefPolicy#resolution
   */
  readonly resolution?: FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRefPolicy#resolve
   */
  readonly resolve?: FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRefPolicy(obj: FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelectorPolicy
 */
export interface FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelectorPolicy(obj: FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRefPolicyResolution
 */
export enum FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRefPolicyResolve
 */
export enum FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelectorPolicyResolution
 */
export enum FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelectorPolicyResolve
 */
export enum FieldLevelEncryptionProfileSpecForProviderEncryptionEntitiesItemsPublicKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Function is the Schema for the Functions API. Provides a CloudFront Function resource. With CloudFront Functions in Amazon CloudFront, you can write lightweight functions in JavaScript for high-scale, latency-sensitive CDN customizations.
 *
 * @schema Function
 */
export class Function extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Function"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudfront.aws.upbound.io/v1beta1',
    kind: 'Function',
  }

  /**
   * Renders a Kubernetes manifest for "Function".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FunctionProps): any {
    return {
      ...Function.GVK,
      ...toJson_FunctionProps(props),
    };
  }

  /**
   * Defines a "Function" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FunctionProps) {
    super(scope, id, {
      ...Function.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Function.GVK,
      ...toJson_FunctionProps(resolved),
    };
  }
}

/**
 * Function is the Schema for the Functions API. Provides a CloudFront Function resource. With CloudFront Functions in Amazon CloudFront, you can write lightweight functions in JavaScript for high-scale, latency-sensitive CDN customizations.
 *
 * @schema Function
 */
export interface FunctionProps {
  /**
   * @schema Function#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FunctionSpec defines the desired state of Function
   *
   * @schema Function#spec
   */
  readonly spec: FunctionSpec;

}

/**
 * Converts an object of type 'FunctionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionProps(obj: FunctionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FunctionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionSpec defines the desired state of Function
 *
 * @schema FunctionSpec
 */
export interface FunctionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FunctionSpec#deletionPolicy
   */
  readonly deletionPolicy?: FunctionSpecDeletionPolicy;

  /**
   * @schema FunctionSpec#forProvider
   */
  readonly forProvider: FunctionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema FunctionSpec#initProvider
   */
  readonly initProvider?: FunctionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FunctionSpec#managementPolicies
   */
  readonly managementPolicies?: FunctionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FunctionSpec#providerConfigRef
   */
  readonly providerConfigRef?: FunctionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FunctionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FunctionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FunctionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FunctionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FunctionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpec(obj: FunctionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FunctionSpecForProvider(obj.forProvider),
    'initProvider': toJson_FunctionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FunctionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FunctionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FunctionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FunctionSpecDeletionPolicy
 */
export enum FunctionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FunctionSpecForProvider
 */
export interface FunctionSpecForProvider {
  /**
   * Source code of the function
   *
   * @schema FunctionSpecForProvider#codeSecretRef
   */
  readonly codeSecretRef?: FunctionSpecForProviderCodeSecretRef;

  /**
   * Comment.
   *
   * @schema FunctionSpecForProvider#comment
   */
  readonly comment?: string;

  /**
   * Whether to publish creation/change as Live CloudFront Function Version. Defaults to true.
   *
   * @default true.
   * @schema FunctionSpecForProvider#publish
   */
  readonly publish?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FunctionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Identifier of the function's runtime. Currently only cloudfront-js-1.0 is valid.
   *
   * @schema FunctionSpecForProvider#runtime
   */
  readonly runtime?: string;

}

/**
 * Converts an object of type 'FunctionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProvider(obj: FunctionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codeSecretRef': toJson_FunctionSpecForProviderCodeSecretRef(obj.codeSecretRef),
    'comment': obj.comment,
    'publish': obj.publish,
    'region': obj.region,
    'runtime': obj.runtime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema FunctionSpecInitProvider
 */
export interface FunctionSpecInitProvider {
  /**
   * Comment.
   *
   * @schema FunctionSpecInitProvider#comment
   */
  readonly comment?: string;

  /**
   * Whether to publish creation/change as Live CloudFront Function Version. Defaults to true.
   *
   * @default true.
   * @schema FunctionSpecInitProvider#publish
   */
  readonly publish?: boolean;

  /**
   * Identifier of the function's runtime. Currently only cloudfront-js-1.0 is valid.
   *
   * @schema FunctionSpecInitProvider#runtime
   */
  readonly runtime?: string;

}

/**
 * Converts an object of type 'FunctionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecInitProvider(obj: FunctionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'publish': obj.publish,
    'runtime': obj.runtime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FunctionSpecManagementPolicies
 */
export enum FunctionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FunctionSpecProviderConfigRef
 */
export interface FunctionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecProviderConfigRef#policy
   */
  readonly policy?: FunctionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderConfigRef(obj: FunctionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FunctionSpecPublishConnectionDetailsTo
 */
export interface FunctionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FunctionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FunctionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsTo(obj: FunctionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FunctionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FunctionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FunctionSpecWriteConnectionSecretToRef
 */
export interface FunctionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FunctionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FunctionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FunctionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecWriteConnectionSecretToRef(obj: FunctionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source code of the function
 *
 * @schema FunctionSpecForProviderCodeSecretRef
 */
export interface FunctionSpecForProviderCodeSecretRef {
  /**
   * The key to select.
   *
   * @schema FunctionSpecForProviderCodeSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema FunctionSpecForProviderCodeSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FunctionSpecForProviderCodeSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderCodeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderCodeSecretRef(obj: FunctionSpecForProviderCodeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecProviderConfigRefPolicy
 */
export interface FunctionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderConfigRefPolicy(obj: FunctionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRef
 */
export interface FunctionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FunctionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToConfigRef(obj: FunctionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FunctionSpecPublishConnectionDetailsToMetadata
 */
export interface FunctionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToMetadata(obj: FunctionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecProviderConfigRefPolicyResolution
 */
export enum FunctionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecProviderConfigRefPolicyResolve
 */
export enum FunctionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FunctionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToConfigRefPolicy(obj: FunctionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * KeyGroup is the Schema for the KeyGroups API. Provides a CloudFront key group.
 *
 * @schema KeyGroup
 */
export class KeyGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KeyGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudfront.aws.upbound.io/v1beta1',
    kind: 'KeyGroup',
  }

  /**
   * Renders a Kubernetes manifest for "KeyGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KeyGroupProps): any {
    return {
      ...KeyGroup.GVK,
      ...toJson_KeyGroupProps(props),
    };
  }

  /**
   * Defines a "KeyGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KeyGroupProps) {
    super(scope, id, {
      ...KeyGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KeyGroup.GVK,
      ...toJson_KeyGroupProps(resolved),
    };
  }
}

/**
 * KeyGroup is the Schema for the KeyGroups API. Provides a CloudFront key group.
 *
 * @schema KeyGroup
 */
export interface KeyGroupProps {
  /**
   * @schema KeyGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * KeyGroupSpec defines the desired state of KeyGroup
   *
   * @schema KeyGroup#spec
   */
  readonly spec: KeyGroupSpec;

}

/**
 * Converts an object of type 'KeyGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyGroupProps(obj: KeyGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KeyGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KeyGroupSpec defines the desired state of KeyGroup
 *
 * @schema KeyGroupSpec
 */
export interface KeyGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema KeyGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: KeyGroupSpecDeletionPolicy;

  /**
   * @schema KeyGroupSpec#forProvider
   */
  readonly forProvider: KeyGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema KeyGroupSpec#initProvider
   */
  readonly initProvider?: KeyGroupSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema KeyGroupSpec#managementPolicies
   */
  readonly managementPolicies?: KeyGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema KeyGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: KeyGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema KeyGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: KeyGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema KeyGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: KeyGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'KeyGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyGroupSpec(obj: KeyGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_KeyGroupSpecForProvider(obj.forProvider),
    'initProvider': toJson_KeyGroupSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_KeyGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_KeyGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_KeyGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema KeyGroupSpecDeletionPolicy
 */
export enum KeyGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema KeyGroupSpecForProvider
 */
export interface KeyGroupSpecForProvider {
  /**
   * A comment to describe the key group..
   *
   * @schema KeyGroupSpecForProvider#comment
   */
  readonly comment?: string;

  /**
   * References to PublicKey to populate items.
   *
   * @schema KeyGroupSpecForProvider#itemRefs
   */
  readonly itemRefs?: KeyGroupSpecForProviderItemRefs[];

  /**
   * Selector for a list of PublicKey to populate items.
   *
   * @schema KeyGroupSpecForProvider#itemSelector
   */
  readonly itemSelector?: KeyGroupSpecForProviderItemSelector;

  /**
   * A list of the identifiers of the public keys in the key group.
   *
   * @schema KeyGroupSpecForProvider#items
   */
  readonly items?: string[];

  /**
   * A name to identify the key group.
   *
   * @schema KeyGroupSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema KeyGroupSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'KeyGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyGroupSpecForProvider(obj: KeyGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'itemRefs': obj.itemRefs?.map(y => toJson_KeyGroupSpecForProviderItemRefs(y)),
    'itemSelector': toJson_KeyGroupSpecForProviderItemSelector(obj.itemSelector),
    'items': obj.items?.map(y => y),
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema KeyGroupSpecInitProvider
 */
export interface KeyGroupSpecInitProvider {
  /**
   * A comment to describe the key group..
   *
   * @schema KeyGroupSpecInitProvider#comment
   */
  readonly comment?: string;

  /**
   * A name to identify the key group.
   *
   * @schema KeyGroupSpecInitProvider#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'KeyGroupSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyGroupSpecInitProvider(obj: KeyGroupSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema KeyGroupSpecManagementPolicies
 */
export enum KeyGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema KeyGroupSpecProviderConfigRef
 */
export interface KeyGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeyGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeyGroupSpecProviderConfigRef#policy
   */
  readonly policy?: KeyGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'KeyGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyGroupSpecProviderConfigRef(obj: KeyGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeyGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema KeyGroupSpecPublishConnectionDetailsTo
 */
export interface KeyGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema KeyGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: KeyGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema KeyGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: KeyGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema KeyGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'KeyGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyGroupSpecPublishConnectionDetailsTo(obj: KeyGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_KeyGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_KeyGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema KeyGroupSpecWriteConnectionSecretToRef
 */
export interface KeyGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema KeyGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema KeyGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'KeyGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyGroupSpecWriteConnectionSecretToRef(obj: KeyGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema KeyGroupSpecForProviderItemRefs
 */
export interface KeyGroupSpecForProviderItemRefs {
  /**
   * Name of the referenced object.
   *
   * @schema KeyGroupSpecForProviderItemRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeyGroupSpecForProviderItemRefs#policy
   */
  readonly policy?: KeyGroupSpecForProviderItemRefsPolicy;

}

/**
 * Converts an object of type 'KeyGroupSpecForProviderItemRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyGroupSpecForProviderItemRefs(obj: KeyGroupSpecForProviderItemRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeyGroupSpecForProviderItemRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of PublicKey to populate items.
 *
 * @schema KeyGroupSpecForProviderItemSelector
 */
export interface KeyGroupSpecForProviderItemSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema KeyGroupSpecForProviderItemSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema KeyGroupSpecForProviderItemSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema KeyGroupSpecForProviderItemSelector#policy
   */
  readonly policy?: KeyGroupSpecForProviderItemSelectorPolicy;

}

/**
 * Converts an object of type 'KeyGroupSpecForProviderItemSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyGroupSpecForProviderItemSelector(obj: KeyGroupSpecForProviderItemSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_KeyGroupSpecForProviderItemSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema KeyGroupSpecProviderConfigRefPolicy
 */
export interface KeyGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeyGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: KeyGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeyGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: KeyGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'KeyGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyGroupSpecProviderConfigRefPolicy(obj: KeyGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema KeyGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface KeyGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeyGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeyGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: KeyGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'KeyGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyGroupSpecPublishConnectionDetailsToConfigRef(obj: KeyGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeyGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema KeyGroupSpecPublishConnectionDetailsToMetadata
 */
export interface KeyGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema KeyGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema KeyGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema KeyGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KeyGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyGroupSpecPublishConnectionDetailsToMetadata(obj: KeyGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema KeyGroupSpecForProviderItemRefsPolicy
 */
export interface KeyGroupSpecForProviderItemRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeyGroupSpecForProviderItemRefsPolicy#resolution
   */
  readonly resolution?: KeyGroupSpecForProviderItemRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeyGroupSpecForProviderItemRefsPolicy#resolve
   */
  readonly resolve?: KeyGroupSpecForProviderItemRefsPolicyResolve;

}

/**
 * Converts an object of type 'KeyGroupSpecForProviderItemRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyGroupSpecForProviderItemRefsPolicy(obj: KeyGroupSpecForProviderItemRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema KeyGroupSpecForProviderItemSelectorPolicy
 */
export interface KeyGroupSpecForProviderItemSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeyGroupSpecForProviderItemSelectorPolicy#resolution
   */
  readonly resolution?: KeyGroupSpecForProviderItemSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeyGroupSpecForProviderItemSelectorPolicy#resolve
   */
  readonly resolve?: KeyGroupSpecForProviderItemSelectorPolicyResolve;

}

/**
 * Converts an object of type 'KeyGroupSpecForProviderItemSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyGroupSpecForProviderItemSelectorPolicy(obj: KeyGroupSpecForProviderItemSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeyGroupSpecProviderConfigRefPolicyResolution
 */
export enum KeyGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeyGroupSpecProviderConfigRefPolicyResolve
 */
export enum KeyGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema KeyGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface KeyGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeyGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: KeyGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeyGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: KeyGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'KeyGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: KeyGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeyGroupSpecForProviderItemRefsPolicyResolution
 */
export enum KeyGroupSpecForProviderItemRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeyGroupSpecForProviderItemRefsPolicyResolve
 */
export enum KeyGroupSpecForProviderItemRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeyGroupSpecForProviderItemSelectorPolicyResolution
 */
export enum KeyGroupSpecForProviderItemSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeyGroupSpecForProviderItemSelectorPolicyResolve
 */
export enum KeyGroupSpecForProviderItemSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeyGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum KeyGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeyGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum KeyGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MonitoringSubscription is the Schema for the MonitoringSubscriptions API. Provides a CloudFront monitoring subscription resource.
 *
 * @schema MonitoringSubscription
 */
export class MonitoringSubscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MonitoringSubscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudfront.aws.upbound.io/v1beta1',
    kind: 'MonitoringSubscription',
  }

  /**
   * Renders a Kubernetes manifest for "MonitoringSubscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MonitoringSubscriptionProps): any {
    return {
      ...MonitoringSubscription.GVK,
      ...toJson_MonitoringSubscriptionProps(props),
    };
  }

  /**
   * Defines a "MonitoringSubscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MonitoringSubscriptionProps) {
    super(scope, id, {
      ...MonitoringSubscription.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MonitoringSubscription.GVK,
      ...toJson_MonitoringSubscriptionProps(resolved),
    };
  }
}

/**
 * MonitoringSubscription is the Schema for the MonitoringSubscriptions API. Provides a CloudFront monitoring subscription resource.
 *
 * @schema MonitoringSubscription
 */
export interface MonitoringSubscriptionProps {
  /**
   * @schema MonitoringSubscription#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MonitoringSubscriptionSpec defines the desired state of MonitoringSubscription
   *
   * @schema MonitoringSubscription#spec
   */
  readonly spec: MonitoringSubscriptionSpec;

}

/**
 * Converts an object of type 'MonitoringSubscriptionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionProps(obj: MonitoringSubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MonitoringSubscriptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MonitoringSubscriptionSpec defines the desired state of MonitoringSubscription
 *
 * @schema MonitoringSubscriptionSpec
 */
export interface MonitoringSubscriptionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MonitoringSubscriptionSpec#deletionPolicy
   */
  readonly deletionPolicy?: MonitoringSubscriptionSpecDeletionPolicy;

  /**
   * @schema MonitoringSubscriptionSpec#forProvider
   */
  readonly forProvider: MonitoringSubscriptionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema MonitoringSubscriptionSpec#initProvider
   */
  readonly initProvider?: MonitoringSubscriptionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema MonitoringSubscriptionSpec#managementPolicies
   */
  readonly managementPolicies?: MonitoringSubscriptionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MonitoringSubscriptionSpec#providerConfigRef
   */
  readonly providerConfigRef?: MonitoringSubscriptionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MonitoringSubscriptionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MonitoringSubscriptionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MonitoringSubscriptionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MonitoringSubscriptionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpec(obj: MonitoringSubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MonitoringSubscriptionSpecForProvider(obj.forProvider),
    'initProvider': toJson_MonitoringSubscriptionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_MonitoringSubscriptionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_MonitoringSubscriptionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MonitoringSubscriptionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MonitoringSubscriptionSpecDeletionPolicy
 */
export enum MonitoringSubscriptionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MonitoringSubscriptionSpecForProvider
 */
export interface MonitoringSubscriptionSpecForProvider {
  /**
   * The ID of the distribution that you are enabling metrics for.
   *
   * @schema MonitoringSubscriptionSpecForProvider#distributionId
   */
  readonly distributionId?: string;

  /**
   * Reference to a Distribution in cloudfront to populate distributionId.
   *
   * @schema MonitoringSubscriptionSpecForProvider#distributionIdRef
   */
  readonly distributionIdRef?: MonitoringSubscriptionSpecForProviderDistributionIdRef;

  /**
   * Selector for a Distribution in cloudfront to populate distributionId.
   *
   * @schema MonitoringSubscriptionSpecForProvider#distributionIdSelector
   */
  readonly distributionIdSelector?: MonitoringSubscriptionSpecForProviderDistributionIdSelector;

  /**
   * A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
   *
   * @schema MonitoringSubscriptionSpecForProvider#monitoringSubscription
   */
  readonly monitoringSubscription?: MonitoringSubscriptionSpecForProviderMonitoringSubscription[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MonitoringSubscriptionSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpecForProvider(obj: MonitoringSubscriptionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distributionId': obj.distributionId,
    'distributionIdRef': toJson_MonitoringSubscriptionSpecForProviderDistributionIdRef(obj.distributionIdRef),
    'distributionIdSelector': toJson_MonitoringSubscriptionSpecForProviderDistributionIdSelector(obj.distributionIdSelector),
    'monitoringSubscription': obj.monitoringSubscription?.map(y => toJson_MonitoringSubscriptionSpecForProviderMonitoringSubscription(y)),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema MonitoringSubscriptionSpecInitProvider
 */
export interface MonitoringSubscriptionSpecInitProvider {
  /**
   * A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
   *
   * @schema MonitoringSubscriptionSpecInitProvider#monitoringSubscription
   */
  readonly monitoringSubscription?: MonitoringSubscriptionSpecInitProviderMonitoringSubscription[];

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpecInitProvider(obj: MonitoringSubscriptionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitoringSubscription': obj.monitoringSubscription?.map(y => toJson_MonitoringSubscriptionSpecInitProviderMonitoringSubscription(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema MonitoringSubscriptionSpecManagementPolicies
 */
export enum MonitoringSubscriptionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MonitoringSubscriptionSpecProviderConfigRef
 */
export interface MonitoringSubscriptionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MonitoringSubscriptionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MonitoringSubscriptionSpecProviderConfigRef#policy
   */
  readonly policy?: MonitoringSubscriptionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpecProviderConfigRef(obj: MonitoringSubscriptionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MonitoringSubscriptionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MonitoringSubscriptionSpecPublishConnectionDetailsTo
 */
export interface MonitoringSubscriptionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MonitoringSubscriptionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MonitoringSubscriptionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MonitoringSubscriptionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MonitoringSubscriptionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpecPublishConnectionDetailsTo(obj: MonitoringSubscriptionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MonitoringSubscriptionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MonitoringSubscriptionSpecWriteConnectionSecretToRef
 */
export interface MonitoringSubscriptionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MonitoringSubscriptionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MonitoringSubscriptionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpecWriteConnectionSecretToRef(obj: MonitoringSubscriptionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Distribution in cloudfront to populate distributionId.
 *
 * @schema MonitoringSubscriptionSpecForProviderDistributionIdRef
 */
export interface MonitoringSubscriptionSpecForProviderDistributionIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MonitoringSubscriptionSpecForProviderDistributionIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MonitoringSubscriptionSpecForProviderDistributionIdRef#policy
   */
  readonly policy?: MonitoringSubscriptionSpecForProviderDistributionIdRefPolicy;

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpecForProviderDistributionIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpecForProviderDistributionIdRef(obj: MonitoringSubscriptionSpecForProviderDistributionIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MonitoringSubscriptionSpecForProviderDistributionIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Distribution in cloudfront to populate distributionId.
 *
 * @schema MonitoringSubscriptionSpecForProviderDistributionIdSelector
 */
export interface MonitoringSubscriptionSpecForProviderDistributionIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MonitoringSubscriptionSpecForProviderDistributionIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MonitoringSubscriptionSpecForProviderDistributionIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MonitoringSubscriptionSpecForProviderDistributionIdSelector#policy
   */
  readonly policy?: MonitoringSubscriptionSpecForProviderDistributionIdSelectorPolicy;

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpecForProviderDistributionIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpecForProviderDistributionIdSelector(obj: MonitoringSubscriptionSpecForProviderDistributionIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MonitoringSubscriptionSpecForProviderDistributionIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringSubscriptionSpecForProviderMonitoringSubscription
 */
export interface MonitoringSubscriptionSpecForProviderMonitoringSubscription {
  /**
   * A subscription configuration for additional CloudWatch metrics. See below.
   *
   * @schema MonitoringSubscriptionSpecForProviderMonitoringSubscription#realtimeMetricsSubscriptionConfig
   */
  readonly realtimeMetricsSubscriptionConfig?: MonitoringSubscriptionSpecForProviderMonitoringSubscriptionRealtimeMetricsSubscriptionConfig[];

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpecForProviderMonitoringSubscription' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpecForProviderMonitoringSubscription(obj: MonitoringSubscriptionSpecForProviderMonitoringSubscription | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'realtimeMetricsSubscriptionConfig': obj.realtimeMetricsSubscriptionConfig?.map(y => toJson_MonitoringSubscriptionSpecForProviderMonitoringSubscriptionRealtimeMetricsSubscriptionConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringSubscriptionSpecInitProviderMonitoringSubscription
 */
export interface MonitoringSubscriptionSpecInitProviderMonitoringSubscription {
  /**
   * A subscription configuration for additional CloudWatch metrics. See below.
   *
   * @schema MonitoringSubscriptionSpecInitProviderMonitoringSubscription#realtimeMetricsSubscriptionConfig
   */
  readonly realtimeMetricsSubscriptionConfig?: MonitoringSubscriptionSpecInitProviderMonitoringSubscriptionRealtimeMetricsSubscriptionConfig[];

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpecInitProviderMonitoringSubscription' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpecInitProviderMonitoringSubscription(obj: MonitoringSubscriptionSpecInitProviderMonitoringSubscription | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'realtimeMetricsSubscriptionConfig': obj.realtimeMetricsSubscriptionConfig?.map(y => toJson_MonitoringSubscriptionSpecInitProviderMonitoringSubscriptionRealtimeMetricsSubscriptionConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MonitoringSubscriptionSpecProviderConfigRefPolicy
 */
export interface MonitoringSubscriptionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MonitoringSubscriptionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MonitoringSubscriptionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MonitoringSubscriptionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MonitoringSubscriptionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpecProviderConfigRefPolicy(obj: MonitoringSubscriptionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRef
 */
export interface MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRef(obj: MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MonitoringSubscriptionSpecPublishConnectionDetailsToMetadata
 */
export interface MonitoringSubscriptionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MonitoringSubscriptionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MonitoringSubscriptionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MonitoringSubscriptionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpecPublishConnectionDetailsToMetadata(obj: MonitoringSubscriptionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MonitoringSubscriptionSpecForProviderDistributionIdRefPolicy
 */
export interface MonitoringSubscriptionSpecForProviderDistributionIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MonitoringSubscriptionSpecForProviderDistributionIdRefPolicy#resolution
   */
  readonly resolution?: MonitoringSubscriptionSpecForProviderDistributionIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MonitoringSubscriptionSpecForProviderDistributionIdRefPolicy#resolve
   */
  readonly resolve?: MonitoringSubscriptionSpecForProviderDistributionIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpecForProviderDistributionIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpecForProviderDistributionIdRefPolicy(obj: MonitoringSubscriptionSpecForProviderDistributionIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MonitoringSubscriptionSpecForProviderDistributionIdSelectorPolicy
 */
export interface MonitoringSubscriptionSpecForProviderDistributionIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MonitoringSubscriptionSpecForProviderDistributionIdSelectorPolicy#resolution
   */
  readonly resolution?: MonitoringSubscriptionSpecForProviderDistributionIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MonitoringSubscriptionSpecForProviderDistributionIdSelectorPolicy#resolve
   */
  readonly resolve?: MonitoringSubscriptionSpecForProviderDistributionIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpecForProviderDistributionIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpecForProviderDistributionIdSelectorPolicy(obj: MonitoringSubscriptionSpecForProviderDistributionIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringSubscriptionSpecForProviderMonitoringSubscriptionRealtimeMetricsSubscriptionConfig
 */
export interface MonitoringSubscriptionSpecForProviderMonitoringSubscriptionRealtimeMetricsSubscriptionConfig {
  /**
   * A flag that indicates whether additional CloudWatch metrics are enabled for a given CloudFront distribution. Valid values are Enabled and Disabled. See below.
   *
   * @schema MonitoringSubscriptionSpecForProviderMonitoringSubscriptionRealtimeMetricsSubscriptionConfig#realtimeMetricsSubscriptionStatus
   */
  readonly realtimeMetricsSubscriptionStatus?: string;

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpecForProviderMonitoringSubscriptionRealtimeMetricsSubscriptionConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpecForProviderMonitoringSubscriptionRealtimeMetricsSubscriptionConfig(obj: MonitoringSubscriptionSpecForProviderMonitoringSubscriptionRealtimeMetricsSubscriptionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'realtimeMetricsSubscriptionStatus': obj.realtimeMetricsSubscriptionStatus,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringSubscriptionSpecInitProviderMonitoringSubscriptionRealtimeMetricsSubscriptionConfig
 */
export interface MonitoringSubscriptionSpecInitProviderMonitoringSubscriptionRealtimeMetricsSubscriptionConfig {
  /**
   * A flag that indicates whether additional CloudWatch metrics are enabled for a given CloudFront distribution. Valid values are Enabled and Disabled. See below.
   *
   * @schema MonitoringSubscriptionSpecInitProviderMonitoringSubscriptionRealtimeMetricsSubscriptionConfig#realtimeMetricsSubscriptionStatus
   */
  readonly realtimeMetricsSubscriptionStatus?: string;

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpecInitProviderMonitoringSubscriptionRealtimeMetricsSubscriptionConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpecInitProviderMonitoringSubscriptionRealtimeMetricsSubscriptionConfig(obj: MonitoringSubscriptionSpecInitProviderMonitoringSubscriptionRealtimeMetricsSubscriptionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'realtimeMetricsSubscriptionStatus': obj.realtimeMetricsSubscriptionStatus,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MonitoringSubscriptionSpecProviderConfigRefPolicyResolution
 */
export enum MonitoringSubscriptionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MonitoringSubscriptionSpecProviderConfigRefPolicyResolve
 */
export enum MonitoringSubscriptionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj: MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MonitoringSubscriptionSpecForProviderDistributionIdRefPolicyResolution
 */
export enum MonitoringSubscriptionSpecForProviderDistributionIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MonitoringSubscriptionSpecForProviderDistributionIdRefPolicyResolve
 */
export enum MonitoringSubscriptionSpecForProviderDistributionIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MonitoringSubscriptionSpecForProviderDistributionIdSelectorPolicyResolution
 */
export enum MonitoringSubscriptionSpecForProviderDistributionIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MonitoringSubscriptionSpecForProviderDistributionIdSelectorPolicyResolve
 */
export enum MonitoringSubscriptionSpecForProviderDistributionIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MonitoringSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * OriginAccessControl is the Schema for the OriginAccessControls API.
 *
 * @schema OriginAccessControl
 */
export class OriginAccessControl extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OriginAccessControl"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudfront.aws.upbound.io/v1beta1',
    kind: 'OriginAccessControl',
  }

  /**
   * Renders a Kubernetes manifest for "OriginAccessControl".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OriginAccessControlProps): any {
    return {
      ...OriginAccessControl.GVK,
      ...toJson_OriginAccessControlProps(props),
    };
  }

  /**
   * Defines a "OriginAccessControl" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OriginAccessControlProps) {
    super(scope, id, {
      ...OriginAccessControl.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OriginAccessControl.GVK,
      ...toJson_OriginAccessControlProps(resolved),
    };
  }
}

/**
 * OriginAccessControl is the Schema for the OriginAccessControls API.
 *
 * @schema OriginAccessControl
 */
export interface OriginAccessControlProps {
  /**
   * @schema OriginAccessControl#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OriginAccessControlSpec defines the desired state of OriginAccessControl
   *
   * @schema OriginAccessControl#spec
   */
  readonly spec: OriginAccessControlSpec;

}

/**
 * Converts an object of type 'OriginAccessControlProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessControlProps(obj: OriginAccessControlProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OriginAccessControlSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OriginAccessControlSpec defines the desired state of OriginAccessControl
 *
 * @schema OriginAccessControlSpec
 */
export interface OriginAccessControlSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OriginAccessControlSpec#deletionPolicy
   */
  readonly deletionPolicy?: OriginAccessControlSpecDeletionPolicy;

  /**
   * @schema OriginAccessControlSpec#forProvider
   */
  readonly forProvider: OriginAccessControlSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema OriginAccessControlSpec#initProvider
   */
  readonly initProvider?: OriginAccessControlSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema OriginAccessControlSpec#managementPolicies
   */
  readonly managementPolicies?: OriginAccessControlSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema OriginAccessControlSpec#providerConfigRef
   */
  readonly providerConfigRef?: OriginAccessControlSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema OriginAccessControlSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: OriginAccessControlSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema OriginAccessControlSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: OriginAccessControlSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'OriginAccessControlSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessControlSpec(obj: OriginAccessControlSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_OriginAccessControlSpecForProvider(obj.forProvider),
    'initProvider': toJson_OriginAccessControlSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_OriginAccessControlSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_OriginAccessControlSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_OriginAccessControlSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OriginAccessControlSpecDeletionPolicy
 */
export enum OriginAccessControlSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema OriginAccessControlSpecForProvider
 */
export interface OriginAccessControlSpecForProvider {
  /**
   * The description of the Origin Access Control.
   *
   * @schema OriginAccessControlSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A name that identifies the Origin Access Control.
   *
   * @schema OriginAccessControlSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The type of origin that this Origin Access Control is for. Valid values are s3, and mediastore.
   *
   * @schema OriginAccessControlSpecForProvider#originAccessControlOriginType
   */
  readonly originAccessControlOriginType?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema OriginAccessControlSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies which requests CloudFront signs. Specify always for the most common use case. Allowed values: always, never, and no-override.
   *
   * @schema OriginAccessControlSpecForProvider#signingBehavior
   */
  readonly signingBehavior?: string;

  /**
   * Determines how CloudFront signs (authenticates) requests. The only valid value is sigv4.
   *
   * @schema OriginAccessControlSpecForProvider#signingProtocol
   */
  readonly signingProtocol?: string;

}

/**
 * Converts an object of type 'OriginAccessControlSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessControlSpecForProvider(obj: OriginAccessControlSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'originAccessControlOriginType': obj.originAccessControlOriginType,
    'region': obj.region,
    'signingBehavior': obj.signingBehavior,
    'signingProtocol': obj.signingProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema OriginAccessControlSpecInitProvider
 */
export interface OriginAccessControlSpecInitProvider {
  /**
   * The description of the Origin Access Control.
   *
   * @schema OriginAccessControlSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * A name that identifies the Origin Access Control.
   *
   * @schema OriginAccessControlSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The type of origin that this Origin Access Control is for. Valid values are s3, and mediastore.
   *
   * @schema OriginAccessControlSpecInitProvider#originAccessControlOriginType
   */
  readonly originAccessControlOriginType?: string;

  /**
   * Specifies which requests CloudFront signs. Specify always for the most common use case. Allowed values: always, never, and no-override.
   *
   * @schema OriginAccessControlSpecInitProvider#signingBehavior
   */
  readonly signingBehavior?: string;

  /**
   * Determines how CloudFront signs (authenticates) requests. The only valid value is sigv4.
   *
   * @schema OriginAccessControlSpecInitProvider#signingProtocol
   */
  readonly signingProtocol?: string;

}

/**
 * Converts an object of type 'OriginAccessControlSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessControlSpecInitProvider(obj: OriginAccessControlSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'originAccessControlOriginType': obj.originAccessControlOriginType,
    'signingBehavior': obj.signingBehavior,
    'signingProtocol': obj.signingProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema OriginAccessControlSpecManagementPolicies
 */
export enum OriginAccessControlSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema OriginAccessControlSpecProviderConfigRef
 */
export interface OriginAccessControlSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OriginAccessControlSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OriginAccessControlSpecProviderConfigRef#policy
   */
  readonly policy?: OriginAccessControlSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'OriginAccessControlSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessControlSpecProviderConfigRef(obj: OriginAccessControlSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OriginAccessControlSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema OriginAccessControlSpecPublishConnectionDetailsTo
 */
export interface OriginAccessControlSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema OriginAccessControlSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: OriginAccessControlSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema OriginAccessControlSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: OriginAccessControlSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema OriginAccessControlSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OriginAccessControlSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessControlSpecPublishConnectionDetailsTo(obj: OriginAccessControlSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_OriginAccessControlSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_OriginAccessControlSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema OriginAccessControlSpecWriteConnectionSecretToRef
 */
export interface OriginAccessControlSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema OriginAccessControlSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OriginAccessControlSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OriginAccessControlSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessControlSpecWriteConnectionSecretToRef(obj: OriginAccessControlSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OriginAccessControlSpecProviderConfigRefPolicy
 */
export interface OriginAccessControlSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OriginAccessControlSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: OriginAccessControlSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OriginAccessControlSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: OriginAccessControlSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OriginAccessControlSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessControlSpecProviderConfigRefPolicy(obj: OriginAccessControlSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema OriginAccessControlSpecPublishConnectionDetailsToConfigRef
 */
export interface OriginAccessControlSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OriginAccessControlSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OriginAccessControlSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: OriginAccessControlSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'OriginAccessControlSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessControlSpecPublishConnectionDetailsToConfigRef(obj: OriginAccessControlSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OriginAccessControlSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema OriginAccessControlSpecPublishConnectionDetailsToMetadata
 */
export interface OriginAccessControlSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema OriginAccessControlSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema OriginAccessControlSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema OriginAccessControlSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'OriginAccessControlSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessControlSpecPublishConnectionDetailsToMetadata(obj: OriginAccessControlSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OriginAccessControlSpecProviderConfigRefPolicyResolution
 */
export enum OriginAccessControlSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OriginAccessControlSpecProviderConfigRefPolicyResolve
 */
export enum OriginAccessControlSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema OriginAccessControlSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface OriginAccessControlSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OriginAccessControlSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: OriginAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OriginAccessControlSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: OriginAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OriginAccessControlSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessControlSpecPublishConnectionDetailsToConfigRefPolicy(obj: OriginAccessControlSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OriginAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum OriginAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OriginAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum OriginAccessControlSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * OriginAccessIdentity is the Schema for the OriginAccessIdentitys API. Provides a CloudFront origin access identity.
 *
 * @schema OriginAccessIdentity
 */
export class OriginAccessIdentity extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OriginAccessIdentity"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudfront.aws.upbound.io/v1beta1',
    kind: 'OriginAccessIdentity',
  }

  /**
   * Renders a Kubernetes manifest for "OriginAccessIdentity".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OriginAccessIdentityProps): any {
    return {
      ...OriginAccessIdentity.GVK,
      ...toJson_OriginAccessIdentityProps(props),
    };
  }

  /**
   * Defines a "OriginAccessIdentity" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OriginAccessIdentityProps) {
    super(scope, id, {
      ...OriginAccessIdentity.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OriginAccessIdentity.GVK,
      ...toJson_OriginAccessIdentityProps(resolved),
    };
  }
}

/**
 * OriginAccessIdentity is the Schema for the OriginAccessIdentitys API. Provides a CloudFront origin access identity.
 *
 * @schema OriginAccessIdentity
 */
export interface OriginAccessIdentityProps {
  /**
   * @schema OriginAccessIdentity#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OriginAccessIdentitySpec defines the desired state of OriginAccessIdentity
   *
   * @schema OriginAccessIdentity#spec
   */
  readonly spec: OriginAccessIdentitySpec;

}

/**
 * Converts an object of type 'OriginAccessIdentityProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessIdentityProps(obj: OriginAccessIdentityProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OriginAccessIdentitySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OriginAccessIdentitySpec defines the desired state of OriginAccessIdentity
 *
 * @schema OriginAccessIdentitySpec
 */
export interface OriginAccessIdentitySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OriginAccessIdentitySpec#deletionPolicy
   */
  readonly deletionPolicy?: OriginAccessIdentitySpecDeletionPolicy;

  /**
   * @schema OriginAccessIdentitySpec#forProvider
   */
  readonly forProvider: OriginAccessIdentitySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema OriginAccessIdentitySpec#initProvider
   */
  readonly initProvider?: OriginAccessIdentitySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema OriginAccessIdentitySpec#managementPolicies
   */
  readonly managementPolicies?: OriginAccessIdentitySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema OriginAccessIdentitySpec#providerConfigRef
   */
  readonly providerConfigRef?: OriginAccessIdentitySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema OriginAccessIdentitySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: OriginAccessIdentitySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema OriginAccessIdentitySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: OriginAccessIdentitySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'OriginAccessIdentitySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessIdentitySpec(obj: OriginAccessIdentitySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_OriginAccessIdentitySpecForProvider(obj.forProvider),
    'initProvider': toJson_OriginAccessIdentitySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_OriginAccessIdentitySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_OriginAccessIdentitySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_OriginAccessIdentitySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OriginAccessIdentitySpecDeletionPolicy
 */
export enum OriginAccessIdentitySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema OriginAccessIdentitySpecForProvider
 */
export interface OriginAccessIdentitySpecForProvider {
  /**
   * An optional comment for the origin access identity.
   *
   * @schema OriginAccessIdentitySpecForProvider#comment
   */
  readonly comment?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema OriginAccessIdentitySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'OriginAccessIdentitySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessIdentitySpecForProvider(obj: OriginAccessIdentitySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema OriginAccessIdentitySpecInitProvider
 */
export interface OriginAccessIdentitySpecInitProvider {
  /**
   * An optional comment for the origin access identity.
   *
   * @schema OriginAccessIdentitySpecInitProvider#comment
   */
  readonly comment?: string;

}

/**
 * Converts an object of type 'OriginAccessIdentitySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessIdentitySpecInitProvider(obj: OriginAccessIdentitySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema OriginAccessIdentitySpecManagementPolicies
 */
export enum OriginAccessIdentitySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema OriginAccessIdentitySpecProviderConfigRef
 */
export interface OriginAccessIdentitySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OriginAccessIdentitySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OriginAccessIdentitySpecProviderConfigRef#policy
   */
  readonly policy?: OriginAccessIdentitySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'OriginAccessIdentitySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessIdentitySpecProviderConfigRef(obj: OriginAccessIdentitySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OriginAccessIdentitySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema OriginAccessIdentitySpecPublishConnectionDetailsTo
 */
export interface OriginAccessIdentitySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema OriginAccessIdentitySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: OriginAccessIdentitySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema OriginAccessIdentitySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: OriginAccessIdentitySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema OriginAccessIdentitySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OriginAccessIdentitySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessIdentitySpecPublishConnectionDetailsTo(obj: OriginAccessIdentitySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_OriginAccessIdentitySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_OriginAccessIdentitySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema OriginAccessIdentitySpecWriteConnectionSecretToRef
 */
export interface OriginAccessIdentitySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema OriginAccessIdentitySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OriginAccessIdentitySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OriginAccessIdentitySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessIdentitySpecWriteConnectionSecretToRef(obj: OriginAccessIdentitySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OriginAccessIdentitySpecProviderConfigRefPolicy
 */
export interface OriginAccessIdentitySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OriginAccessIdentitySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: OriginAccessIdentitySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OriginAccessIdentitySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: OriginAccessIdentitySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OriginAccessIdentitySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessIdentitySpecProviderConfigRefPolicy(obj: OriginAccessIdentitySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema OriginAccessIdentitySpecPublishConnectionDetailsToConfigRef
 */
export interface OriginAccessIdentitySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OriginAccessIdentitySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OriginAccessIdentitySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: OriginAccessIdentitySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'OriginAccessIdentitySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessIdentitySpecPublishConnectionDetailsToConfigRef(obj: OriginAccessIdentitySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OriginAccessIdentitySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema OriginAccessIdentitySpecPublishConnectionDetailsToMetadata
 */
export interface OriginAccessIdentitySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema OriginAccessIdentitySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema OriginAccessIdentitySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema OriginAccessIdentitySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'OriginAccessIdentitySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessIdentitySpecPublishConnectionDetailsToMetadata(obj: OriginAccessIdentitySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OriginAccessIdentitySpecProviderConfigRefPolicyResolution
 */
export enum OriginAccessIdentitySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OriginAccessIdentitySpecProviderConfigRefPolicyResolve
 */
export enum OriginAccessIdentitySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema OriginAccessIdentitySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface OriginAccessIdentitySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OriginAccessIdentitySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: OriginAccessIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OriginAccessIdentitySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: OriginAccessIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OriginAccessIdentitySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginAccessIdentitySpecPublishConnectionDetailsToConfigRefPolicy(obj: OriginAccessIdentitySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OriginAccessIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum OriginAccessIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OriginAccessIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum OriginAccessIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * OriginRequestPolicy is the Schema for the OriginRequestPolicys API. Determines the values that CloudFront includes in requests that it sends to the origin.
 *
 * @schema OriginRequestPolicy
 */
export class OriginRequestPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OriginRequestPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudfront.aws.upbound.io/v1beta1',
    kind: 'OriginRequestPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "OriginRequestPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OriginRequestPolicyProps): any {
    return {
      ...OriginRequestPolicy.GVK,
      ...toJson_OriginRequestPolicyProps(props),
    };
  }

  /**
   * Defines a "OriginRequestPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OriginRequestPolicyProps) {
    super(scope, id, {
      ...OriginRequestPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OriginRequestPolicy.GVK,
      ...toJson_OriginRequestPolicyProps(resolved),
    };
  }
}

/**
 * OriginRequestPolicy is the Schema for the OriginRequestPolicys API. Determines the values that CloudFront includes in requests that it sends to the origin.
 *
 * @schema OriginRequestPolicy
 */
export interface OriginRequestPolicyProps {
  /**
   * @schema OriginRequestPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OriginRequestPolicySpec defines the desired state of OriginRequestPolicy
   *
   * @schema OriginRequestPolicy#spec
   */
  readonly spec: OriginRequestPolicySpec;

}

/**
 * Converts an object of type 'OriginRequestPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicyProps(obj: OriginRequestPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OriginRequestPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OriginRequestPolicySpec defines the desired state of OriginRequestPolicy
 *
 * @schema OriginRequestPolicySpec
 */
export interface OriginRequestPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OriginRequestPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: OriginRequestPolicySpecDeletionPolicy;

  /**
   * @schema OriginRequestPolicySpec#forProvider
   */
  readonly forProvider: OriginRequestPolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema OriginRequestPolicySpec#initProvider
   */
  readonly initProvider?: OriginRequestPolicySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema OriginRequestPolicySpec#managementPolicies
   */
  readonly managementPolicies?: OriginRequestPolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema OriginRequestPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: OriginRequestPolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema OriginRequestPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: OriginRequestPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema OriginRequestPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: OriginRequestPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'OriginRequestPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpec(obj: OriginRequestPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_OriginRequestPolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_OriginRequestPolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_OriginRequestPolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_OriginRequestPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_OriginRequestPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OriginRequestPolicySpecDeletionPolicy
 */
export enum OriginRequestPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema OriginRequestPolicySpecForProvider
 */
export interface OriginRequestPolicySpecForProvider {
  /**
   * Comment to describe the origin request policy.
   *
   * @schema OriginRequestPolicySpecForProvider#comment
   */
  readonly comment?: string;

  /**
   * Object that determines whether any cookies in viewer requests (and if so, which cookies) are included in the origin request key and automatically included in requests that CloudFront sends to the origin. See Cookies Config for more information.
   *
   * @schema OriginRequestPolicySpecForProvider#cookiesConfig
   */
  readonly cookiesConfig?: OriginRequestPolicySpecForProviderCookiesConfig[];

  /**
   * Object that determines whether any HTTP headers (and if so, which headers) are included in the origin request key and automatically included in requests that CloudFront sends to the origin. See Headers Config for more information.
   *
   * @schema OriginRequestPolicySpecForProvider#headersConfig
   */
  readonly headersConfig?: OriginRequestPolicySpecForProviderHeadersConfig[];

  /**
   * Object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in the origin request key and automatically included in requests that CloudFront sends to the origin. See Query String Config for more information.
   *
   * @schema OriginRequestPolicySpecForProvider#queryStringsConfig
   */
  readonly queryStringsConfig?: OriginRequestPolicySpecForProviderQueryStringsConfig[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema OriginRequestPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'OriginRequestPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecForProvider(obj: OriginRequestPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'cookiesConfig': obj.cookiesConfig?.map(y => toJson_OriginRequestPolicySpecForProviderCookiesConfig(y)),
    'headersConfig': obj.headersConfig?.map(y => toJson_OriginRequestPolicySpecForProviderHeadersConfig(y)),
    'queryStringsConfig': obj.queryStringsConfig?.map(y => toJson_OriginRequestPolicySpecForProviderQueryStringsConfig(y)),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema OriginRequestPolicySpecInitProvider
 */
export interface OriginRequestPolicySpecInitProvider {
  /**
   * Comment to describe the origin request policy.
   *
   * @schema OriginRequestPolicySpecInitProvider#comment
   */
  readonly comment?: string;

  /**
   * Object that determines whether any cookies in viewer requests (and if so, which cookies) are included in the origin request key and automatically included in requests that CloudFront sends to the origin. See Cookies Config for more information.
   *
   * @schema OriginRequestPolicySpecInitProvider#cookiesConfig
   */
  readonly cookiesConfig?: OriginRequestPolicySpecInitProviderCookiesConfig[];

  /**
   * Object that determines whether any HTTP headers (and if so, which headers) are included in the origin request key and automatically included in requests that CloudFront sends to the origin. See Headers Config for more information.
   *
   * @schema OriginRequestPolicySpecInitProvider#headersConfig
   */
  readonly headersConfig?: OriginRequestPolicySpecInitProviderHeadersConfig[];

  /**
   * Object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in the origin request key and automatically included in requests that CloudFront sends to the origin. See Query String Config for more information.
   *
   * @schema OriginRequestPolicySpecInitProvider#queryStringsConfig
   */
  readonly queryStringsConfig?: OriginRequestPolicySpecInitProviderQueryStringsConfig[];

}

/**
 * Converts an object of type 'OriginRequestPolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecInitProvider(obj: OriginRequestPolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'cookiesConfig': obj.cookiesConfig?.map(y => toJson_OriginRequestPolicySpecInitProviderCookiesConfig(y)),
    'headersConfig': obj.headersConfig?.map(y => toJson_OriginRequestPolicySpecInitProviderHeadersConfig(y)),
    'queryStringsConfig': obj.queryStringsConfig?.map(y => toJson_OriginRequestPolicySpecInitProviderQueryStringsConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema OriginRequestPolicySpecManagementPolicies
 */
export enum OriginRequestPolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema OriginRequestPolicySpecProviderConfigRef
 */
export interface OriginRequestPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OriginRequestPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OriginRequestPolicySpecProviderConfigRef#policy
   */
  readonly policy?: OriginRequestPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'OriginRequestPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecProviderConfigRef(obj: OriginRequestPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OriginRequestPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema OriginRequestPolicySpecPublishConnectionDetailsTo
 */
export interface OriginRequestPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema OriginRequestPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: OriginRequestPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema OriginRequestPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: OriginRequestPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema OriginRequestPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OriginRequestPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecPublishConnectionDetailsTo(obj: OriginRequestPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_OriginRequestPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_OriginRequestPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema OriginRequestPolicySpecWriteConnectionSecretToRef
 */
export interface OriginRequestPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema OriginRequestPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OriginRequestPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OriginRequestPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecWriteConnectionSecretToRef(obj: OriginRequestPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OriginRequestPolicySpecForProviderCookiesConfig
 */
export interface OriginRequestPolicySpecForProviderCookiesConfig {
  /**
   * @schema OriginRequestPolicySpecForProviderCookiesConfig#cookieBehavior
   */
  readonly cookieBehavior?: string;

  /**
   * @schema OriginRequestPolicySpecForProviderCookiesConfig#cookies
   */
  readonly cookies?: OriginRequestPolicySpecForProviderCookiesConfigCookies[];

}

/**
 * Converts an object of type 'OriginRequestPolicySpecForProviderCookiesConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecForProviderCookiesConfig(obj: OriginRequestPolicySpecForProviderCookiesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookieBehavior': obj.cookieBehavior,
    'cookies': obj.cookies?.map(y => toJson_OriginRequestPolicySpecForProviderCookiesConfigCookies(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OriginRequestPolicySpecForProviderHeadersConfig
 */
export interface OriginRequestPolicySpecForProviderHeadersConfig {
  /**
   * @schema OriginRequestPolicySpecForProviderHeadersConfig#headerBehavior
   */
  readonly headerBehavior?: string;

  /**
   * @schema OriginRequestPolicySpecForProviderHeadersConfig#headers
   */
  readonly headers?: OriginRequestPolicySpecForProviderHeadersConfigHeaders[];

}

/**
 * Converts an object of type 'OriginRequestPolicySpecForProviderHeadersConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecForProviderHeadersConfig(obj: OriginRequestPolicySpecForProviderHeadersConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerBehavior': obj.headerBehavior,
    'headers': obj.headers?.map(y => toJson_OriginRequestPolicySpecForProviderHeadersConfigHeaders(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OriginRequestPolicySpecForProviderQueryStringsConfig
 */
export interface OriginRequestPolicySpecForProviderQueryStringsConfig {
  /**
   * @schema OriginRequestPolicySpecForProviderQueryStringsConfig#queryStringBehavior
   */
  readonly queryStringBehavior?: string;

  /**
   * @schema OriginRequestPolicySpecForProviderQueryStringsConfig#queryStrings
   */
  readonly queryStrings?: OriginRequestPolicySpecForProviderQueryStringsConfigQueryStrings[];

}

/**
 * Converts an object of type 'OriginRequestPolicySpecForProviderQueryStringsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecForProviderQueryStringsConfig(obj: OriginRequestPolicySpecForProviderQueryStringsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'queryStringBehavior': obj.queryStringBehavior,
    'queryStrings': obj.queryStrings?.map(y => toJson_OriginRequestPolicySpecForProviderQueryStringsConfigQueryStrings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OriginRequestPolicySpecInitProviderCookiesConfig
 */
export interface OriginRequestPolicySpecInitProviderCookiesConfig {
  /**
   * @schema OriginRequestPolicySpecInitProviderCookiesConfig#cookieBehavior
   */
  readonly cookieBehavior?: string;

  /**
   * @schema OriginRequestPolicySpecInitProviderCookiesConfig#cookies
   */
  readonly cookies?: OriginRequestPolicySpecInitProviderCookiesConfigCookies[];

}

/**
 * Converts an object of type 'OriginRequestPolicySpecInitProviderCookiesConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecInitProviderCookiesConfig(obj: OriginRequestPolicySpecInitProviderCookiesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookieBehavior': obj.cookieBehavior,
    'cookies': obj.cookies?.map(y => toJson_OriginRequestPolicySpecInitProviderCookiesConfigCookies(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OriginRequestPolicySpecInitProviderHeadersConfig
 */
export interface OriginRequestPolicySpecInitProviderHeadersConfig {
  /**
   * @schema OriginRequestPolicySpecInitProviderHeadersConfig#headerBehavior
   */
  readonly headerBehavior?: string;

  /**
   * @schema OriginRequestPolicySpecInitProviderHeadersConfig#headers
   */
  readonly headers?: OriginRequestPolicySpecInitProviderHeadersConfigHeaders[];

}

/**
 * Converts an object of type 'OriginRequestPolicySpecInitProviderHeadersConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecInitProviderHeadersConfig(obj: OriginRequestPolicySpecInitProviderHeadersConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerBehavior': obj.headerBehavior,
    'headers': obj.headers?.map(y => toJson_OriginRequestPolicySpecInitProviderHeadersConfigHeaders(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OriginRequestPolicySpecInitProviderQueryStringsConfig
 */
export interface OriginRequestPolicySpecInitProviderQueryStringsConfig {
  /**
   * @schema OriginRequestPolicySpecInitProviderQueryStringsConfig#queryStringBehavior
   */
  readonly queryStringBehavior?: string;

  /**
   * @schema OriginRequestPolicySpecInitProviderQueryStringsConfig#queryStrings
   */
  readonly queryStrings?: OriginRequestPolicySpecInitProviderQueryStringsConfigQueryStrings[];

}

/**
 * Converts an object of type 'OriginRequestPolicySpecInitProviderQueryStringsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecInitProviderQueryStringsConfig(obj: OriginRequestPolicySpecInitProviderQueryStringsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'queryStringBehavior': obj.queryStringBehavior,
    'queryStrings': obj.queryStrings?.map(y => toJson_OriginRequestPolicySpecInitProviderQueryStringsConfigQueryStrings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OriginRequestPolicySpecProviderConfigRefPolicy
 */
export interface OriginRequestPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OriginRequestPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: OriginRequestPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OriginRequestPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: OriginRequestPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OriginRequestPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecProviderConfigRefPolicy(obj: OriginRequestPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema OriginRequestPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface OriginRequestPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OriginRequestPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OriginRequestPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: OriginRequestPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'OriginRequestPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecPublishConnectionDetailsToConfigRef(obj: OriginRequestPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OriginRequestPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema OriginRequestPolicySpecPublishConnectionDetailsToMetadata
 */
export interface OriginRequestPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema OriginRequestPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema OriginRequestPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema OriginRequestPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'OriginRequestPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecPublishConnectionDetailsToMetadata(obj: OriginRequestPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OriginRequestPolicySpecForProviderCookiesConfigCookies
 */
export interface OriginRequestPolicySpecForProviderCookiesConfigCookies {
  /**
   * @schema OriginRequestPolicySpecForProviderCookiesConfigCookies#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'OriginRequestPolicySpecForProviderCookiesConfigCookies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecForProviderCookiesConfigCookies(obj: OriginRequestPolicySpecForProviderCookiesConfigCookies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OriginRequestPolicySpecForProviderHeadersConfigHeaders
 */
export interface OriginRequestPolicySpecForProviderHeadersConfigHeaders {
  /**
   * @schema OriginRequestPolicySpecForProviderHeadersConfigHeaders#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'OriginRequestPolicySpecForProviderHeadersConfigHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecForProviderHeadersConfigHeaders(obj: OriginRequestPolicySpecForProviderHeadersConfigHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OriginRequestPolicySpecForProviderQueryStringsConfigQueryStrings
 */
export interface OriginRequestPolicySpecForProviderQueryStringsConfigQueryStrings {
  /**
   * @schema OriginRequestPolicySpecForProviderQueryStringsConfigQueryStrings#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'OriginRequestPolicySpecForProviderQueryStringsConfigQueryStrings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecForProviderQueryStringsConfigQueryStrings(obj: OriginRequestPolicySpecForProviderQueryStringsConfigQueryStrings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OriginRequestPolicySpecInitProviderCookiesConfigCookies
 */
export interface OriginRequestPolicySpecInitProviderCookiesConfigCookies {
  /**
   * @schema OriginRequestPolicySpecInitProviderCookiesConfigCookies#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'OriginRequestPolicySpecInitProviderCookiesConfigCookies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecInitProviderCookiesConfigCookies(obj: OriginRequestPolicySpecInitProviderCookiesConfigCookies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OriginRequestPolicySpecInitProviderHeadersConfigHeaders
 */
export interface OriginRequestPolicySpecInitProviderHeadersConfigHeaders {
  /**
   * @schema OriginRequestPolicySpecInitProviderHeadersConfigHeaders#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'OriginRequestPolicySpecInitProviderHeadersConfigHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecInitProviderHeadersConfigHeaders(obj: OriginRequestPolicySpecInitProviderHeadersConfigHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OriginRequestPolicySpecInitProviderQueryStringsConfigQueryStrings
 */
export interface OriginRequestPolicySpecInitProviderQueryStringsConfigQueryStrings {
  /**
   * @schema OriginRequestPolicySpecInitProviderQueryStringsConfigQueryStrings#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'OriginRequestPolicySpecInitProviderQueryStringsConfigQueryStrings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecInitProviderQueryStringsConfigQueryStrings(obj: OriginRequestPolicySpecInitProviderQueryStringsConfigQueryStrings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OriginRequestPolicySpecProviderConfigRefPolicyResolution
 */
export enum OriginRequestPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OriginRequestPolicySpecProviderConfigRefPolicyResolve
 */
export enum OriginRequestPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema OriginRequestPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface OriginRequestPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OriginRequestPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: OriginRequestPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OriginRequestPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: OriginRequestPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OriginRequestPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OriginRequestPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: OriginRequestPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OriginRequestPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum OriginRequestPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OriginRequestPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum OriginRequestPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PublicKey is the Schema for the PublicKeys API. Provides a CloudFront Public Key which you add to CloudFront to use with features like field-level encryption.
 *
 * @schema PublicKey
 */
export class PublicKey extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PublicKey"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudfront.aws.upbound.io/v1beta1',
    kind: 'PublicKey',
  }

  /**
   * Renders a Kubernetes manifest for "PublicKey".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PublicKeyProps): any {
    return {
      ...PublicKey.GVK,
      ...toJson_PublicKeyProps(props),
    };
  }

  /**
   * Defines a "PublicKey" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PublicKeyProps) {
    super(scope, id, {
      ...PublicKey.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PublicKey.GVK,
      ...toJson_PublicKeyProps(resolved),
    };
  }
}

/**
 * PublicKey is the Schema for the PublicKeys API. Provides a CloudFront Public Key which you add to CloudFront to use with features like field-level encryption.
 *
 * @schema PublicKey
 */
export interface PublicKeyProps {
  /**
   * @schema PublicKey#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PublicKeySpec defines the desired state of PublicKey
   *
   * @schema PublicKey#spec
   */
  readonly spec: PublicKeySpec;

}

/**
 * Converts an object of type 'PublicKeyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicKeyProps(obj: PublicKeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PublicKeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublicKeySpec defines the desired state of PublicKey
 *
 * @schema PublicKeySpec
 */
export interface PublicKeySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PublicKeySpec#deletionPolicy
   */
  readonly deletionPolicy?: PublicKeySpecDeletionPolicy;

  /**
   * @schema PublicKeySpec#forProvider
   */
  readonly forProvider: PublicKeySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema PublicKeySpec#initProvider
   */
  readonly initProvider?: PublicKeySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PublicKeySpec#managementPolicies
   */
  readonly managementPolicies?: PublicKeySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PublicKeySpec#providerConfigRef
   */
  readonly providerConfigRef?: PublicKeySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PublicKeySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PublicKeySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PublicKeySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PublicKeySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PublicKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicKeySpec(obj: PublicKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PublicKeySpecForProvider(obj.forProvider),
    'initProvider': toJson_PublicKeySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PublicKeySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PublicKeySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PublicKeySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PublicKeySpecDeletionPolicy
 */
export enum PublicKeySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PublicKeySpecForProvider
 */
export interface PublicKeySpecForProvider {
  /**
   * An optional comment about the public key.
   *
   * @schema PublicKeySpecForProvider#comment
   */
  readonly comment?: string;

  /**
   * The encoded public key that you want to add to CloudFront to use with features like field-level encryption.
   *
   * @schema PublicKeySpecForProvider#encodedKeySecretRef
   */
  readonly encodedKeySecretRef?: PublicKeySpecForProviderEncodedKeySecretRef;

  /**
   * The name for the public key.
   *
   * @schema PublicKeySpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PublicKeySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'PublicKeySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicKeySpecForProvider(obj: PublicKeySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'encodedKeySecretRef': toJson_PublicKeySpecForProviderEncodedKeySecretRef(obj.encodedKeySecretRef),
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema PublicKeySpecInitProvider
 */
export interface PublicKeySpecInitProvider {
  /**
   * An optional comment about the public key.
   *
   * @schema PublicKeySpecInitProvider#comment
   */
  readonly comment?: string;

  /**
   * The name for the public key.
   *
   * @schema PublicKeySpecInitProvider#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PublicKeySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicKeySpecInitProvider(obj: PublicKeySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PublicKeySpecManagementPolicies
 */
export enum PublicKeySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PublicKeySpecProviderConfigRef
 */
export interface PublicKeySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PublicKeySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PublicKeySpecProviderConfigRef#policy
   */
  readonly policy?: PublicKeySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PublicKeySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicKeySpecProviderConfigRef(obj: PublicKeySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PublicKeySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PublicKeySpecPublishConnectionDetailsTo
 */
export interface PublicKeySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PublicKeySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PublicKeySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PublicKeySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PublicKeySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PublicKeySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PublicKeySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicKeySpecPublishConnectionDetailsTo(obj: PublicKeySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PublicKeySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PublicKeySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PublicKeySpecWriteConnectionSecretToRef
 */
export interface PublicKeySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PublicKeySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PublicKeySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PublicKeySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicKeySpecWriteConnectionSecretToRef(obj: PublicKeySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The encoded public key that you want to add to CloudFront to use with features like field-level encryption.
 *
 * @schema PublicKeySpecForProviderEncodedKeySecretRef
 */
export interface PublicKeySpecForProviderEncodedKeySecretRef {
  /**
   * The key to select.
   *
   * @schema PublicKeySpecForProviderEncodedKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema PublicKeySpecForProviderEncodedKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PublicKeySpecForProviderEncodedKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PublicKeySpecForProviderEncodedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicKeySpecForProviderEncodedKeySecretRef(obj: PublicKeySpecForProviderEncodedKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PublicKeySpecProviderConfigRefPolicy
 */
export interface PublicKeySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PublicKeySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PublicKeySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PublicKeySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PublicKeySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PublicKeySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicKeySpecProviderConfigRefPolicy(obj: PublicKeySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PublicKeySpecPublishConnectionDetailsToConfigRef
 */
export interface PublicKeySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PublicKeySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PublicKeySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PublicKeySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PublicKeySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicKeySpecPublishConnectionDetailsToConfigRef(obj: PublicKeySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PublicKeySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PublicKeySpecPublishConnectionDetailsToMetadata
 */
export interface PublicKeySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PublicKeySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PublicKeySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PublicKeySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PublicKeySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicKeySpecPublishConnectionDetailsToMetadata(obj: PublicKeySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PublicKeySpecProviderConfigRefPolicyResolution
 */
export enum PublicKeySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PublicKeySpecProviderConfigRefPolicyResolve
 */
export enum PublicKeySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PublicKeySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PublicKeySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PublicKeySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PublicKeySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PublicKeySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PublicKeySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PublicKeySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicKeySpecPublishConnectionDetailsToConfigRefPolicy(obj: PublicKeySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PublicKeySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PublicKeySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PublicKeySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PublicKeySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RealtimeLogConfig is the Schema for the RealtimeLogConfigs API. Provides a CloudFront real-time log configuration resource.
 *
 * @schema RealtimeLogConfig
 */
export class RealtimeLogConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RealtimeLogConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudfront.aws.upbound.io/v1beta1',
    kind: 'RealtimeLogConfig',
  }

  /**
   * Renders a Kubernetes manifest for "RealtimeLogConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RealtimeLogConfigProps): any {
    return {
      ...RealtimeLogConfig.GVK,
      ...toJson_RealtimeLogConfigProps(props),
    };
  }

  /**
   * Defines a "RealtimeLogConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RealtimeLogConfigProps) {
    super(scope, id, {
      ...RealtimeLogConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RealtimeLogConfig.GVK,
      ...toJson_RealtimeLogConfigProps(resolved),
    };
  }
}

/**
 * RealtimeLogConfig is the Schema for the RealtimeLogConfigs API. Provides a CloudFront real-time log configuration resource.
 *
 * @schema RealtimeLogConfig
 */
export interface RealtimeLogConfigProps {
  /**
   * @schema RealtimeLogConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RealtimeLogConfigSpec defines the desired state of RealtimeLogConfig
   *
   * @schema RealtimeLogConfig#spec
   */
  readonly spec: RealtimeLogConfigSpec;

}

/**
 * Converts an object of type 'RealtimeLogConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigProps(obj: RealtimeLogConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RealtimeLogConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RealtimeLogConfigSpec defines the desired state of RealtimeLogConfig
 *
 * @schema RealtimeLogConfigSpec
 */
export interface RealtimeLogConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RealtimeLogConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: RealtimeLogConfigSpecDeletionPolicy;

  /**
   * @schema RealtimeLogConfigSpec#forProvider
   */
  readonly forProvider: RealtimeLogConfigSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema RealtimeLogConfigSpec#initProvider
   */
  readonly initProvider?: RealtimeLogConfigSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RealtimeLogConfigSpec#managementPolicies
   */
  readonly managementPolicies?: RealtimeLogConfigSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RealtimeLogConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: RealtimeLogConfigSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RealtimeLogConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RealtimeLogConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RealtimeLogConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RealtimeLogConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpec(obj: RealtimeLogConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RealtimeLogConfigSpecForProvider(obj.forProvider),
    'initProvider': toJson_RealtimeLogConfigSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RealtimeLogConfigSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RealtimeLogConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RealtimeLogConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RealtimeLogConfigSpecDeletionPolicy
 */
export enum RealtimeLogConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RealtimeLogConfigSpecForProvider
 */
export interface RealtimeLogConfigSpecForProvider {
  /**
   * The Amazon Kinesis data streams where real-time log data is sent.
   *
   * @schema RealtimeLogConfigSpecForProvider#endpoint
   */
  readonly endpoint?: RealtimeLogConfigSpecForProviderEndpoint[];

  /**
   * The fields that are included in each real-time log record. See the AWS documentation for supported values.
   *
   * @schema RealtimeLogConfigSpecForProvider#fields
   */
  readonly fields?: string[];

  /**
   * The unique name to identify this real-time log configuration.
   *
   * @schema RealtimeLogConfigSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RealtimeLogConfigSpecForProvider#region
   */
  readonly region: string;

  /**
   * The sampling rate for this real-time log configuration. The sampling rate determines the percentage of viewer requests that are represented in the real-time log data. An integer between 1 and 100, inclusive.
   *
   * @schema RealtimeLogConfigSpecForProvider#samplingRate
   */
  readonly samplingRate?: number;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecForProvider(obj: RealtimeLogConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoint': obj.endpoint?.map(y => toJson_RealtimeLogConfigSpecForProviderEndpoint(y)),
    'fields': obj.fields?.map(y => y),
    'name': obj.name,
    'region': obj.region,
    'samplingRate': obj.samplingRate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema RealtimeLogConfigSpecInitProvider
 */
export interface RealtimeLogConfigSpecInitProvider {
  /**
   * The Amazon Kinesis data streams where real-time log data is sent.
   *
   * @schema RealtimeLogConfigSpecInitProvider#endpoint
   */
  readonly endpoint?: RealtimeLogConfigSpecInitProviderEndpoint[];

  /**
   * The fields that are included in each real-time log record. See the AWS documentation for supported values.
   *
   * @schema RealtimeLogConfigSpecInitProvider#fields
   */
  readonly fields?: string[];

  /**
   * The unique name to identify this real-time log configuration.
   *
   * @schema RealtimeLogConfigSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The sampling rate for this real-time log configuration. The sampling rate determines the percentage of viewer requests that are represented in the real-time log data. An integer between 1 and 100, inclusive.
   *
   * @schema RealtimeLogConfigSpecInitProvider#samplingRate
   */
  readonly samplingRate?: number;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecInitProvider(obj: RealtimeLogConfigSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoint': obj.endpoint?.map(y => toJson_RealtimeLogConfigSpecInitProviderEndpoint(y)),
    'fields': obj.fields?.map(y => y),
    'name': obj.name,
    'samplingRate': obj.samplingRate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RealtimeLogConfigSpecManagementPolicies
 */
export enum RealtimeLogConfigSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RealtimeLogConfigSpecProviderConfigRef
 */
export interface RealtimeLogConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RealtimeLogConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RealtimeLogConfigSpecProviderConfigRef#policy
   */
  readonly policy?: RealtimeLogConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecProviderConfigRef(obj: RealtimeLogConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RealtimeLogConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RealtimeLogConfigSpecPublishConnectionDetailsTo
 */
export interface RealtimeLogConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RealtimeLogConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RealtimeLogConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RealtimeLogConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RealtimeLogConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RealtimeLogConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecPublishConnectionDetailsTo(obj: RealtimeLogConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RealtimeLogConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RealtimeLogConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RealtimeLogConfigSpecWriteConnectionSecretToRef
 */
export interface RealtimeLogConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RealtimeLogConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RealtimeLogConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecWriteConnectionSecretToRef(obj: RealtimeLogConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RealtimeLogConfigSpecForProviderEndpoint
 */
export interface RealtimeLogConfigSpecForProviderEndpoint {
  /**
   * The Amazon Kinesis data stream configuration.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpoint#kinesisStreamConfig
   */
  readonly kinesisStreamConfig?: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfig[];

  /**
   * The type of data stream where real-time log data is sent. The only valid value is Kinesis.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpoint#streamType
   */
  readonly streamType?: string;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecForProviderEndpoint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecForProviderEndpoint(obj: RealtimeLogConfigSpecForProviderEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kinesisStreamConfig': obj.kinesisStreamConfig?.map(y => toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfig(y)),
    'streamType': obj.streamType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RealtimeLogConfigSpecInitProviderEndpoint
 */
export interface RealtimeLogConfigSpecInitProviderEndpoint {
  /**
   * The Amazon Kinesis data stream configuration.
   *
   * @schema RealtimeLogConfigSpecInitProviderEndpoint#kinesisStreamConfig
   */
  readonly kinesisStreamConfig?: any[];

  /**
   * The type of data stream where real-time log data is sent. The only valid value is Kinesis.
   *
   * @schema RealtimeLogConfigSpecInitProviderEndpoint#streamType
   */
  readonly streamType?: string;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecInitProviderEndpoint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecInitProviderEndpoint(obj: RealtimeLogConfigSpecInitProviderEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kinesisStreamConfig': obj.kinesisStreamConfig?.map(y => y),
    'streamType': obj.streamType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RealtimeLogConfigSpecProviderConfigRefPolicy
 */
export interface RealtimeLogConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RealtimeLogConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RealtimeLogConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RealtimeLogConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RealtimeLogConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecProviderConfigRefPolicy(obj: RealtimeLogConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RealtimeLogConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface RealtimeLogConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RealtimeLogConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RealtimeLogConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RealtimeLogConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecPublishConnectionDetailsToConfigRef(obj: RealtimeLogConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RealtimeLogConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RealtimeLogConfigSpecPublishConnectionDetailsToMetadata
 */
export interface RealtimeLogConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RealtimeLogConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RealtimeLogConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RealtimeLogConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecPublishConnectionDetailsToMetadata(obj: RealtimeLogConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfig
 */
export interface RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfig {
  /**
   * The ARN of an IAM role that CloudFront can use to send real-time log data to the Kinesis data stream. See the AWS documentation for more information.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfig#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfig#roleArnRef
   */
  readonly roleArnRef?: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfig#roleArnSelector
   */
  readonly roleArnSelector?: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelector;

  /**
   * The ARN of the Kinesis data stream.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfig#streamArn
   */
  readonly streamArn?: string;

  /**
   * Reference to a Stream in kinesis to populate streamArn.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfig#streamArnRef
   */
  readonly streamArnRef?: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRef;

  /**
   * Selector for a Stream in kinesis to populate streamArn.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfig#streamArnSelector
   */
  readonly streamArnSelector?: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelector;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfig(obj: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelector(obj.roleArnSelector),
    'streamArn': obj.streamArn,
    'streamArnRef': toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRef(obj.streamArnRef),
    'streamArnSelector': toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelector(obj.streamArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RealtimeLogConfigSpecProviderConfigRefPolicyResolution
 */
export enum RealtimeLogConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RealtimeLogConfigSpecProviderConfigRefPolicyResolve
 */
export enum RealtimeLogConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RealtimeLogConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RealtimeLogConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RealtimeLogConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RealtimeLogConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RealtimeLogConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RealtimeLogConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: RealtimeLogConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRef
 */
export interface RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRef#policy
   */
  readonly policy?: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRefPolicy;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRef(obj: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelector
 */
export interface RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelector#policy
   */
  readonly policy?: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelector(obj: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stream in kinesis to populate streamArn.
 *
 * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRef
 */
export interface RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRef#policy
   */
  readonly policy?: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRefPolicy;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRef(obj: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stream in kinesis to populate streamArn.
 *
 * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelector
 */
export interface RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelector#policy
   */
  readonly policy?: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelectorPolicy;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelector(obj: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RealtimeLogConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RealtimeLogConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RealtimeLogConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RealtimeLogConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRefPolicy
 */
export interface RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRefPolicy#resolution
   */
  readonly resolution?: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRefPolicy#resolve
   */
  readonly resolve?: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRefPolicy(obj: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelectorPolicy
 */
export interface RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelectorPolicy(obj: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRefPolicy
 */
export interface RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRefPolicy#resolution
   */
  readonly resolution?: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRefPolicy#resolve
   */
  readonly resolve?: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRefPolicy(obj: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelectorPolicy
 */
export interface RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelectorPolicy#resolution
   */
  readonly resolution?: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelectorPolicy#resolve
   */
  readonly resolve?: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelectorPolicy(obj: RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRefPolicyResolution
 */
export enum RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRefPolicyResolve
 */
export enum RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelectorPolicyResolution
 */
export enum RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelectorPolicyResolve
 */
export enum RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRefPolicyResolution
 */
export enum RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRefPolicyResolve
 */
export enum RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelectorPolicyResolution
 */
export enum RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelectorPolicyResolve
 */
export enum RealtimeLogConfigSpecForProviderEndpointKinesisStreamConfigStreamArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ResponseHeadersPolicy is the Schema for the ResponseHeadersPolicys API. Provides a CloudFront response headers policy resource.
 *
 * @schema ResponseHeadersPolicy
 */
export class ResponseHeadersPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ResponseHeadersPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudfront.aws.upbound.io/v1beta1',
    kind: 'ResponseHeadersPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ResponseHeadersPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ResponseHeadersPolicyProps): any {
    return {
      ...ResponseHeadersPolicy.GVK,
      ...toJson_ResponseHeadersPolicyProps(props),
    };
  }

  /**
   * Defines a "ResponseHeadersPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ResponseHeadersPolicyProps) {
    super(scope, id, {
      ...ResponseHeadersPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ResponseHeadersPolicy.GVK,
      ...toJson_ResponseHeadersPolicyProps(resolved),
    };
  }
}

/**
 * ResponseHeadersPolicy is the Schema for the ResponseHeadersPolicys API. Provides a CloudFront response headers policy resource.
 *
 * @schema ResponseHeadersPolicy
 */
export interface ResponseHeadersPolicyProps {
  /**
   * @schema ResponseHeadersPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ResponseHeadersPolicySpec defines the desired state of ResponseHeadersPolicy
   *
   * @schema ResponseHeadersPolicy#spec
   */
  readonly spec: ResponseHeadersPolicySpec;

}

/**
 * Converts an object of type 'ResponseHeadersPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicyProps(obj: ResponseHeadersPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResponseHeadersPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResponseHeadersPolicySpec defines the desired state of ResponseHeadersPolicy
 *
 * @schema ResponseHeadersPolicySpec
 */
export interface ResponseHeadersPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ResponseHeadersPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: ResponseHeadersPolicySpecDeletionPolicy;

  /**
   * @schema ResponseHeadersPolicySpec#forProvider
   */
  readonly forProvider: ResponseHeadersPolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ResponseHeadersPolicySpec#initProvider
   */
  readonly initProvider?: ResponseHeadersPolicySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ResponseHeadersPolicySpec#managementPolicies
   */
  readonly managementPolicies?: ResponseHeadersPolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ResponseHeadersPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: ResponseHeadersPolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ResponseHeadersPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ResponseHeadersPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ResponseHeadersPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ResponseHeadersPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpec(obj: ResponseHeadersPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ResponseHeadersPolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_ResponseHeadersPolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ResponseHeadersPolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ResponseHeadersPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ResponseHeadersPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ResponseHeadersPolicySpecDeletionPolicy
 */
export enum ResponseHeadersPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ResponseHeadersPolicySpecForProvider
 */
export interface ResponseHeadersPolicySpecForProvider {
  /**
   * A comment to describe the response headers policy. The comment cannot be longer than 128 characters.
   *
   * @schema ResponseHeadersPolicySpecForProvider#comment
   */
  readonly comment?: string;

  /**
   * A configuration for a set of HTTP response headers that are used for Cross-Origin Resource Sharing (CORS). See Cors Config for more information.
   *
   * @schema ResponseHeadersPolicySpecForProvider#corsConfig
   */
  readonly corsConfig?: ResponseHeadersPolicySpecForProviderCorsConfig[];

  /**
   * Object that contains an attribute items that contains a list of custom headers. See Custom Header for more information.
   *
   * @schema ResponseHeadersPolicySpecForProvider#customHeadersConfig
   */
  readonly customHeadersConfig?: ResponseHeadersPolicySpecForProviderCustomHeadersConfig[];

  /**
   * The current version of the response headers policy.
   *
   * @schema ResponseHeadersPolicySpecForProvider#etag
   */
  readonly etag?: string;

  /**
   * A unique name to identify the response headers policy.
   *
   * @schema ResponseHeadersPolicySpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ResponseHeadersPolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * A configuration for a set of HTTP headers to remove from the HTTP response. Object that contains an attribute items that contains a list of headers. See Remove Header for more information.
   *
   * @schema ResponseHeadersPolicySpecForProvider#removeHeadersConfig
   */
  readonly removeHeadersConfig?: ResponseHeadersPolicySpecForProviderRemoveHeadersConfig[];

  /**
   * A configuration for a set of security-related HTTP response headers. See Security Headers Config for more information.
   *
   * @schema ResponseHeadersPolicySpecForProvider#securityHeadersConfig
   */
  readonly securityHeadersConfig?: ResponseHeadersPolicySpecForProviderSecurityHeadersConfig[];

  /**
   * A configuration for enabling the Server-Timing header in HTTP responses sent from CloudFront. See Server Timing Headers Config for more information.
   *
   * @schema ResponseHeadersPolicySpecForProvider#serverTimingHeadersConfig
   */
  readonly serverTimingHeadersConfig?: ResponseHeadersPolicySpecForProviderServerTimingHeadersConfig[];

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProvider(obj: ResponseHeadersPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'corsConfig': obj.corsConfig?.map(y => toJson_ResponseHeadersPolicySpecForProviderCorsConfig(y)),
    'customHeadersConfig': obj.customHeadersConfig?.map(y => toJson_ResponseHeadersPolicySpecForProviderCustomHeadersConfig(y)),
    'etag': obj.etag,
    'name': obj.name,
    'region': obj.region,
    'removeHeadersConfig': obj.removeHeadersConfig?.map(y => toJson_ResponseHeadersPolicySpecForProviderRemoveHeadersConfig(y)),
    'securityHeadersConfig': obj.securityHeadersConfig?.map(y => toJson_ResponseHeadersPolicySpecForProviderSecurityHeadersConfig(y)),
    'serverTimingHeadersConfig': obj.serverTimingHeadersConfig?.map(y => toJson_ResponseHeadersPolicySpecForProviderServerTimingHeadersConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ResponseHeadersPolicySpecInitProvider
 */
export interface ResponseHeadersPolicySpecInitProvider {
  /**
   * A comment to describe the response headers policy. The comment cannot be longer than 128 characters.
   *
   * @schema ResponseHeadersPolicySpecInitProvider#comment
   */
  readonly comment?: string;

  /**
   * A configuration for a set of HTTP response headers that are used for Cross-Origin Resource Sharing (CORS). See Cors Config for more information.
   *
   * @schema ResponseHeadersPolicySpecInitProvider#corsConfig
   */
  readonly corsConfig?: ResponseHeadersPolicySpecInitProviderCorsConfig[];

  /**
   * Object that contains an attribute items that contains a list of custom headers. See Custom Header for more information.
   *
   * @schema ResponseHeadersPolicySpecInitProvider#customHeadersConfig
   */
  readonly customHeadersConfig?: ResponseHeadersPolicySpecInitProviderCustomHeadersConfig[];

  /**
   * The current version of the response headers policy.
   *
   * @schema ResponseHeadersPolicySpecInitProvider#etag
   */
  readonly etag?: string;

  /**
   * A unique name to identify the response headers policy.
   *
   * @schema ResponseHeadersPolicySpecInitProvider#name
   */
  readonly name?: string;

  /**
   * A configuration for a set of HTTP headers to remove from the HTTP response. Object that contains an attribute items that contains a list of headers. See Remove Header for more information.
   *
   * @schema ResponseHeadersPolicySpecInitProvider#removeHeadersConfig
   */
  readonly removeHeadersConfig?: ResponseHeadersPolicySpecInitProviderRemoveHeadersConfig[];

  /**
   * A configuration for a set of security-related HTTP response headers. See Security Headers Config for more information.
   *
   * @schema ResponseHeadersPolicySpecInitProvider#securityHeadersConfig
   */
  readonly securityHeadersConfig?: ResponseHeadersPolicySpecInitProviderSecurityHeadersConfig[];

  /**
   * A configuration for enabling the Server-Timing header in HTTP responses sent from CloudFront. See Server Timing Headers Config for more information.
   *
   * @schema ResponseHeadersPolicySpecInitProvider#serverTimingHeadersConfig
   */
  readonly serverTimingHeadersConfig?: ResponseHeadersPolicySpecInitProviderServerTimingHeadersConfig[];

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProvider(obj: ResponseHeadersPolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'corsConfig': obj.corsConfig?.map(y => toJson_ResponseHeadersPolicySpecInitProviderCorsConfig(y)),
    'customHeadersConfig': obj.customHeadersConfig?.map(y => toJson_ResponseHeadersPolicySpecInitProviderCustomHeadersConfig(y)),
    'etag': obj.etag,
    'name': obj.name,
    'removeHeadersConfig': obj.removeHeadersConfig?.map(y => toJson_ResponseHeadersPolicySpecInitProviderRemoveHeadersConfig(y)),
    'securityHeadersConfig': obj.securityHeadersConfig?.map(y => toJson_ResponseHeadersPolicySpecInitProviderSecurityHeadersConfig(y)),
    'serverTimingHeadersConfig': obj.serverTimingHeadersConfig?.map(y => toJson_ResponseHeadersPolicySpecInitProviderServerTimingHeadersConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ResponseHeadersPolicySpecManagementPolicies
 */
export enum ResponseHeadersPolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ResponseHeadersPolicySpecProviderConfigRef
 */
export interface ResponseHeadersPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResponseHeadersPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResponseHeadersPolicySpecProviderConfigRef#policy
   */
  readonly policy?: ResponseHeadersPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecProviderConfigRef(obj: ResponseHeadersPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResponseHeadersPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ResponseHeadersPolicySpecPublishConnectionDetailsTo
 */
export interface ResponseHeadersPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ResponseHeadersPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ResponseHeadersPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ResponseHeadersPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ResponseHeadersPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecPublishConnectionDetailsTo(obj: ResponseHeadersPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ResponseHeadersPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ResponseHeadersPolicySpecWriteConnectionSecretToRef
 */
export interface ResponseHeadersPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ResponseHeadersPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ResponseHeadersPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecWriteConnectionSecretToRef(obj: ResponseHeadersPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecForProviderCorsConfig
 */
export interface ResponseHeadersPolicySpecForProviderCorsConfig {
  /**
   * A Boolean value that CloudFront uses as the value for the Access-Control-Allow-Credentials HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecForProviderCorsConfig#accessControlAllowCredentials
   */
  readonly accessControlAllowCredentials?: boolean;

  /**
   * Object that contains an attribute items that contains a list of HTTP header names that CloudFront includes as values for the Access-Control-Allow-Headers HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecForProviderCorsConfig#accessControlAllowHeaders
   */
  readonly accessControlAllowHeaders?: ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowHeaders[];

  /**
   * Object that contains an attribute items that contains a list of HTTP methods that CloudFront includes as values for the Access-Control-Allow-Methods HTTP response header. Valid values: GET | POST | OPTIONS | PUT | DELETE | HEAD | ALL
   *
   * @schema ResponseHeadersPolicySpecForProviderCorsConfig#accessControlAllowMethods
   */
  readonly accessControlAllowMethods?: ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowMethods[];

  /**
   * Object that contains an attribute items that contains a list of origins that CloudFront can use as the value for the Access-Control-Allow-Origin HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecForProviderCorsConfig#accessControlAllowOrigins
   */
  readonly accessControlAllowOrigins?: ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowOrigins[];

  /**
   * Object that contains an attribute items that contains a list of HTTP headers that CloudFront includes as values for the Access-Control-Expose-Headers HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecForProviderCorsConfig#accessControlExposeHeaders
   */
  readonly accessControlExposeHeaders?: ResponseHeadersPolicySpecForProviderCorsConfigAccessControlExposeHeaders[];

  /**
   * A number that CloudFront uses as the value for the Access-Control-Max-Age HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecForProviderCorsConfig#accessControlMaxAgeSec
   */
  readonly accessControlMaxAgeSec?: number;

  /**
   * A Boolean value that determines how CloudFront behaves for the HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecForProviderCorsConfig#originOverride
   */
  readonly originOverride?: boolean;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProviderCorsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProviderCorsConfig(obj: ResponseHeadersPolicySpecForProviderCorsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessControlAllowCredentials': obj.accessControlAllowCredentials,
    'accessControlAllowHeaders': obj.accessControlAllowHeaders?.map(y => toJson_ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowHeaders(y)),
    'accessControlAllowMethods': obj.accessControlAllowMethods?.map(y => toJson_ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowMethods(y)),
    'accessControlAllowOrigins': obj.accessControlAllowOrigins?.map(y => toJson_ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowOrigins(y)),
    'accessControlExposeHeaders': obj.accessControlExposeHeaders?.map(y => toJson_ResponseHeadersPolicySpecForProviderCorsConfigAccessControlExposeHeaders(y)),
    'accessControlMaxAgeSec': obj.accessControlMaxAgeSec,
    'originOverride': obj.originOverride,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecForProviderCustomHeadersConfig
 */
export interface ResponseHeadersPolicySpecForProviderCustomHeadersConfig {
  /**
   * @schema ResponseHeadersPolicySpecForProviderCustomHeadersConfig#items
   */
  readonly items?: ResponseHeadersPolicySpecForProviderCustomHeadersConfigItems[];

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProviderCustomHeadersConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProviderCustomHeadersConfig(obj: ResponseHeadersPolicySpecForProviderCustomHeadersConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ResponseHeadersPolicySpecForProviderCustomHeadersConfigItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecForProviderRemoveHeadersConfig
 */
export interface ResponseHeadersPolicySpecForProviderRemoveHeadersConfig {
  /**
   * @schema ResponseHeadersPolicySpecForProviderRemoveHeadersConfig#items
   */
  readonly items?: ResponseHeadersPolicySpecForProviderRemoveHeadersConfigItems[];

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProviderRemoveHeadersConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProviderRemoveHeadersConfig(obj: ResponseHeadersPolicySpecForProviderRemoveHeadersConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ResponseHeadersPolicySpecForProviderRemoveHeadersConfigItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfig
 */
export interface ResponseHeadersPolicySpecForProviderSecurityHeadersConfig {
  /**
   * The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header. See Content Security Policy for more information.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfig#contentSecurityPolicy
   */
  readonly contentSecurityPolicy?: ResponseHeadersPolicySpecForProviderSecurityHeadersConfigContentSecurityPolicy[];

  /**
   * Determines whether CloudFront includes the X-Content-Type-Options HTTP response header with its value set to nosniff. See Content Type Options for more information.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfig#contentTypeOptions
   */
  readonly contentTypeOptions?: ResponseHeadersPolicySpecForProviderSecurityHeadersConfigContentTypeOptions[];

  /**
   * Determines whether CloudFront includes the X-Frame-Options HTTP response header and the header’s value. See Frame Options for more information.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfig#frameOptions
   */
  readonly frameOptions?: ResponseHeadersPolicySpecForProviderSecurityHeadersConfigFrameOptions[];

  /**
   * Determines whether CloudFront includes the Referrer-Policy HTTP response header and the header’s value. See Referrer Policy for more information.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfig#referrerPolicy
   */
  readonly referrerPolicy?: ResponseHeadersPolicySpecForProviderSecurityHeadersConfigReferrerPolicy[];

  /**
   * Determines whether CloudFront includes the Strict-Transport-Security HTTP response header and the header’s value. See Strict Transport Security for more information.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfig#strictTransportSecurity
   */
  readonly strictTransportSecurity?: ResponseHeadersPolicySpecForProviderSecurityHeadersConfigStrictTransportSecurity[];

  /**
   * Determine whether CloudFront includes the X-XSS-Protection HTTP response header and the header’s value. See XSS Protection for more information.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfig#xssProtection
   */
  readonly xssProtection?: ResponseHeadersPolicySpecForProviderSecurityHeadersConfigXssProtection[];

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProviderSecurityHeadersConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProviderSecurityHeadersConfig(obj: ResponseHeadersPolicySpecForProviderSecurityHeadersConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentSecurityPolicy': obj.contentSecurityPolicy?.map(y => toJson_ResponseHeadersPolicySpecForProviderSecurityHeadersConfigContentSecurityPolicy(y)),
    'contentTypeOptions': obj.contentTypeOptions?.map(y => toJson_ResponseHeadersPolicySpecForProviderSecurityHeadersConfigContentTypeOptions(y)),
    'frameOptions': obj.frameOptions?.map(y => toJson_ResponseHeadersPolicySpecForProviderSecurityHeadersConfigFrameOptions(y)),
    'referrerPolicy': obj.referrerPolicy?.map(y => toJson_ResponseHeadersPolicySpecForProviderSecurityHeadersConfigReferrerPolicy(y)),
    'strictTransportSecurity': obj.strictTransportSecurity?.map(y => toJson_ResponseHeadersPolicySpecForProviderSecurityHeadersConfigStrictTransportSecurity(y)),
    'xssProtection': obj.xssProtection?.map(y => toJson_ResponseHeadersPolicySpecForProviderSecurityHeadersConfigXssProtection(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecForProviderServerTimingHeadersConfig
 */
export interface ResponseHeadersPolicySpecForProviderServerTimingHeadersConfig {
  /**
   * A Whether CloudFront adds the Server-Timing header to HTTP responses that it sends in response to requests that match a cache behavior that's associated with this response headers policy.
   *
   * @schema ResponseHeadersPolicySpecForProviderServerTimingHeadersConfig#enabled
   */
  readonly enabled?: boolean;

  /**
   * A number 0–100 (inclusive) that specifies the percentage of responses that you want CloudFront to add the Server-Timing header to. Valid range: Minimum value of 0.0. Maximum value of 100.0.
   *
   * @schema ResponseHeadersPolicySpecForProviderServerTimingHeadersConfig#samplingRate
   */
  readonly samplingRate?: number;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProviderServerTimingHeadersConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProviderServerTimingHeadersConfig(obj: ResponseHeadersPolicySpecForProviderServerTimingHeadersConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'samplingRate': obj.samplingRate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecInitProviderCorsConfig
 */
export interface ResponseHeadersPolicySpecInitProviderCorsConfig {
  /**
   * A Boolean value that CloudFront uses as the value for the Access-Control-Allow-Credentials HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecInitProviderCorsConfig#accessControlAllowCredentials
   */
  readonly accessControlAllowCredentials?: boolean;

  /**
   * Object that contains an attribute items that contains a list of HTTP header names that CloudFront includes as values for the Access-Control-Allow-Headers HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecInitProviderCorsConfig#accessControlAllowHeaders
   */
  readonly accessControlAllowHeaders?: ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowHeaders[];

  /**
   * Object that contains an attribute items that contains a list of HTTP methods that CloudFront includes as values for the Access-Control-Allow-Methods HTTP response header. Valid values: GET | POST | OPTIONS | PUT | DELETE | HEAD | ALL
   *
   * @schema ResponseHeadersPolicySpecInitProviderCorsConfig#accessControlAllowMethods
   */
  readonly accessControlAllowMethods?: ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowMethods[];

  /**
   * Object that contains an attribute items that contains a list of origins that CloudFront can use as the value for the Access-Control-Allow-Origin HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecInitProviderCorsConfig#accessControlAllowOrigins
   */
  readonly accessControlAllowOrigins?: ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowOrigins[];

  /**
   * Object that contains an attribute items that contains a list of HTTP headers that CloudFront includes as values for the Access-Control-Expose-Headers HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecInitProviderCorsConfig#accessControlExposeHeaders
   */
  readonly accessControlExposeHeaders?: ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlExposeHeaders[];

  /**
   * A number that CloudFront uses as the value for the Access-Control-Max-Age HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecInitProviderCorsConfig#accessControlMaxAgeSec
   */
  readonly accessControlMaxAgeSec?: number;

  /**
   * A Boolean value that determines how CloudFront behaves for the HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecInitProviderCorsConfig#originOverride
   */
  readonly originOverride?: boolean;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProviderCorsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProviderCorsConfig(obj: ResponseHeadersPolicySpecInitProviderCorsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessControlAllowCredentials': obj.accessControlAllowCredentials,
    'accessControlAllowHeaders': obj.accessControlAllowHeaders?.map(y => toJson_ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowHeaders(y)),
    'accessControlAllowMethods': obj.accessControlAllowMethods?.map(y => toJson_ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowMethods(y)),
    'accessControlAllowOrigins': obj.accessControlAllowOrigins?.map(y => toJson_ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowOrigins(y)),
    'accessControlExposeHeaders': obj.accessControlExposeHeaders?.map(y => toJson_ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlExposeHeaders(y)),
    'accessControlMaxAgeSec': obj.accessControlMaxAgeSec,
    'originOverride': obj.originOverride,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecInitProviderCustomHeadersConfig
 */
export interface ResponseHeadersPolicySpecInitProviderCustomHeadersConfig {
  /**
   * @schema ResponseHeadersPolicySpecInitProviderCustomHeadersConfig#items
   */
  readonly items?: ResponseHeadersPolicySpecInitProviderCustomHeadersConfigItems[];

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProviderCustomHeadersConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProviderCustomHeadersConfig(obj: ResponseHeadersPolicySpecInitProviderCustomHeadersConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ResponseHeadersPolicySpecInitProviderCustomHeadersConfigItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecInitProviderRemoveHeadersConfig
 */
export interface ResponseHeadersPolicySpecInitProviderRemoveHeadersConfig {
  /**
   * @schema ResponseHeadersPolicySpecInitProviderRemoveHeadersConfig#items
   */
  readonly items?: ResponseHeadersPolicySpecInitProviderRemoveHeadersConfigItems[];

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProviderRemoveHeadersConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProviderRemoveHeadersConfig(obj: ResponseHeadersPolicySpecInitProviderRemoveHeadersConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ResponseHeadersPolicySpecInitProviderRemoveHeadersConfigItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfig
 */
export interface ResponseHeadersPolicySpecInitProviderSecurityHeadersConfig {
  /**
   * The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header. See Content Security Policy for more information.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfig#contentSecurityPolicy
   */
  readonly contentSecurityPolicy?: ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigContentSecurityPolicy[];

  /**
   * Determines whether CloudFront includes the X-Content-Type-Options HTTP response header with its value set to nosniff. See Content Type Options for more information.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfig#contentTypeOptions
   */
  readonly contentTypeOptions?: ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigContentTypeOptions[];

  /**
   * Determines whether CloudFront includes the X-Frame-Options HTTP response header and the header’s value. See Frame Options for more information.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfig#frameOptions
   */
  readonly frameOptions?: ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigFrameOptions[];

  /**
   * Determines whether CloudFront includes the Referrer-Policy HTTP response header and the header’s value. See Referrer Policy for more information.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfig#referrerPolicy
   */
  readonly referrerPolicy?: ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigReferrerPolicy[];

  /**
   * Determines whether CloudFront includes the Strict-Transport-Security HTTP response header and the header’s value. See Strict Transport Security for more information.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfig#strictTransportSecurity
   */
  readonly strictTransportSecurity?: ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigStrictTransportSecurity[];

  /**
   * Determine whether CloudFront includes the X-XSS-Protection HTTP response header and the header’s value. See XSS Protection for more information.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfig#xssProtection
   */
  readonly xssProtection?: ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigXssProtection[];

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProviderSecurityHeadersConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProviderSecurityHeadersConfig(obj: ResponseHeadersPolicySpecInitProviderSecurityHeadersConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentSecurityPolicy': obj.contentSecurityPolicy?.map(y => toJson_ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigContentSecurityPolicy(y)),
    'contentTypeOptions': obj.contentTypeOptions?.map(y => toJson_ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigContentTypeOptions(y)),
    'frameOptions': obj.frameOptions?.map(y => toJson_ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigFrameOptions(y)),
    'referrerPolicy': obj.referrerPolicy?.map(y => toJson_ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigReferrerPolicy(y)),
    'strictTransportSecurity': obj.strictTransportSecurity?.map(y => toJson_ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigStrictTransportSecurity(y)),
    'xssProtection': obj.xssProtection?.map(y => toJson_ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigXssProtection(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecInitProviderServerTimingHeadersConfig
 */
export interface ResponseHeadersPolicySpecInitProviderServerTimingHeadersConfig {
  /**
   * A Whether CloudFront adds the Server-Timing header to HTTP responses that it sends in response to requests that match a cache behavior that's associated with this response headers policy.
   *
   * @schema ResponseHeadersPolicySpecInitProviderServerTimingHeadersConfig#enabled
   */
  readonly enabled?: boolean;

  /**
   * A number 0–100 (inclusive) that specifies the percentage of responses that you want CloudFront to add the Server-Timing header to. Valid range: Minimum value of 0.0. Maximum value of 100.0.
   *
   * @schema ResponseHeadersPolicySpecInitProviderServerTimingHeadersConfig#samplingRate
   */
  readonly samplingRate?: number;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProviderServerTimingHeadersConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProviderServerTimingHeadersConfig(obj: ResponseHeadersPolicySpecInitProviderServerTimingHeadersConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'samplingRate': obj.samplingRate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResponseHeadersPolicySpecProviderConfigRefPolicy
 */
export interface ResponseHeadersPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResponseHeadersPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ResponseHeadersPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResponseHeadersPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ResponseHeadersPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecProviderConfigRefPolicy(obj: ResponseHeadersPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRef(obj: ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ResponseHeadersPolicySpecPublishConnectionDetailsToMetadata
 */
export interface ResponseHeadersPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResponseHeadersPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResponseHeadersPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ResponseHeadersPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecPublishConnectionDetailsToMetadata(obj: ResponseHeadersPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowHeaders
 */
export interface ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowHeaders {
  /**
   * @schema ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowHeaders#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowHeaders(obj: ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowMethods
 */
export interface ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowMethods {
  /**
   * @schema ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowMethods#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowMethods' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowMethods(obj: ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowMethods | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowOrigins
 */
export interface ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowOrigins {
  /**
   * @schema ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowOrigins#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowOrigins' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowOrigins(obj: ResponseHeadersPolicySpecForProviderCorsConfigAccessControlAllowOrigins | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecForProviderCorsConfigAccessControlExposeHeaders
 */
export interface ResponseHeadersPolicySpecForProviderCorsConfigAccessControlExposeHeaders {
  /**
   * @schema ResponseHeadersPolicySpecForProviderCorsConfigAccessControlExposeHeaders#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProviderCorsConfigAccessControlExposeHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProviderCorsConfigAccessControlExposeHeaders(obj: ResponseHeadersPolicySpecForProviderCorsConfigAccessControlExposeHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecForProviderCustomHeadersConfigItems
 */
export interface ResponseHeadersPolicySpecForProviderCustomHeadersConfigItems {
  /**
   * The HTTP response header name.
   *
   * @schema ResponseHeadersPolicySpecForProviderCustomHeadersConfigItems#header
   */
  readonly header?: string;

  /**
   * Whether CloudFront overrides a response header with the same name received from the origin with the header specifies here.
   *
   * @schema ResponseHeadersPolicySpecForProviderCustomHeadersConfigItems#override
   */
  readonly override?: boolean;

  /**
   * The value for the HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecForProviderCustomHeadersConfigItems#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProviderCustomHeadersConfigItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProviderCustomHeadersConfigItems(obj: ResponseHeadersPolicySpecForProviderCustomHeadersConfigItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header,
    'override': obj.override,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecForProviderRemoveHeadersConfigItems
 */
export interface ResponseHeadersPolicySpecForProviderRemoveHeadersConfigItems {
  /**
   * The HTTP response header name.
   *
   * @schema ResponseHeadersPolicySpecForProviderRemoveHeadersConfigItems#header
   */
  readonly header?: string;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProviderRemoveHeadersConfigItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProviderRemoveHeadersConfigItems(obj: ResponseHeadersPolicySpecForProviderRemoveHeadersConfigItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigContentSecurityPolicy
 */
export interface ResponseHeadersPolicySpecForProviderSecurityHeadersConfigContentSecurityPolicy {
  /**
   * The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header. See Content Security Policy for more information.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigContentSecurityPolicy#contentSecurityPolicy
   */
  readonly contentSecurityPolicy?: string;

  /**
   * Whether CloudFront overrides a response header with the same name received from the origin with the header specifies here.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigContentSecurityPolicy#override
   */
  readonly override?: boolean;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProviderSecurityHeadersConfigContentSecurityPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProviderSecurityHeadersConfigContentSecurityPolicy(obj: ResponseHeadersPolicySpecForProviderSecurityHeadersConfigContentSecurityPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentSecurityPolicy': obj.contentSecurityPolicy,
    'override': obj.override,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigContentTypeOptions
 */
export interface ResponseHeadersPolicySpecForProviderSecurityHeadersConfigContentTypeOptions {
  /**
   * Whether CloudFront overrides a response header with the same name received from the origin with the header specifies here.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigContentTypeOptions#override
   */
  readonly override?: boolean;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProviderSecurityHeadersConfigContentTypeOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProviderSecurityHeadersConfigContentTypeOptions(obj: ResponseHeadersPolicySpecForProviderSecurityHeadersConfigContentTypeOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'override': obj.override,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigFrameOptions
 */
export interface ResponseHeadersPolicySpecForProviderSecurityHeadersConfigFrameOptions {
  /**
   * The value of the X-Frame-Options HTTP response header. Valid values: DENY | SAMEORIGIN
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigFrameOptions#frameOption
   */
  readonly frameOption?: string;

  /**
   * Whether CloudFront overrides a response header with the same name received from the origin with the header specifies here.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigFrameOptions#override
   */
  readonly override?: boolean;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProviderSecurityHeadersConfigFrameOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProviderSecurityHeadersConfigFrameOptions(obj: ResponseHeadersPolicySpecForProviderSecurityHeadersConfigFrameOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'frameOption': obj.frameOption,
    'override': obj.override,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigReferrerPolicy
 */
export interface ResponseHeadersPolicySpecForProviderSecurityHeadersConfigReferrerPolicy {
  /**
   * Whether CloudFront overrides a response header with the same name received from the origin with the header specifies here.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigReferrerPolicy#override
   */
  readonly override?: boolean;

  /**
   * Determines whether CloudFront includes the Referrer-Policy HTTP response header and the header’s value. See Referrer Policy for more information.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigReferrerPolicy#referrerPolicy
   */
  readonly referrerPolicy?: string;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProviderSecurityHeadersConfigReferrerPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProviderSecurityHeadersConfigReferrerPolicy(obj: ResponseHeadersPolicySpecForProviderSecurityHeadersConfigReferrerPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'override': obj.override,
    'referrerPolicy': obj.referrerPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigStrictTransportSecurity
 */
export interface ResponseHeadersPolicySpecForProviderSecurityHeadersConfigStrictTransportSecurity {
  /**
   * A number that CloudFront uses as the value for the Access-Control-Max-Age HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigStrictTransportSecurity#accessControlMaxAgeSec
   */
  readonly accessControlMaxAgeSec?: number;

  /**
   * Whether CloudFront includes the includeSubDomains directive in the Strict-Transport-Security HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigStrictTransportSecurity#includeSubdomains
   */
  readonly includeSubdomains?: boolean;

  /**
   * Whether CloudFront overrides a response header with the same name received from the origin with the header specifies here.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigStrictTransportSecurity#override
   */
  readonly override?: boolean;

  /**
   * Whether CloudFront includes the preload directive in the Strict-Transport-Security HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigStrictTransportSecurity#preload
   */
  readonly preload?: boolean;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProviderSecurityHeadersConfigStrictTransportSecurity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProviderSecurityHeadersConfigStrictTransportSecurity(obj: ResponseHeadersPolicySpecForProviderSecurityHeadersConfigStrictTransportSecurity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessControlMaxAgeSec': obj.accessControlMaxAgeSec,
    'includeSubdomains': obj.includeSubdomains,
    'override': obj.override,
    'preload': obj.preload,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigXssProtection
 */
export interface ResponseHeadersPolicySpecForProviderSecurityHeadersConfigXssProtection {
  /**
   * Whether CloudFront includes the mode=block directive in the X-XSS-Protection header.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigXssProtection#modeBlock
   */
  readonly modeBlock?: boolean;

  /**
   * Whether CloudFront overrides a response header with the same name received from the origin with the header specifies here.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigXssProtection#override
   */
  readonly override?: boolean;

  /**
   * A Boolean value that determines the value of the X-XSS-Protection HTTP response header. When this setting is true, the value of the X-XSS-Protection header is 1. When this setting is false, the value of the X-XSS-Protection header is 0.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigXssProtection#protection
   */
  readonly protection?: boolean;

  /**
   * A reporting URI, which CloudFront uses as the value of the report directive in the X-XSS-Protection header. You cannot specify a report_uri when mode_block is true.
   *
   * @schema ResponseHeadersPolicySpecForProviderSecurityHeadersConfigXssProtection#reportUri
   */
  readonly reportUri?: string;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecForProviderSecurityHeadersConfigXssProtection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecForProviderSecurityHeadersConfigXssProtection(obj: ResponseHeadersPolicySpecForProviderSecurityHeadersConfigXssProtection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'modeBlock': obj.modeBlock,
    'override': obj.override,
    'protection': obj.protection,
    'reportUri': obj.reportUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowHeaders
 */
export interface ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowHeaders {
  /**
   * @schema ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowHeaders#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowHeaders(obj: ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowMethods
 */
export interface ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowMethods {
  /**
   * @schema ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowMethods#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowMethods' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowMethods(obj: ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowMethods | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowOrigins
 */
export interface ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowOrigins {
  /**
   * @schema ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowOrigins#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowOrigins' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowOrigins(obj: ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlAllowOrigins | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlExposeHeaders
 */
export interface ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlExposeHeaders {
  /**
   * @schema ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlExposeHeaders#items
   */
  readonly items?: string[];

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlExposeHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlExposeHeaders(obj: ResponseHeadersPolicySpecInitProviderCorsConfigAccessControlExposeHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecInitProviderCustomHeadersConfigItems
 */
export interface ResponseHeadersPolicySpecInitProviderCustomHeadersConfigItems {
  /**
   * The HTTP response header name.
   *
   * @schema ResponseHeadersPolicySpecInitProviderCustomHeadersConfigItems#header
   */
  readonly header?: string;

  /**
   * Whether CloudFront overrides a response header with the same name received from the origin with the header specifies here.
   *
   * @schema ResponseHeadersPolicySpecInitProviderCustomHeadersConfigItems#override
   */
  readonly override?: boolean;

  /**
   * The value for the HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecInitProviderCustomHeadersConfigItems#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProviderCustomHeadersConfigItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProviderCustomHeadersConfigItems(obj: ResponseHeadersPolicySpecInitProviderCustomHeadersConfigItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header,
    'override': obj.override,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecInitProviderRemoveHeadersConfigItems
 */
export interface ResponseHeadersPolicySpecInitProviderRemoveHeadersConfigItems {
  /**
   * The HTTP response header name.
   *
   * @schema ResponseHeadersPolicySpecInitProviderRemoveHeadersConfigItems#header
   */
  readonly header?: string;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProviderRemoveHeadersConfigItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProviderRemoveHeadersConfigItems(obj: ResponseHeadersPolicySpecInitProviderRemoveHeadersConfigItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigContentSecurityPolicy
 */
export interface ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigContentSecurityPolicy {
  /**
   * The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header. See Content Security Policy for more information.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigContentSecurityPolicy#contentSecurityPolicy
   */
  readonly contentSecurityPolicy?: string;

  /**
   * Whether CloudFront overrides a response header with the same name received from the origin with the header specifies here.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigContentSecurityPolicy#override
   */
  readonly override?: boolean;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigContentSecurityPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigContentSecurityPolicy(obj: ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigContentSecurityPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentSecurityPolicy': obj.contentSecurityPolicy,
    'override': obj.override,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigContentTypeOptions
 */
export interface ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigContentTypeOptions {
  /**
   * Whether CloudFront overrides a response header with the same name received from the origin with the header specifies here.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigContentTypeOptions#override
   */
  readonly override?: boolean;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigContentTypeOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigContentTypeOptions(obj: ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigContentTypeOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'override': obj.override,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigFrameOptions
 */
export interface ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigFrameOptions {
  /**
   * The value of the X-Frame-Options HTTP response header. Valid values: DENY | SAMEORIGIN
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigFrameOptions#frameOption
   */
  readonly frameOption?: string;

  /**
   * Whether CloudFront overrides a response header with the same name received from the origin with the header specifies here.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigFrameOptions#override
   */
  readonly override?: boolean;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigFrameOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigFrameOptions(obj: ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigFrameOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'frameOption': obj.frameOption,
    'override': obj.override,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigReferrerPolicy
 */
export interface ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigReferrerPolicy {
  /**
   * Whether CloudFront overrides a response header with the same name received from the origin with the header specifies here.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigReferrerPolicy#override
   */
  readonly override?: boolean;

  /**
   * Determines whether CloudFront includes the Referrer-Policy HTTP response header and the header’s value. See Referrer Policy for more information.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigReferrerPolicy#referrerPolicy
   */
  readonly referrerPolicy?: string;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigReferrerPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigReferrerPolicy(obj: ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigReferrerPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'override': obj.override,
    'referrerPolicy': obj.referrerPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigStrictTransportSecurity
 */
export interface ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigStrictTransportSecurity {
  /**
   * A number that CloudFront uses as the value for the Access-Control-Max-Age HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigStrictTransportSecurity#accessControlMaxAgeSec
   */
  readonly accessControlMaxAgeSec?: number;

  /**
   * Whether CloudFront includes the includeSubDomains directive in the Strict-Transport-Security HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigStrictTransportSecurity#includeSubdomains
   */
  readonly includeSubdomains?: boolean;

  /**
   * Whether CloudFront overrides a response header with the same name received from the origin with the header specifies here.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigStrictTransportSecurity#override
   */
  readonly override?: boolean;

  /**
   * Whether CloudFront includes the preload directive in the Strict-Transport-Security HTTP response header.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigStrictTransportSecurity#preload
   */
  readonly preload?: boolean;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigStrictTransportSecurity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigStrictTransportSecurity(obj: ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigStrictTransportSecurity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessControlMaxAgeSec': obj.accessControlMaxAgeSec,
    'includeSubdomains': obj.includeSubdomains,
    'override': obj.override,
    'preload': obj.preload,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigXssProtection
 */
export interface ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigXssProtection {
  /**
   * Whether CloudFront includes the mode=block directive in the X-XSS-Protection header.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigXssProtection#modeBlock
   */
  readonly modeBlock?: boolean;

  /**
   * Whether CloudFront overrides a response header with the same name received from the origin with the header specifies here.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigXssProtection#override
   */
  readonly override?: boolean;

  /**
   * A Boolean value that determines the value of the X-XSS-Protection HTTP response header. When this setting is true, the value of the X-XSS-Protection header is 1. When this setting is false, the value of the X-XSS-Protection header is 0.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigXssProtection#protection
   */
  readonly protection?: boolean;

  /**
   * A reporting URI, which CloudFront uses as the value of the report directive in the X-XSS-Protection header. You cannot specify a report_uri when mode_block is true.
   *
   * @schema ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigXssProtection#reportUri
   */
  readonly reportUri?: string;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigXssProtection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigXssProtection(obj: ResponseHeadersPolicySpecInitProviderSecurityHeadersConfigXssProtection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'modeBlock': obj.modeBlock,
    'override': obj.override,
    'protection': obj.protection,
    'reportUri': obj.reportUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResponseHeadersPolicySpecProviderConfigRefPolicyResolution
 */
export enum ResponseHeadersPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResponseHeadersPolicySpecProviderConfigRefPolicyResolve
 */
export enum ResponseHeadersPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ResponseHeadersPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

