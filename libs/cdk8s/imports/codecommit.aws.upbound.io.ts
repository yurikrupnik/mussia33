// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ApprovalRuleTemplate is the Schema for the ApprovalRuleTemplates API. Provides a CodeCommit Approval Rule Template Resource.
 *
 * @schema ApprovalRuleTemplate
 */
export class ApprovalRuleTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ApprovalRuleTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'codecommit.aws.upbound.io/v1beta1',
    kind: 'ApprovalRuleTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "ApprovalRuleTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApprovalRuleTemplateProps): any {
    return {
      ...ApprovalRuleTemplate.GVK,
      ...toJson_ApprovalRuleTemplateProps(props),
    };
  }

  /**
   * Defines a "ApprovalRuleTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApprovalRuleTemplateProps) {
    super(scope, id, {
      ...ApprovalRuleTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApprovalRuleTemplate.GVK,
      ...toJson_ApprovalRuleTemplateProps(resolved),
    };
  }
}

/**
 * ApprovalRuleTemplate is the Schema for the ApprovalRuleTemplates API. Provides a CodeCommit Approval Rule Template Resource.
 *
 * @schema ApprovalRuleTemplate
 */
export interface ApprovalRuleTemplateProps {
  /**
   * @schema ApprovalRuleTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ApprovalRuleTemplateSpec defines the desired state of ApprovalRuleTemplate
   *
   * @schema ApprovalRuleTemplate#spec
   */
  readonly spec: ApprovalRuleTemplateSpec;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateProps(obj: ApprovalRuleTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApprovalRuleTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApprovalRuleTemplateSpec defines the desired state of ApprovalRuleTemplate
 *
 * @schema ApprovalRuleTemplateSpec
 */
export interface ApprovalRuleTemplateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApprovalRuleTemplateSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApprovalRuleTemplateSpecDeletionPolicy;

  /**
   * @schema ApprovalRuleTemplateSpec#forProvider
   */
  readonly forProvider: ApprovalRuleTemplateSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ApprovalRuleTemplateSpec#initProvider
   */
  readonly initProvider?: ApprovalRuleTemplateSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ApprovalRuleTemplateSpec#managementPolicies
   */
  readonly managementPolicies?: ApprovalRuleTemplateSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApprovalRuleTemplateSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApprovalRuleTemplateSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApprovalRuleTemplateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApprovalRuleTemplateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApprovalRuleTemplateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApprovalRuleTemplateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateSpec(obj: ApprovalRuleTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApprovalRuleTemplateSpecForProvider(obj.forProvider),
    'initProvider': toJson_ApprovalRuleTemplateSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ApprovalRuleTemplateSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ApprovalRuleTemplateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApprovalRuleTemplateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApprovalRuleTemplateSpecDeletionPolicy
 */
export enum ApprovalRuleTemplateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApprovalRuleTemplateSpecForProvider
 */
export interface ApprovalRuleTemplateSpecForProvider {
  /**
   * The content of the approval rule template. Maximum of 3000 characters.
   *
   * @schema ApprovalRuleTemplateSpecForProvider#content
   */
  readonly content?: string;

  /**
   * The description of the approval rule template. Maximum of 1000 characters.
   *
   * @schema ApprovalRuleTemplateSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ApprovalRuleTemplateSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateSpecForProvider(obj: ApprovalRuleTemplateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'description': obj.description,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ApprovalRuleTemplateSpecInitProvider
 */
export interface ApprovalRuleTemplateSpecInitProvider {
  /**
   * The content of the approval rule template. Maximum of 3000 characters.
   *
   * @schema ApprovalRuleTemplateSpecInitProvider#content
   */
  readonly content?: string;

  /**
   * The description of the approval rule template. Maximum of 1000 characters.
   *
   * @schema ApprovalRuleTemplateSpecInitProvider#description
   */
  readonly description?: string;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateSpecInitProvider(obj: ApprovalRuleTemplateSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'description': obj.description,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ApprovalRuleTemplateSpecManagementPolicies
 */
export enum ApprovalRuleTemplateSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApprovalRuleTemplateSpecProviderConfigRef
 */
export interface ApprovalRuleTemplateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApprovalRuleTemplateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApprovalRuleTemplateSpecProviderConfigRef#policy
   */
  readonly policy?: ApprovalRuleTemplateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateSpecProviderConfigRef(obj: ApprovalRuleTemplateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApprovalRuleTemplateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApprovalRuleTemplateSpecPublishConnectionDetailsTo
 */
export interface ApprovalRuleTemplateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApprovalRuleTemplateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApprovalRuleTemplateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApprovalRuleTemplateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApprovalRuleTemplateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateSpecPublishConnectionDetailsTo(obj: ApprovalRuleTemplateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApprovalRuleTemplateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApprovalRuleTemplateSpecWriteConnectionSecretToRef
 */
export interface ApprovalRuleTemplateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApprovalRuleTemplateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApprovalRuleTemplateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateSpecWriteConnectionSecretToRef(obj: ApprovalRuleTemplateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApprovalRuleTemplateSpecProviderConfigRefPolicy
 */
export interface ApprovalRuleTemplateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApprovalRuleTemplateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApprovalRuleTemplateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApprovalRuleTemplateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApprovalRuleTemplateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateSpecProviderConfigRefPolicy(obj: ApprovalRuleTemplateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRef
 */
export interface ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRef(obj: ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApprovalRuleTemplateSpecPublishConnectionDetailsToMetadata
 */
export interface ApprovalRuleTemplateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApprovalRuleTemplateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApprovalRuleTemplateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApprovalRuleTemplateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateSpecPublishConnectionDetailsToMetadata(obj: ApprovalRuleTemplateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApprovalRuleTemplateSpecProviderConfigRefPolicyResolution
 */
export enum ApprovalRuleTemplateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApprovalRuleTemplateSpecProviderConfigRefPolicyResolve
 */
export enum ApprovalRuleTemplateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApprovalRuleTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ApprovalRuleTemplateAssociation is the Schema for the ApprovalRuleTemplateAssociations API. Associates a CodeCommit Approval Rule Template with a Repository.
 *
 * @schema ApprovalRuleTemplateAssociation
 */
export class ApprovalRuleTemplateAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ApprovalRuleTemplateAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'codecommit.aws.upbound.io/v1beta1',
    kind: 'ApprovalRuleTemplateAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "ApprovalRuleTemplateAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApprovalRuleTemplateAssociationProps): any {
    return {
      ...ApprovalRuleTemplateAssociation.GVK,
      ...toJson_ApprovalRuleTemplateAssociationProps(props),
    };
  }

  /**
   * Defines a "ApprovalRuleTemplateAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApprovalRuleTemplateAssociationProps) {
    super(scope, id, {
      ...ApprovalRuleTemplateAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApprovalRuleTemplateAssociation.GVK,
      ...toJson_ApprovalRuleTemplateAssociationProps(resolved),
    };
  }
}

/**
 * ApprovalRuleTemplateAssociation is the Schema for the ApprovalRuleTemplateAssociations API. Associates a CodeCommit Approval Rule Template with a Repository.
 *
 * @schema ApprovalRuleTemplateAssociation
 */
export interface ApprovalRuleTemplateAssociationProps {
  /**
   * @schema ApprovalRuleTemplateAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ApprovalRuleTemplateAssociationSpec defines the desired state of ApprovalRuleTemplateAssociation
   *
   * @schema ApprovalRuleTemplateAssociation#spec
   */
  readonly spec: ApprovalRuleTemplateAssociationSpec;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationProps(obj: ApprovalRuleTemplateAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApprovalRuleTemplateAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApprovalRuleTemplateAssociationSpec defines the desired state of ApprovalRuleTemplateAssociation
 *
 * @schema ApprovalRuleTemplateAssociationSpec
 */
export interface ApprovalRuleTemplateAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApprovalRuleTemplateAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApprovalRuleTemplateAssociationSpecDeletionPolicy;

  /**
   * @schema ApprovalRuleTemplateAssociationSpec#forProvider
   */
  readonly forProvider: ApprovalRuleTemplateAssociationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ApprovalRuleTemplateAssociationSpec#initProvider
   */
  readonly initProvider?: any;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ApprovalRuleTemplateAssociationSpec#managementPolicies
   */
  readonly managementPolicies?: ApprovalRuleTemplateAssociationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApprovalRuleTemplateAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApprovalRuleTemplateAssociationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApprovalRuleTemplateAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApprovalRuleTemplateAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApprovalRuleTemplateAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationSpec(obj: ApprovalRuleTemplateAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApprovalRuleTemplateAssociationSpecForProvider(obj.forProvider),
    'initProvider': obj.initProvider,
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ApprovalRuleTemplateAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApprovalRuleTemplateAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApprovalRuleTemplateAssociationSpecDeletionPolicy
 */
export enum ApprovalRuleTemplateAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApprovalRuleTemplateAssociationSpecForProvider
 */
export interface ApprovalRuleTemplateAssociationSpecForProvider {
  /**
   * The name for the approval rule template.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProvider#approvalRuleTemplateName
   */
  readonly approvalRuleTemplateName?: string;

  /**
   * Reference to a ApprovalRuleTemplate in codecommit to populate approvalRuleTemplateName.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProvider#approvalRuleTemplateNameRef
   */
  readonly approvalRuleTemplateNameRef?: ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRef;

  /**
   * Selector for a ApprovalRuleTemplate in codecommit to populate approvalRuleTemplateName.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProvider#approvalRuleTemplateNameSelector
   */
  readonly approvalRuleTemplateNameSelector?: ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name of the repository that you want to associate with the template.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProvider#repositoryName
   */
  readonly repositoryName?: string;

  /**
   * Reference to a Repository in codecommit to populate repositoryName.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProvider#repositoryNameRef
   */
  readonly repositoryNameRef?: ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRef;

  /**
   * Selector for a Repository in codecommit to populate repositoryName.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProvider#repositoryNameSelector
   */
  readonly repositoryNameSelector?: ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelector;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationSpecForProvider(obj: ApprovalRuleTemplateAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'approvalRuleTemplateName': obj.approvalRuleTemplateName,
    'approvalRuleTemplateNameRef': toJson_ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRef(obj.approvalRuleTemplateNameRef),
    'approvalRuleTemplateNameSelector': toJson_ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelector(obj.approvalRuleTemplateNameSelector),
    'region': obj.region,
    'repositoryName': obj.repositoryName,
    'repositoryNameRef': toJson_ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRef(obj.repositoryNameRef),
    'repositoryNameSelector': toJson_ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelector(obj.repositoryNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ApprovalRuleTemplateAssociationSpecManagementPolicies
 */
export enum ApprovalRuleTemplateAssociationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApprovalRuleTemplateAssociationSpecProviderConfigRef
 */
export interface ApprovalRuleTemplateAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApprovalRuleTemplateAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApprovalRuleTemplateAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: ApprovalRuleTemplateAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationSpecProviderConfigRef(obj: ApprovalRuleTemplateAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApprovalRuleTemplateAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsTo
 */
export interface ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsTo(obj: ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApprovalRuleTemplateAssociationSpecWriteConnectionSecretToRef
 */
export interface ApprovalRuleTemplateAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApprovalRuleTemplateAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApprovalRuleTemplateAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationSpecWriteConnectionSecretToRef(obj: ApprovalRuleTemplateAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ApprovalRuleTemplate in codecommit to populate approvalRuleTemplateName.
 *
 * @schema ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRef
 */
export interface ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRef#policy
   */
  readonly policy?: ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRefPolicy;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRef(obj: ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ApprovalRuleTemplate in codecommit to populate approvalRuleTemplateName.
 *
 * @schema ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelector
 */
export interface ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelector#policy
   */
  readonly policy?: ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelectorPolicy;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelector(obj: ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Repository in codecommit to populate repositoryName.
 *
 * @schema ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRef
 */
export interface ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRef#policy
   */
  readonly policy?: ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRefPolicy;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRef(obj: ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Repository in codecommit to populate repositoryName.
 *
 * @schema ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelector
 */
export interface ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelector#policy
   */
  readonly policy?: ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelectorPolicy;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelector(obj: ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApprovalRuleTemplateAssociationSpecProviderConfigRefPolicy
 */
export interface ApprovalRuleTemplateAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApprovalRuleTemplateAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApprovalRuleTemplateAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApprovalRuleTemplateAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApprovalRuleTemplateAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationSpecProviderConfigRefPolicy(obj: ApprovalRuleTemplateAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRef(obj: ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToMetadata(obj: ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRefPolicy
 */
export interface ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRefPolicy#resolution
   */
  readonly resolution?: ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRefPolicy#resolve
   */
  readonly resolve?: ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRefPolicy(obj: ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelectorPolicy
 */
export interface ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelectorPolicy#resolution
   */
  readonly resolution?: ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelectorPolicy#resolve
   */
  readonly resolve?: ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelectorPolicy(obj: ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRefPolicy
 */
export interface ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRefPolicy#resolution
   */
  readonly resolution?: ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRefPolicy#resolve
   */
  readonly resolve?: ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRefPolicy(obj: ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelectorPolicy
 */
export interface ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelectorPolicy#resolution
   */
  readonly resolution?: ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelectorPolicy#resolve
   */
  readonly resolve?: ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelectorPolicy(obj: ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApprovalRuleTemplateAssociationSpecProviderConfigRefPolicyResolution
 */
export enum ApprovalRuleTemplateAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApprovalRuleTemplateAssociationSpecProviderConfigRefPolicyResolve
 */
export enum ApprovalRuleTemplateAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRefPolicyResolution
 */
export enum ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRefPolicyResolve
 */
export enum ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelectorPolicyResolution
 */
export enum ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelectorPolicyResolve
 */
export enum ApprovalRuleTemplateAssociationSpecForProviderApprovalRuleTemplateNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRefPolicyResolution
 */
export enum ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRefPolicyResolve
 */
export enum ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelectorPolicyResolution
 */
export enum ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelectorPolicyResolve
 */
export enum ApprovalRuleTemplateAssociationSpecForProviderRepositoryNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApprovalRuleTemplateAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Repository is the Schema for the Repositorys API. Provides a CodeCommit Repository Resource.
 *
 * @schema Repository
 */
export class Repository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Repository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'codecommit.aws.upbound.io/v1beta1',
    kind: 'Repository',
  }

  /**
   * Renders a Kubernetes manifest for "Repository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RepositoryProps): any {
    return {
      ...Repository.GVK,
      ...toJson_RepositoryProps(props),
    };
  }

  /**
   * Defines a "Repository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RepositoryProps) {
    super(scope, id, {
      ...Repository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Repository.GVK,
      ...toJson_RepositoryProps(resolved),
    };
  }
}

/**
 * Repository is the Schema for the Repositorys API. Provides a CodeCommit Repository Resource.
 *
 * @schema Repository
 */
export interface RepositoryProps {
  /**
   * @schema Repository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RepositorySpec defines the desired state of Repository
   *
   * @schema Repository#spec
   */
  readonly spec: RepositorySpec;

}

/**
 * Converts an object of type 'RepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryProps(obj: RepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepositorySpec defines the desired state of Repository
 *
 * @schema RepositorySpec
 */
export interface RepositorySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RepositorySpec#deletionPolicy
   */
  readonly deletionPolicy?: RepositorySpecDeletionPolicy;

  /**
   * @schema RepositorySpec#forProvider
   */
  readonly forProvider: RepositorySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema RepositorySpec#initProvider
   */
  readonly initProvider?: RepositorySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RepositorySpec#managementPolicies
   */
  readonly managementPolicies?: RepositorySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RepositorySpec#providerConfigRef
   */
  readonly providerConfigRef?: RepositorySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RepositorySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RepositorySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RepositorySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RepositorySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpec(obj: RepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RepositorySpecForProvider(obj.forProvider),
    'initProvider': toJson_RepositorySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RepositorySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RepositorySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RepositorySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RepositorySpecDeletionPolicy
 */
export enum RepositorySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RepositorySpecForProvider
 */
export interface RepositorySpecForProvider {
  /**
   * The default branch of the repository. The branch specified here needs to exist.
   *
   * @schema RepositorySpecForProvider#defaultBranch
   */
  readonly defaultBranch?: string;

  /**
   * The description of the repository. This needs to be less than 1000 characters
   *
   * @schema RepositorySpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RepositorySpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RepositorySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RepositorySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProvider(obj: RepositorySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultBranch': obj.defaultBranch,
    'description': obj.description,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema RepositorySpecInitProvider
 */
export interface RepositorySpecInitProvider {
  /**
   * The default branch of the repository. The branch specified here needs to exist.
   *
   * @schema RepositorySpecInitProvider#defaultBranch
   */
  readonly defaultBranch?: string;

  /**
   * The description of the repository. This needs to be less than 1000 characters
   *
   * @schema RepositorySpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RepositorySpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RepositorySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecInitProvider(obj: RepositorySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultBranch': obj.defaultBranch,
    'description': obj.description,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RepositorySpecManagementPolicies
 */
export enum RepositorySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RepositorySpecProviderConfigRef
 */
export interface RepositorySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositorySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositorySpecProviderConfigRef#policy
   */
  readonly policy?: RepositorySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositorySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecProviderConfigRef(obj: RepositorySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositorySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RepositorySpecPublishConnectionDetailsTo
 */
export interface RepositorySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RepositorySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RepositorySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RepositorySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RepositorySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RepositorySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsTo(obj: RepositorySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RepositorySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RepositorySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RepositorySpecWriteConnectionSecretToRef
 */
export interface RepositorySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RepositorySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RepositorySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RepositorySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecWriteConnectionSecretToRef(obj: RepositorySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositorySpecProviderConfigRefPolicy
 */
export interface RepositorySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RepositorySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RepositorySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecProviderConfigRefPolicy(obj: RepositorySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRef
 */
export interface RepositorySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RepositorySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsToConfigRef(obj: RepositorySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositorySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RepositorySpecPublishConnectionDetailsToMetadata
 */
export interface RepositorySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositorySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositorySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RepositorySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsToMetadata(obj: RepositorySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecProviderConfigRefPolicyResolution
 */
export enum RepositorySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecProviderConfigRefPolicyResolve
 */
export enum RepositorySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RepositorySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsToConfigRefPolicy(obj: RepositorySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Trigger is the Schema for the Triggers API. Provides a CodeCommit Trigger Resource.
 *
 * @schema Trigger
 */
export class Trigger extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Trigger"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'codecommit.aws.upbound.io/v1beta1',
    kind: 'Trigger',
  }

  /**
   * Renders a Kubernetes manifest for "Trigger".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TriggerProps): any {
    return {
      ...Trigger.GVK,
      ...toJson_TriggerProps(props),
    };
  }

  /**
   * Defines a "Trigger" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TriggerProps) {
    super(scope, id, {
      ...Trigger.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Trigger.GVK,
      ...toJson_TriggerProps(resolved),
    };
  }
}

/**
 * Trigger is the Schema for the Triggers API. Provides a CodeCommit Trigger Resource.
 *
 * @schema Trigger
 */
export interface TriggerProps {
  /**
   * @schema Trigger#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TriggerSpec defines the desired state of Trigger
   *
   * @schema Trigger#spec
   */
  readonly spec: TriggerSpec;

}

/**
 * Converts an object of type 'TriggerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerProps(obj: TriggerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TriggerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TriggerSpec defines the desired state of Trigger
 *
 * @schema TriggerSpec
 */
export interface TriggerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TriggerSpec#deletionPolicy
   */
  readonly deletionPolicy?: TriggerSpecDeletionPolicy;

  /**
   * @schema TriggerSpec#forProvider
   */
  readonly forProvider: TriggerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema TriggerSpec#initProvider
   */
  readonly initProvider?: TriggerSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TriggerSpec#managementPolicies
   */
  readonly managementPolicies?: TriggerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TriggerSpec#providerConfigRef
   */
  readonly providerConfigRef?: TriggerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TriggerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TriggerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TriggerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TriggerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TriggerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpec(obj: TriggerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TriggerSpecForProvider(obj.forProvider),
    'initProvider': toJson_TriggerSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TriggerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TriggerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TriggerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TriggerSpecDeletionPolicy
 */
export enum TriggerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TriggerSpecForProvider
 */
export interface TriggerSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TriggerSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name for the repository. This needs to be less than 100 characters.
   *
   * @schema TriggerSpecForProvider#repositoryName
   */
  readonly repositoryName?: string;

  /**
   * Reference to a Repository in codecommit to populate repositoryName.
   *
   * @schema TriggerSpecForProvider#repositoryNameRef
   */
  readonly repositoryNameRef?: TriggerSpecForProviderRepositoryNameRef;

  /**
   * Selector for a Repository in codecommit to populate repositoryName.
   *
   * @schema TriggerSpecForProvider#repositoryNameSelector
   */
  readonly repositoryNameSelector?: TriggerSpecForProviderRepositoryNameSelector;

  /**
   * @schema TriggerSpecForProvider#trigger
   */
  readonly trigger?: TriggerSpecForProviderTrigger[];

}

/**
 * Converts an object of type 'TriggerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProvider(obj: TriggerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'repositoryName': obj.repositoryName,
    'repositoryNameRef': toJson_TriggerSpecForProviderRepositoryNameRef(obj.repositoryNameRef),
    'repositoryNameSelector': toJson_TriggerSpecForProviderRepositoryNameSelector(obj.repositoryNameSelector),
    'trigger': obj.trigger?.map(y => toJson_TriggerSpecForProviderTrigger(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema TriggerSpecInitProvider
 */
export interface TriggerSpecInitProvider {
  /**
   * @schema TriggerSpecInitProvider#trigger
   */
  readonly trigger?: TriggerSpecInitProviderTrigger[];

}

/**
 * Converts an object of type 'TriggerSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecInitProvider(obj: TriggerSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'trigger': obj.trigger?.map(y => toJson_TriggerSpecInitProviderTrigger(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TriggerSpecManagementPolicies
 */
export enum TriggerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TriggerSpecProviderConfigRef
 */
export interface TriggerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TriggerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TriggerSpecProviderConfigRef#policy
   */
  readonly policy?: TriggerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TriggerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecProviderConfigRef(obj: TriggerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TriggerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TriggerSpecPublishConnectionDetailsTo
 */
export interface TriggerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TriggerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TriggerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TriggerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TriggerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TriggerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TriggerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecPublishConnectionDetailsTo(obj: TriggerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TriggerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TriggerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TriggerSpecWriteConnectionSecretToRef
 */
export interface TriggerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TriggerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TriggerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TriggerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecWriteConnectionSecretToRef(obj: TriggerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Repository in codecommit to populate repositoryName.
 *
 * @schema TriggerSpecForProviderRepositoryNameRef
 */
export interface TriggerSpecForProviderRepositoryNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema TriggerSpecForProviderRepositoryNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TriggerSpecForProviderRepositoryNameRef#policy
   */
  readonly policy?: TriggerSpecForProviderRepositoryNameRefPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderRepositoryNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderRepositoryNameRef(obj: TriggerSpecForProviderRepositoryNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TriggerSpecForProviderRepositoryNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Repository in codecommit to populate repositoryName.
 *
 * @schema TriggerSpecForProviderRepositoryNameSelector
 */
export interface TriggerSpecForProviderRepositoryNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TriggerSpecForProviderRepositoryNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TriggerSpecForProviderRepositoryNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TriggerSpecForProviderRepositoryNameSelector#policy
   */
  readonly policy?: TriggerSpecForProviderRepositoryNameSelectorPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderRepositoryNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderRepositoryNameSelector(obj: TriggerSpecForProviderRepositoryNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TriggerSpecForProviderRepositoryNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderTrigger
 */
export interface TriggerSpecForProviderTrigger {
  /**
   * The branches that will be included in the trigger configuration. If no branches are specified, the trigger will apply to all branches.
   *
   * @schema TriggerSpecForProviderTrigger#branches
   */
  readonly branches?: string[];

  /**
   * Any custom data associated with the trigger that will be included in the information sent to the target of the trigger.
   *
   * @schema TriggerSpecForProviderTrigger#customData
   */
  readonly customData?: string;

  /**
   * The ARN of the resource that is the target for a trigger. For example, the ARN of a topic in Amazon Simple Notification Service (SNS).
   *
   * @schema TriggerSpecForProviderTrigger#destinationArn
   */
  readonly destinationArn?: string;

  /**
   * Reference to a Topic in sns to populate destinationArn.
   *
   * @schema TriggerSpecForProviderTrigger#destinationArnRef
   */
  readonly destinationArnRef?: TriggerSpecForProviderTriggerDestinationArnRef;

  /**
   * Selector for a Topic in sns to populate destinationArn.
   *
   * @schema TriggerSpecForProviderTrigger#destinationArnSelector
   */
  readonly destinationArnSelector?: TriggerSpecForProviderTriggerDestinationArnSelector;

  /**
   * The repository events that will cause the trigger to run actions in another service, such as sending a notification through Amazon Simple Notification Service (SNS). If no events are specified, the trigger will run for all repository events. Event types include: all, updateReference, createReference, deleteReference.
   *
   * @schema TriggerSpecForProviderTrigger#events
   */
  readonly events?: string[];

  /**
   * The name of the trigger.
   *
   * @schema TriggerSpecForProviderTrigger#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'TriggerSpecForProviderTrigger' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderTrigger(obj: TriggerSpecForProviderTrigger | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branches': obj.branches?.map(y => y),
    'customData': obj.customData,
    'destinationArn': obj.destinationArn,
    'destinationArnRef': toJson_TriggerSpecForProviderTriggerDestinationArnRef(obj.destinationArnRef),
    'destinationArnSelector': toJson_TriggerSpecForProviderTriggerDestinationArnSelector(obj.destinationArnSelector),
    'events': obj.events?.map(y => y),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecInitProviderTrigger
 */
export interface TriggerSpecInitProviderTrigger {
  /**
   * The branches that will be included in the trigger configuration. If no branches are specified, the trigger will apply to all branches.
   *
   * @schema TriggerSpecInitProviderTrigger#branches
   */
  readonly branches?: string[];

  /**
   * Any custom data associated with the trigger that will be included in the information sent to the target of the trigger.
   *
   * @schema TriggerSpecInitProviderTrigger#customData
   */
  readonly customData?: string;

  /**
   * The repository events that will cause the trigger to run actions in another service, such as sending a notification through Amazon Simple Notification Service (SNS). If no events are specified, the trigger will run for all repository events. Event types include: all, updateReference, createReference, deleteReference.
   *
   * @schema TriggerSpecInitProviderTrigger#events
   */
  readonly events?: string[];

  /**
   * The name of the trigger.
   *
   * @schema TriggerSpecInitProviderTrigger#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'TriggerSpecInitProviderTrigger' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecInitProviderTrigger(obj: TriggerSpecInitProviderTrigger | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branches': obj.branches?.map(y => y),
    'customData': obj.customData,
    'events': obj.events?.map(y => y),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TriggerSpecProviderConfigRefPolicy
 */
export interface TriggerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TriggerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TriggerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecProviderConfigRefPolicy(obj: TriggerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TriggerSpecPublishConnectionDetailsToConfigRef
 */
export interface TriggerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TriggerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TriggerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TriggerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TriggerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecPublishConnectionDetailsToConfigRef(obj: TriggerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TriggerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TriggerSpecPublishConnectionDetailsToMetadata
 */
export interface TriggerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TriggerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TriggerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TriggerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TriggerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecPublishConnectionDetailsToMetadata(obj: TriggerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TriggerSpecForProviderRepositoryNameRefPolicy
 */
export interface TriggerSpecForProviderRepositoryNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderRepositoryNameRefPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderRepositoryNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderRepositoryNameRefPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderRepositoryNameRefPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderRepositoryNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderRepositoryNameRefPolicy(obj: TriggerSpecForProviderRepositoryNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TriggerSpecForProviderRepositoryNameSelectorPolicy
 */
export interface TriggerSpecForProviderRepositoryNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderRepositoryNameSelectorPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderRepositoryNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderRepositoryNameSelectorPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderRepositoryNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderRepositoryNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderRepositoryNameSelectorPolicy(obj: TriggerSpecForProviderRepositoryNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate destinationArn.
 *
 * @schema TriggerSpecForProviderTriggerDestinationArnRef
 */
export interface TriggerSpecForProviderTriggerDestinationArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TriggerSpecForProviderTriggerDestinationArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TriggerSpecForProviderTriggerDestinationArnRef#policy
   */
  readonly policy?: TriggerSpecForProviderTriggerDestinationArnRefPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderTriggerDestinationArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderTriggerDestinationArnRef(obj: TriggerSpecForProviderTriggerDestinationArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TriggerSpecForProviderTriggerDestinationArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate destinationArn.
 *
 * @schema TriggerSpecForProviderTriggerDestinationArnSelector
 */
export interface TriggerSpecForProviderTriggerDestinationArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TriggerSpecForProviderTriggerDestinationArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TriggerSpecForProviderTriggerDestinationArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TriggerSpecForProviderTriggerDestinationArnSelector#policy
   */
  readonly policy?: TriggerSpecForProviderTriggerDestinationArnSelectorPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderTriggerDestinationArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderTriggerDestinationArnSelector(obj: TriggerSpecForProviderTriggerDestinationArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TriggerSpecForProviderTriggerDestinationArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecProviderConfigRefPolicyResolution
 */
export enum TriggerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecProviderConfigRefPolicyResolve
 */
export enum TriggerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TriggerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TriggerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecPublishConnectionDetailsToConfigRefPolicy(obj: TriggerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderRepositoryNameRefPolicyResolution
 */
export enum TriggerSpecForProviderRepositoryNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderRepositoryNameRefPolicyResolve
 */
export enum TriggerSpecForProviderRepositoryNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderRepositoryNameSelectorPolicyResolution
 */
export enum TriggerSpecForProviderRepositoryNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderRepositoryNameSelectorPolicyResolve
 */
export enum TriggerSpecForProviderRepositoryNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TriggerSpecForProviderTriggerDestinationArnRefPolicy
 */
export interface TriggerSpecForProviderTriggerDestinationArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderTriggerDestinationArnRefPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderTriggerDestinationArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderTriggerDestinationArnRefPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderTriggerDestinationArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderTriggerDestinationArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderTriggerDestinationArnRefPolicy(obj: TriggerSpecForProviderTriggerDestinationArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TriggerSpecForProviderTriggerDestinationArnSelectorPolicy
 */
export interface TriggerSpecForProviderTriggerDestinationArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderTriggerDestinationArnSelectorPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderTriggerDestinationArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderTriggerDestinationArnSelectorPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderTriggerDestinationArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderTriggerDestinationArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderTriggerDestinationArnSelectorPolicy(obj: TriggerSpecForProviderTriggerDestinationArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderTriggerDestinationArnRefPolicyResolution
 */
export enum TriggerSpecForProviderTriggerDestinationArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderTriggerDestinationArnRefPolicyResolve
 */
export enum TriggerSpecForProviderTriggerDestinationArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderTriggerDestinationArnSelectorPolicyResolution
 */
export enum TriggerSpecForProviderTriggerDestinationArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderTriggerDestinationArnSelectorPolicyResolve
 */
export enum TriggerSpecForProviderTriggerDestinationArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

