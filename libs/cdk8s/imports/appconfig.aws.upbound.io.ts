// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Application is the Schema for the Applications API. Provides an AppConfig Application resource.
 *
 * @schema Application
 */
export class Application extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Application"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appconfig.aws.upbound.io/v1beta1',
    kind: 'Application',
  }

  /**
   * Renders a Kubernetes manifest for "Application".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApplicationProps): any {
    return {
      ...Application.GVK,
      ...toJson_ApplicationProps(props),
    };
  }

  /**
   * Defines a "Application" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApplicationProps) {
    super(scope, id, {
      ...Application.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Application.GVK,
      ...toJson_ApplicationProps(resolved),
    };
  }
}

/**
 * Application is the Schema for the Applications API. Provides an AppConfig Application resource.
 *
 * @schema Application
 */
export interface ApplicationProps {
  /**
   * @schema Application#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ApplicationSpec defines the desired state of Application
   *
   * @schema Application#spec
   */
  readonly spec: ApplicationSpec;

}

/**
 * Converts an object of type 'ApplicationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationProps(obj: ApplicationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApplicationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplicationSpec defines the desired state of Application
 *
 * @schema ApplicationSpec
 */
export interface ApplicationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApplicationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApplicationSpecDeletionPolicy;

  /**
   * @schema ApplicationSpec#forProvider
   */
  readonly forProvider: ApplicationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApplicationSpec#managementPolicy
   */
  readonly managementPolicy?: ApplicationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApplicationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApplicationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ApplicationSpec#providerRef
   */
  readonly providerRef?: ApplicationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApplicationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApplicationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApplicationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApplicationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApplicationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpec(obj: ApplicationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApplicationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ApplicationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ApplicationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ApplicationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApplicationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApplicationSpecDeletionPolicy
 */
export enum ApplicationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApplicationSpecForProvider
 */
export interface ApplicationSpecForProvider {
  /**
   * Description of the application. Can be at most 1024 characters.
   *
   * @schema ApplicationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Name for the application. Must be between 1 and 64 characters in length.
   *
   * @schema ApplicationSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ApplicationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ApplicationSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApplicationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProvider(obj: ApplicationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApplicationSpecManagementPolicy
 */
export enum ApplicationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApplicationSpecProviderConfigRef
 */
export interface ApplicationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecProviderConfigRef#policy
   */
  readonly policy?: ApplicationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderConfigRef(obj: ApplicationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ApplicationSpecProviderRef
 */
export interface ApplicationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecProviderRef#policy
   */
  readonly policy?: ApplicationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderRef(obj: ApplicationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApplicationSpecPublishConnectionDetailsTo
 */
export interface ApplicationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApplicationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApplicationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsTo(obj: ApplicationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApplicationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApplicationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApplicationSpecWriteConnectionSecretToRef
 */
export interface ApplicationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApplicationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApplicationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApplicationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecWriteConnectionSecretToRef(obj: ApplicationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecProviderConfigRefPolicy
 */
export interface ApplicationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderConfigRefPolicy(obj: ApplicationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecProviderRefPolicy
 */
export interface ApplicationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderRefPolicy(obj: ApplicationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRef
 */
export interface ApplicationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToConfigRef(obj: ApplicationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToMetadata
 */
export interface ApplicationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToMetadata(obj: ApplicationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecProviderConfigRefPolicyResolution
 */
export enum ApplicationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecProviderConfigRefPolicyResolve
 */
export enum ApplicationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecProviderRefPolicyResolution
 */
export enum ApplicationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecProviderRefPolicyResolve
 */
export enum ApplicationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApplicationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApplicationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ConfigurationProfile is the Schema for the ConfigurationProfiles API. Provides an AppConfig Configuration Profile resource.
 *
 * @schema ConfigurationProfile
 */
export class ConfigurationProfile extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ConfigurationProfile"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appconfig.aws.upbound.io/v1beta1',
    kind: 'ConfigurationProfile',
  }

  /**
   * Renders a Kubernetes manifest for "ConfigurationProfile".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConfigurationProfileProps): any {
    return {
      ...ConfigurationProfile.GVK,
      ...toJson_ConfigurationProfileProps(props),
    };
  }

  /**
   * Defines a "ConfigurationProfile" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConfigurationProfileProps) {
    super(scope, id, {
      ...ConfigurationProfile.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ConfigurationProfile.GVK,
      ...toJson_ConfigurationProfileProps(resolved),
    };
  }
}

/**
 * ConfigurationProfile is the Schema for the ConfigurationProfiles API. Provides an AppConfig Configuration Profile resource.
 *
 * @schema ConfigurationProfile
 */
export interface ConfigurationProfileProps {
  /**
   * @schema ConfigurationProfile#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConfigurationProfileSpec defines the desired state of ConfigurationProfile
   *
   * @schema ConfigurationProfile#spec
   */
  readonly spec: ConfigurationProfileSpec;

}

/**
 * Converts an object of type 'ConfigurationProfileProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileProps(obj: ConfigurationProfileProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConfigurationProfileSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigurationProfileSpec defines the desired state of ConfigurationProfile
 *
 * @schema ConfigurationProfileSpec
 */
export interface ConfigurationProfileSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConfigurationProfileSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConfigurationProfileSpecDeletionPolicy;

  /**
   * @schema ConfigurationProfileSpec#forProvider
   */
  readonly forProvider: ConfigurationProfileSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConfigurationProfileSpec#managementPolicy
   */
  readonly managementPolicy?: ConfigurationProfileSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConfigurationProfileSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConfigurationProfileSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ConfigurationProfileSpec#providerRef
   */
  readonly providerRef?: ConfigurationProfileSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConfigurationProfileSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConfigurationProfileSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConfigurationProfileSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConfigurationProfileSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConfigurationProfileSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpec(obj: ConfigurationProfileSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConfigurationProfileSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ConfigurationProfileSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ConfigurationProfileSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ConfigurationProfileSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConfigurationProfileSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConfigurationProfileSpecDeletionPolicy
 */
export enum ConfigurationProfileSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConfigurationProfileSpecForProvider
 */
export interface ConfigurationProfileSpecForProvider {
  /**
   * Application ID. Must be between 4 and 7 characters in length.
   *
   * @schema ConfigurationProfileSpecForProvider#applicationId
   */
  readonly applicationId?: string;

  /**
   * Reference to a Application in appconfig to populate applicationId.
   *
   * @schema ConfigurationProfileSpecForProvider#applicationIdRef
   */
  readonly applicationIdRef?: ConfigurationProfileSpecForProviderApplicationIdRef;

  /**
   * Selector for a Application in appconfig to populate applicationId.
   *
   * @schema ConfigurationProfileSpecForProvider#applicationIdSelector
   */
  readonly applicationIdSelector?: ConfigurationProfileSpecForProviderApplicationIdSelector;

  /**
   * Description of the configuration profile. Can be at most 1024 characters.
   *
   * @schema ConfigurationProfileSpecForProvider#description
   */
  readonly description?: string;

  /**
   * URI to locate the configuration. You can specify the AWS AppConfig hosted configuration store, Systems Manager (SSM) document, an SSM Parameter Store parameter, or an Amazon S3 object. For the hosted configuration store, specify hosted. For an SSM document, specify either the document name in the format ssm-document://<Document_name> or the ARN. For a parameter, specify either the parameter name in the format ssm-parameter://<Parameter_name> or the ARN. For an Amazon S3 object, specify the URI in the following format: s3://<bucket>/<objectKey>.
   *
   * @schema ConfigurationProfileSpecForProvider#locationUri
   */
  readonly locationUri?: string;

  /**
   * Name for the configuration profile. Must be between 1 and 64 characters in length.
   *
   * @schema ConfigurationProfileSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConfigurationProfileSpecForProvider#region
   */
  readonly region: string;

  /**
   * ARN of an IAM role with permission to access the configuration at the specified location_uri. A retrieval role ARN is not required for configurations stored in the AWS AppConfig hosted configuration store. It is required for all other sources that store your configuration.
   *
   * @schema ConfigurationProfileSpecForProvider#retrievalRoleArn
   */
  readonly retrievalRoleArn?: string;

  /**
   * Reference to a Role in iam to populate retrievalRoleArn.
   *
   * @schema ConfigurationProfileSpecForProvider#retrievalRoleArnRef
   */
  readonly retrievalRoleArnRef?: ConfigurationProfileSpecForProviderRetrievalRoleArnRef;

  /**
   * Selector for a Role in iam to populate retrievalRoleArn.
   *
   * @schema ConfigurationProfileSpecForProvider#retrievalRoleArnSelector
   */
  readonly retrievalRoleArnSelector?: ConfigurationProfileSpecForProviderRetrievalRoleArnSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema ConfigurationProfileSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Type of configurations contained in the profile. Valid values: AWS.AppConfig.FeatureFlags and AWS.Freeform.  Default: AWS.Freeform.
   *
   * @schema ConfigurationProfileSpecForProvider#type
   */
  readonly type?: string;

  /**
   * Set of methods for validating the configuration. Maximum of 2. See Validator below for more details.
   *
   * @schema ConfigurationProfileSpecForProvider#validator
   */
  readonly validator?: ConfigurationProfileSpecForProviderValidator[];

}

/**
 * Converts an object of type 'ConfigurationProfileSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecForProvider(obj: ConfigurationProfileSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationId': obj.applicationId,
    'applicationIdRef': toJson_ConfigurationProfileSpecForProviderApplicationIdRef(obj.applicationIdRef),
    'applicationIdSelector': toJson_ConfigurationProfileSpecForProviderApplicationIdSelector(obj.applicationIdSelector),
    'description': obj.description,
    'locationUri': obj.locationUri,
    'name': obj.name,
    'region': obj.region,
    'retrievalRoleArn': obj.retrievalRoleArn,
    'retrievalRoleArnRef': toJson_ConfigurationProfileSpecForProviderRetrievalRoleArnRef(obj.retrievalRoleArnRef),
    'retrievalRoleArnSelector': toJson_ConfigurationProfileSpecForProviderRetrievalRoleArnSelector(obj.retrievalRoleArnSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
    'validator': obj.validator?.map(y => toJson_ConfigurationProfileSpecForProviderValidator(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConfigurationProfileSpecManagementPolicy
 */
export enum ConfigurationProfileSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConfigurationProfileSpecProviderConfigRef
 */
export interface ConfigurationProfileSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationProfileSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationProfileSpecProviderConfigRef#policy
   */
  readonly policy?: ConfigurationProfileSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecProviderConfigRef(obj: ConfigurationProfileSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationProfileSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ConfigurationProfileSpecProviderRef
 */
export interface ConfigurationProfileSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationProfileSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationProfileSpecProviderRef#policy
   */
  readonly policy?: ConfigurationProfileSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecProviderRef(obj: ConfigurationProfileSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationProfileSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConfigurationProfileSpecPublishConnectionDetailsTo
 */
export interface ConfigurationProfileSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConfigurationProfileSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConfigurationProfileSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConfigurationProfileSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConfigurationProfileSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConfigurationProfileSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecPublishConnectionDetailsTo(obj: ConfigurationProfileSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConfigurationProfileSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConfigurationProfileSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConfigurationProfileSpecWriteConnectionSecretToRef
 */
export interface ConfigurationProfileSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConfigurationProfileSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConfigurationProfileSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecWriteConnectionSecretToRef(obj: ConfigurationProfileSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Application in appconfig to populate applicationId.
 *
 * @schema ConfigurationProfileSpecForProviderApplicationIdRef
 */
export interface ConfigurationProfileSpecForProviderApplicationIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationProfileSpecForProviderApplicationIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationProfileSpecForProviderApplicationIdRef#policy
   */
  readonly policy?: ConfigurationProfileSpecForProviderApplicationIdRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecForProviderApplicationIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecForProviderApplicationIdRef(obj: ConfigurationProfileSpecForProviderApplicationIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationProfileSpecForProviderApplicationIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Application in appconfig to populate applicationId.
 *
 * @schema ConfigurationProfileSpecForProviderApplicationIdSelector
 */
export interface ConfigurationProfileSpecForProviderApplicationIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConfigurationProfileSpecForProviderApplicationIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConfigurationProfileSpecForProviderApplicationIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConfigurationProfileSpecForProviderApplicationIdSelector#policy
   */
  readonly policy?: ConfigurationProfileSpecForProviderApplicationIdSelectorPolicy;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecForProviderApplicationIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecForProviderApplicationIdSelector(obj: ConfigurationProfileSpecForProviderApplicationIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConfigurationProfileSpecForProviderApplicationIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate retrievalRoleArn.
 *
 * @schema ConfigurationProfileSpecForProviderRetrievalRoleArnRef
 */
export interface ConfigurationProfileSpecForProviderRetrievalRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationProfileSpecForProviderRetrievalRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationProfileSpecForProviderRetrievalRoleArnRef#policy
   */
  readonly policy?: ConfigurationProfileSpecForProviderRetrievalRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecForProviderRetrievalRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecForProviderRetrievalRoleArnRef(obj: ConfigurationProfileSpecForProviderRetrievalRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationProfileSpecForProviderRetrievalRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate retrievalRoleArn.
 *
 * @schema ConfigurationProfileSpecForProviderRetrievalRoleArnSelector
 */
export interface ConfigurationProfileSpecForProviderRetrievalRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConfigurationProfileSpecForProviderRetrievalRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConfigurationProfileSpecForProviderRetrievalRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConfigurationProfileSpecForProviderRetrievalRoleArnSelector#policy
   */
  readonly policy?: ConfigurationProfileSpecForProviderRetrievalRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecForProviderRetrievalRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecForProviderRetrievalRoleArnSelector(obj: ConfigurationProfileSpecForProviderRetrievalRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConfigurationProfileSpecForProviderRetrievalRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationProfileSpecForProviderValidator
 */
export interface ConfigurationProfileSpecForProviderValidator {
  /**
   * Either the JSON Schema content or the ARN of an AWS Lambda function.
   *
   * @schema ConfigurationProfileSpecForProviderValidator#contentSecretRef
   */
  readonly contentSecretRef?: ConfigurationProfileSpecForProviderValidatorContentSecretRef;

  /**
   * Type of validator. Valid values: JSON_SCHEMA and LAMBDA.
   *
   * @schema ConfigurationProfileSpecForProviderValidator#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecForProviderValidator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecForProviderValidator(obj: ConfigurationProfileSpecForProviderValidator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentSecretRef': toJson_ConfigurationProfileSpecForProviderValidatorContentSecretRef(obj.contentSecretRef),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationProfileSpecProviderConfigRefPolicy
 */
export interface ConfigurationProfileSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationProfileSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationProfileSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationProfileSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationProfileSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecProviderConfigRefPolicy(obj: ConfigurationProfileSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationProfileSpecProviderRefPolicy
 */
export interface ConfigurationProfileSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationProfileSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ConfigurationProfileSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationProfileSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ConfigurationProfileSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecProviderRefPolicy(obj: ConfigurationProfileSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConfigurationProfileSpecPublishConnectionDetailsToConfigRef
 */
export interface ConfigurationProfileSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationProfileSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationProfileSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConfigurationProfileSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecPublishConnectionDetailsToConfigRef(obj: ConfigurationProfileSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConfigurationProfileSpecPublishConnectionDetailsToMetadata
 */
export interface ConfigurationProfileSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationProfileSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationProfileSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConfigurationProfileSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecPublishConnectionDetailsToMetadata(obj: ConfigurationProfileSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationProfileSpecForProviderApplicationIdRefPolicy
 */
export interface ConfigurationProfileSpecForProviderApplicationIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationProfileSpecForProviderApplicationIdRefPolicy#resolution
   */
  readonly resolution?: ConfigurationProfileSpecForProviderApplicationIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationProfileSpecForProviderApplicationIdRefPolicy#resolve
   */
  readonly resolve?: ConfigurationProfileSpecForProviderApplicationIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecForProviderApplicationIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecForProviderApplicationIdRefPolicy(obj: ConfigurationProfileSpecForProviderApplicationIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConfigurationProfileSpecForProviderApplicationIdSelectorPolicy
 */
export interface ConfigurationProfileSpecForProviderApplicationIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationProfileSpecForProviderApplicationIdSelectorPolicy#resolution
   */
  readonly resolution?: ConfigurationProfileSpecForProviderApplicationIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationProfileSpecForProviderApplicationIdSelectorPolicy#resolve
   */
  readonly resolve?: ConfigurationProfileSpecForProviderApplicationIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecForProviderApplicationIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecForProviderApplicationIdSelectorPolicy(obj: ConfigurationProfileSpecForProviderApplicationIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationProfileSpecForProviderRetrievalRoleArnRefPolicy
 */
export interface ConfigurationProfileSpecForProviderRetrievalRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationProfileSpecForProviderRetrievalRoleArnRefPolicy#resolution
   */
  readonly resolution?: ConfigurationProfileSpecForProviderRetrievalRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationProfileSpecForProviderRetrievalRoleArnRefPolicy#resolve
   */
  readonly resolve?: ConfigurationProfileSpecForProviderRetrievalRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecForProviderRetrievalRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecForProviderRetrievalRoleArnRefPolicy(obj: ConfigurationProfileSpecForProviderRetrievalRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConfigurationProfileSpecForProviderRetrievalRoleArnSelectorPolicy
 */
export interface ConfigurationProfileSpecForProviderRetrievalRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationProfileSpecForProviderRetrievalRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ConfigurationProfileSpecForProviderRetrievalRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationProfileSpecForProviderRetrievalRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ConfigurationProfileSpecForProviderRetrievalRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecForProviderRetrievalRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecForProviderRetrievalRoleArnSelectorPolicy(obj: ConfigurationProfileSpecForProviderRetrievalRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Either the JSON Schema content or the ARN of an AWS Lambda function.
 *
 * @schema ConfigurationProfileSpecForProviderValidatorContentSecretRef
 */
export interface ConfigurationProfileSpecForProviderValidatorContentSecretRef {
  /**
   * The key to select.
   *
   * @schema ConfigurationProfileSpecForProviderValidatorContentSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConfigurationProfileSpecForProviderValidatorContentSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConfigurationProfileSpecForProviderValidatorContentSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecForProviderValidatorContentSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecForProviderValidatorContentSecretRef(obj: ConfigurationProfileSpecForProviderValidatorContentSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationProfileSpecProviderConfigRefPolicyResolution
 */
export enum ConfigurationProfileSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationProfileSpecProviderConfigRefPolicyResolve
 */
export enum ConfigurationProfileSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationProfileSpecProviderRefPolicyResolution
 */
export enum ConfigurationProfileSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationProfileSpecProviderRefPolicyResolve
 */
export enum ConfigurationProfileSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConfigurationProfileSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConfigurationProfileSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationProfileSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConfigurationProfileSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationProfileSpecForProviderApplicationIdRefPolicyResolution
 */
export enum ConfigurationProfileSpecForProviderApplicationIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationProfileSpecForProviderApplicationIdRefPolicyResolve
 */
export enum ConfigurationProfileSpecForProviderApplicationIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationProfileSpecForProviderApplicationIdSelectorPolicyResolution
 */
export enum ConfigurationProfileSpecForProviderApplicationIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationProfileSpecForProviderApplicationIdSelectorPolicyResolve
 */
export enum ConfigurationProfileSpecForProviderApplicationIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationProfileSpecForProviderRetrievalRoleArnRefPolicyResolution
 */
export enum ConfigurationProfileSpecForProviderRetrievalRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationProfileSpecForProviderRetrievalRoleArnRefPolicyResolve
 */
export enum ConfigurationProfileSpecForProviderRetrievalRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationProfileSpecForProviderRetrievalRoleArnSelectorPolicyResolution
 */
export enum ConfigurationProfileSpecForProviderRetrievalRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationProfileSpecForProviderRetrievalRoleArnSelectorPolicyResolve
 */
export enum ConfigurationProfileSpecForProviderRetrievalRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConfigurationProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConfigurationProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Deployment is the Schema for the Deployments API. Provides an AppConfig Deployment resource.
 *
 * @schema Deployment
 */
export class Deployment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Deployment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appconfig.aws.upbound.io/v1beta1',
    kind: 'Deployment',
  }

  /**
   * Renders a Kubernetes manifest for "Deployment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DeploymentProps): any {
    return {
      ...Deployment.GVK,
      ...toJson_DeploymentProps(props),
    };
  }

  /**
   * Defines a "Deployment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DeploymentProps) {
    super(scope, id, {
      ...Deployment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Deployment.GVK,
      ...toJson_DeploymentProps(resolved),
    };
  }
}

/**
 * Deployment is the Schema for the Deployments API. Provides an AppConfig Deployment resource.
 *
 * @schema Deployment
 */
export interface DeploymentProps {
  /**
   * @schema Deployment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeploymentSpec defines the desired state of Deployment
   *
   * @schema Deployment#spec
   */
  readonly spec: DeploymentSpec;

}

/**
 * Converts an object of type 'DeploymentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentProps(obj: DeploymentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DeploymentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeploymentSpec defines the desired state of Deployment
 *
 * @schema DeploymentSpec
 */
export interface DeploymentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeploymentSpec#deletionPolicy
   */
  readonly deletionPolicy?: DeploymentSpecDeletionPolicy;

  /**
   * @schema DeploymentSpec#forProvider
   */
  readonly forProvider: DeploymentSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeploymentSpec#managementPolicy
   */
  readonly managementPolicy?: DeploymentSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DeploymentSpec#providerConfigRef
   */
  readonly providerConfigRef?: DeploymentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DeploymentSpec#providerRef
   */
  readonly providerRef?: DeploymentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DeploymentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DeploymentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DeploymentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DeploymentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DeploymentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpec(obj: DeploymentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DeploymentSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DeploymentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DeploymentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DeploymentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DeploymentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeploymentSpecDeletionPolicy
 */
export enum DeploymentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DeploymentSpecForProvider
 */
export interface DeploymentSpecForProvider {
  /**
   * Application ID. Must be between 4 and 7 characters in length.
   *
   * @schema DeploymentSpecForProvider#applicationId
   */
  readonly applicationId?: string;

  /**
   * Reference to a Application in appconfig to populate applicationId.
   *
   * @schema DeploymentSpecForProvider#applicationIdRef
   */
  readonly applicationIdRef?: DeploymentSpecForProviderApplicationIdRef;

  /**
   * Selector for a Application in appconfig to populate applicationId.
   *
   * @schema DeploymentSpecForProvider#applicationIdSelector
   */
  readonly applicationIdSelector?: DeploymentSpecForProviderApplicationIdSelector;

  /**
   * Configuration profile ID. Must be between 4 and 7 characters in length.
   *
   * @schema DeploymentSpecForProvider#configurationProfileId
   */
  readonly configurationProfileId?: string;

  /**
   * Reference to a ConfigurationProfile in appconfig to populate configurationProfileId.
   *
   * @schema DeploymentSpecForProvider#configurationProfileIdRef
   */
  readonly configurationProfileIdRef?: DeploymentSpecForProviderConfigurationProfileIdRef;

  /**
   * Selector for a ConfigurationProfile in appconfig to populate configurationProfileId.
   *
   * @schema DeploymentSpecForProvider#configurationProfileIdSelector
   */
  readonly configurationProfileIdSelector?: DeploymentSpecForProviderConfigurationProfileIdSelector;

  /**
   * Configuration version to deploy. Can be at most 1024 characters.
   *
   * @schema DeploymentSpecForProvider#configurationVersion
   */
  readonly configurationVersion?: string;

  /**
   * Reference to a HostedConfigurationVersion in appconfig to populate configurationVersion.
   *
   * @schema DeploymentSpecForProvider#configurationVersionRef
   */
  readonly configurationVersionRef?: DeploymentSpecForProviderConfigurationVersionRef;

  /**
   * Selector for a HostedConfigurationVersion in appconfig to populate configurationVersion.
   *
   * @schema DeploymentSpecForProvider#configurationVersionSelector
   */
  readonly configurationVersionSelector?: DeploymentSpecForProviderConfigurationVersionSelector;

  /**
   * Deployment strategy ID or name of a predefined deployment strategy. See Predefined Deployment Strategies for more details.
   *
   * @schema DeploymentSpecForProvider#deploymentStrategyId
   */
  readonly deploymentStrategyId?: string;

  /**
   * Reference to a DeploymentStrategy in appconfig to populate deploymentStrategyId.
   *
   * @schema DeploymentSpecForProvider#deploymentStrategyIdRef
   */
  readonly deploymentStrategyIdRef?: DeploymentSpecForProviderDeploymentStrategyIdRef;

  /**
   * Selector for a DeploymentStrategy in appconfig to populate deploymentStrategyId.
   *
   * @schema DeploymentSpecForProvider#deploymentStrategyIdSelector
   */
  readonly deploymentStrategyIdSelector?: DeploymentSpecForProviderDeploymentStrategyIdSelector;

  /**
   * Description of the deployment. Can be at most 1024 characters.
   *
   * @schema DeploymentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Environment ID. Must be between 4 and 7 characters in length.
   *
   * @schema DeploymentSpecForProvider#environmentId
   */
  readonly environmentId?: string;

  /**
   * Reference to a Environment in appconfig to populate environmentId.
   *
   * @schema DeploymentSpecForProvider#environmentIdRef
   */
  readonly environmentIdRef?: DeploymentSpecForProviderEnvironmentIdRef;

  /**
   * Selector for a Environment in appconfig to populate environmentId.
   *
   * @schema DeploymentSpecForProvider#environmentIdSelector
   */
  readonly environmentIdSelector?: DeploymentSpecForProviderEnvironmentIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DeploymentSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema DeploymentSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DeploymentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProvider(obj: DeploymentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationId': obj.applicationId,
    'applicationIdRef': toJson_DeploymentSpecForProviderApplicationIdRef(obj.applicationIdRef),
    'applicationIdSelector': toJson_DeploymentSpecForProviderApplicationIdSelector(obj.applicationIdSelector),
    'configurationProfileId': obj.configurationProfileId,
    'configurationProfileIdRef': toJson_DeploymentSpecForProviderConfigurationProfileIdRef(obj.configurationProfileIdRef),
    'configurationProfileIdSelector': toJson_DeploymentSpecForProviderConfigurationProfileIdSelector(obj.configurationProfileIdSelector),
    'configurationVersion': obj.configurationVersion,
    'configurationVersionRef': toJson_DeploymentSpecForProviderConfigurationVersionRef(obj.configurationVersionRef),
    'configurationVersionSelector': toJson_DeploymentSpecForProviderConfigurationVersionSelector(obj.configurationVersionSelector),
    'deploymentStrategyId': obj.deploymentStrategyId,
    'deploymentStrategyIdRef': toJson_DeploymentSpecForProviderDeploymentStrategyIdRef(obj.deploymentStrategyIdRef),
    'deploymentStrategyIdSelector': toJson_DeploymentSpecForProviderDeploymentStrategyIdSelector(obj.deploymentStrategyIdSelector),
    'description': obj.description,
    'environmentId': obj.environmentId,
    'environmentIdRef': toJson_DeploymentSpecForProviderEnvironmentIdRef(obj.environmentIdRef),
    'environmentIdSelector': toJson_DeploymentSpecForProviderEnvironmentIdSelector(obj.environmentIdSelector),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeploymentSpecManagementPolicy
 */
export enum DeploymentSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DeploymentSpecProviderConfigRef
 */
export interface DeploymentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecProviderConfigRef#policy
   */
  readonly policy?: DeploymentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecProviderConfigRef(obj: DeploymentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DeploymentSpecProviderRef
 */
export interface DeploymentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecProviderRef#policy
   */
  readonly policy?: DeploymentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecProviderRef(obj: DeploymentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DeploymentSpecPublishConnectionDetailsTo
 */
export interface DeploymentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DeploymentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DeploymentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DeploymentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DeploymentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DeploymentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsTo(obj: DeploymentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DeploymentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DeploymentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DeploymentSpecWriteConnectionSecretToRef
 */
export interface DeploymentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DeploymentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeploymentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeploymentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecWriteConnectionSecretToRef(obj: DeploymentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Application in appconfig to populate applicationId.
 *
 * @schema DeploymentSpecForProviderApplicationIdRef
 */
export interface DeploymentSpecForProviderApplicationIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecForProviderApplicationIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecForProviderApplicationIdRef#policy
   */
  readonly policy?: DeploymentSpecForProviderApplicationIdRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderApplicationIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderApplicationIdRef(obj: DeploymentSpecForProviderApplicationIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecForProviderApplicationIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Application in appconfig to populate applicationId.
 *
 * @schema DeploymentSpecForProviderApplicationIdSelector
 */
export interface DeploymentSpecForProviderApplicationIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeploymentSpecForProviderApplicationIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeploymentSpecForProviderApplicationIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeploymentSpecForProviderApplicationIdSelector#policy
   */
  readonly policy?: DeploymentSpecForProviderApplicationIdSelectorPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderApplicationIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderApplicationIdSelector(obj: DeploymentSpecForProviderApplicationIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeploymentSpecForProviderApplicationIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ConfigurationProfile in appconfig to populate configurationProfileId.
 *
 * @schema DeploymentSpecForProviderConfigurationProfileIdRef
 */
export interface DeploymentSpecForProviderConfigurationProfileIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecForProviderConfigurationProfileIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecForProviderConfigurationProfileIdRef#policy
   */
  readonly policy?: DeploymentSpecForProviderConfigurationProfileIdRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderConfigurationProfileIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderConfigurationProfileIdRef(obj: DeploymentSpecForProviderConfigurationProfileIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecForProviderConfigurationProfileIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ConfigurationProfile in appconfig to populate configurationProfileId.
 *
 * @schema DeploymentSpecForProviderConfigurationProfileIdSelector
 */
export interface DeploymentSpecForProviderConfigurationProfileIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeploymentSpecForProviderConfigurationProfileIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeploymentSpecForProviderConfigurationProfileIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeploymentSpecForProviderConfigurationProfileIdSelector#policy
   */
  readonly policy?: DeploymentSpecForProviderConfigurationProfileIdSelectorPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderConfigurationProfileIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderConfigurationProfileIdSelector(obj: DeploymentSpecForProviderConfigurationProfileIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeploymentSpecForProviderConfigurationProfileIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a HostedConfigurationVersion in appconfig to populate configurationVersion.
 *
 * @schema DeploymentSpecForProviderConfigurationVersionRef
 */
export interface DeploymentSpecForProviderConfigurationVersionRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecForProviderConfigurationVersionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecForProviderConfigurationVersionRef#policy
   */
  readonly policy?: DeploymentSpecForProviderConfigurationVersionRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderConfigurationVersionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderConfigurationVersionRef(obj: DeploymentSpecForProviderConfigurationVersionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecForProviderConfigurationVersionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a HostedConfigurationVersion in appconfig to populate configurationVersion.
 *
 * @schema DeploymentSpecForProviderConfigurationVersionSelector
 */
export interface DeploymentSpecForProviderConfigurationVersionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeploymentSpecForProviderConfigurationVersionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeploymentSpecForProviderConfigurationVersionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeploymentSpecForProviderConfigurationVersionSelector#policy
   */
  readonly policy?: DeploymentSpecForProviderConfigurationVersionSelectorPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderConfigurationVersionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderConfigurationVersionSelector(obj: DeploymentSpecForProviderConfigurationVersionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeploymentSpecForProviderConfigurationVersionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DeploymentStrategy in appconfig to populate deploymentStrategyId.
 *
 * @schema DeploymentSpecForProviderDeploymentStrategyIdRef
 */
export interface DeploymentSpecForProviderDeploymentStrategyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecForProviderDeploymentStrategyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecForProviderDeploymentStrategyIdRef#policy
   */
  readonly policy?: DeploymentSpecForProviderDeploymentStrategyIdRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderDeploymentStrategyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderDeploymentStrategyIdRef(obj: DeploymentSpecForProviderDeploymentStrategyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecForProviderDeploymentStrategyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DeploymentStrategy in appconfig to populate deploymentStrategyId.
 *
 * @schema DeploymentSpecForProviderDeploymentStrategyIdSelector
 */
export interface DeploymentSpecForProviderDeploymentStrategyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeploymentSpecForProviderDeploymentStrategyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeploymentSpecForProviderDeploymentStrategyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeploymentSpecForProviderDeploymentStrategyIdSelector#policy
   */
  readonly policy?: DeploymentSpecForProviderDeploymentStrategyIdSelectorPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderDeploymentStrategyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderDeploymentStrategyIdSelector(obj: DeploymentSpecForProviderDeploymentStrategyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeploymentSpecForProviderDeploymentStrategyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Environment in appconfig to populate environmentId.
 *
 * @schema DeploymentSpecForProviderEnvironmentIdRef
 */
export interface DeploymentSpecForProviderEnvironmentIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecForProviderEnvironmentIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecForProviderEnvironmentIdRef#policy
   */
  readonly policy?: DeploymentSpecForProviderEnvironmentIdRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderEnvironmentIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderEnvironmentIdRef(obj: DeploymentSpecForProviderEnvironmentIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecForProviderEnvironmentIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Environment in appconfig to populate environmentId.
 *
 * @schema DeploymentSpecForProviderEnvironmentIdSelector
 */
export interface DeploymentSpecForProviderEnvironmentIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeploymentSpecForProviderEnvironmentIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeploymentSpecForProviderEnvironmentIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeploymentSpecForProviderEnvironmentIdSelector#policy
   */
  readonly policy?: DeploymentSpecForProviderEnvironmentIdSelectorPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderEnvironmentIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderEnvironmentIdSelector(obj: DeploymentSpecForProviderEnvironmentIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeploymentSpecForProviderEnvironmentIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecProviderConfigRefPolicy
 */
export interface DeploymentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecProviderConfigRefPolicy(obj: DeploymentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecProviderRefPolicy
 */
export interface DeploymentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecProviderRefPolicy(obj: DeploymentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRef
 */
export interface DeploymentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DeploymentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsToConfigRef(obj: DeploymentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToMetadata
 */
export interface DeploymentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsToMetadata(obj: DeploymentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecForProviderApplicationIdRefPolicy
 */
export interface DeploymentSpecForProviderApplicationIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderApplicationIdRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderApplicationIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderApplicationIdRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderApplicationIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderApplicationIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderApplicationIdRefPolicy(obj: DeploymentSpecForProviderApplicationIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeploymentSpecForProviderApplicationIdSelectorPolicy
 */
export interface DeploymentSpecForProviderApplicationIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderApplicationIdSelectorPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderApplicationIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderApplicationIdSelectorPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderApplicationIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderApplicationIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderApplicationIdSelectorPolicy(obj: DeploymentSpecForProviderApplicationIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecForProviderConfigurationProfileIdRefPolicy
 */
export interface DeploymentSpecForProviderConfigurationProfileIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderConfigurationProfileIdRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderConfigurationProfileIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderConfigurationProfileIdRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderConfigurationProfileIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderConfigurationProfileIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderConfigurationProfileIdRefPolicy(obj: DeploymentSpecForProviderConfigurationProfileIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeploymentSpecForProviderConfigurationProfileIdSelectorPolicy
 */
export interface DeploymentSpecForProviderConfigurationProfileIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderConfigurationProfileIdSelectorPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderConfigurationProfileIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderConfigurationProfileIdSelectorPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderConfigurationProfileIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderConfigurationProfileIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderConfigurationProfileIdSelectorPolicy(obj: DeploymentSpecForProviderConfigurationProfileIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecForProviderConfigurationVersionRefPolicy
 */
export interface DeploymentSpecForProviderConfigurationVersionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderConfigurationVersionRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderConfigurationVersionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderConfigurationVersionRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderConfigurationVersionRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderConfigurationVersionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderConfigurationVersionRefPolicy(obj: DeploymentSpecForProviderConfigurationVersionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeploymentSpecForProviderConfigurationVersionSelectorPolicy
 */
export interface DeploymentSpecForProviderConfigurationVersionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderConfigurationVersionSelectorPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderConfigurationVersionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderConfigurationVersionSelectorPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderConfigurationVersionSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderConfigurationVersionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderConfigurationVersionSelectorPolicy(obj: DeploymentSpecForProviderConfigurationVersionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecForProviderDeploymentStrategyIdRefPolicy
 */
export interface DeploymentSpecForProviderDeploymentStrategyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderDeploymentStrategyIdRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderDeploymentStrategyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderDeploymentStrategyIdRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderDeploymentStrategyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderDeploymentStrategyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderDeploymentStrategyIdRefPolicy(obj: DeploymentSpecForProviderDeploymentStrategyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeploymentSpecForProviderDeploymentStrategyIdSelectorPolicy
 */
export interface DeploymentSpecForProviderDeploymentStrategyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderDeploymentStrategyIdSelectorPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderDeploymentStrategyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderDeploymentStrategyIdSelectorPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderDeploymentStrategyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderDeploymentStrategyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderDeploymentStrategyIdSelectorPolicy(obj: DeploymentSpecForProviderDeploymentStrategyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecForProviderEnvironmentIdRefPolicy
 */
export interface DeploymentSpecForProviderEnvironmentIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderEnvironmentIdRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderEnvironmentIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderEnvironmentIdRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderEnvironmentIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderEnvironmentIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderEnvironmentIdRefPolicy(obj: DeploymentSpecForProviderEnvironmentIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeploymentSpecForProviderEnvironmentIdSelectorPolicy
 */
export interface DeploymentSpecForProviderEnvironmentIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderEnvironmentIdSelectorPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderEnvironmentIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderEnvironmentIdSelectorPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderEnvironmentIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderEnvironmentIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderEnvironmentIdSelectorPolicy(obj: DeploymentSpecForProviderEnvironmentIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecProviderConfigRefPolicyResolution
 */
export enum DeploymentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecProviderConfigRefPolicyResolve
 */
export enum DeploymentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecProviderRefPolicyResolution
 */
export enum DeploymentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecProviderRefPolicyResolve
 */
export enum DeploymentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DeploymentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsToConfigRefPolicy(obj: DeploymentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderApplicationIdRefPolicyResolution
 */
export enum DeploymentSpecForProviderApplicationIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderApplicationIdRefPolicyResolve
 */
export enum DeploymentSpecForProviderApplicationIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderApplicationIdSelectorPolicyResolution
 */
export enum DeploymentSpecForProviderApplicationIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderApplicationIdSelectorPolicyResolve
 */
export enum DeploymentSpecForProviderApplicationIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderConfigurationProfileIdRefPolicyResolution
 */
export enum DeploymentSpecForProviderConfigurationProfileIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderConfigurationProfileIdRefPolicyResolve
 */
export enum DeploymentSpecForProviderConfigurationProfileIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderConfigurationProfileIdSelectorPolicyResolution
 */
export enum DeploymentSpecForProviderConfigurationProfileIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderConfigurationProfileIdSelectorPolicyResolve
 */
export enum DeploymentSpecForProviderConfigurationProfileIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderConfigurationVersionRefPolicyResolution
 */
export enum DeploymentSpecForProviderConfigurationVersionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderConfigurationVersionRefPolicyResolve
 */
export enum DeploymentSpecForProviderConfigurationVersionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderConfigurationVersionSelectorPolicyResolution
 */
export enum DeploymentSpecForProviderConfigurationVersionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderConfigurationVersionSelectorPolicyResolve
 */
export enum DeploymentSpecForProviderConfigurationVersionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderDeploymentStrategyIdRefPolicyResolution
 */
export enum DeploymentSpecForProviderDeploymentStrategyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderDeploymentStrategyIdRefPolicyResolve
 */
export enum DeploymentSpecForProviderDeploymentStrategyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderDeploymentStrategyIdSelectorPolicyResolution
 */
export enum DeploymentSpecForProviderDeploymentStrategyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderDeploymentStrategyIdSelectorPolicyResolve
 */
export enum DeploymentSpecForProviderDeploymentStrategyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderEnvironmentIdRefPolicyResolution
 */
export enum DeploymentSpecForProviderEnvironmentIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderEnvironmentIdRefPolicyResolve
 */
export enum DeploymentSpecForProviderEnvironmentIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderEnvironmentIdSelectorPolicyResolution
 */
export enum DeploymentSpecForProviderEnvironmentIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderEnvironmentIdSelectorPolicyResolve
 */
export enum DeploymentSpecForProviderEnvironmentIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DeploymentStrategy is the Schema for the DeploymentStrategys API. Provides an AppConfig Deployment Strategy resource.
 *
 * @schema DeploymentStrategy
 */
export class DeploymentStrategy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DeploymentStrategy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appconfig.aws.upbound.io/v1beta1',
    kind: 'DeploymentStrategy',
  }

  /**
   * Renders a Kubernetes manifest for "DeploymentStrategy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DeploymentStrategyProps): any {
    return {
      ...DeploymentStrategy.GVK,
      ...toJson_DeploymentStrategyProps(props),
    };
  }

  /**
   * Defines a "DeploymentStrategy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DeploymentStrategyProps) {
    super(scope, id, {
      ...DeploymentStrategy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DeploymentStrategy.GVK,
      ...toJson_DeploymentStrategyProps(resolved),
    };
  }
}

/**
 * DeploymentStrategy is the Schema for the DeploymentStrategys API. Provides an AppConfig Deployment Strategy resource.
 *
 * @schema DeploymentStrategy
 */
export interface DeploymentStrategyProps {
  /**
   * @schema DeploymentStrategy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeploymentStrategySpec defines the desired state of DeploymentStrategy
   *
   * @schema DeploymentStrategy#spec
   */
  readonly spec: DeploymentStrategySpec;

}

/**
 * Converts an object of type 'DeploymentStrategyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentStrategyProps(obj: DeploymentStrategyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DeploymentStrategySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeploymentStrategySpec defines the desired state of DeploymentStrategy
 *
 * @schema DeploymentStrategySpec
 */
export interface DeploymentStrategySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeploymentStrategySpec#deletionPolicy
   */
  readonly deletionPolicy?: DeploymentStrategySpecDeletionPolicy;

  /**
   * @schema DeploymentStrategySpec#forProvider
   */
  readonly forProvider: DeploymentStrategySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeploymentStrategySpec#managementPolicy
   */
  readonly managementPolicy?: DeploymentStrategySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DeploymentStrategySpec#providerConfigRef
   */
  readonly providerConfigRef?: DeploymentStrategySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DeploymentStrategySpec#providerRef
   */
  readonly providerRef?: DeploymentStrategySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DeploymentStrategySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DeploymentStrategySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DeploymentStrategySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DeploymentStrategySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DeploymentStrategySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentStrategySpec(obj: DeploymentStrategySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DeploymentStrategySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DeploymentStrategySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DeploymentStrategySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DeploymentStrategySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DeploymentStrategySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeploymentStrategySpecDeletionPolicy
 */
export enum DeploymentStrategySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DeploymentStrategySpecForProvider
 */
export interface DeploymentStrategySpecForProvider {
  /**
   * Total amount of time for a deployment to last. Minimum value of 0, maximum value of 1440.
   *
   * @schema DeploymentStrategySpecForProvider#deploymentDurationInMinutes
   */
  readonly deploymentDurationInMinutes?: number;

  /**
   * Description of the deployment strategy. Can be at most 1024 characters.
   *
   * @schema DeploymentStrategySpecForProvider#description
   */
  readonly description?: string;

  /**
   * Amount of time AWS AppConfig monitors for alarms before considering the deployment to be complete and no longer eligible for automatic roll back. Minimum value of 0, maximum value of 1440.
   *
   * @schema DeploymentStrategySpecForProvider#finalBakeTimeInMinutes
   */
  readonly finalBakeTimeInMinutes?: number;

  /**
   * Percentage of targets to receive a deployed configuration during each interval. Minimum value of 1.0, maximum value of 100.0.
   *
   * @schema DeploymentStrategySpecForProvider#growthFactor
   */
  readonly growthFactor?: number;

  /**
   * Algorithm used to define how percentage grows over time. Valid value: LINEAR and EXPONENTIAL. Defaults to LINEAR.
   *
   * @default LINEAR.
   * @schema DeploymentStrategySpecForProvider#growthType
   */
  readonly growthType?: string;

  /**
   * Name for the deployment strategy. Must be between 1 and 64 characters in length.
   *
   * @schema DeploymentStrategySpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DeploymentStrategySpecForProvider#region
   */
  readonly region: string;

  /**
   * Where to save the deployment strategy. Valid values: NONE and SSM_DOCUMENT.
   *
   * @schema DeploymentStrategySpecForProvider#replicateTo
   */
  readonly replicateTo?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema DeploymentStrategySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DeploymentStrategySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentStrategySpecForProvider(obj: DeploymentStrategySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deploymentDurationInMinutes': obj.deploymentDurationInMinutes,
    'description': obj.description,
    'finalBakeTimeInMinutes': obj.finalBakeTimeInMinutes,
    'growthFactor': obj.growthFactor,
    'growthType': obj.growthType,
    'name': obj.name,
    'region': obj.region,
    'replicateTo': obj.replicateTo,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeploymentStrategySpecManagementPolicy
 */
export enum DeploymentStrategySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DeploymentStrategySpecProviderConfigRef
 */
export interface DeploymentStrategySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentStrategySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentStrategySpecProviderConfigRef#policy
   */
  readonly policy?: DeploymentStrategySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DeploymentStrategySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentStrategySpecProviderConfigRef(obj: DeploymentStrategySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentStrategySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DeploymentStrategySpecProviderRef
 */
export interface DeploymentStrategySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentStrategySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentStrategySpecProviderRef#policy
   */
  readonly policy?: DeploymentStrategySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DeploymentStrategySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentStrategySpecProviderRef(obj: DeploymentStrategySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentStrategySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DeploymentStrategySpecPublishConnectionDetailsTo
 */
export interface DeploymentStrategySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DeploymentStrategySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DeploymentStrategySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DeploymentStrategySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DeploymentStrategySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DeploymentStrategySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeploymentStrategySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentStrategySpecPublishConnectionDetailsTo(obj: DeploymentStrategySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DeploymentStrategySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DeploymentStrategySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DeploymentStrategySpecWriteConnectionSecretToRef
 */
export interface DeploymentStrategySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DeploymentStrategySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeploymentStrategySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeploymentStrategySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentStrategySpecWriteConnectionSecretToRef(obj: DeploymentStrategySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentStrategySpecProviderConfigRefPolicy
 */
export interface DeploymentStrategySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentStrategySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DeploymentStrategySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentStrategySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DeploymentStrategySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentStrategySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentStrategySpecProviderConfigRefPolicy(obj: DeploymentStrategySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentStrategySpecProviderRefPolicy
 */
export interface DeploymentStrategySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentStrategySpecProviderRefPolicy#resolution
   */
  readonly resolution?: DeploymentStrategySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentStrategySpecProviderRefPolicy#resolve
   */
  readonly resolve?: DeploymentStrategySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentStrategySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentStrategySpecProviderRefPolicy(obj: DeploymentStrategySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DeploymentStrategySpecPublishConnectionDetailsToConfigRef
 */
export interface DeploymentStrategySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentStrategySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentStrategySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DeploymentStrategySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DeploymentStrategySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentStrategySpecPublishConnectionDetailsToConfigRef(obj: DeploymentStrategySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentStrategySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DeploymentStrategySpecPublishConnectionDetailsToMetadata
 */
export interface DeploymentStrategySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeploymentStrategySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeploymentStrategySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DeploymentStrategySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeploymentStrategySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentStrategySpecPublishConnectionDetailsToMetadata(obj: DeploymentStrategySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentStrategySpecProviderConfigRefPolicyResolution
 */
export enum DeploymentStrategySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentStrategySpecProviderConfigRefPolicyResolve
 */
export enum DeploymentStrategySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentStrategySpecProviderRefPolicyResolution
 */
export enum DeploymentStrategySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentStrategySpecProviderRefPolicyResolve
 */
export enum DeploymentStrategySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeploymentStrategySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DeploymentStrategySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentStrategySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DeploymentStrategySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentStrategySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DeploymentStrategySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentStrategySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentStrategySpecPublishConnectionDetailsToConfigRefPolicy(obj: DeploymentStrategySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentStrategySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DeploymentStrategySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentStrategySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DeploymentStrategySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Environment is the Schema for the Environments API. Provides an AppConfig Environment resource.
 *
 * @schema Environment
 */
export class Environment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Environment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appconfig.aws.upbound.io/v1beta1',
    kind: 'Environment',
  }

  /**
   * Renders a Kubernetes manifest for "Environment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EnvironmentProps): any {
    return {
      ...Environment.GVK,
      ...toJson_EnvironmentProps(props),
    };
  }

  /**
   * Defines a "Environment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EnvironmentProps) {
    super(scope, id, {
      ...Environment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Environment.GVK,
      ...toJson_EnvironmentProps(resolved),
    };
  }
}

/**
 * Environment is the Schema for the Environments API. Provides an AppConfig Environment resource.
 *
 * @schema Environment
 */
export interface EnvironmentProps {
  /**
   * @schema Environment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EnvironmentSpec defines the desired state of Environment
   *
   * @schema Environment#spec
   */
  readonly spec: EnvironmentSpec;

}

/**
 * Converts an object of type 'EnvironmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentProps(obj: EnvironmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EnvironmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvironmentSpec defines the desired state of Environment
 *
 * @schema EnvironmentSpec
 */
export interface EnvironmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EnvironmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: EnvironmentSpecDeletionPolicy;

  /**
   * @schema EnvironmentSpec#forProvider
   */
  readonly forProvider: EnvironmentSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EnvironmentSpec#managementPolicy
   */
  readonly managementPolicy?: EnvironmentSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EnvironmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: EnvironmentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EnvironmentSpec#providerRef
   */
  readonly providerRef?: EnvironmentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EnvironmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EnvironmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EnvironmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EnvironmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EnvironmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpec(obj: EnvironmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EnvironmentSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_EnvironmentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EnvironmentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EnvironmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EnvironmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EnvironmentSpecDeletionPolicy
 */
export enum EnvironmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EnvironmentSpecForProvider
 */
export interface EnvironmentSpecForProvider {
  /**
   * AppConfig application ID. Must be between 4 and 7 characters in length.
   *
   * @schema EnvironmentSpecForProvider#applicationId
   */
  readonly applicationId?: string;

  /**
   * Reference to a Application in appconfig to populate applicationId.
   *
   * @schema EnvironmentSpecForProvider#applicationIdRef
   */
  readonly applicationIdRef?: EnvironmentSpecForProviderApplicationIdRef;

  /**
   * Selector for a Application in appconfig to populate applicationId.
   *
   * @schema EnvironmentSpecForProvider#applicationIdSelector
   */
  readonly applicationIdSelector?: EnvironmentSpecForProviderApplicationIdSelector;

  /**
   * Description of the environment. Can be at most 1024 characters.
   *
   * @schema EnvironmentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Set of Amazon CloudWatch alarms to monitor during the deployment process. Maximum of 5. See Monitor below for more details.
   *
   * @schema EnvironmentSpecForProvider#monitor
   */
  readonly monitor?: EnvironmentSpecForProviderMonitor[];

  /**
   * Name for the environment. Must be between 1 and 64 characters in length.
   *
   * @schema EnvironmentSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EnvironmentSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema EnvironmentSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'EnvironmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProvider(obj: EnvironmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationId': obj.applicationId,
    'applicationIdRef': toJson_EnvironmentSpecForProviderApplicationIdRef(obj.applicationIdRef),
    'applicationIdSelector': toJson_EnvironmentSpecForProviderApplicationIdSelector(obj.applicationIdSelector),
    'description': obj.description,
    'monitor': obj.monitor?.map(y => toJson_EnvironmentSpecForProviderMonitor(y)),
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EnvironmentSpecManagementPolicy
 */
export enum EnvironmentSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EnvironmentSpecProviderConfigRef
 */
export interface EnvironmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecProviderConfigRef#policy
   */
  readonly policy?: EnvironmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderConfigRef(obj: EnvironmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EnvironmentSpecProviderRef
 */
export interface EnvironmentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecProviderRef#policy
   */
  readonly policy?: EnvironmentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderRef(obj: EnvironmentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsTo
 */
export interface EnvironmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EnvironmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EnvironmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsTo(obj: EnvironmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EnvironmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EnvironmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EnvironmentSpecWriteConnectionSecretToRef
 */
export interface EnvironmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EnvironmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EnvironmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EnvironmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecWriteConnectionSecretToRef(obj: EnvironmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Application in appconfig to populate applicationId.
 *
 * @schema EnvironmentSpecForProviderApplicationIdRef
 */
export interface EnvironmentSpecForProviderApplicationIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecForProviderApplicationIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecForProviderApplicationIdRef#policy
   */
  readonly policy?: EnvironmentSpecForProviderApplicationIdRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderApplicationIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderApplicationIdRef(obj: EnvironmentSpecForProviderApplicationIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecForProviderApplicationIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Application in appconfig to populate applicationId.
 *
 * @schema EnvironmentSpecForProviderApplicationIdSelector
 */
export interface EnvironmentSpecForProviderApplicationIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EnvironmentSpecForProviderApplicationIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EnvironmentSpecForProviderApplicationIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EnvironmentSpecForProviderApplicationIdSelector#policy
   */
  readonly policy?: EnvironmentSpecForProviderApplicationIdSelectorPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderApplicationIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderApplicationIdSelector(obj: EnvironmentSpecForProviderApplicationIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EnvironmentSpecForProviderApplicationIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderMonitor
 */
export interface EnvironmentSpecForProviderMonitor {
  /**
   * ARN of the Amazon CloudWatch alarm.
   *
   * @schema EnvironmentSpecForProviderMonitor#alarmArn
   */
  readonly alarmArn?: string;

  /**
   * Reference to a MetricAlarm in cloudwatch to populate alarmArn.
   *
   * @schema EnvironmentSpecForProviderMonitor#alarmArnRef
   */
  readonly alarmArnRef?: EnvironmentSpecForProviderMonitorAlarmArnRef;

  /**
   * Selector for a MetricAlarm in cloudwatch to populate alarmArn.
   *
   * @schema EnvironmentSpecForProviderMonitor#alarmArnSelector
   */
  readonly alarmArnSelector?: EnvironmentSpecForProviderMonitorAlarmArnSelector;

  /**
   * ARN of an IAM role for AWS AppConfig to monitor alarm_arn.
   *
   * @schema EnvironmentSpecForProviderMonitor#alarmRoleArn
   */
  readonly alarmRoleArn?: string;

  /**
   * Reference to a Role in iam to populate alarmRoleArn.
   *
   * @schema EnvironmentSpecForProviderMonitor#alarmRoleArnRef
   */
  readonly alarmRoleArnRef?: EnvironmentSpecForProviderMonitorAlarmRoleArnRef;

  /**
   * Selector for a Role in iam to populate alarmRoleArn.
   *
   * @schema EnvironmentSpecForProviderMonitor#alarmRoleArnSelector
   */
  readonly alarmRoleArnSelector?: EnvironmentSpecForProviderMonitorAlarmRoleArnSelector;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderMonitor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderMonitor(obj: EnvironmentSpecForProviderMonitor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarmArn': obj.alarmArn,
    'alarmArnRef': toJson_EnvironmentSpecForProviderMonitorAlarmArnRef(obj.alarmArnRef),
    'alarmArnSelector': toJson_EnvironmentSpecForProviderMonitorAlarmArnSelector(obj.alarmArnSelector),
    'alarmRoleArn': obj.alarmRoleArn,
    'alarmRoleArnRef': toJson_EnvironmentSpecForProviderMonitorAlarmRoleArnRef(obj.alarmRoleArnRef),
    'alarmRoleArnSelector': toJson_EnvironmentSpecForProviderMonitorAlarmRoleArnSelector(obj.alarmRoleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicy
 */
export interface EnvironmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderConfigRefPolicy(obj: EnvironmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecProviderRefPolicy
 */
export interface EnvironmentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderRefPolicy(obj: EnvironmentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef
 */
export interface EnvironmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToConfigRef(obj: EnvironmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToMetadata
 */
export interface EnvironmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToMetadata(obj: EnvironmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecForProviderApplicationIdRefPolicy
 */
export interface EnvironmentSpecForProviderApplicationIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderApplicationIdRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderApplicationIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderApplicationIdRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderApplicationIdRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderApplicationIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderApplicationIdRefPolicy(obj: EnvironmentSpecForProviderApplicationIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EnvironmentSpecForProviderApplicationIdSelectorPolicy
 */
export interface EnvironmentSpecForProviderApplicationIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderApplicationIdSelectorPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderApplicationIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderApplicationIdSelectorPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderApplicationIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderApplicationIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderApplicationIdSelectorPolicy(obj: EnvironmentSpecForProviderApplicationIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a MetricAlarm in cloudwatch to populate alarmArn.
 *
 * @schema EnvironmentSpecForProviderMonitorAlarmArnRef
 */
export interface EnvironmentSpecForProviderMonitorAlarmArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmArnRef#policy
   */
  readonly policy?: EnvironmentSpecForProviderMonitorAlarmArnRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderMonitorAlarmArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderMonitorAlarmArnRef(obj: EnvironmentSpecForProviderMonitorAlarmArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecForProviderMonitorAlarmArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a MetricAlarm in cloudwatch to populate alarmArn.
 *
 * @schema EnvironmentSpecForProviderMonitorAlarmArnSelector
 */
export interface EnvironmentSpecForProviderMonitorAlarmArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmArnSelector#policy
   */
  readonly policy?: EnvironmentSpecForProviderMonitorAlarmArnSelectorPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderMonitorAlarmArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderMonitorAlarmArnSelector(obj: EnvironmentSpecForProviderMonitorAlarmArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EnvironmentSpecForProviderMonitorAlarmArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate alarmRoleArn.
 *
 * @schema EnvironmentSpecForProviderMonitorAlarmRoleArnRef
 */
export interface EnvironmentSpecForProviderMonitorAlarmRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmRoleArnRef#policy
   */
  readonly policy?: EnvironmentSpecForProviderMonitorAlarmRoleArnRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderMonitorAlarmRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderMonitorAlarmRoleArnRef(obj: EnvironmentSpecForProviderMonitorAlarmRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecForProviderMonitorAlarmRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate alarmRoleArn.
 *
 * @schema EnvironmentSpecForProviderMonitorAlarmRoleArnSelector
 */
export interface EnvironmentSpecForProviderMonitorAlarmRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmRoleArnSelector#policy
   */
  readonly policy?: EnvironmentSpecForProviderMonitorAlarmRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderMonitorAlarmRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderMonitorAlarmRoleArnSelector(obj: EnvironmentSpecForProviderMonitorAlarmRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EnvironmentSpecForProviderMonitorAlarmRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicyResolution
 */
export enum EnvironmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicyResolve
 */
export enum EnvironmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecProviderRefPolicyResolution
 */
export enum EnvironmentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecProviderRefPolicyResolve
 */
export enum EnvironmentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderApplicationIdRefPolicyResolution
 */
export enum EnvironmentSpecForProviderApplicationIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderApplicationIdRefPolicyResolve
 */
export enum EnvironmentSpecForProviderApplicationIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderApplicationIdSelectorPolicyResolution
 */
export enum EnvironmentSpecForProviderApplicationIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderApplicationIdSelectorPolicyResolve
 */
export enum EnvironmentSpecForProviderApplicationIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecForProviderMonitorAlarmArnRefPolicy
 */
export interface EnvironmentSpecForProviderMonitorAlarmArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmArnRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderMonitorAlarmArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmArnRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderMonitorAlarmArnRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderMonitorAlarmArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderMonitorAlarmArnRefPolicy(obj: EnvironmentSpecForProviderMonitorAlarmArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EnvironmentSpecForProviderMonitorAlarmArnSelectorPolicy
 */
export interface EnvironmentSpecForProviderMonitorAlarmArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmArnSelectorPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderMonitorAlarmArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmArnSelectorPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderMonitorAlarmArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderMonitorAlarmArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderMonitorAlarmArnSelectorPolicy(obj: EnvironmentSpecForProviderMonitorAlarmArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecForProviderMonitorAlarmRoleArnRefPolicy
 */
export interface EnvironmentSpecForProviderMonitorAlarmRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmRoleArnRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderMonitorAlarmRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmRoleArnRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderMonitorAlarmRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderMonitorAlarmRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderMonitorAlarmRoleArnRefPolicy(obj: EnvironmentSpecForProviderMonitorAlarmRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EnvironmentSpecForProviderMonitorAlarmRoleArnSelectorPolicy
 */
export interface EnvironmentSpecForProviderMonitorAlarmRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderMonitorAlarmRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderMonitorAlarmRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderMonitorAlarmRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderMonitorAlarmRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderMonitorAlarmRoleArnSelectorPolicy(obj: EnvironmentSpecForProviderMonitorAlarmRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderMonitorAlarmArnRefPolicyResolution
 */
export enum EnvironmentSpecForProviderMonitorAlarmArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderMonitorAlarmArnRefPolicyResolve
 */
export enum EnvironmentSpecForProviderMonitorAlarmArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderMonitorAlarmArnSelectorPolicyResolution
 */
export enum EnvironmentSpecForProviderMonitorAlarmArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderMonitorAlarmArnSelectorPolicyResolve
 */
export enum EnvironmentSpecForProviderMonitorAlarmArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderMonitorAlarmRoleArnRefPolicyResolution
 */
export enum EnvironmentSpecForProviderMonitorAlarmRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderMonitorAlarmRoleArnRefPolicyResolve
 */
export enum EnvironmentSpecForProviderMonitorAlarmRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderMonitorAlarmRoleArnSelectorPolicyResolution
 */
export enum EnvironmentSpecForProviderMonitorAlarmRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderMonitorAlarmRoleArnSelectorPolicyResolve
 */
export enum EnvironmentSpecForProviderMonitorAlarmRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Extension is the Schema for the Extensions API. Provides an AppConfig Extension resource.
 *
 * @schema Extension
 */
export class Extension extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Extension"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appconfig.aws.upbound.io/v1beta1',
    kind: 'Extension',
  }

  /**
   * Renders a Kubernetes manifest for "Extension".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ExtensionProps): any {
    return {
      ...Extension.GVK,
      ...toJson_ExtensionProps(props),
    };
  }

  /**
   * Defines a "Extension" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ExtensionProps) {
    super(scope, id, {
      ...Extension.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Extension.GVK,
      ...toJson_ExtensionProps(resolved),
    };
  }
}

/**
 * Extension is the Schema for the Extensions API. Provides an AppConfig Extension resource.
 *
 * @schema Extension
 */
export interface ExtensionProps {
  /**
   * @schema Extension#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ExtensionSpec defines the desired state of Extension
   *
   * @schema Extension#spec
   */
  readonly spec: ExtensionSpec;

}

/**
 * Converts an object of type 'ExtensionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionProps(obj: ExtensionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ExtensionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtensionSpec defines the desired state of Extension
 *
 * @schema ExtensionSpec
 */
export interface ExtensionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ExtensionSpec#deletionPolicy
   */
  readonly deletionPolicy?: ExtensionSpecDeletionPolicy;

  /**
   * @schema ExtensionSpec#forProvider
   */
  readonly forProvider: ExtensionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ExtensionSpec#managementPolicy
   */
  readonly managementPolicy?: ExtensionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ExtensionSpec#providerConfigRef
   */
  readonly providerConfigRef?: ExtensionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ExtensionSpec#providerRef
   */
  readonly providerRef?: ExtensionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ExtensionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ExtensionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ExtensionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ExtensionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ExtensionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpec(obj: ExtensionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ExtensionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ExtensionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ExtensionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ExtensionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ExtensionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ExtensionSpecDeletionPolicy
 */
export enum ExtensionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ExtensionSpecForProvider
 */
export interface ExtensionSpecForProvider {
  /**
   * The action points defined in the extension. Detailed below.
   *
   * @schema ExtensionSpecForProvider#actionPoint
   */
  readonly actionPoint?: ExtensionSpecForProviderActionPoint[];

  /**
   * Information about the extension.
   *
   * @schema ExtensionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A name for the extension. Each extension name in your account must be unique. Extension versions use the same name.
   *
   * @schema ExtensionSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The parameters accepted by the extension. You specify parameter values when you associate the extension to an AppConfig resource by using the CreateExtensionAssociation API action. For Lambda extension actions, these parameters are included in the Lambda request object. Detailed below.
   *
   * @schema ExtensionSpecForProvider#parameter
   */
  readonly parameter?: ExtensionSpecForProviderParameter[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ExtensionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ExtensionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ExtensionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecForProvider(obj: ExtensionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionPoint': obj.actionPoint?.map(y => toJson_ExtensionSpecForProviderActionPoint(y)),
    'description': obj.description,
    'name': obj.name,
    'parameter': obj.parameter?.map(y => toJson_ExtensionSpecForProviderParameter(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ExtensionSpecManagementPolicy
 */
export enum ExtensionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ExtensionSpecProviderConfigRef
 */
export interface ExtensionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExtensionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExtensionSpecProviderConfigRef#policy
   */
  readonly policy?: ExtensionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ExtensionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecProviderConfigRef(obj: ExtensionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExtensionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ExtensionSpecProviderRef
 */
export interface ExtensionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExtensionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExtensionSpecProviderRef#policy
   */
  readonly policy?: ExtensionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ExtensionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecProviderRef(obj: ExtensionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExtensionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ExtensionSpecPublishConnectionDetailsTo
 */
export interface ExtensionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ExtensionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ExtensionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ExtensionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ExtensionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ExtensionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExtensionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecPublishConnectionDetailsTo(obj: ExtensionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ExtensionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ExtensionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ExtensionSpecWriteConnectionSecretToRef
 */
export interface ExtensionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ExtensionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ExtensionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ExtensionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecWriteConnectionSecretToRef(obj: ExtensionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExtensionSpecForProviderActionPoint
 */
export interface ExtensionSpecForProviderActionPoint {
  /**
   * An action defines the tasks the extension performs during the AppConfig workflow. Detailed below.
   *
   * @schema ExtensionSpecForProviderActionPoint#action
   */
  readonly action: ExtensionSpecForProviderActionPointAction[];

  /**
   * The point at which to perform the defined actions. Valid points are PRE_CREATE_HOSTED_CONFIGURATION_VERSION, PRE_START_DEPLOYMENT, ON_DEPLOYMENT_START, ON_DEPLOYMENT_STEP, ON_DEPLOYMENT_BAKING, ON_DEPLOYMENT_COMPLETE, ON_DEPLOYMENT_ROLLED_BACK.
   *
   * @schema ExtensionSpecForProviderActionPoint#point
   */
  readonly point: string;

}

/**
 * Converts an object of type 'ExtensionSpecForProviderActionPoint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecForProviderActionPoint(obj: ExtensionSpecForProviderActionPoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_ExtensionSpecForProviderActionPointAction(y)),
    'point': obj.point,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExtensionSpecForProviderParameter
 */
export interface ExtensionSpecForProviderParameter {
  /**
   * Information about the parameter.
   *
   * @schema ExtensionSpecForProviderParameter#description
   */
  readonly description?: string;

  /**
   * The parameter name.
   *
   * @schema ExtensionSpecForProviderParameter#name
   */
  readonly name: string;

  /**
   * Determines if a parameter value must be specified in the extension association.
   *
   * @schema ExtensionSpecForProviderParameter#required
   */
  readonly required?: boolean;

}

/**
 * Converts an object of type 'ExtensionSpecForProviderParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecForProviderParameter(obj: ExtensionSpecForProviderParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'required': obj.required,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ExtensionSpecProviderConfigRefPolicy
 */
export interface ExtensionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExtensionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ExtensionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExtensionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ExtensionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ExtensionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecProviderConfigRefPolicy(obj: ExtensionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ExtensionSpecProviderRefPolicy
 */
export interface ExtensionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExtensionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ExtensionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExtensionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ExtensionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ExtensionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecProviderRefPolicy(obj: ExtensionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ExtensionSpecPublishConnectionDetailsToConfigRef
 */
export interface ExtensionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExtensionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExtensionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ExtensionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ExtensionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecPublishConnectionDetailsToConfigRef(obj: ExtensionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExtensionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ExtensionSpecPublishConnectionDetailsToMetadata
 */
export interface ExtensionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ExtensionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ExtensionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ExtensionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ExtensionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecPublishConnectionDetailsToMetadata(obj: ExtensionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExtensionSpecForProviderActionPointAction
 */
export interface ExtensionSpecForProviderActionPointAction {
  /**
   * Information about the action.
   *
   * @schema ExtensionSpecForProviderActionPointAction#description
   */
  readonly description?: string;

  /**
   * The action name.
   *
   * @schema ExtensionSpecForProviderActionPointAction#name
   */
  readonly name: string;

  /**
   * An Amazon Resource Name (ARN) for an Identity and Access Management assume role.
   *
   * @schema ExtensionSpecForProviderActionPointAction#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ExtensionSpecForProviderActionPointAction#roleArnRef
   */
  readonly roleArnRef?: ExtensionSpecForProviderActionPointActionRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ExtensionSpecForProviderActionPointAction#roleArnSelector
   */
  readonly roleArnSelector?: ExtensionSpecForProviderActionPointActionRoleArnSelector;

  /**
   * The extension URI associated to the action point in the extension definition. The URI can be an Amazon Resource Name (ARN) for one of the following: an Lambda function, an Amazon Simple Queue Service queue, an Amazon Simple Notification Service topic, or the Amazon EventBridge default event bus.
   *
   * @schema ExtensionSpecForProviderActionPointAction#uri
   */
  readonly uri?: string;

  /**
   * Reference to a Topic in sns to populate uri.
   *
   * @schema ExtensionSpecForProviderActionPointAction#uriRef
   */
  readonly uriRef?: ExtensionSpecForProviderActionPointActionUriRef;

  /**
   * Selector for a Topic in sns to populate uri.
   *
   * @schema ExtensionSpecForProviderActionPointAction#uriSelector
   */
  readonly uriSelector?: ExtensionSpecForProviderActionPointActionUriSelector;

}

/**
 * Converts an object of type 'ExtensionSpecForProviderActionPointAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecForProviderActionPointAction(obj: ExtensionSpecForProviderActionPointAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ExtensionSpecForProviderActionPointActionRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ExtensionSpecForProviderActionPointActionRoleArnSelector(obj.roleArnSelector),
    'uri': obj.uri,
    'uriRef': toJson_ExtensionSpecForProviderActionPointActionUriRef(obj.uriRef),
    'uriSelector': toJson_ExtensionSpecForProviderActionPointActionUriSelector(obj.uriSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExtensionSpecProviderConfigRefPolicyResolution
 */
export enum ExtensionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExtensionSpecProviderConfigRefPolicyResolve
 */
export enum ExtensionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExtensionSpecProviderRefPolicyResolution
 */
export enum ExtensionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExtensionSpecProviderRefPolicyResolve
 */
export enum ExtensionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ExtensionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ExtensionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExtensionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ExtensionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExtensionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ExtensionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ExtensionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecPublishConnectionDetailsToConfigRefPolicy(obj: ExtensionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ExtensionSpecForProviderActionPointActionRoleArnRef
 */
export interface ExtensionSpecForProviderActionPointActionRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExtensionSpecForProviderActionPointActionRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExtensionSpecForProviderActionPointActionRoleArnRef#policy
   */
  readonly policy?: ExtensionSpecForProviderActionPointActionRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ExtensionSpecForProviderActionPointActionRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecForProviderActionPointActionRoleArnRef(obj: ExtensionSpecForProviderActionPointActionRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExtensionSpecForProviderActionPointActionRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ExtensionSpecForProviderActionPointActionRoleArnSelector
 */
export interface ExtensionSpecForProviderActionPointActionRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ExtensionSpecForProviderActionPointActionRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ExtensionSpecForProviderActionPointActionRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ExtensionSpecForProviderActionPointActionRoleArnSelector#policy
   */
  readonly policy?: ExtensionSpecForProviderActionPointActionRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ExtensionSpecForProviderActionPointActionRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecForProviderActionPointActionRoleArnSelector(obj: ExtensionSpecForProviderActionPointActionRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ExtensionSpecForProviderActionPointActionRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate uri.
 *
 * @schema ExtensionSpecForProviderActionPointActionUriRef
 */
export interface ExtensionSpecForProviderActionPointActionUriRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExtensionSpecForProviderActionPointActionUriRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExtensionSpecForProviderActionPointActionUriRef#policy
   */
  readonly policy?: ExtensionSpecForProviderActionPointActionUriRefPolicy;

}

/**
 * Converts an object of type 'ExtensionSpecForProviderActionPointActionUriRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecForProviderActionPointActionUriRef(obj: ExtensionSpecForProviderActionPointActionUriRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExtensionSpecForProviderActionPointActionUriRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate uri.
 *
 * @schema ExtensionSpecForProviderActionPointActionUriSelector
 */
export interface ExtensionSpecForProviderActionPointActionUriSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ExtensionSpecForProviderActionPointActionUriSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ExtensionSpecForProviderActionPointActionUriSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ExtensionSpecForProviderActionPointActionUriSelector#policy
   */
  readonly policy?: ExtensionSpecForProviderActionPointActionUriSelectorPolicy;

}

/**
 * Converts an object of type 'ExtensionSpecForProviderActionPointActionUriSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecForProviderActionPointActionUriSelector(obj: ExtensionSpecForProviderActionPointActionUriSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ExtensionSpecForProviderActionPointActionUriSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExtensionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ExtensionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExtensionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ExtensionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ExtensionSpecForProviderActionPointActionRoleArnRefPolicy
 */
export interface ExtensionSpecForProviderActionPointActionRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExtensionSpecForProviderActionPointActionRoleArnRefPolicy#resolution
   */
  readonly resolution?: ExtensionSpecForProviderActionPointActionRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExtensionSpecForProviderActionPointActionRoleArnRefPolicy#resolve
   */
  readonly resolve?: ExtensionSpecForProviderActionPointActionRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ExtensionSpecForProviderActionPointActionRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecForProviderActionPointActionRoleArnRefPolicy(obj: ExtensionSpecForProviderActionPointActionRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ExtensionSpecForProviderActionPointActionRoleArnSelectorPolicy
 */
export interface ExtensionSpecForProviderActionPointActionRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExtensionSpecForProviderActionPointActionRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ExtensionSpecForProviderActionPointActionRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExtensionSpecForProviderActionPointActionRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ExtensionSpecForProviderActionPointActionRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ExtensionSpecForProviderActionPointActionRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecForProviderActionPointActionRoleArnSelectorPolicy(obj: ExtensionSpecForProviderActionPointActionRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ExtensionSpecForProviderActionPointActionUriRefPolicy
 */
export interface ExtensionSpecForProviderActionPointActionUriRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExtensionSpecForProviderActionPointActionUriRefPolicy#resolution
   */
  readonly resolution?: ExtensionSpecForProviderActionPointActionUriRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExtensionSpecForProviderActionPointActionUriRefPolicy#resolve
   */
  readonly resolve?: ExtensionSpecForProviderActionPointActionUriRefPolicyResolve;

}

/**
 * Converts an object of type 'ExtensionSpecForProviderActionPointActionUriRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecForProviderActionPointActionUriRefPolicy(obj: ExtensionSpecForProviderActionPointActionUriRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ExtensionSpecForProviderActionPointActionUriSelectorPolicy
 */
export interface ExtensionSpecForProviderActionPointActionUriSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExtensionSpecForProviderActionPointActionUriSelectorPolicy#resolution
   */
  readonly resolution?: ExtensionSpecForProviderActionPointActionUriSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExtensionSpecForProviderActionPointActionUriSelectorPolicy#resolve
   */
  readonly resolve?: ExtensionSpecForProviderActionPointActionUriSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ExtensionSpecForProviderActionPointActionUriSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionSpecForProviderActionPointActionUriSelectorPolicy(obj: ExtensionSpecForProviderActionPointActionUriSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExtensionSpecForProviderActionPointActionRoleArnRefPolicyResolution
 */
export enum ExtensionSpecForProviderActionPointActionRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExtensionSpecForProviderActionPointActionRoleArnRefPolicyResolve
 */
export enum ExtensionSpecForProviderActionPointActionRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExtensionSpecForProviderActionPointActionRoleArnSelectorPolicyResolution
 */
export enum ExtensionSpecForProviderActionPointActionRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExtensionSpecForProviderActionPointActionRoleArnSelectorPolicyResolve
 */
export enum ExtensionSpecForProviderActionPointActionRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExtensionSpecForProviderActionPointActionUriRefPolicyResolution
 */
export enum ExtensionSpecForProviderActionPointActionUriRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExtensionSpecForProviderActionPointActionUriRefPolicyResolve
 */
export enum ExtensionSpecForProviderActionPointActionUriRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExtensionSpecForProviderActionPointActionUriSelectorPolicyResolution
 */
export enum ExtensionSpecForProviderActionPointActionUriSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExtensionSpecForProviderActionPointActionUriSelectorPolicyResolve
 */
export enum ExtensionSpecForProviderActionPointActionUriSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ExtensionAssociation is the Schema for the ExtensionAssociations API. Associates an AppConfig Extension with a Resource.
 *
 * @schema ExtensionAssociation
 */
export class ExtensionAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ExtensionAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appconfig.aws.upbound.io/v1beta1',
    kind: 'ExtensionAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "ExtensionAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ExtensionAssociationProps): any {
    return {
      ...ExtensionAssociation.GVK,
      ...toJson_ExtensionAssociationProps(props),
    };
  }

  /**
   * Defines a "ExtensionAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ExtensionAssociationProps) {
    super(scope, id, {
      ...ExtensionAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ExtensionAssociation.GVK,
      ...toJson_ExtensionAssociationProps(resolved),
    };
  }
}

/**
 * ExtensionAssociation is the Schema for the ExtensionAssociations API. Associates an AppConfig Extension with a Resource.
 *
 * @schema ExtensionAssociation
 */
export interface ExtensionAssociationProps {
  /**
   * @schema ExtensionAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ExtensionAssociationSpec defines the desired state of ExtensionAssociation
   *
   * @schema ExtensionAssociation#spec
   */
  readonly spec: ExtensionAssociationSpec;

}

/**
 * Converts an object of type 'ExtensionAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationProps(obj: ExtensionAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ExtensionAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtensionAssociationSpec defines the desired state of ExtensionAssociation
 *
 * @schema ExtensionAssociationSpec
 */
export interface ExtensionAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ExtensionAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ExtensionAssociationSpecDeletionPolicy;

  /**
   * @schema ExtensionAssociationSpec#forProvider
   */
  readonly forProvider: ExtensionAssociationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ExtensionAssociationSpec#managementPolicy
   */
  readonly managementPolicy?: ExtensionAssociationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ExtensionAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ExtensionAssociationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ExtensionAssociationSpec#providerRef
   */
  readonly providerRef?: ExtensionAssociationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ExtensionAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ExtensionAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ExtensionAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ExtensionAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ExtensionAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpec(obj: ExtensionAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ExtensionAssociationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ExtensionAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ExtensionAssociationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ExtensionAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ExtensionAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ExtensionAssociationSpecDeletionPolicy
 */
export enum ExtensionAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ExtensionAssociationSpecForProvider
 */
export interface ExtensionAssociationSpecForProvider {
  /**
   * The ARN of the extension defined in the association.
   *
   * @schema ExtensionAssociationSpecForProvider#extensionArn
   */
  readonly extensionArn?: string;

  /**
   * Reference to a Extension in appconfig to populate extensionArn.
   *
   * @schema ExtensionAssociationSpecForProvider#extensionArnRef
   */
  readonly extensionArnRef?: ExtensionAssociationSpecForProviderExtensionArnRef;

  /**
   * Selector for a Extension in appconfig to populate extensionArn.
   *
   * @schema ExtensionAssociationSpecForProvider#extensionArnSelector
   */
  readonly extensionArnSelector?: ExtensionAssociationSpecForProviderExtensionArnSelector;

  /**
   * The parameter names and values defined for the association.
   *
   * @schema ExtensionAssociationSpecForProvider#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ExtensionAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ARN of the application, configuration profile, or environment to associate with the extension.
   *
   * @schema ExtensionAssociationSpecForProvider#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * Reference to a Application in appconfig to populate resourceArn.
   *
   * @schema ExtensionAssociationSpecForProvider#resourceArnRef
   */
  readonly resourceArnRef?: ExtensionAssociationSpecForProviderResourceArnRef;

  /**
   * Selector for a Application in appconfig to populate resourceArn.
   *
   * @schema ExtensionAssociationSpecForProvider#resourceArnSelector
   */
  readonly resourceArnSelector?: ExtensionAssociationSpecForProviderResourceArnSelector;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecForProvider(obj: ExtensionAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extensionArn': obj.extensionArn,
    'extensionArnRef': toJson_ExtensionAssociationSpecForProviderExtensionArnRef(obj.extensionArnRef),
    'extensionArnSelector': toJson_ExtensionAssociationSpecForProviderExtensionArnSelector(obj.extensionArnSelector),
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'resourceArn': obj.resourceArn,
    'resourceArnRef': toJson_ExtensionAssociationSpecForProviderResourceArnRef(obj.resourceArnRef),
    'resourceArnSelector': toJson_ExtensionAssociationSpecForProviderResourceArnSelector(obj.resourceArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ExtensionAssociationSpecManagementPolicy
 */
export enum ExtensionAssociationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ExtensionAssociationSpecProviderConfigRef
 */
export interface ExtensionAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExtensionAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExtensionAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: ExtensionAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecProviderConfigRef(obj: ExtensionAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExtensionAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ExtensionAssociationSpecProviderRef
 */
export interface ExtensionAssociationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExtensionAssociationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExtensionAssociationSpecProviderRef#policy
   */
  readonly policy?: ExtensionAssociationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecProviderRef(obj: ExtensionAssociationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExtensionAssociationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ExtensionAssociationSpecPublishConnectionDetailsTo
 */
export interface ExtensionAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ExtensionAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ExtensionAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ExtensionAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ExtensionAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ExtensionAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecPublishConnectionDetailsTo(obj: ExtensionAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ExtensionAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ExtensionAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ExtensionAssociationSpecWriteConnectionSecretToRef
 */
export interface ExtensionAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ExtensionAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ExtensionAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecWriteConnectionSecretToRef(obj: ExtensionAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Extension in appconfig to populate extensionArn.
 *
 * @schema ExtensionAssociationSpecForProviderExtensionArnRef
 */
export interface ExtensionAssociationSpecForProviderExtensionArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExtensionAssociationSpecForProviderExtensionArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExtensionAssociationSpecForProviderExtensionArnRef#policy
   */
  readonly policy?: ExtensionAssociationSpecForProviderExtensionArnRefPolicy;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecForProviderExtensionArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecForProviderExtensionArnRef(obj: ExtensionAssociationSpecForProviderExtensionArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExtensionAssociationSpecForProviderExtensionArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Extension in appconfig to populate extensionArn.
 *
 * @schema ExtensionAssociationSpecForProviderExtensionArnSelector
 */
export interface ExtensionAssociationSpecForProviderExtensionArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ExtensionAssociationSpecForProviderExtensionArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ExtensionAssociationSpecForProviderExtensionArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ExtensionAssociationSpecForProviderExtensionArnSelector#policy
   */
  readonly policy?: ExtensionAssociationSpecForProviderExtensionArnSelectorPolicy;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecForProviderExtensionArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecForProviderExtensionArnSelector(obj: ExtensionAssociationSpecForProviderExtensionArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ExtensionAssociationSpecForProviderExtensionArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Application in appconfig to populate resourceArn.
 *
 * @schema ExtensionAssociationSpecForProviderResourceArnRef
 */
export interface ExtensionAssociationSpecForProviderResourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExtensionAssociationSpecForProviderResourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExtensionAssociationSpecForProviderResourceArnRef#policy
   */
  readonly policy?: ExtensionAssociationSpecForProviderResourceArnRefPolicy;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecForProviderResourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecForProviderResourceArnRef(obj: ExtensionAssociationSpecForProviderResourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExtensionAssociationSpecForProviderResourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Application in appconfig to populate resourceArn.
 *
 * @schema ExtensionAssociationSpecForProviderResourceArnSelector
 */
export interface ExtensionAssociationSpecForProviderResourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ExtensionAssociationSpecForProviderResourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ExtensionAssociationSpecForProviderResourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ExtensionAssociationSpecForProviderResourceArnSelector#policy
   */
  readonly policy?: ExtensionAssociationSpecForProviderResourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecForProviderResourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecForProviderResourceArnSelector(obj: ExtensionAssociationSpecForProviderResourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ExtensionAssociationSpecForProviderResourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ExtensionAssociationSpecProviderConfigRefPolicy
 */
export interface ExtensionAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExtensionAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ExtensionAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExtensionAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ExtensionAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecProviderConfigRefPolicy(obj: ExtensionAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ExtensionAssociationSpecProviderRefPolicy
 */
export interface ExtensionAssociationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExtensionAssociationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ExtensionAssociationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExtensionAssociationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ExtensionAssociationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecProviderRefPolicy(obj: ExtensionAssociationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ExtensionAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface ExtensionAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExtensionAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExtensionAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ExtensionAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecPublishConnectionDetailsToConfigRef(obj: ExtensionAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExtensionAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ExtensionAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface ExtensionAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ExtensionAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ExtensionAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ExtensionAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecPublishConnectionDetailsToMetadata(obj: ExtensionAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ExtensionAssociationSpecForProviderExtensionArnRefPolicy
 */
export interface ExtensionAssociationSpecForProviderExtensionArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExtensionAssociationSpecForProviderExtensionArnRefPolicy#resolution
   */
  readonly resolution?: ExtensionAssociationSpecForProviderExtensionArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExtensionAssociationSpecForProviderExtensionArnRefPolicy#resolve
   */
  readonly resolve?: ExtensionAssociationSpecForProviderExtensionArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecForProviderExtensionArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecForProviderExtensionArnRefPolicy(obj: ExtensionAssociationSpecForProviderExtensionArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ExtensionAssociationSpecForProviderExtensionArnSelectorPolicy
 */
export interface ExtensionAssociationSpecForProviderExtensionArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExtensionAssociationSpecForProviderExtensionArnSelectorPolicy#resolution
   */
  readonly resolution?: ExtensionAssociationSpecForProviderExtensionArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExtensionAssociationSpecForProviderExtensionArnSelectorPolicy#resolve
   */
  readonly resolve?: ExtensionAssociationSpecForProviderExtensionArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecForProviderExtensionArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecForProviderExtensionArnSelectorPolicy(obj: ExtensionAssociationSpecForProviderExtensionArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ExtensionAssociationSpecForProviderResourceArnRefPolicy
 */
export interface ExtensionAssociationSpecForProviderResourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExtensionAssociationSpecForProviderResourceArnRefPolicy#resolution
   */
  readonly resolution?: ExtensionAssociationSpecForProviderResourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExtensionAssociationSpecForProviderResourceArnRefPolicy#resolve
   */
  readonly resolve?: ExtensionAssociationSpecForProviderResourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecForProviderResourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecForProviderResourceArnRefPolicy(obj: ExtensionAssociationSpecForProviderResourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ExtensionAssociationSpecForProviderResourceArnSelectorPolicy
 */
export interface ExtensionAssociationSpecForProviderResourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExtensionAssociationSpecForProviderResourceArnSelectorPolicy#resolution
   */
  readonly resolution?: ExtensionAssociationSpecForProviderResourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExtensionAssociationSpecForProviderResourceArnSelectorPolicy#resolve
   */
  readonly resolve?: ExtensionAssociationSpecForProviderResourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecForProviderResourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecForProviderResourceArnSelectorPolicy(obj: ExtensionAssociationSpecForProviderResourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExtensionAssociationSpecProviderConfigRefPolicyResolution
 */
export enum ExtensionAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExtensionAssociationSpecProviderConfigRefPolicyResolve
 */
export enum ExtensionAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExtensionAssociationSpecProviderRefPolicyResolution
 */
export enum ExtensionAssociationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExtensionAssociationSpecProviderRefPolicyResolve
 */
export enum ExtensionAssociationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ExtensionAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ExtensionAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExtensionAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ExtensionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExtensionAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ExtensionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ExtensionAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ExtensionAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExtensionAssociationSpecForProviderExtensionArnRefPolicyResolution
 */
export enum ExtensionAssociationSpecForProviderExtensionArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExtensionAssociationSpecForProviderExtensionArnRefPolicyResolve
 */
export enum ExtensionAssociationSpecForProviderExtensionArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExtensionAssociationSpecForProviderExtensionArnSelectorPolicyResolution
 */
export enum ExtensionAssociationSpecForProviderExtensionArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExtensionAssociationSpecForProviderExtensionArnSelectorPolicyResolve
 */
export enum ExtensionAssociationSpecForProviderExtensionArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExtensionAssociationSpecForProviderResourceArnRefPolicyResolution
 */
export enum ExtensionAssociationSpecForProviderResourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExtensionAssociationSpecForProviderResourceArnRefPolicyResolve
 */
export enum ExtensionAssociationSpecForProviderResourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExtensionAssociationSpecForProviderResourceArnSelectorPolicyResolution
 */
export enum ExtensionAssociationSpecForProviderResourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExtensionAssociationSpecForProviderResourceArnSelectorPolicyResolve
 */
export enum ExtensionAssociationSpecForProviderResourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExtensionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ExtensionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExtensionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ExtensionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * HostedConfigurationVersion is the Schema for the HostedConfigurationVersions API. Provides an AppConfig Hosted Configuration Version resource.
 *
 * @schema HostedConfigurationVersion
 */
export class HostedConfigurationVersion extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HostedConfigurationVersion"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appconfig.aws.upbound.io/v1beta1',
    kind: 'HostedConfigurationVersion',
  }

  /**
   * Renders a Kubernetes manifest for "HostedConfigurationVersion".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HostedConfigurationVersionProps): any {
    return {
      ...HostedConfigurationVersion.GVK,
      ...toJson_HostedConfigurationVersionProps(props),
    };
  }

  /**
   * Defines a "HostedConfigurationVersion" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HostedConfigurationVersionProps) {
    super(scope, id, {
      ...HostedConfigurationVersion.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HostedConfigurationVersion.GVK,
      ...toJson_HostedConfigurationVersionProps(resolved),
    };
  }
}

/**
 * HostedConfigurationVersion is the Schema for the HostedConfigurationVersions API. Provides an AppConfig Hosted Configuration Version resource.
 *
 * @schema HostedConfigurationVersion
 */
export interface HostedConfigurationVersionProps {
  /**
   * @schema HostedConfigurationVersion#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HostedConfigurationVersionSpec defines the desired state of HostedConfigurationVersion
   *
   * @schema HostedConfigurationVersion#spec
   */
  readonly spec: HostedConfigurationVersionSpec;

}

/**
 * Converts an object of type 'HostedConfigurationVersionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionProps(obj: HostedConfigurationVersionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HostedConfigurationVersionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostedConfigurationVersionSpec defines the desired state of HostedConfigurationVersion
 *
 * @schema HostedConfigurationVersionSpec
 */
export interface HostedConfigurationVersionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HostedConfigurationVersionSpec#deletionPolicy
   */
  readonly deletionPolicy?: HostedConfigurationVersionSpecDeletionPolicy;

  /**
   * @schema HostedConfigurationVersionSpec#forProvider
   */
  readonly forProvider: HostedConfigurationVersionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HostedConfigurationVersionSpec#managementPolicy
   */
  readonly managementPolicy?: HostedConfigurationVersionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema HostedConfigurationVersionSpec#providerConfigRef
   */
  readonly providerConfigRef?: HostedConfigurationVersionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema HostedConfigurationVersionSpec#providerRef
   */
  readonly providerRef?: HostedConfigurationVersionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema HostedConfigurationVersionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HostedConfigurationVersionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema HostedConfigurationVersionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HostedConfigurationVersionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpec(obj: HostedConfigurationVersionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HostedConfigurationVersionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_HostedConfigurationVersionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_HostedConfigurationVersionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_HostedConfigurationVersionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HostedConfigurationVersionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HostedConfigurationVersionSpecDeletionPolicy
 */
export enum HostedConfigurationVersionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema HostedConfigurationVersionSpecForProvider
 */
export interface HostedConfigurationVersionSpecForProvider {
  /**
   * Application ID.
   *
   * @schema HostedConfigurationVersionSpecForProvider#applicationId
   */
  readonly applicationId?: string;

  /**
   * Reference to a Application in appconfig to populate applicationId.
   *
   * @schema HostedConfigurationVersionSpecForProvider#applicationIdRef
   */
  readonly applicationIdRef?: HostedConfigurationVersionSpecForProviderApplicationIdRef;

  /**
   * Selector for a Application in appconfig to populate applicationId.
   *
   * @schema HostedConfigurationVersionSpecForProvider#applicationIdSelector
   */
  readonly applicationIdSelector?: HostedConfigurationVersionSpecForProviderApplicationIdSelector;

  /**
   * Configuration profile ID.
   *
   * @schema HostedConfigurationVersionSpecForProvider#configurationProfileId
   */
  readonly configurationProfileId?: string;

  /**
   * Reference to a ConfigurationProfile in appconfig to populate configurationProfileId.
   *
   * @schema HostedConfigurationVersionSpecForProvider#configurationProfileIdRef
   */
  readonly configurationProfileIdRef?: HostedConfigurationVersionSpecForProviderConfigurationProfileIdRef;

  /**
   * Selector for a ConfigurationProfile in appconfig to populate configurationProfileId.
   *
   * @schema HostedConfigurationVersionSpecForProvider#configurationProfileIdSelector
   */
  readonly configurationProfileIdSelector?: HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelector;

  /**
   * Content of the configuration or the configuration data.
   *
   * @schema HostedConfigurationVersionSpecForProvider#contentSecretRef
   */
  readonly contentSecretRef?: HostedConfigurationVersionSpecForProviderContentSecretRef;

  /**
   * Standard MIME type describing the format of the configuration content. For more information, see Content-Type.
   *
   * @schema HostedConfigurationVersionSpecForProvider#contentType
   */
  readonly contentType?: string;

  /**
   * Description of the configuration.
   *
   * @schema HostedConfigurationVersionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema HostedConfigurationVersionSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecForProvider(obj: HostedConfigurationVersionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationId': obj.applicationId,
    'applicationIdRef': toJson_HostedConfigurationVersionSpecForProviderApplicationIdRef(obj.applicationIdRef),
    'applicationIdSelector': toJson_HostedConfigurationVersionSpecForProviderApplicationIdSelector(obj.applicationIdSelector),
    'configurationProfileId': obj.configurationProfileId,
    'configurationProfileIdRef': toJson_HostedConfigurationVersionSpecForProviderConfigurationProfileIdRef(obj.configurationProfileIdRef),
    'configurationProfileIdSelector': toJson_HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelector(obj.configurationProfileIdSelector),
    'contentSecretRef': toJson_HostedConfigurationVersionSpecForProviderContentSecretRef(obj.contentSecretRef),
    'contentType': obj.contentType,
    'description': obj.description,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HostedConfigurationVersionSpecManagementPolicy
 */
export enum HostedConfigurationVersionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema HostedConfigurationVersionSpecProviderConfigRef
 */
export interface HostedConfigurationVersionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedConfigurationVersionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedConfigurationVersionSpecProviderConfigRef#policy
   */
  readonly policy?: HostedConfigurationVersionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecProviderConfigRef(obj: HostedConfigurationVersionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedConfigurationVersionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema HostedConfigurationVersionSpecProviderRef
 */
export interface HostedConfigurationVersionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedConfigurationVersionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedConfigurationVersionSpecProviderRef#policy
   */
  readonly policy?: HostedConfigurationVersionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecProviderRef(obj: HostedConfigurationVersionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedConfigurationVersionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema HostedConfigurationVersionSpecPublishConnectionDetailsTo
 */
export interface HostedConfigurationVersionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema HostedConfigurationVersionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HostedConfigurationVersionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HostedConfigurationVersionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HostedConfigurationVersionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecPublishConnectionDetailsTo(obj: HostedConfigurationVersionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HostedConfigurationVersionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema HostedConfigurationVersionSpecWriteConnectionSecretToRef
 */
export interface HostedConfigurationVersionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HostedConfigurationVersionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HostedConfigurationVersionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecWriteConnectionSecretToRef(obj: HostedConfigurationVersionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Application in appconfig to populate applicationId.
 *
 * @schema HostedConfigurationVersionSpecForProviderApplicationIdRef
 */
export interface HostedConfigurationVersionSpecForProviderApplicationIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedConfigurationVersionSpecForProviderApplicationIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedConfigurationVersionSpecForProviderApplicationIdRef#policy
   */
  readonly policy?: HostedConfigurationVersionSpecForProviderApplicationIdRefPolicy;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecForProviderApplicationIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecForProviderApplicationIdRef(obj: HostedConfigurationVersionSpecForProviderApplicationIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedConfigurationVersionSpecForProviderApplicationIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Application in appconfig to populate applicationId.
 *
 * @schema HostedConfigurationVersionSpecForProviderApplicationIdSelector
 */
export interface HostedConfigurationVersionSpecForProviderApplicationIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema HostedConfigurationVersionSpecForProviderApplicationIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HostedConfigurationVersionSpecForProviderApplicationIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HostedConfigurationVersionSpecForProviderApplicationIdSelector#policy
   */
  readonly policy?: HostedConfigurationVersionSpecForProviderApplicationIdSelectorPolicy;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecForProviderApplicationIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecForProviderApplicationIdSelector(obj: HostedConfigurationVersionSpecForProviderApplicationIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HostedConfigurationVersionSpecForProviderApplicationIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ConfigurationProfile in appconfig to populate configurationProfileId.
 *
 * @schema HostedConfigurationVersionSpecForProviderConfigurationProfileIdRef
 */
export interface HostedConfigurationVersionSpecForProviderConfigurationProfileIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedConfigurationVersionSpecForProviderConfigurationProfileIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedConfigurationVersionSpecForProviderConfigurationProfileIdRef#policy
   */
  readonly policy?: HostedConfigurationVersionSpecForProviderConfigurationProfileIdRefPolicy;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecForProviderConfigurationProfileIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecForProviderConfigurationProfileIdRef(obj: HostedConfigurationVersionSpecForProviderConfigurationProfileIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedConfigurationVersionSpecForProviderConfigurationProfileIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ConfigurationProfile in appconfig to populate configurationProfileId.
 *
 * @schema HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelector
 */
export interface HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelector#policy
   */
  readonly policy?: HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelectorPolicy;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelector(obj: HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Content of the configuration or the configuration data.
 *
 * @schema HostedConfigurationVersionSpecForProviderContentSecretRef
 */
export interface HostedConfigurationVersionSpecForProviderContentSecretRef {
  /**
   * The key to select.
   *
   * @schema HostedConfigurationVersionSpecForProviderContentSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema HostedConfigurationVersionSpecForProviderContentSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HostedConfigurationVersionSpecForProviderContentSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecForProviderContentSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecForProviderContentSecretRef(obj: HostedConfigurationVersionSpecForProviderContentSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedConfigurationVersionSpecProviderConfigRefPolicy
 */
export interface HostedConfigurationVersionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedConfigurationVersionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HostedConfigurationVersionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedConfigurationVersionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HostedConfigurationVersionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecProviderConfigRefPolicy(obj: HostedConfigurationVersionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedConfigurationVersionSpecProviderRefPolicy
 */
export interface HostedConfigurationVersionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedConfigurationVersionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: HostedConfigurationVersionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedConfigurationVersionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: HostedConfigurationVersionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecProviderRefPolicy(obj: HostedConfigurationVersionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRef
 */
export interface HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRef(obj: HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HostedConfigurationVersionSpecPublishConnectionDetailsToMetadata
 */
export interface HostedConfigurationVersionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedConfigurationVersionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedConfigurationVersionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema HostedConfigurationVersionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecPublishConnectionDetailsToMetadata(obj: HostedConfigurationVersionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedConfigurationVersionSpecForProviderApplicationIdRefPolicy
 */
export interface HostedConfigurationVersionSpecForProviderApplicationIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedConfigurationVersionSpecForProviderApplicationIdRefPolicy#resolution
   */
  readonly resolution?: HostedConfigurationVersionSpecForProviderApplicationIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedConfigurationVersionSpecForProviderApplicationIdRefPolicy#resolve
   */
  readonly resolve?: HostedConfigurationVersionSpecForProviderApplicationIdRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecForProviderApplicationIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecForProviderApplicationIdRefPolicy(obj: HostedConfigurationVersionSpecForProviderApplicationIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HostedConfigurationVersionSpecForProviderApplicationIdSelectorPolicy
 */
export interface HostedConfigurationVersionSpecForProviderApplicationIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedConfigurationVersionSpecForProviderApplicationIdSelectorPolicy#resolution
   */
  readonly resolution?: HostedConfigurationVersionSpecForProviderApplicationIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedConfigurationVersionSpecForProviderApplicationIdSelectorPolicy#resolve
   */
  readonly resolve?: HostedConfigurationVersionSpecForProviderApplicationIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecForProviderApplicationIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecForProviderApplicationIdSelectorPolicy(obj: HostedConfigurationVersionSpecForProviderApplicationIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedConfigurationVersionSpecForProviderConfigurationProfileIdRefPolicy
 */
export interface HostedConfigurationVersionSpecForProviderConfigurationProfileIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedConfigurationVersionSpecForProviderConfigurationProfileIdRefPolicy#resolution
   */
  readonly resolution?: HostedConfigurationVersionSpecForProviderConfigurationProfileIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedConfigurationVersionSpecForProviderConfigurationProfileIdRefPolicy#resolve
   */
  readonly resolve?: HostedConfigurationVersionSpecForProviderConfigurationProfileIdRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecForProviderConfigurationProfileIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecForProviderConfigurationProfileIdRefPolicy(obj: HostedConfigurationVersionSpecForProviderConfigurationProfileIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelectorPolicy
 */
export interface HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelectorPolicy#resolution
   */
  readonly resolution?: HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelectorPolicy#resolve
   */
  readonly resolve?: HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelectorPolicy(obj: HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedConfigurationVersionSpecProviderConfigRefPolicyResolution
 */
export enum HostedConfigurationVersionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedConfigurationVersionSpecProviderConfigRefPolicyResolve
 */
export enum HostedConfigurationVersionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedConfigurationVersionSpecProviderRefPolicyResolution
 */
export enum HostedConfigurationVersionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedConfigurationVersionSpecProviderRefPolicyResolve
 */
export enum HostedConfigurationVersionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj: HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedConfigurationVersionSpecForProviderApplicationIdRefPolicyResolution
 */
export enum HostedConfigurationVersionSpecForProviderApplicationIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedConfigurationVersionSpecForProviderApplicationIdRefPolicyResolve
 */
export enum HostedConfigurationVersionSpecForProviderApplicationIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedConfigurationVersionSpecForProviderApplicationIdSelectorPolicyResolution
 */
export enum HostedConfigurationVersionSpecForProviderApplicationIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedConfigurationVersionSpecForProviderApplicationIdSelectorPolicyResolve
 */
export enum HostedConfigurationVersionSpecForProviderApplicationIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedConfigurationVersionSpecForProviderConfigurationProfileIdRefPolicyResolution
 */
export enum HostedConfigurationVersionSpecForProviderConfigurationProfileIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedConfigurationVersionSpecForProviderConfigurationProfileIdRefPolicyResolve
 */
export enum HostedConfigurationVersionSpecForProviderConfigurationProfileIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelectorPolicyResolution
 */
export enum HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelectorPolicyResolve
 */
export enum HostedConfigurationVersionSpecForProviderConfigurationProfileIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HostedConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

