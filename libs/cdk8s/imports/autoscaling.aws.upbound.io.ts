// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Attachment is the Schema for the Attachments API. Provides an AutoScaling Group Attachment resource.
 *
 * @schema Attachment
 */
export class Attachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Attachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'autoscaling.aws.upbound.io/v1beta1',
    kind: 'Attachment',
  }

  /**
   * Renders a Kubernetes manifest for "Attachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AttachmentProps): any {
    return {
      ...Attachment.GVK,
      ...toJson_AttachmentProps(props),
    };
  }

  /**
   * Defines a "Attachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AttachmentProps) {
    super(scope, id, {
      ...Attachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Attachment.GVK,
      ...toJson_AttachmentProps(resolved),
    };
  }
}

/**
 * Attachment is the Schema for the Attachments API. Provides an AutoScaling Group Attachment resource.
 *
 * @schema Attachment
 */
export interface AttachmentProps {
  /**
   * @schema Attachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AttachmentSpec defines the desired state of Attachment
   *
   * @schema Attachment#spec
   */
  readonly spec: AttachmentSpec;

}

/**
 * Converts an object of type 'AttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentProps(obj: AttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AttachmentSpec defines the desired state of Attachment
 *
 * @schema AttachmentSpec
 */
export interface AttachmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AttachmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: AttachmentSpecDeletionPolicy;

  /**
   * @schema AttachmentSpec#forProvider
   */
  readonly forProvider: AttachmentSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AttachmentSpec#initProvider
   */
  readonly initProvider?: any;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AttachmentSpec#managementPolicies
   */
  readonly managementPolicies?: AttachmentSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AttachmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: AttachmentSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AttachmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AttachmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AttachmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AttachmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpec(obj: AttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AttachmentSpecForProvider(obj.forProvider),
    'initProvider': obj.initProvider,
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AttachmentSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AttachmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AttachmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AttachmentSpecDeletionPolicy
 */
export enum AttachmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AttachmentSpecForProvider
 */
export interface AttachmentSpecForProvider {
  /**
   * ARN of an ALB Target Group.
   *
   * @schema AttachmentSpecForProvider#albTargetGroupArn
   */
  readonly albTargetGroupArn?: string;

  /**
   * Reference to a LBTargetGroup in elbv2 to populate albTargetGroupArn.
   *
   * @schema AttachmentSpecForProvider#albTargetGroupArnRef
   */
  readonly albTargetGroupArnRef?: AttachmentSpecForProviderAlbTargetGroupArnRef;

  /**
   * Selector for a LBTargetGroup in elbv2 to populate albTargetGroupArn.
   *
   * @schema AttachmentSpecForProvider#albTargetGroupArnSelector
   */
  readonly albTargetGroupArnSelector?: AttachmentSpecForProviderAlbTargetGroupArnSelector;

  /**
   * Name of ASG to associate with the ELB.
   *
   * @schema AttachmentSpecForProvider#autoscalingGroupName
   */
  readonly autoscalingGroupName?: string;

  /**
   * Reference to a AutoscalingGroup to populate autoscalingGroupName.
   *
   * @schema AttachmentSpecForProvider#autoscalingGroupNameRef
   */
  readonly autoscalingGroupNameRef?: AttachmentSpecForProviderAutoscalingGroupNameRef;

  /**
   * Selector for a AutoscalingGroup to populate autoscalingGroupName.
   *
   * @schema AttachmentSpecForProvider#autoscalingGroupNameSelector
   */
  readonly autoscalingGroupNameSelector?: AttachmentSpecForProviderAutoscalingGroupNameSelector;

  /**
   * Name of the ELB.
   *
   * @schema AttachmentSpecForProvider#elb
   */
  readonly elb?: string;

  /**
   * Reference to a ELB in elb to populate elb.
   *
   * @schema AttachmentSpecForProvider#elbRef
   */
  readonly elbRef?: AttachmentSpecForProviderElbRef;

  /**
   * Selector for a ELB in elb to populate elb.
   *
   * @schema AttachmentSpecForProvider#elbSelector
   */
  readonly elbSelector?: AttachmentSpecForProviderElbSelector;

  /**
   * ARN of a load balancer target group.
   *
   * @schema AttachmentSpecForProvider#lbTargetGroupArn
   */
  readonly lbTargetGroupArn?: string;

  /**
   * Reference to a LBTargetGroup in elbv2 to populate lbTargetGroupArn.
   *
   * @schema AttachmentSpecForProvider#lbTargetGroupArnRef
   */
  readonly lbTargetGroupArnRef?: AttachmentSpecForProviderLbTargetGroupArnRef;

  /**
   * Selector for a LBTargetGroup in elbv2 to populate lbTargetGroupArn.
   *
   * @schema AttachmentSpecForProvider#lbTargetGroupArnSelector
   */
  readonly lbTargetGroupArnSelector?: AttachmentSpecForProviderLbTargetGroupArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AttachmentSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'AttachmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProvider(obj: AttachmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'albTargetGroupArn': obj.albTargetGroupArn,
    'albTargetGroupArnRef': toJson_AttachmentSpecForProviderAlbTargetGroupArnRef(obj.albTargetGroupArnRef),
    'albTargetGroupArnSelector': toJson_AttachmentSpecForProviderAlbTargetGroupArnSelector(obj.albTargetGroupArnSelector),
    'autoscalingGroupName': obj.autoscalingGroupName,
    'autoscalingGroupNameRef': toJson_AttachmentSpecForProviderAutoscalingGroupNameRef(obj.autoscalingGroupNameRef),
    'autoscalingGroupNameSelector': toJson_AttachmentSpecForProviderAutoscalingGroupNameSelector(obj.autoscalingGroupNameSelector),
    'elb': obj.elb,
    'elbRef': toJson_AttachmentSpecForProviderElbRef(obj.elbRef),
    'elbSelector': toJson_AttachmentSpecForProviderElbSelector(obj.elbSelector),
    'lbTargetGroupArn': obj.lbTargetGroupArn,
    'lbTargetGroupArnRef': toJson_AttachmentSpecForProviderLbTargetGroupArnRef(obj.lbTargetGroupArnRef),
    'lbTargetGroupArnSelector': toJson_AttachmentSpecForProviderLbTargetGroupArnSelector(obj.lbTargetGroupArnSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AttachmentSpecManagementPolicies
 */
export enum AttachmentSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AttachmentSpecProviderConfigRef
 */
export interface AttachmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttachmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttachmentSpecProviderConfigRef#policy
   */
  readonly policy?: AttachmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AttachmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecProviderConfigRef(obj: AttachmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttachmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AttachmentSpecPublishConnectionDetailsTo
 */
export interface AttachmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AttachmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AttachmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AttachmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AttachmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AttachmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AttachmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecPublishConnectionDetailsTo(obj: AttachmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AttachmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AttachmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AttachmentSpecWriteConnectionSecretToRef
 */
export interface AttachmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AttachmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AttachmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AttachmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecWriteConnectionSecretToRef(obj: AttachmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LBTargetGroup in elbv2 to populate albTargetGroupArn.
 *
 * @schema AttachmentSpecForProviderAlbTargetGroupArnRef
 */
export interface AttachmentSpecForProviderAlbTargetGroupArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttachmentSpecForProviderAlbTargetGroupArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttachmentSpecForProviderAlbTargetGroupArnRef#policy
   */
  readonly policy?: AttachmentSpecForProviderAlbTargetGroupArnRefPolicy;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderAlbTargetGroupArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderAlbTargetGroupArnRef(obj: AttachmentSpecForProviderAlbTargetGroupArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttachmentSpecForProviderAlbTargetGroupArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LBTargetGroup in elbv2 to populate albTargetGroupArn.
 *
 * @schema AttachmentSpecForProviderAlbTargetGroupArnSelector
 */
export interface AttachmentSpecForProviderAlbTargetGroupArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AttachmentSpecForProviderAlbTargetGroupArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AttachmentSpecForProviderAlbTargetGroupArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AttachmentSpecForProviderAlbTargetGroupArnSelector#policy
   */
  readonly policy?: AttachmentSpecForProviderAlbTargetGroupArnSelectorPolicy;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderAlbTargetGroupArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderAlbTargetGroupArnSelector(obj: AttachmentSpecForProviderAlbTargetGroupArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AttachmentSpecForProviderAlbTargetGroupArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a AutoscalingGroup to populate autoscalingGroupName.
 *
 * @schema AttachmentSpecForProviderAutoscalingGroupNameRef
 */
export interface AttachmentSpecForProviderAutoscalingGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttachmentSpecForProviderAutoscalingGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttachmentSpecForProviderAutoscalingGroupNameRef#policy
   */
  readonly policy?: AttachmentSpecForProviderAutoscalingGroupNameRefPolicy;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderAutoscalingGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderAutoscalingGroupNameRef(obj: AttachmentSpecForProviderAutoscalingGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttachmentSpecForProviderAutoscalingGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a AutoscalingGroup to populate autoscalingGroupName.
 *
 * @schema AttachmentSpecForProviderAutoscalingGroupNameSelector
 */
export interface AttachmentSpecForProviderAutoscalingGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AttachmentSpecForProviderAutoscalingGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AttachmentSpecForProviderAutoscalingGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AttachmentSpecForProviderAutoscalingGroupNameSelector#policy
   */
  readonly policy?: AttachmentSpecForProviderAutoscalingGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderAutoscalingGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderAutoscalingGroupNameSelector(obj: AttachmentSpecForProviderAutoscalingGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AttachmentSpecForProviderAutoscalingGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ELB in elb to populate elb.
 *
 * @schema AttachmentSpecForProviderElbRef
 */
export interface AttachmentSpecForProviderElbRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttachmentSpecForProviderElbRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttachmentSpecForProviderElbRef#policy
   */
  readonly policy?: AttachmentSpecForProviderElbRefPolicy;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderElbRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderElbRef(obj: AttachmentSpecForProviderElbRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttachmentSpecForProviderElbRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ELB in elb to populate elb.
 *
 * @schema AttachmentSpecForProviderElbSelector
 */
export interface AttachmentSpecForProviderElbSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AttachmentSpecForProviderElbSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AttachmentSpecForProviderElbSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AttachmentSpecForProviderElbSelector#policy
   */
  readonly policy?: AttachmentSpecForProviderElbSelectorPolicy;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderElbSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderElbSelector(obj: AttachmentSpecForProviderElbSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AttachmentSpecForProviderElbSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LBTargetGroup in elbv2 to populate lbTargetGroupArn.
 *
 * @schema AttachmentSpecForProviderLbTargetGroupArnRef
 */
export interface AttachmentSpecForProviderLbTargetGroupArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttachmentSpecForProviderLbTargetGroupArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttachmentSpecForProviderLbTargetGroupArnRef#policy
   */
  readonly policy?: AttachmentSpecForProviderLbTargetGroupArnRefPolicy;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderLbTargetGroupArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderLbTargetGroupArnRef(obj: AttachmentSpecForProviderLbTargetGroupArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttachmentSpecForProviderLbTargetGroupArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LBTargetGroup in elbv2 to populate lbTargetGroupArn.
 *
 * @schema AttachmentSpecForProviderLbTargetGroupArnSelector
 */
export interface AttachmentSpecForProviderLbTargetGroupArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AttachmentSpecForProviderLbTargetGroupArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AttachmentSpecForProviderLbTargetGroupArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AttachmentSpecForProviderLbTargetGroupArnSelector#policy
   */
  readonly policy?: AttachmentSpecForProviderLbTargetGroupArnSelectorPolicy;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderLbTargetGroupArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderLbTargetGroupArnSelector(obj: AttachmentSpecForProviderLbTargetGroupArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AttachmentSpecForProviderLbTargetGroupArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AttachmentSpecProviderConfigRefPolicy
 */
export interface AttachmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AttachmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AttachmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecProviderConfigRefPolicy(obj: AttachmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AttachmentSpecPublishConnectionDetailsToConfigRef
 */
export interface AttachmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttachmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttachmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AttachmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AttachmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecPublishConnectionDetailsToConfigRef(obj: AttachmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AttachmentSpecPublishConnectionDetailsToMetadata
 */
export interface AttachmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AttachmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AttachmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AttachmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AttachmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecPublishConnectionDetailsToMetadata(obj: AttachmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AttachmentSpecForProviderAlbTargetGroupArnRefPolicy
 */
export interface AttachmentSpecForProviderAlbTargetGroupArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentSpecForProviderAlbTargetGroupArnRefPolicy#resolution
   */
  readonly resolution?: AttachmentSpecForProviderAlbTargetGroupArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentSpecForProviderAlbTargetGroupArnRefPolicy#resolve
   */
  readonly resolve?: AttachmentSpecForProviderAlbTargetGroupArnRefPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderAlbTargetGroupArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderAlbTargetGroupArnRefPolicy(obj: AttachmentSpecForProviderAlbTargetGroupArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AttachmentSpecForProviderAlbTargetGroupArnSelectorPolicy
 */
export interface AttachmentSpecForProviderAlbTargetGroupArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentSpecForProviderAlbTargetGroupArnSelectorPolicy#resolution
   */
  readonly resolution?: AttachmentSpecForProviderAlbTargetGroupArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentSpecForProviderAlbTargetGroupArnSelectorPolicy#resolve
   */
  readonly resolve?: AttachmentSpecForProviderAlbTargetGroupArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderAlbTargetGroupArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderAlbTargetGroupArnSelectorPolicy(obj: AttachmentSpecForProviderAlbTargetGroupArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AttachmentSpecForProviderAutoscalingGroupNameRefPolicy
 */
export interface AttachmentSpecForProviderAutoscalingGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentSpecForProviderAutoscalingGroupNameRefPolicy#resolution
   */
  readonly resolution?: AttachmentSpecForProviderAutoscalingGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentSpecForProviderAutoscalingGroupNameRefPolicy#resolve
   */
  readonly resolve?: AttachmentSpecForProviderAutoscalingGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderAutoscalingGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderAutoscalingGroupNameRefPolicy(obj: AttachmentSpecForProviderAutoscalingGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AttachmentSpecForProviderAutoscalingGroupNameSelectorPolicy
 */
export interface AttachmentSpecForProviderAutoscalingGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentSpecForProviderAutoscalingGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: AttachmentSpecForProviderAutoscalingGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentSpecForProviderAutoscalingGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: AttachmentSpecForProviderAutoscalingGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderAutoscalingGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderAutoscalingGroupNameSelectorPolicy(obj: AttachmentSpecForProviderAutoscalingGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AttachmentSpecForProviderElbRefPolicy
 */
export interface AttachmentSpecForProviderElbRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentSpecForProviderElbRefPolicy#resolution
   */
  readonly resolution?: AttachmentSpecForProviderElbRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentSpecForProviderElbRefPolicy#resolve
   */
  readonly resolve?: AttachmentSpecForProviderElbRefPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderElbRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderElbRefPolicy(obj: AttachmentSpecForProviderElbRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AttachmentSpecForProviderElbSelectorPolicy
 */
export interface AttachmentSpecForProviderElbSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentSpecForProviderElbSelectorPolicy#resolution
   */
  readonly resolution?: AttachmentSpecForProviderElbSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentSpecForProviderElbSelectorPolicy#resolve
   */
  readonly resolve?: AttachmentSpecForProviderElbSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderElbSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderElbSelectorPolicy(obj: AttachmentSpecForProviderElbSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AttachmentSpecForProviderLbTargetGroupArnRefPolicy
 */
export interface AttachmentSpecForProviderLbTargetGroupArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentSpecForProviderLbTargetGroupArnRefPolicy#resolution
   */
  readonly resolution?: AttachmentSpecForProviderLbTargetGroupArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentSpecForProviderLbTargetGroupArnRefPolicy#resolve
   */
  readonly resolve?: AttachmentSpecForProviderLbTargetGroupArnRefPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderLbTargetGroupArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderLbTargetGroupArnRefPolicy(obj: AttachmentSpecForProviderLbTargetGroupArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AttachmentSpecForProviderLbTargetGroupArnSelectorPolicy
 */
export interface AttachmentSpecForProviderLbTargetGroupArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentSpecForProviderLbTargetGroupArnSelectorPolicy#resolution
   */
  readonly resolution?: AttachmentSpecForProviderLbTargetGroupArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentSpecForProviderLbTargetGroupArnSelectorPolicy#resolve
   */
  readonly resolve?: AttachmentSpecForProviderLbTargetGroupArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentSpecForProviderLbTargetGroupArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecForProviderLbTargetGroupArnSelectorPolicy(obj: AttachmentSpecForProviderLbTargetGroupArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentSpecProviderConfigRefPolicyResolution
 */
export enum AttachmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentSpecProviderConfigRefPolicyResolve
 */
export enum AttachmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AttachmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AttachmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: AttachmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentSpecForProviderAlbTargetGroupArnRefPolicyResolution
 */
export enum AttachmentSpecForProviderAlbTargetGroupArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentSpecForProviderAlbTargetGroupArnRefPolicyResolve
 */
export enum AttachmentSpecForProviderAlbTargetGroupArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentSpecForProviderAlbTargetGroupArnSelectorPolicyResolution
 */
export enum AttachmentSpecForProviderAlbTargetGroupArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentSpecForProviderAlbTargetGroupArnSelectorPolicyResolve
 */
export enum AttachmentSpecForProviderAlbTargetGroupArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentSpecForProviderAutoscalingGroupNameRefPolicyResolution
 */
export enum AttachmentSpecForProviderAutoscalingGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentSpecForProviderAutoscalingGroupNameRefPolicyResolve
 */
export enum AttachmentSpecForProviderAutoscalingGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentSpecForProviderAutoscalingGroupNameSelectorPolicyResolution
 */
export enum AttachmentSpecForProviderAutoscalingGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentSpecForProviderAutoscalingGroupNameSelectorPolicyResolve
 */
export enum AttachmentSpecForProviderAutoscalingGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentSpecForProviderElbRefPolicyResolution
 */
export enum AttachmentSpecForProviderElbRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentSpecForProviderElbRefPolicyResolve
 */
export enum AttachmentSpecForProviderElbRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentSpecForProviderElbSelectorPolicyResolution
 */
export enum AttachmentSpecForProviderElbSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentSpecForProviderElbSelectorPolicyResolve
 */
export enum AttachmentSpecForProviderElbSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentSpecForProviderLbTargetGroupArnRefPolicyResolution
 */
export enum AttachmentSpecForProviderLbTargetGroupArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentSpecForProviderLbTargetGroupArnRefPolicyResolve
 */
export enum AttachmentSpecForProviderLbTargetGroupArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentSpecForProviderLbTargetGroupArnSelectorPolicyResolution
 */
export enum AttachmentSpecForProviderLbTargetGroupArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentSpecForProviderLbTargetGroupArnSelectorPolicyResolve
 */
export enum AttachmentSpecForProviderLbTargetGroupArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * AutoscalingGroup is the Schema for the AutoscalingGroups API. Provides an Auto Scaling Group resource.
 *
 * @schema AutoscalingGroup
 */
export class AutoscalingGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AutoscalingGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'autoscaling.aws.upbound.io/v1beta1',
    kind: 'AutoscalingGroup',
  }

  /**
   * Renders a Kubernetes manifest for "AutoscalingGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AutoscalingGroupProps): any {
    return {
      ...AutoscalingGroup.GVK,
      ...toJson_AutoscalingGroupProps(props),
    };
  }

  /**
   * Defines a "AutoscalingGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AutoscalingGroupProps) {
    super(scope, id, {
      ...AutoscalingGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AutoscalingGroup.GVK,
      ...toJson_AutoscalingGroupProps(resolved),
    };
  }
}

/**
 * AutoscalingGroup is the Schema for the AutoscalingGroups API. Provides an Auto Scaling Group resource.
 *
 * @schema AutoscalingGroup
 */
export interface AutoscalingGroupProps {
  /**
   * @schema AutoscalingGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AutoscalingGroupSpec defines the desired state of AutoscalingGroup
   *
   * @schema AutoscalingGroup#spec
   */
  readonly spec: AutoscalingGroupSpec;

}

/**
 * Converts an object of type 'AutoscalingGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupProps(obj: AutoscalingGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AutoscalingGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AutoscalingGroupSpec defines the desired state of AutoscalingGroup
 *
 * @schema AutoscalingGroupSpec
 */
export interface AutoscalingGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AutoscalingGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: AutoscalingGroupSpecDeletionPolicy;

  /**
   * @schema AutoscalingGroupSpec#forProvider
   */
  readonly forProvider: AutoscalingGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AutoscalingGroupSpec#initProvider
   */
  readonly initProvider?: AutoscalingGroupSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AutoscalingGroupSpec#managementPolicies
   */
  readonly managementPolicies?: AutoscalingGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AutoscalingGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: AutoscalingGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AutoscalingGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AutoscalingGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AutoscalingGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AutoscalingGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AutoscalingGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpec(obj: AutoscalingGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AutoscalingGroupSpecForProvider(obj.forProvider),
    'initProvider': toJson_AutoscalingGroupSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AutoscalingGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AutoscalingGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AutoscalingGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AutoscalingGroupSpecDeletionPolicy
 */
export enum AutoscalingGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AutoscalingGroupSpecForProvider
 */
export interface AutoscalingGroupSpecForProvider {
  /**
   * List of one or more availability zones for the group. Used for EC2-Classic, attaching a network interface via id from a launch template and default subnets when not specified with vpc_zone_identifier argument. Conflicts with vpc_zone_identifier.
   *
   * @schema AutoscalingGroupSpecForProvider#availabilityZones
   */
  readonly availabilityZones?: string[];

  /**
   * Whether capacity rebalance is enabled. Otherwise, capacity rebalance is disabled.
   *
   * @schema AutoscalingGroupSpecForProvider#capacityRebalance
   */
  readonly capacityRebalance?: boolean;

  /**
   * Reserved.
   *
   * @schema AutoscalingGroupSpecForProvider#context
   */
  readonly context?: string;

  /**
   * Amount of time, in seconds, after a scaling activity completes before another scaling activity can start.
   *
   * @schema AutoscalingGroupSpecForProvider#defaultCooldown
   */
  readonly defaultCooldown?: number;

  /**
   * Amount of time, in seconds, until a newly launched instance can contribute to the Amazon CloudWatch metrics. This delay lets an instance finish initializing before Amazon EC2 Auto Scaling aggregates instance metrics, resulting in more reliable usage data. Set this value equal to the amount of time that it takes for resource consumption to become stable after an instance reaches the InService state. (See Set the default instance warmup for an Auto Scaling group)
   *
   * @schema AutoscalingGroupSpecForProvider#defaultInstanceWarmup
   */
  readonly defaultInstanceWarmup?: number;

  /**
   * Number of Amazon EC2 instances that should be running in the group. (See also Waiting for Capacity below.)
   *
   * @schema AutoscalingGroupSpecForProvider#desiredCapacity
   */
  readonly desiredCapacity?: number;

  /**
   * The unit of measurement for the value specified for desired_capacity. Supported for attribute-based instance type selection only. Valid values: "units", "vcpu", "memory-mib".
   *
   * @schema AutoscalingGroupSpecForProvider#desiredCapacityType
   */
  readonly desiredCapacityType?: string;

  /**
   * List of metrics to collect. The allowed values are defined by the underlying AWS API.
   *
   * @schema AutoscalingGroupSpecForProvider#enabledMetrics
   */
  readonly enabledMetrics?: string[];

  /**
   * Allows deleting the Auto Scaling Group without waiting for all instances in the pool to terminate.  You can force an Auto Scaling Group to delete even if it's in the process of scaling a resource.  This bypasses that behavior and potentially leaves resources dangling.
   *
   * @schema AutoscalingGroupSpecForProvider#forceDelete
   */
  readonly forceDelete?: boolean;

  /**
   * If this block is configured, add a Warm Pool to the specified Auto Scaling group. Defined below
   *
   * @schema AutoscalingGroupSpecForProvider#forceDeleteWarmPool
   */
  readonly forceDeleteWarmPool?: boolean;

  /**
   * Time (in seconds) after instance comes into service before checking health.
   *
   * @schema AutoscalingGroupSpecForProvider#healthCheckGracePeriod
   */
  readonly healthCheckGracePeriod?: number;

  /**
   * "EC2" or "ELB". Controls how health checking is done.
   *
   * @schema AutoscalingGroupSpecForProvider#healthCheckType
   */
  readonly healthCheckType?: string;

  /**
   * One or more Lifecycle Hooks to attach to the Auto Scaling Group before instances are launched. The syntax is exactly the same as the separate aws_autoscaling_lifecycle_hook resource, without the autoscaling_group_name attribute. Please note that this will only work when creating a new Auto Scaling Group. For all other use-cases, please use aws_autoscaling_lifecycle_hook resource.
   *
   * @schema AutoscalingGroupSpecForProvider#initialLifecycleHook
   */
  readonly initialLifecycleHook?: AutoscalingGroupSpecForProviderInitialLifecycleHook[];

  /**
   * If this block is configured, start an Instance Refresh when this Auto Scaling Group is updated. Defined below.
   *
   * @schema AutoscalingGroupSpecForProvider#instanceRefresh
   */
  readonly instanceRefresh?: AutoscalingGroupSpecForProviderInstanceRefresh[];

  /**
   * Name of the launch configuration to use.
   *
   * @schema AutoscalingGroupSpecForProvider#launchConfiguration
   */
  readonly launchConfiguration?: string;

  /**
   * Reference to a LaunchConfiguration in autoscaling to populate launchConfiguration.
   *
   * @schema AutoscalingGroupSpecForProvider#launchConfigurationRef
   */
  readonly launchConfigurationRef?: AutoscalingGroupSpecForProviderLaunchConfigurationRef;

  /**
   * Selector for a LaunchConfiguration in autoscaling to populate launchConfiguration.
   *
   * @schema AutoscalingGroupSpecForProvider#launchConfigurationSelector
   */
  readonly launchConfigurationSelector?: AutoscalingGroupSpecForProviderLaunchConfigurationSelector;

  /**
   * Nested argument with Launch template specification to use to launch instances. See Launch Template below for more details.
   *
   * @schema AutoscalingGroupSpecForProvider#launchTemplate
   */
  readonly launchTemplate?: AutoscalingGroupSpecForProviderLaunchTemplate[];

  /**
   * Maximum amount of time, in seconds, that an instance can be in service, values must be either equal to 0 or between 86400 and 31536000 seconds.
   *
   * @schema AutoscalingGroupSpecForProvider#maxInstanceLifetime
   */
  readonly maxInstanceLifetime?: number;

  /**
   * Maximum size of the Auto Scaling Group.
   *
   * @schema AutoscalingGroupSpecForProvider#maxSize
   */
  readonly maxSize?: number;

  /**
   * Granularity to associate with the metrics to collect. The only valid value is 1Minute. Default is 1Minute.
   *
   * @default 1Minute.
   * @schema AutoscalingGroupSpecForProvider#metricsGranularity
   */
  readonly metricsGranularity?: string;

  /**
   * Updates will not wait on ELB instance number changes. (See also Waiting for Capacity below.)
   *
   * @schema AutoscalingGroupSpecForProvider#minElbCapacity
   */
  readonly minElbCapacity?: number;

  /**
   * Minimum size of the Auto Scaling Group. (See also Waiting for Capacity below.)
   *
   * @schema AutoscalingGroupSpecForProvider#minSize
   */
  readonly minSize?: number;

  /**
   * Configuration block containing settings to define launch targets for Auto Scaling groups. See Mixed Instances Policy below for more details.
   *
   * @schema AutoscalingGroupSpecForProvider#mixedInstancesPolicy
   */
  readonly mixedInstancesPolicy?: AutoscalingGroupSpecForProviderMixedInstancesPolicy[];

  /**
   * Name of the placement group into which you'll launch your instances, if any.
   *
   * @schema AutoscalingGroupSpecForProvider#placementGroup
   */
  readonly placementGroup?: string;

  /**
   * Reference to a PlacementGroup in ec2 to populate placementGroup.
   *
   * @schema AutoscalingGroupSpecForProvider#placementGroupRef
   */
  readonly placementGroupRef?: AutoscalingGroupSpecForProviderPlacementGroupRef;

  /**
   * Selector for a PlacementGroup in ec2 to populate placementGroup.
   *
   * @schema AutoscalingGroupSpecForProvider#placementGroupSelector
   */
  readonly placementGroupSelector?: AutoscalingGroupSpecForProviderPlacementGroupSelector;

  /**
   * in protection in the Amazon EC2 Auto Scaling User Guide.
   *
   * @schema AutoscalingGroupSpecForProvider#protectFromScaleIn
   */
  readonly protectFromScaleIn?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AutoscalingGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * linked role that the ASG will use to call other AWS services
   *
   * @schema AutoscalingGroupSpecForProvider#serviceLinkedRoleArn
   */
  readonly serviceLinkedRoleArn?: string;

  /**
   * Reference to a Role in iam to populate serviceLinkedRoleArn.
   *
   * @schema AutoscalingGroupSpecForProvider#serviceLinkedRoleArnRef
   */
  readonly serviceLinkedRoleArnRef?: AutoscalingGroupSpecForProviderServiceLinkedRoleArnRef;

  /**
   * Selector for a Role in iam to populate serviceLinkedRoleArn.
   *
   * @schema AutoscalingGroupSpecForProvider#serviceLinkedRoleArnSelector
   */
  readonly serviceLinkedRoleArnSelector?: AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelector;

  /**
   * List of processes to suspend for the Auto Scaling Group. The allowed values are Launch, Terminate, HealthCheck, ReplaceUnhealthy, AZRebalance, AlarmNotification, ScheduledActions, AddToLoadBalancer, InstanceRefresh. Note that if you suspend either the Launch or Terminate process types, it can prevent your Auto Scaling Group from functioning properly.
   *
   * @schema AutoscalingGroupSpecForProvider#suspendedProcesses
   */
  readonly suspendedProcesses?: string[];

  /**
   * Configuration block(s) containing resource tags. Conflicts with tags. See Tag below for more details.
   *
   * @schema AutoscalingGroupSpecForProvider#tag
   */
  readonly tag?: AutoscalingGroupSpecForProviderTag[];

  /**
   * Key-value map of resource tags.
   *
   * @schema AutoscalingGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string }[];

  /**
   * List of policies to decide how the instances in the Auto Scaling Group should be terminated. The allowed values are OldestInstance, NewestInstance, OldestLaunchConfiguration, ClosestToNextInstanceHour, OldestLaunchTemplate, AllocationStrategy, Default. Additionally, the ARN of a Lambda function can be specified for custom termination policies.
   *
   * @schema AutoscalingGroupSpecForProvider#terminationPolicies
   */
  readonly terminationPolicies?: string[];

  /**
   * List of subnet IDs to launch resources in. Subnets automatically determine which availability zones the group will reside. Conflicts with availability_zones.
   *
   * @schema AutoscalingGroupSpecForProvider#vpcZoneIdentifier
   */
  readonly vpcZoneIdentifier?: string[];

  /**
   * References to Subnet in ec2 to populate vpcZoneIdentifier.
   *
   * @schema AutoscalingGroupSpecForProvider#vpcZoneIdentifierRefs
   */
  readonly vpcZoneIdentifierRefs?: AutoscalingGroupSpecForProviderVpcZoneIdentifierRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate vpcZoneIdentifier.
   *
   * @schema AutoscalingGroupSpecForProvider#vpcZoneIdentifierSelector
   */
  readonly vpcZoneIdentifierSelector?: AutoscalingGroupSpecForProviderVpcZoneIdentifierSelector;

  /**
   * (See also Waiting for Capacity below.
   *
   * @schema AutoscalingGroupSpecForProvider#waitForCapacityTimeout
   */
  readonly waitForCapacityTimeout?: string;

  /**
   * (Takes precedence over min_elb_capacity behavior.) (See also Waiting for Capacity below.)
   *
   * @schema AutoscalingGroupSpecForProvider#waitForElbCapacity
   */
  readonly waitForElbCapacity?: number;

  /**
   * If this block is configured, add a Warm Pool to the specified Auto Scaling group. Defined below
   *
   * @schema AutoscalingGroupSpecForProvider#warmPool
   */
  readonly warmPool?: AutoscalingGroupSpecForProviderWarmPool[];

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProvider(obj: AutoscalingGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityZones': obj.availabilityZones?.map(y => y),
    'capacityRebalance': obj.capacityRebalance,
    'context': obj.context,
    'defaultCooldown': obj.defaultCooldown,
    'defaultInstanceWarmup': obj.defaultInstanceWarmup,
    'desiredCapacity': obj.desiredCapacity,
    'desiredCapacityType': obj.desiredCapacityType,
    'enabledMetrics': obj.enabledMetrics?.map(y => y),
    'forceDelete': obj.forceDelete,
    'forceDeleteWarmPool': obj.forceDeleteWarmPool,
    'healthCheckGracePeriod': obj.healthCheckGracePeriod,
    'healthCheckType': obj.healthCheckType,
    'initialLifecycleHook': obj.initialLifecycleHook?.map(y => toJson_AutoscalingGroupSpecForProviderInitialLifecycleHook(y)),
    'instanceRefresh': obj.instanceRefresh?.map(y => toJson_AutoscalingGroupSpecForProviderInstanceRefresh(y)),
    'launchConfiguration': obj.launchConfiguration,
    'launchConfigurationRef': toJson_AutoscalingGroupSpecForProviderLaunchConfigurationRef(obj.launchConfigurationRef),
    'launchConfigurationSelector': toJson_AutoscalingGroupSpecForProviderLaunchConfigurationSelector(obj.launchConfigurationSelector),
    'launchTemplate': obj.launchTemplate?.map(y => toJson_AutoscalingGroupSpecForProviderLaunchTemplate(y)),
    'maxInstanceLifetime': obj.maxInstanceLifetime,
    'maxSize': obj.maxSize,
    'metricsGranularity': obj.metricsGranularity,
    'minElbCapacity': obj.minElbCapacity,
    'minSize': obj.minSize,
    'mixedInstancesPolicy': obj.mixedInstancesPolicy?.map(y => toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicy(y)),
    'placementGroup': obj.placementGroup,
    'placementGroupRef': toJson_AutoscalingGroupSpecForProviderPlacementGroupRef(obj.placementGroupRef),
    'placementGroupSelector': toJson_AutoscalingGroupSpecForProviderPlacementGroupSelector(obj.placementGroupSelector),
    'protectFromScaleIn': obj.protectFromScaleIn,
    'region': obj.region,
    'serviceLinkedRoleArn': obj.serviceLinkedRoleArn,
    'serviceLinkedRoleArnRef': toJson_AutoscalingGroupSpecForProviderServiceLinkedRoleArnRef(obj.serviceLinkedRoleArnRef),
    'serviceLinkedRoleArnSelector': toJson_AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelector(obj.serviceLinkedRoleArnSelector),
    'suspendedProcesses': obj.suspendedProcesses?.map(y => y),
    'tag': obj.tag?.map(y => toJson_AutoscalingGroupSpecForProviderTag(y)),
    'tags': obj.tags?.map(y => ((y) === undefined) ? undefined : (Object.entries(y).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {}))),
    'terminationPolicies': obj.terminationPolicies?.map(y => y),
    'vpcZoneIdentifier': obj.vpcZoneIdentifier?.map(y => y),
    'vpcZoneIdentifierRefs': obj.vpcZoneIdentifierRefs?.map(y => toJson_AutoscalingGroupSpecForProviderVpcZoneIdentifierRefs(y)),
    'vpcZoneIdentifierSelector': toJson_AutoscalingGroupSpecForProviderVpcZoneIdentifierSelector(obj.vpcZoneIdentifierSelector),
    'waitForCapacityTimeout': obj.waitForCapacityTimeout,
    'waitForElbCapacity': obj.waitForElbCapacity,
    'warmPool': obj.warmPool?.map(y => toJson_AutoscalingGroupSpecForProviderWarmPool(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AutoscalingGroupSpecInitProvider
 */
export interface AutoscalingGroupSpecInitProvider {
  /**
   * List of one or more availability zones for the group. Used for EC2-Classic, attaching a network interface via id from a launch template and default subnets when not specified with vpc_zone_identifier argument. Conflicts with vpc_zone_identifier.
   *
   * @schema AutoscalingGroupSpecInitProvider#availabilityZones
   */
  readonly availabilityZones?: string[];

  /**
   * Whether capacity rebalance is enabled. Otherwise, capacity rebalance is disabled.
   *
   * @schema AutoscalingGroupSpecInitProvider#capacityRebalance
   */
  readonly capacityRebalance?: boolean;

  /**
   * Reserved.
   *
   * @schema AutoscalingGroupSpecInitProvider#context
   */
  readonly context?: string;

  /**
   * Amount of time, in seconds, after a scaling activity completes before another scaling activity can start.
   *
   * @schema AutoscalingGroupSpecInitProvider#defaultCooldown
   */
  readonly defaultCooldown?: number;

  /**
   * Amount of time, in seconds, until a newly launched instance can contribute to the Amazon CloudWatch metrics. This delay lets an instance finish initializing before Amazon EC2 Auto Scaling aggregates instance metrics, resulting in more reliable usage data. Set this value equal to the amount of time that it takes for resource consumption to become stable after an instance reaches the InService state. (See Set the default instance warmup for an Auto Scaling group)
   *
   * @schema AutoscalingGroupSpecInitProvider#defaultInstanceWarmup
   */
  readonly defaultInstanceWarmup?: number;

  /**
   * Number of Amazon EC2 instances that should be running in the group. (See also Waiting for Capacity below.)
   *
   * @schema AutoscalingGroupSpecInitProvider#desiredCapacity
   */
  readonly desiredCapacity?: number;

  /**
   * The unit of measurement for the value specified for desired_capacity. Supported for attribute-based instance type selection only. Valid values: "units", "vcpu", "memory-mib".
   *
   * @schema AutoscalingGroupSpecInitProvider#desiredCapacityType
   */
  readonly desiredCapacityType?: string;

  /**
   * List of metrics to collect. The allowed values are defined by the underlying AWS API.
   *
   * @schema AutoscalingGroupSpecInitProvider#enabledMetrics
   */
  readonly enabledMetrics?: string[];

  /**
   * Allows deleting the Auto Scaling Group without waiting for all instances in the pool to terminate.  You can force an Auto Scaling Group to delete even if it's in the process of scaling a resource.  This bypasses that behavior and potentially leaves resources dangling.
   *
   * @schema AutoscalingGroupSpecInitProvider#forceDelete
   */
  readonly forceDelete?: boolean;

  /**
   * If this block is configured, add a Warm Pool to the specified Auto Scaling group. Defined below
   *
   * @schema AutoscalingGroupSpecInitProvider#forceDeleteWarmPool
   */
  readonly forceDeleteWarmPool?: boolean;

  /**
   * Time (in seconds) after instance comes into service before checking health.
   *
   * @schema AutoscalingGroupSpecInitProvider#healthCheckGracePeriod
   */
  readonly healthCheckGracePeriod?: number;

  /**
   * "EC2" or "ELB". Controls how health checking is done.
   *
   * @schema AutoscalingGroupSpecInitProvider#healthCheckType
   */
  readonly healthCheckType?: string;

  /**
   * One or more Lifecycle Hooks to attach to the Auto Scaling Group before instances are launched. The syntax is exactly the same as the separate aws_autoscaling_lifecycle_hook resource, without the autoscaling_group_name attribute. Please note that this will only work when creating a new Auto Scaling Group. For all other use-cases, please use aws_autoscaling_lifecycle_hook resource.
   *
   * @schema AutoscalingGroupSpecInitProvider#initialLifecycleHook
   */
  readonly initialLifecycleHook?: AutoscalingGroupSpecInitProviderInitialLifecycleHook[];

  /**
   * If this block is configured, start an Instance Refresh when this Auto Scaling Group is updated. Defined below.
   *
   * @schema AutoscalingGroupSpecInitProvider#instanceRefresh
   */
  readonly instanceRefresh?: AutoscalingGroupSpecInitProviderInstanceRefresh[];

  /**
   * Nested argument with Launch template specification to use to launch instances. See Launch Template below for more details.
   *
   * @schema AutoscalingGroupSpecInitProvider#launchTemplate
   */
  readonly launchTemplate?: AutoscalingGroupSpecInitProviderLaunchTemplate[];

  /**
   * Maximum amount of time, in seconds, that an instance can be in service, values must be either equal to 0 or between 86400 and 31536000 seconds.
   *
   * @schema AutoscalingGroupSpecInitProvider#maxInstanceLifetime
   */
  readonly maxInstanceLifetime?: number;

  /**
   * Maximum size of the Auto Scaling Group.
   *
   * @schema AutoscalingGroupSpecInitProvider#maxSize
   */
  readonly maxSize?: number;

  /**
   * Granularity to associate with the metrics to collect. The only valid value is 1Minute. Default is 1Minute.
   *
   * @default 1Minute.
   * @schema AutoscalingGroupSpecInitProvider#metricsGranularity
   */
  readonly metricsGranularity?: string;

  /**
   * Updates will not wait on ELB instance number changes. (See also Waiting for Capacity below.)
   *
   * @schema AutoscalingGroupSpecInitProvider#minElbCapacity
   */
  readonly minElbCapacity?: number;

  /**
   * Minimum size of the Auto Scaling Group. (See also Waiting for Capacity below.)
   *
   * @schema AutoscalingGroupSpecInitProvider#minSize
   */
  readonly minSize?: number;

  /**
   * Configuration block containing settings to define launch targets for Auto Scaling groups. See Mixed Instances Policy below for more details.
   *
   * @schema AutoscalingGroupSpecInitProvider#mixedInstancesPolicy
   */
  readonly mixedInstancesPolicy?: AutoscalingGroupSpecInitProviderMixedInstancesPolicy[];

  /**
   * in protection in the Amazon EC2 Auto Scaling User Guide.
   *
   * @schema AutoscalingGroupSpecInitProvider#protectFromScaleIn
   */
  readonly protectFromScaleIn?: boolean;

  /**
   * List of processes to suspend for the Auto Scaling Group. The allowed values are Launch, Terminate, HealthCheck, ReplaceUnhealthy, AZRebalance, AlarmNotification, ScheduledActions, AddToLoadBalancer, InstanceRefresh. Note that if you suspend either the Launch or Terminate process types, it can prevent your Auto Scaling Group from functioning properly.
   *
   * @schema AutoscalingGroupSpecInitProvider#suspendedProcesses
   */
  readonly suspendedProcesses?: string[];

  /**
   * Configuration block(s) containing resource tags. Conflicts with tags. See Tag below for more details.
   *
   * @schema AutoscalingGroupSpecInitProvider#tag
   */
  readonly tag?: AutoscalingGroupSpecInitProviderTag[];

  /**
   * Key-value map of resource tags.
   *
   * @schema AutoscalingGroupSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string }[];

  /**
   * List of policies to decide how the instances in the Auto Scaling Group should be terminated. The allowed values are OldestInstance, NewestInstance, OldestLaunchConfiguration, ClosestToNextInstanceHour, OldestLaunchTemplate, AllocationStrategy, Default. Additionally, the ARN of a Lambda function can be specified for custom termination policies.
   *
   * @schema AutoscalingGroupSpecInitProvider#terminationPolicies
   */
  readonly terminationPolicies?: string[];

  /**
   * (See also Waiting for Capacity below.
   *
   * @schema AutoscalingGroupSpecInitProvider#waitForCapacityTimeout
   */
  readonly waitForCapacityTimeout?: string;

  /**
   * (Takes precedence over min_elb_capacity behavior.) (See also Waiting for Capacity below.)
   *
   * @schema AutoscalingGroupSpecInitProvider#waitForElbCapacity
   */
  readonly waitForElbCapacity?: number;

  /**
   * If this block is configured, add a Warm Pool to the specified Auto Scaling group. Defined below
   *
   * @schema AutoscalingGroupSpecInitProvider#warmPool
   */
  readonly warmPool?: AutoscalingGroupSpecInitProviderWarmPool[];

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProvider(obj: AutoscalingGroupSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityZones': obj.availabilityZones?.map(y => y),
    'capacityRebalance': obj.capacityRebalance,
    'context': obj.context,
    'defaultCooldown': obj.defaultCooldown,
    'defaultInstanceWarmup': obj.defaultInstanceWarmup,
    'desiredCapacity': obj.desiredCapacity,
    'desiredCapacityType': obj.desiredCapacityType,
    'enabledMetrics': obj.enabledMetrics?.map(y => y),
    'forceDelete': obj.forceDelete,
    'forceDeleteWarmPool': obj.forceDeleteWarmPool,
    'healthCheckGracePeriod': obj.healthCheckGracePeriod,
    'healthCheckType': obj.healthCheckType,
    'initialLifecycleHook': obj.initialLifecycleHook?.map(y => toJson_AutoscalingGroupSpecInitProviderInitialLifecycleHook(y)),
    'instanceRefresh': obj.instanceRefresh?.map(y => toJson_AutoscalingGroupSpecInitProviderInstanceRefresh(y)),
    'launchTemplate': obj.launchTemplate?.map(y => toJson_AutoscalingGroupSpecInitProviderLaunchTemplate(y)),
    'maxInstanceLifetime': obj.maxInstanceLifetime,
    'maxSize': obj.maxSize,
    'metricsGranularity': obj.metricsGranularity,
    'minElbCapacity': obj.minElbCapacity,
    'minSize': obj.minSize,
    'mixedInstancesPolicy': obj.mixedInstancesPolicy?.map(y => toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicy(y)),
    'protectFromScaleIn': obj.protectFromScaleIn,
    'suspendedProcesses': obj.suspendedProcesses?.map(y => y),
    'tag': obj.tag?.map(y => toJson_AutoscalingGroupSpecInitProviderTag(y)),
    'tags': obj.tags?.map(y => ((y) === undefined) ? undefined : (Object.entries(y).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {}))),
    'terminationPolicies': obj.terminationPolicies?.map(y => y),
    'waitForCapacityTimeout': obj.waitForCapacityTimeout,
    'waitForElbCapacity': obj.waitForElbCapacity,
    'warmPool': obj.warmPool?.map(y => toJson_AutoscalingGroupSpecInitProviderWarmPool(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AutoscalingGroupSpecManagementPolicies
 */
export enum AutoscalingGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AutoscalingGroupSpecProviderConfigRef
 */
export interface AutoscalingGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AutoscalingGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AutoscalingGroupSpecProviderConfigRef#policy
   */
  readonly policy?: AutoscalingGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecProviderConfigRef(obj: AutoscalingGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AutoscalingGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AutoscalingGroupSpecPublishConnectionDetailsTo
 */
export interface AutoscalingGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AutoscalingGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AutoscalingGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AutoscalingGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AutoscalingGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AutoscalingGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecPublishConnectionDetailsTo(obj: AutoscalingGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AutoscalingGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AutoscalingGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AutoscalingGroupSpecWriteConnectionSecretToRef
 */
export interface AutoscalingGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AutoscalingGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AutoscalingGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecWriteConnectionSecretToRef(obj: AutoscalingGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderInitialLifecycleHook
 */
export interface AutoscalingGroupSpecForProviderInitialLifecycleHook {
  /**
   * @schema AutoscalingGroupSpecForProviderInitialLifecycleHook#defaultResult
   */
  readonly defaultResult?: string;

  /**
   * @schema AutoscalingGroupSpecForProviderInitialLifecycleHook#heartbeatTimeout
   */
  readonly heartbeatTimeout?: number;

  /**
   * @schema AutoscalingGroupSpecForProviderInitialLifecycleHook#lifecycleTransition
   */
  readonly lifecycleTransition?: string;

  /**
   * Name of the Auto Scaling Group. Conflicts with name_prefix.
   *
   * @schema AutoscalingGroupSpecForProviderInitialLifecycleHook#name
   */
  readonly name?: string;

  /**
   * @schema AutoscalingGroupSpecForProviderInitialLifecycleHook#notificationMetadata
   */
  readonly notificationMetadata?: string;

  /**
   * ARN for this Auto Scaling Group
   *
   * @schema AutoscalingGroupSpecForProviderInitialLifecycleHook#notificationTargetArn
   */
  readonly notificationTargetArn?: string;

  /**
   * ARN for this Auto Scaling Group
   *
   * @schema AutoscalingGroupSpecForProviderInitialLifecycleHook#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderInitialLifecycleHook' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderInitialLifecycleHook(obj: AutoscalingGroupSpecForProviderInitialLifecycleHook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultResult': obj.defaultResult,
    'heartbeatTimeout': obj.heartbeatTimeout,
    'lifecycleTransition': obj.lifecycleTransition,
    'name': obj.name,
    'notificationMetadata': obj.notificationMetadata,
    'notificationTargetArn': obj.notificationTargetArn,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderInstanceRefresh
 */
export interface AutoscalingGroupSpecForProviderInstanceRefresh {
  /**
   * Override default parameters for Instance Refresh.
   *
   * @schema AutoscalingGroupSpecForProviderInstanceRefresh#preferences
   */
  readonly preferences?: AutoscalingGroupSpecForProviderInstanceRefreshPreferences[];

  /**
   * Strategy to use for instance refresh. The only allowed value is Rolling. See StartInstanceRefresh Action for more information.
   *
   * @schema AutoscalingGroupSpecForProviderInstanceRefresh#strategy
   */
  readonly strategy?: string;

  /**
   * Set of additional property names that will trigger an Instance Refresh. A refresh will always be triggered by a change in any of launch_configuration, launch_template, or mixed_instances_policy.
   *
   * @schema AutoscalingGroupSpecForProviderInstanceRefresh#triggers
   */
  readonly triggers?: string[];

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderInstanceRefresh' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderInstanceRefresh(obj: AutoscalingGroupSpecForProviderInstanceRefresh | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferences': obj.preferences?.map(y => toJson_AutoscalingGroupSpecForProviderInstanceRefreshPreferences(y)),
    'strategy': obj.strategy,
    'triggers': obj.triggers?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LaunchConfiguration in autoscaling to populate launchConfiguration.
 *
 * @schema AutoscalingGroupSpecForProviderLaunchConfigurationRef
 */
export interface AutoscalingGroupSpecForProviderLaunchConfigurationRef {
  /**
   * Name of the referenced object.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchConfigurationRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchConfigurationRef#policy
   */
  readonly policy?: AutoscalingGroupSpecForProviderLaunchConfigurationRefPolicy;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderLaunchConfigurationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderLaunchConfigurationRef(obj: AutoscalingGroupSpecForProviderLaunchConfigurationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AutoscalingGroupSpecForProviderLaunchConfigurationRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LaunchConfiguration in autoscaling to populate launchConfiguration.
 *
 * @schema AutoscalingGroupSpecForProviderLaunchConfigurationSelector
 */
export interface AutoscalingGroupSpecForProviderLaunchConfigurationSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchConfigurationSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchConfigurationSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchConfigurationSelector#policy
   */
  readonly policy?: AutoscalingGroupSpecForProviderLaunchConfigurationSelectorPolicy;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderLaunchConfigurationSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderLaunchConfigurationSelector(obj: AutoscalingGroupSpecForProviderLaunchConfigurationSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AutoscalingGroupSpecForProviderLaunchConfigurationSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderLaunchTemplate
 */
export interface AutoscalingGroupSpecForProviderLaunchTemplate {
  /**
   * ID of the launch template. Conflicts with name.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchTemplate#id
   */
  readonly id?: string;

  /**
   * Reference to a LaunchTemplate in ec2 to populate id.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchTemplate#idRef
   */
  readonly idRef?: AutoscalingGroupSpecForProviderLaunchTemplateIdRef;

  /**
   * Selector for a LaunchTemplate in ec2 to populate id.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchTemplate#idSelector
   */
  readonly idSelector?: AutoscalingGroupSpecForProviderLaunchTemplateIdSelector;

  /**
   * Name of the launch template. Conflicts with id.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchTemplate#name
   */
  readonly name?: string;

  /**
   * Template version. Can be version number, $Latest, or $Default. (Default: $Default).
   *
   * @schema AutoscalingGroupSpecForProviderLaunchTemplate#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderLaunchTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderLaunchTemplate(obj: AutoscalingGroupSpecForProviderLaunchTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'idRef': toJson_AutoscalingGroupSpecForProviderLaunchTemplateIdRef(obj.idRef),
    'idSelector': toJson_AutoscalingGroupSpecForProviderLaunchTemplateIdSelector(obj.idSelector),
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicy
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicy {
  /**
   * Nested argument containing settings on how to mix on-demand and Spot instances in the Auto Scaling group. Defined below.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicy#instancesDistribution
   */
  readonly instancesDistribution?: AutoscalingGroupSpecForProviderMixedInstancesPolicyInstancesDistribution[];

  /**
   * Nested argument containing launch template settings along with the overrides to specify multiple instance types and weights. Defined below.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicy#launchTemplate
   */
  readonly launchTemplate?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplate[];

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicy(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instancesDistribution': obj.instancesDistribution?.map(y => toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyInstancesDistribution(y)),
    'launchTemplate': obj.launchTemplate?.map(y => toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplate(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a PlacementGroup in ec2 to populate placementGroup.
 *
 * @schema AutoscalingGroupSpecForProviderPlacementGroupRef
 */
export interface AutoscalingGroupSpecForProviderPlacementGroupRef {
  /**
   * Name of the referenced object.
   *
   * @schema AutoscalingGroupSpecForProviderPlacementGroupRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AutoscalingGroupSpecForProviderPlacementGroupRef#policy
   */
  readonly policy?: AutoscalingGroupSpecForProviderPlacementGroupRefPolicy;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderPlacementGroupRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderPlacementGroupRef(obj: AutoscalingGroupSpecForProviderPlacementGroupRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AutoscalingGroupSpecForProviderPlacementGroupRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a PlacementGroup in ec2 to populate placementGroup.
 *
 * @schema AutoscalingGroupSpecForProviderPlacementGroupSelector
 */
export interface AutoscalingGroupSpecForProviderPlacementGroupSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AutoscalingGroupSpecForProviderPlacementGroupSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AutoscalingGroupSpecForProviderPlacementGroupSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AutoscalingGroupSpecForProviderPlacementGroupSelector#policy
   */
  readonly policy?: AutoscalingGroupSpecForProviderPlacementGroupSelectorPolicy;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderPlacementGroupSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderPlacementGroupSelector(obj: AutoscalingGroupSpecForProviderPlacementGroupSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AutoscalingGroupSpecForProviderPlacementGroupSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate serviceLinkedRoleArn.
 *
 * @schema AutoscalingGroupSpecForProviderServiceLinkedRoleArnRef
 */
export interface AutoscalingGroupSpecForProviderServiceLinkedRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema AutoscalingGroupSpecForProviderServiceLinkedRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AutoscalingGroupSpecForProviderServiceLinkedRoleArnRef#policy
   */
  readonly policy?: AutoscalingGroupSpecForProviderServiceLinkedRoleArnRefPolicy;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderServiceLinkedRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderServiceLinkedRoleArnRef(obj: AutoscalingGroupSpecForProviderServiceLinkedRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AutoscalingGroupSpecForProviderServiceLinkedRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate serviceLinkedRoleArn.
 *
 * @schema AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelector
 */
export interface AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelector#policy
   */
  readonly policy?: AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelector(obj: AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderTag
 */
export interface AutoscalingGroupSpecForProviderTag {
  /**
   * Key
   *
   * @schema AutoscalingGroupSpecForProviderTag#key
   */
  readonly key?: string;

  /**
   * Enables propagation of the tag to Amazon EC2 instances launched via this ASG
   *
   * @schema AutoscalingGroupSpecForProviderTag#propagateAtLaunch
   */
  readonly propagateAtLaunch?: boolean;

  /**
   * Value
   *
   * @schema AutoscalingGroupSpecForProviderTag#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderTag(obj: AutoscalingGroupSpecForProviderTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'propagateAtLaunch': obj.propagateAtLaunch,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema AutoscalingGroupSpecForProviderVpcZoneIdentifierRefs
 */
export interface AutoscalingGroupSpecForProviderVpcZoneIdentifierRefs {
  /**
   * Name of the referenced object.
   *
   * @schema AutoscalingGroupSpecForProviderVpcZoneIdentifierRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AutoscalingGroupSpecForProviderVpcZoneIdentifierRefs#policy
   */
  readonly policy?: AutoscalingGroupSpecForProviderVpcZoneIdentifierRefsPolicy;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderVpcZoneIdentifierRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderVpcZoneIdentifierRefs(obj: AutoscalingGroupSpecForProviderVpcZoneIdentifierRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AutoscalingGroupSpecForProviderVpcZoneIdentifierRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate vpcZoneIdentifier.
 *
 * @schema AutoscalingGroupSpecForProviderVpcZoneIdentifierSelector
 */
export interface AutoscalingGroupSpecForProviderVpcZoneIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AutoscalingGroupSpecForProviderVpcZoneIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AutoscalingGroupSpecForProviderVpcZoneIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AutoscalingGroupSpecForProviderVpcZoneIdentifierSelector#policy
   */
  readonly policy?: AutoscalingGroupSpecForProviderVpcZoneIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderVpcZoneIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderVpcZoneIdentifierSelector(obj: AutoscalingGroupSpecForProviderVpcZoneIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AutoscalingGroupSpecForProviderVpcZoneIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderWarmPool
 */
export interface AutoscalingGroupSpecForProviderWarmPool {
  /**
   * Whether instances in the Auto Scaling group can be returned to the warm pool on scale in. The default is to terminate instances in the Auto Scaling group when the group scales in.
   *
   * @schema AutoscalingGroupSpecForProviderWarmPool#instanceReusePolicy
   */
  readonly instanceReusePolicy?: AutoscalingGroupSpecForProviderWarmPoolInstanceReusePolicy[];

  /**
   * Total maximum number of instances that are allowed to be in the warm pool or in any state except Terminated for the Auto Scaling group.
   *
   * @schema AutoscalingGroupSpecForProviderWarmPool#maxGroupPreparedCapacity
   */
  readonly maxGroupPreparedCapacity?: number;

  /**
   * Minimum size of the Auto Scaling Group. (See also Waiting for Capacity below.)
   *
   * @schema AutoscalingGroupSpecForProviderWarmPool#minSize
   */
  readonly minSize?: number;

  /**
   * Sets the instance state to transition to after the lifecycle hooks finish. Valid values are: Stopped (default), Running or Hibernated.
   *
   * @schema AutoscalingGroupSpecForProviderWarmPool#poolState
   */
  readonly poolState?: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderWarmPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderWarmPool(obj: AutoscalingGroupSpecForProviderWarmPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceReusePolicy': obj.instanceReusePolicy?.map(y => toJson_AutoscalingGroupSpecForProviderWarmPoolInstanceReusePolicy(y)),
    'maxGroupPreparedCapacity': obj.maxGroupPreparedCapacity,
    'minSize': obj.minSize,
    'poolState': obj.poolState,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderInitialLifecycleHook
 */
export interface AutoscalingGroupSpecInitProviderInitialLifecycleHook {
  /**
   * @schema AutoscalingGroupSpecInitProviderInitialLifecycleHook#defaultResult
   */
  readonly defaultResult?: string;

  /**
   * @schema AutoscalingGroupSpecInitProviderInitialLifecycleHook#heartbeatTimeout
   */
  readonly heartbeatTimeout?: number;

  /**
   * @schema AutoscalingGroupSpecInitProviderInitialLifecycleHook#lifecycleTransition
   */
  readonly lifecycleTransition?: string;

  /**
   * Name of the Auto Scaling Group. Conflicts with name_prefix.
   *
   * @schema AutoscalingGroupSpecInitProviderInitialLifecycleHook#name
   */
  readonly name?: string;

  /**
   * @schema AutoscalingGroupSpecInitProviderInitialLifecycleHook#notificationMetadata
   */
  readonly notificationMetadata?: string;

  /**
   * ARN for this Auto Scaling Group
   *
   * @schema AutoscalingGroupSpecInitProviderInitialLifecycleHook#notificationTargetArn
   */
  readonly notificationTargetArn?: string;

  /**
   * ARN for this Auto Scaling Group
   *
   * @schema AutoscalingGroupSpecInitProviderInitialLifecycleHook#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderInitialLifecycleHook' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderInitialLifecycleHook(obj: AutoscalingGroupSpecInitProviderInitialLifecycleHook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultResult': obj.defaultResult,
    'heartbeatTimeout': obj.heartbeatTimeout,
    'lifecycleTransition': obj.lifecycleTransition,
    'name': obj.name,
    'notificationMetadata': obj.notificationMetadata,
    'notificationTargetArn': obj.notificationTargetArn,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderInstanceRefresh
 */
export interface AutoscalingGroupSpecInitProviderInstanceRefresh {
  /**
   * Override default parameters for Instance Refresh.
   *
   * @schema AutoscalingGroupSpecInitProviderInstanceRefresh#preferences
   */
  readonly preferences?: AutoscalingGroupSpecInitProviderInstanceRefreshPreferences[];

  /**
   * Strategy to use for instance refresh. The only allowed value is Rolling. See StartInstanceRefresh Action for more information.
   *
   * @schema AutoscalingGroupSpecInitProviderInstanceRefresh#strategy
   */
  readonly strategy?: string;

  /**
   * Set of additional property names that will trigger an Instance Refresh. A refresh will always be triggered by a change in any of launch_configuration, launch_template, or mixed_instances_policy.
   *
   * @schema AutoscalingGroupSpecInitProviderInstanceRefresh#triggers
   */
  readonly triggers?: string[];

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderInstanceRefresh' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderInstanceRefresh(obj: AutoscalingGroupSpecInitProviderInstanceRefresh | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferences': obj.preferences?.map(y => toJson_AutoscalingGroupSpecInitProviderInstanceRefreshPreferences(y)),
    'strategy': obj.strategy,
    'triggers': obj.triggers?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderLaunchTemplate
 */
export interface AutoscalingGroupSpecInitProviderLaunchTemplate {
  /**
   * Name of the launch template. Conflicts with id.
   *
   * @schema AutoscalingGroupSpecInitProviderLaunchTemplate#name
   */
  readonly name?: string;

  /**
   * Template version. Can be version number, $Latest, or $Default. (Default: $Default).
   *
   * @schema AutoscalingGroupSpecInitProviderLaunchTemplate#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderLaunchTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderLaunchTemplate(obj: AutoscalingGroupSpecInitProviderLaunchTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicy
 */
export interface AutoscalingGroupSpecInitProviderMixedInstancesPolicy {
  /**
   * Nested argument containing settings on how to mix on-demand and Spot instances in the Auto Scaling group. Defined below.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicy#instancesDistribution
   */
  readonly instancesDistribution?: AutoscalingGroupSpecInitProviderMixedInstancesPolicyInstancesDistribution[];

  /**
   * Nested argument containing launch template settings along with the overrides to specify multiple instance types and weights. Defined below.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicy#launchTemplate
   */
  readonly launchTemplate?: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplate[];

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderMixedInstancesPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicy(obj: AutoscalingGroupSpecInitProviderMixedInstancesPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instancesDistribution': obj.instancesDistribution?.map(y => toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyInstancesDistribution(y)),
    'launchTemplate': obj.launchTemplate?.map(y => toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplate(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderTag
 */
export interface AutoscalingGroupSpecInitProviderTag {
  /**
   * Key
   *
   * @schema AutoscalingGroupSpecInitProviderTag#key
   */
  readonly key?: string;

  /**
   * Enables propagation of the tag to Amazon EC2 instances launched via this ASG
   *
   * @schema AutoscalingGroupSpecInitProviderTag#propagateAtLaunch
   */
  readonly propagateAtLaunch?: boolean;

  /**
   * Value
   *
   * @schema AutoscalingGroupSpecInitProviderTag#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderTag(obj: AutoscalingGroupSpecInitProviderTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'propagateAtLaunch': obj.propagateAtLaunch,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderWarmPool
 */
export interface AutoscalingGroupSpecInitProviderWarmPool {
  /**
   * Whether instances in the Auto Scaling group can be returned to the warm pool on scale in. The default is to terminate instances in the Auto Scaling group when the group scales in.
   *
   * @schema AutoscalingGroupSpecInitProviderWarmPool#instanceReusePolicy
   */
  readonly instanceReusePolicy?: AutoscalingGroupSpecInitProviderWarmPoolInstanceReusePolicy[];

  /**
   * Total maximum number of instances that are allowed to be in the warm pool or in any state except Terminated for the Auto Scaling group.
   *
   * @schema AutoscalingGroupSpecInitProviderWarmPool#maxGroupPreparedCapacity
   */
  readonly maxGroupPreparedCapacity?: number;

  /**
   * Minimum size of the Auto Scaling Group. (See also Waiting for Capacity below.)
   *
   * @schema AutoscalingGroupSpecInitProviderWarmPool#minSize
   */
  readonly minSize?: number;

  /**
   * Sets the instance state to transition to after the lifecycle hooks finish. Valid values are: Stopped (default), Running or Hibernated.
   *
   * @schema AutoscalingGroupSpecInitProviderWarmPool#poolState
   */
  readonly poolState?: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderWarmPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderWarmPool(obj: AutoscalingGroupSpecInitProviderWarmPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceReusePolicy': obj.instanceReusePolicy?.map(y => toJson_AutoscalingGroupSpecInitProviderWarmPoolInstanceReusePolicy(y)),
    'maxGroupPreparedCapacity': obj.maxGroupPreparedCapacity,
    'minSize': obj.minSize,
    'poolState': obj.poolState,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AutoscalingGroupSpecProviderConfigRefPolicy
 */
export interface AutoscalingGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoscalingGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AutoscalingGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoscalingGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AutoscalingGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecProviderConfigRefPolicy(obj: AutoscalingGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AutoscalingGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface AutoscalingGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AutoscalingGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AutoscalingGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AutoscalingGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecPublishConnectionDetailsToConfigRef(obj: AutoscalingGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AutoscalingGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AutoscalingGroupSpecPublishConnectionDetailsToMetadata
 */
export interface AutoscalingGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AutoscalingGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AutoscalingGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AutoscalingGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecPublishConnectionDetailsToMetadata(obj: AutoscalingGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderInstanceRefreshPreferences
 */
export interface AutoscalingGroupSpecForProviderInstanceRefreshPreferences {
  /**
   * Automatically rollback if instance refresh fails. Defaults to false.
   *
   * @default false.
   * @schema AutoscalingGroupSpecForProviderInstanceRefreshPreferences#autoRollback
   */
  readonly autoRollback?: boolean;

  /**
   * Number of seconds to wait after a checkpoint. Defaults to 3600.
   *
   * @default 3600.
   * @schema AutoscalingGroupSpecForProviderInstanceRefreshPreferences#checkpointDelay
   */
  readonly checkpointDelay?: string;

  /**
   * List of percentages for each checkpoint. Values must be unique and in ascending order. To replace all instances, the final number must be 100.
   *
   * @schema AutoscalingGroupSpecForProviderInstanceRefreshPreferences#checkpointPercentages
   */
  readonly checkpointPercentages?: number[];

  /**
   * Number of seconds until a newly launched instance is configured and ready to use. Default behavior is to use the Auto Scaling Group's health check grace period.
   *
   * @schema AutoscalingGroupSpecForProviderInstanceRefreshPreferences#instanceWarmup
   */
  readonly instanceWarmup?: string;

  /**
   * Amount of capacity in the Auto Scaling group that must remain healthy during an instance refresh to allow the operation to continue, as a percentage of the desired capacity of the Auto Scaling group. Defaults to 90.
   *
   * @default 90.
   * @schema AutoscalingGroupSpecForProviderInstanceRefreshPreferences#minHealthyPercentage
   */
  readonly minHealthyPercentage?: number;

  /**
   * Replace instances that already have your desired configuration. Defaults to false.
   *
   * @default false.
   * @schema AutoscalingGroupSpecForProviderInstanceRefreshPreferences#skipMatching
   */
  readonly skipMatching?: boolean;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderInstanceRefreshPreferences' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderInstanceRefreshPreferences(obj: AutoscalingGroupSpecForProviderInstanceRefreshPreferences | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoRollback': obj.autoRollback,
    'checkpointDelay': obj.checkpointDelay,
    'checkpointPercentages': obj.checkpointPercentages?.map(y => y),
    'instanceWarmup': obj.instanceWarmup,
    'minHealthyPercentage': obj.minHealthyPercentage,
    'skipMatching': obj.skipMatching,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AutoscalingGroupSpecForProviderLaunchConfigurationRefPolicy
 */
export interface AutoscalingGroupSpecForProviderLaunchConfigurationRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchConfigurationRefPolicy#resolution
   */
  readonly resolution?: AutoscalingGroupSpecForProviderLaunchConfigurationRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchConfigurationRefPolicy#resolve
   */
  readonly resolve?: AutoscalingGroupSpecForProviderLaunchConfigurationRefPolicyResolve;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderLaunchConfigurationRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderLaunchConfigurationRefPolicy(obj: AutoscalingGroupSpecForProviderLaunchConfigurationRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AutoscalingGroupSpecForProviderLaunchConfigurationSelectorPolicy
 */
export interface AutoscalingGroupSpecForProviderLaunchConfigurationSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchConfigurationSelectorPolicy#resolution
   */
  readonly resolution?: AutoscalingGroupSpecForProviderLaunchConfigurationSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchConfigurationSelectorPolicy#resolve
   */
  readonly resolve?: AutoscalingGroupSpecForProviderLaunchConfigurationSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderLaunchConfigurationSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderLaunchConfigurationSelectorPolicy(obj: AutoscalingGroupSpecForProviderLaunchConfigurationSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LaunchTemplate in ec2 to populate id.
 *
 * @schema AutoscalingGroupSpecForProviderLaunchTemplateIdRef
 */
export interface AutoscalingGroupSpecForProviderLaunchTemplateIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchTemplateIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchTemplateIdRef#policy
   */
  readonly policy?: AutoscalingGroupSpecForProviderLaunchTemplateIdRefPolicy;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderLaunchTemplateIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderLaunchTemplateIdRef(obj: AutoscalingGroupSpecForProviderLaunchTemplateIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AutoscalingGroupSpecForProviderLaunchTemplateIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LaunchTemplate in ec2 to populate id.
 *
 * @schema AutoscalingGroupSpecForProviderLaunchTemplateIdSelector
 */
export interface AutoscalingGroupSpecForProviderLaunchTemplateIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchTemplateIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchTemplateIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchTemplateIdSelector#policy
   */
  readonly policy?: AutoscalingGroupSpecForProviderLaunchTemplateIdSelectorPolicy;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderLaunchTemplateIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderLaunchTemplateIdSelector(obj: AutoscalingGroupSpecForProviderLaunchTemplateIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AutoscalingGroupSpecForProviderLaunchTemplateIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyInstancesDistribution
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyInstancesDistribution {
  /**
   * Strategy to use when launching on-demand instances. Valid values: prioritized, lowest-price. Default: prioritized.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyInstancesDistribution#onDemandAllocationStrategy
   */
  readonly onDemandAllocationStrategy?: string;

  /**
   * Absolute minimum amount of desired capacity that must be fulfilled by on-demand instances. Default: 0.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyInstancesDistribution#onDemandBaseCapacity
   */
  readonly onDemandBaseCapacity?: number;

  /**
   * Percentage split between on-demand and Spot instances above the base on-demand capacity. Default: 100.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyInstancesDistribution#onDemandPercentageAboveBaseCapacity
   */
  readonly onDemandPercentageAboveBaseCapacity?: number;

  /**
   * How to allocate capacity across the Spot pools. Valid values: lowest-price, capacity-optimized, capacity-optimized-prioritized, and price-capacity-optimized. Default: lowest-price.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyInstancesDistribution#spotAllocationStrategy
   */
  readonly spotAllocationStrategy?: string;

  /**
   * Number of Spot pools per availability zone to allocate capacity. EC2 Auto Scaling selects the cheapest Spot pools and evenly allocates Spot capacity across the number of Spot pools that you specify. Only available with spot_allocation_strategy set to lowest-price. Otherwise it must be set to 0, if it has been defined before. Default: 2.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyInstancesDistribution#spotInstancePools
   */
  readonly spotInstancePools?: number;

  /**
   * Maximum price per unit hour that the user is willing to pay for the Spot instances. Default: an empty string which means the on-demand price.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyInstancesDistribution#spotMaxPrice
   */
  readonly spotMaxPrice?: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyInstancesDistribution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyInstancesDistribution(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyInstancesDistribution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'onDemandAllocationStrategy': obj.onDemandAllocationStrategy,
    'onDemandBaseCapacity': obj.onDemandBaseCapacity,
    'onDemandPercentageAboveBaseCapacity': obj.onDemandPercentageAboveBaseCapacity,
    'spotAllocationStrategy': obj.spotAllocationStrategy,
    'spotInstancePools': obj.spotInstancePools,
    'spotMaxPrice': obj.spotMaxPrice,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplate
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplate {
  /**
   * Nested argument defines the Launch Template. Defined below.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplate#launchTemplateSpecification
   */
  readonly launchTemplateSpecification?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification[];

  /**
   * List of nested arguments provides the ability to specify multiple instance types. This will override the same parameter in the launch template. For on-demand instances, Auto Scaling considers the order of preference of instance types to launch based on the order specified in the overrides list. Defined below.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplate#override
   */
  readonly override?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverride[];

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplate(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'launchTemplateSpecification': obj.launchTemplateSpecification?.map(y => toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification(y)),
    'override': obj.override?.map(y => toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverride(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AutoscalingGroupSpecForProviderPlacementGroupRefPolicy
 */
export interface AutoscalingGroupSpecForProviderPlacementGroupRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoscalingGroupSpecForProviderPlacementGroupRefPolicy#resolution
   */
  readonly resolution?: AutoscalingGroupSpecForProviderPlacementGroupRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoscalingGroupSpecForProviderPlacementGroupRefPolicy#resolve
   */
  readonly resolve?: AutoscalingGroupSpecForProviderPlacementGroupRefPolicyResolve;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderPlacementGroupRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderPlacementGroupRefPolicy(obj: AutoscalingGroupSpecForProviderPlacementGroupRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AutoscalingGroupSpecForProviderPlacementGroupSelectorPolicy
 */
export interface AutoscalingGroupSpecForProviderPlacementGroupSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoscalingGroupSpecForProviderPlacementGroupSelectorPolicy#resolution
   */
  readonly resolution?: AutoscalingGroupSpecForProviderPlacementGroupSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoscalingGroupSpecForProviderPlacementGroupSelectorPolicy#resolve
   */
  readonly resolve?: AutoscalingGroupSpecForProviderPlacementGroupSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderPlacementGroupSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderPlacementGroupSelectorPolicy(obj: AutoscalingGroupSpecForProviderPlacementGroupSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AutoscalingGroupSpecForProviderServiceLinkedRoleArnRefPolicy
 */
export interface AutoscalingGroupSpecForProviderServiceLinkedRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoscalingGroupSpecForProviderServiceLinkedRoleArnRefPolicy#resolution
   */
  readonly resolution?: AutoscalingGroupSpecForProviderServiceLinkedRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoscalingGroupSpecForProviderServiceLinkedRoleArnRefPolicy#resolve
   */
  readonly resolve?: AutoscalingGroupSpecForProviderServiceLinkedRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderServiceLinkedRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderServiceLinkedRoleArnRefPolicy(obj: AutoscalingGroupSpecForProviderServiceLinkedRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelectorPolicy
 */
export interface AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelectorPolicy(obj: AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AutoscalingGroupSpecForProviderVpcZoneIdentifierRefsPolicy
 */
export interface AutoscalingGroupSpecForProviderVpcZoneIdentifierRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoscalingGroupSpecForProviderVpcZoneIdentifierRefsPolicy#resolution
   */
  readonly resolution?: AutoscalingGroupSpecForProviderVpcZoneIdentifierRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoscalingGroupSpecForProviderVpcZoneIdentifierRefsPolicy#resolve
   */
  readonly resolve?: AutoscalingGroupSpecForProviderVpcZoneIdentifierRefsPolicyResolve;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderVpcZoneIdentifierRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderVpcZoneIdentifierRefsPolicy(obj: AutoscalingGroupSpecForProviderVpcZoneIdentifierRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AutoscalingGroupSpecForProviderVpcZoneIdentifierSelectorPolicy
 */
export interface AutoscalingGroupSpecForProviderVpcZoneIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoscalingGroupSpecForProviderVpcZoneIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: AutoscalingGroupSpecForProviderVpcZoneIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoscalingGroupSpecForProviderVpcZoneIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: AutoscalingGroupSpecForProviderVpcZoneIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderVpcZoneIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderVpcZoneIdentifierSelectorPolicy(obj: AutoscalingGroupSpecForProviderVpcZoneIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderWarmPoolInstanceReusePolicy
 */
export interface AutoscalingGroupSpecForProviderWarmPoolInstanceReusePolicy {
  /**
   * Whether instances in the Auto Scaling group can be returned to the warm pool on scale in.
   *
   * @schema AutoscalingGroupSpecForProviderWarmPoolInstanceReusePolicy#reuseOnScaleIn
   */
  readonly reuseOnScaleIn?: boolean;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderWarmPoolInstanceReusePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderWarmPoolInstanceReusePolicy(obj: AutoscalingGroupSpecForProviderWarmPoolInstanceReusePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'reuseOnScaleIn': obj.reuseOnScaleIn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderInstanceRefreshPreferences
 */
export interface AutoscalingGroupSpecInitProviderInstanceRefreshPreferences {
  /**
   * Automatically rollback if instance refresh fails. Defaults to false.
   *
   * @default false.
   * @schema AutoscalingGroupSpecInitProviderInstanceRefreshPreferences#autoRollback
   */
  readonly autoRollback?: boolean;

  /**
   * Number of seconds to wait after a checkpoint. Defaults to 3600.
   *
   * @default 3600.
   * @schema AutoscalingGroupSpecInitProviderInstanceRefreshPreferences#checkpointDelay
   */
  readonly checkpointDelay?: string;

  /**
   * List of percentages for each checkpoint. Values must be unique and in ascending order. To replace all instances, the final number must be 100.
   *
   * @schema AutoscalingGroupSpecInitProviderInstanceRefreshPreferences#checkpointPercentages
   */
  readonly checkpointPercentages?: number[];

  /**
   * Number of seconds until a newly launched instance is configured and ready to use. Default behavior is to use the Auto Scaling Group's health check grace period.
   *
   * @schema AutoscalingGroupSpecInitProviderInstanceRefreshPreferences#instanceWarmup
   */
  readonly instanceWarmup?: string;

  /**
   * Amount of capacity in the Auto Scaling group that must remain healthy during an instance refresh to allow the operation to continue, as a percentage of the desired capacity of the Auto Scaling group. Defaults to 90.
   *
   * @default 90.
   * @schema AutoscalingGroupSpecInitProviderInstanceRefreshPreferences#minHealthyPercentage
   */
  readonly minHealthyPercentage?: number;

  /**
   * Replace instances that already have your desired configuration. Defaults to false.
   *
   * @default false.
   * @schema AutoscalingGroupSpecInitProviderInstanceRefreshPreferences#skipMatching
   */
  readonly skipMatching?: boolean;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderInstanceRefreshPreferences' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderInstanceRefreshPreferences(obj: AutoscalingGroupSpecInitProviderInstanceRefreshPreferences | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoRollback': obj.autoRollback,
    'checkpointDelay': obj.checkpointDelay,
    'checkpointPercentages': obj.checkpointPercentages?.map(y => y),
    'instanceWarmup': obj.instanceWarmup,
    'minHealthyPercentage': obj.minHealthyPercentage,
    'skipMatching': obj.skipMatching,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyInstancesDistribution
 */
export interface AutoscalingGroupSpecInitProviderMixedInstancesPolicyInstancesDistribution {
  /**
   * Strategy to use when launching on-demand instances. Valid values: prioritized, lowest-price. Default: prioritized.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyInstancesDistribution#onDemandAllocationStrategy
   */
  readonly onDemandAllocationStrategy?: string;

  /**
   * Absolute minimum amount of desired capacity that must be fulfilled by on-demand instances. Default: 0.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyInstancesDistribution#onDemandBaseCapacity
   */
  readonly onDemandBaseCapacity?: number;

  /**
   * Percentage split between on-demand and Spot instances above the base on-demand capacity. Default: 100.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyInstancesDistribution#onDemandPercentageAboveBaseCapacity
   */
  readonly onDemandPercentageAboveBaseCapacity?: number;

  /**
   * How to allocate capacity across the Spot pools. Valid values: lowest-price, capacity-optimized, capacity-optimized-prioritized, and price-capacity-optimized. Default: lowest-price.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyInstancesDistribution#spotAllocationStrategy
   */
  readonly spotAllocationStrategy?: string;

  /**
   * Number of Spot pools per availability zone to allocate capacity. EC2 Auto Scaling selects the cheapest Spot pools and evenly allocates Spot capacity across the number of Spot pools that you specify. Only available with spot_allocation_strategy set to lowest-price. Otherwise it must be set to 0, if it has been defined before. Default: 2.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyInstancesDistribution#spotInstancePools
   */
  readonly spotInstancePools?: number;

  /**
   * Maximum price per unit hour that the user is willing to pay for the Spot instances. Default: an empty string which means the on-demand price.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyInstancesDistribution#spotMaxPrice
   */
  readonly spotMaxPrice?: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderMixedInstancesPolicyInstancesDistribution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyInstancesDistribution(obj: AutoscalingGroupSpecInitProviderMixedInstancesPolicyInstancesDistribution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'onDemandAllocationStrategy': obj.onDemandAllocationStrategy,
    'onDemandBaseCapacity': obj.onDemandBaseCapacity,
    'onDemandPercentageAboveBaseCapacity': obj.onDemandPercentageAboveBaseCapacity,
    'spotAllocationStrategy': obj.spotAllocationStrategy,
    'spotInstancePools': obj.spotInstancePools,
    'spotMaxPrice': obj.spotMaxPrice,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplate
 */
export interface AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplate {
  /**
   * Nested argument defines the Launch Template. Defined below.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplate#launchTemplateSpecification
   */
  readonly launchTemplateSpecification?: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification[];

  /**
   * List of nested arguments provides the ability to specify multiple instance types. This will override the same parameter in the launch template. For on-demand instances, Auto Scaling considers the order of preference of instance types to launch based on the order specified in the overrides list. Defined below.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplate#override
   */
  readonly override?: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverride[];

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplate(obj: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'launchTemplateSpecification': obj.launchTemplateSpecification?.map(y => toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification(y)),
    'override': obj.override?.map(y => toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverride(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderWarmPoolInstanceReusePolicy
 */
export interface AutoscalingGroupSpecInitProviderWarmPoolInstanceReusePolicy {
  /**
   * Whether instances in the Auto Scaling group can be returned to the warm pool on scale in.
   *
   * @schema AutoscalingGroupSpecInitProviderWarmPoolInstanceReusePolicy#reuseOnScaleIn
   */
  readonly reuseOnScaleIn?: boolean;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderWarmPoolInstanceReusePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderWarmPoolInstanceReusePolicy(obj: AutoscalingGroupSpecInitProviderWarmPoolInstanceReusePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'reuseOnScaleIn': obj.reuseOnScaleIn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoscalingGroupSpecProviderConfigRefPolicyResolution
 */
export enum AutoscalingGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoscalingGroupSpecProviderConfigRefPolicyResolve
 */
export enum AutoscalingGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AutoscalingGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AutoscalingGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoscalingGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AutoscalingGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoscalingGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AutoscalingGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: AutoscalingGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoscalingGroupSpecForProviderLaunchConfigurationRefPolicyResolution
 */
export enum AutoscalingGroupSpecForProviderLaunchConfigurationRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoscalingGroupSpecForProviderLaunchConfigurationRefPolicyResolve
 */
export enum AutoscalingGroupSpecForProviderLaunchConfigurationRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoscalingGroupSpecForProviderLaunchConfigurationSelectorPolicyResolution
 */
export enum AutoscalingGroupSpecForProviderLaunchConfigurationSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoscalingGroupSpecForProviderLaunchConfigurationSelectorPolicyResolve
 */
export enum AutoscalingGroupSpecForProviderLaunchConfigurationSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AutoscalingGroupSpecForProviderLaunchTemplateIdRefPolicy
 */
export interface AutoscalingGroupSpecForProviderLaunchTemplateIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchTemplateIdRefPolicy#resolution
   */
  readonly resolution?: AutoscalingGroupSpecForProviderLaunchTemplateIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchTemplateIdRefPolicy#resolve
   */
  readonly resolve?: AutoscalingGroupSpecForProviderLaunchTemplateIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderLaunchTemplateIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderLaunchTemplateIdRefPolicy(obj: AutoscalingGroupSpecForProviderLaunchTemplateIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AutoscalingGroupSpecForProviderLaunchTemplateIdSelectorPolicy
 */
export interface AutoscalingGroupSpecForProviderLaunchTemplateIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchTemplateIdSelectorPolicy#resolution
   */
  readonly resolution?: AutoscalingGroupSpecForProviderLaunchTemplateIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoscalingGroupSpecForProviderLaunchTemplateIdSelectorPolicy#resolve
   */
  readonly resolve?: AutoscalingGroupSpecForProviderLaunchTemplateIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderLaunchTemplateIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderLaunchTemplateIdSelectorPolicy(obj: AutoscalingGroupSpecForProviderLaunchTemplateIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification {
  /**
   * ID of the launch template. Conflicts with launch_template_name.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification#launchTemplateId
   */
  readonly launchTemplateId?: string;

  /**
   * Reference to a LaunchTemplate in ec2 to populate launchTemplateId.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification#launchTemplateIdRef
   */
  readonly launchTemplateIdRef?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRef;

  /**
   * Selector for a LaunchTemplate in ec2 to populate launchTemplateId.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification#launchTemplateIdSelector
   */
  readonly launchTemplateIdSelector?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelector;

  /**
   * Name of the launch template. Conflicts with launch_template_id.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification#launchTemplateName
   */
  readonly launchTemplateName?: string;

  /**
   * Template version. Can be version number, $Latest, or $Default. (Default: $Default).
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'launchTemplateId': obj.launchTemplateId,
    'launchTemplateIdRef': toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRef(obj.launchTemplateIdRef),
    'launchTemplateIdSelector': toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelector(obj.launchTemplateIdSelector),
    'launchTemplateName': obj.launchTemplateName,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverride
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverride {
  /**
   * Override the instance type in the Launch Template with instance types that satisfy the requirements.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverride#instanceRequirements
   */
  readonly instanceRequirements?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements[];

  /**
   * Override the instance type in the Launch Template.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverride#instanceType
   */
  readonly instanceType?: string;

  /**
   * Nested argument defines the Launch Template. Defined below.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverride#launchTemplateSpecification
   */
  readonly launchTemplateSpecification?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification[];

  /**
   * Number of capacity units, which gives the instance type a proportional weight to other instance types.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverride#weightedCapacity
   */
  readonly weightedCapacity?: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverride' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverride(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceRequirements': obj.instanceRequirements?.map(y => toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements(y)),
    'instanceType': obj.instanceType,
    'launchTemplateSpecification': obj.launchTemplateSpecification?.map(y => toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification(y)),
    'weightedCapacity': obj.weightedCapacity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoscalingGroupSpecForProviderPlacementGroupRefPolicyResolution
 */
export enum AutoscalingGroupSpecForProviderPlacementGroupRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoscalingGroupSpecForProviderPlacementGroupRefPolicyResolve
 */
export enum AutoscalingGroupSpecForProviderPlacementGroupRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoscalingGroupSpecForProviderPlacementGroupSelectorPolicyResolution
 */
export enum AutoscalingGroupSpecForProviderPlacementGroupSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoscalingGroupSpecForProviderPlacementGroupSelectorPolicyResolve
 */
export enum AutoscalingGroupSpecForProviderPlacementGroupSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoscalingGroupSpecForProviderServiceLinkedRoleArnRefPolicyResolution
 */
export enum AutoscalingGroupSpecForProviderServiceLinkedRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoscalingGroupSpecForProviderServiceLinkedRoleArnRefPolicyResolve
 */
export enum AutoscalingGroupSpecForProviderServiceLinkedRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelectorPolicyResolution
 */
export enum AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelectorPolicyResolve
 */
export enum AutoscalingGroupSpecForProviderServiceLinkedRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoscalingGroupSpecForProviderVpcZoneIdentifierRefsPolicyResolution
 */
export enum AutoscalingGroupSpecForProviderVpcZoneIdentifierRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoscalingGroupSpecForProviderVpcZoneIdentifierRefsPolicyResolve
 */
export enum AutoscalingGroupSpecForProviderVpcZoneIdentifierRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoscalingGroupSpecForProviderVpcZoneIdentifierSelectorPolicyResolution
 */
export enum AutoscalingGroupSpecForProviderVpcZoneIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoscalingGroupSpecForProviderVpcZoneIdentifierSelectorPolicyResolve
 */
export enum AutoscalingGroupSpecForProviderVpcZoneIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification
 */
export interface AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification {
  /**
   * Name of the launch template. Conflicts with launch_template_id.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification#launchTemplateName
   */
  readonly launchTemplateName?: string;

  /**
   * Template version. Can be version number, $Latest, or $Default. (Default: $Default).
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification(obj: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'launchTemplateName': obj.launchTemplateName,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverride
 */
export interface AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverride {
  /**
   * Override the instance type in the Launch Template with instance types that satisfy the requirements.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverride#instanceRequirements
   */
  readonly instanceRequirements?: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements[];

  /**
   * Override the instance type in the Launch Template.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverride#instanceType
   */
  readonly instanceType?: string;

  /**
   * Nested argument defines the Launch Template. Defined below.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverride#launchTemplateSpecification
   */
  readonly launchTemplateSpecification?: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification[];

  /**
   * Number of capacity units, which gives the instance type a proportional weight to other instance types.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverride#weightedCapacity
   */
  readonly weightedCapacity?: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverride' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverride(obj: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceRequirements': obj.instanceRequirements?.map(y => toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements(y)),
    'instanceType': obj.instanceType,
    'launchTemplateSpecification': obj.launchTemplateSpecification?.map(y => toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification(y)),
    'weightedCapacity': obj.weightedCapacity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoscalingGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AutoscalingGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoscalingGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AutoscalingGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoscalingGroupSpecForProviderLaunchTemplateIdRefPolicyResolution
 */
export enum AutoscalingGroupSpecForProviderLaunchTemplateIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoscalingGroupSpecForProviderLaunchTemplateIdRefPolicyResolve
 */
export enum AutoscalingGroupSpecForProviderLaunchTemplateIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoscalingGroupSpecForProviderLaunchTemplateIdSelectorPolicyResolution
 */
export enum AutoscalingGroupSpecForProviderLaunchTemplateIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoscalingGroupSpecForProviderLaunchTemplateIdSelectorPolicyResolve
 */
export enum AutoscalingGroupSpecForProviderLaunchTemplateIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a LaunchTemplate in ec2 to populate launchTemplateId.
 *
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRef
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRef#policy
   */
  readonly policy?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRefPolicy;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRef(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LaunchTemplate in ec2 to populate launchTemplateId.
 *
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelector
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelector#policy
   */
  readonly policy?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelector(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements {
  /**
   * Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
   *
   * @default no minimum or maximum.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#acceleratorCount
   */
  readonly acceleratorCount?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount[];

  /**
   * List of accelerator manufacturer names. Default is any manufacturer.
   *
   * @default any manufacturer.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#acceleratorManufacturers
   */
  readonly acceleratorManufacturers?: string[];

  /**
   * List of accelerator names. Default is any acclerator.
   *
   * @default any acclerator.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#acceleratorNames
   */
  readonly acceleratorNames?: string[];

  /**
   * Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
   *
   * @default no minimum or maximum.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#acceleratorTotalMemoryMib
   */
  readonly acceleratorTotalMemoryMib?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib[];

  /**
   * List of accelerator types. Default is any accelerator type.
   *
   * @default any accelerator type.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#acceleratorTypes
   */
  readonly acceleratorTypes?: string[];

  /**
   * List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (*), to allow an instance type, size, or generation. The following are examples: m5.8xlarge, c5*.*, m5a.*, r*, *3*. For example, if you specify c5*, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify m5a.*, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
   *
   * @default all instance types.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#allowedInstanceTypes
   */
  readonly allowedInstanceTypes?: string[];

  /**
   * Indicate whether bare metal instace types should be included, excluded, or required. Default is excluded.
   *
   * @default excluded.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#bareMetal
   */
  readonly bareMetal?: string;

  /**
   * Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
   *
   * @default no minimum or maximum.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#baselineEbsBandwidthMbps
   */
  readonly baselineEbsBandwidthMbps?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps[];

  /**
   * Indicate whether burstable performance instance types should be included, excluded, or required. Default is excluded.
   *
   * @default excluded.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#burstablePerformance
   */
  readonly burstablePerformance?: string;

  /**
   * List of CPU manufacturer names. Default is any manufacturer.
   *
   * @default any manufacturer.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#cpuManufacturers
   */
  readonly cpuManufacturers?: string[];

  /**
   * List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (*), to exclude an instance type, size, or generation. The following are examples: m5.8xlarge, c5*.*, m5a.*, r*, *3*. For example, if you specify c5*, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify m5a.*, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
   *
   * @default no excluded instance types.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#excludedInstanceTypes
   */
  readonly excludedInstanceTypes?: string[];

  /**
   * List of instance generation names. Default is any generation.
   *
   * @default any generation.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#instanceGenerations
   */
  readonly instanceGenerations?: string[];

  /**
   * Indicate whether instance types with local storage volumes are included, excluded, or required. Default is included.
   *
   * @default included.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#localStorage
   */
  readonly localStorage?: string;

  /**
   * List of local storage type names. Default any storage type.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#localStorageTypes
   */
  readonly localStorageTypes?: string[];

  /**
   * Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
   *
   * @default no minimum or maximum.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#memoryGibPerVcpu
   */
  readonly memoryGibPerVcpu?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu[];

  /**
   * Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
   *
   * @default no maximum.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#memoryMib
   */
  readonly memoryMib?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib[];

  /**
   * Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
   *
   * @default no minimum or maximum.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#networkBandwidthGbps
   */
  readonly networkBandwidthGbps?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps[];

  /**
   * Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
   *
   * @default no minimum or maximum.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#networkInterfaceCount
   */
  readonly networkInterfaceCount?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount[];

  /**
   * Price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
   *
   * @default 20.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#onDemandMaxPricePercentageOverLowestPrice
   */
  readonly onDemandMaxPricePercentageOverLowestPrice?: number;

  /**
   * Indicate whether instance types must support On-Demand Instance Hibernation, either true or false. Default is false.
   *
   * @default false.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#requireHibernateSupport
   */
  readonly requireHibernateSupport?: boolean;

  /**
   * Price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
   *
   * @default 100.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#spotMaxPricePercentageOverLowestPrice
   */
  readonly spotMaxPricePercentageOverLowestPrice?: number;

  /**
   * Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
   *
   * @default no minimum or maximum.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#totalLocalStorageGb
   */
  readonly totalLocalStorageGb?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb[];

  /**
   * Block describing the minimum and maximum number of vCPUs. Default is no maximum.
   *
   * @default no maximum.
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#vcpuCount
   */
  readonly vcpuCount?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount[];

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorCount': obj.acceleratorCount?.map(y => toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount(y)),
    'acceleratorManufacturers': obj.acceleratorManufacturers?.map(y => y),
    'acceleratorNames': obj.acceleratorNames?.map(y => y),
    'acceleratorTotalMemoryMib': obj.acceleratorTotalMemoryMib?.map(y => toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib(y)),
    'acceleratorTypes': obj.acceleratorTypes?.map(y => y),
    'allowedInstanceTypes': obj.allowedInstanceTypes?.map(y => y),
    'bareMetal': obj.bareMetal,
    'baselineEbsBandwidthMbps': obj.baselineEbsBandwidthMbps?.map(y => toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps(y)),
    'burstablePerformance': obj.burstablePerformance,
    'cpuManufacturers': obj.cpuManufacturers?.map(y => y),
    'excludedInstanceTypes': obj.excludedInstanceTypes?.map(y => y),
    'instanceGenerations': obj.instanceGenerations?.map(y => y),
    'localStorage': obj.localStorage,
    'localStorageTypes': obj.localStorageTypes?.map(y => y),
    'memoryGibPerVcpu': obj.memoryGibPerVcpu?.map(y => toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu(y)),
    'memoryMib': obj.memoryMib?.map(y => toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib(y)),
    'networkBandwidthGbps': obj.networkBandwidthGbps?.map(y => toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps(y)),
    'networkInterfaceCount': obj.networkInterfaceCount?.map(y => toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount(y)),
    'onDemandMaxPricePercentageOverLowestPrice': obj.onDemandMaxPricePercentageOverLowestPrice,
    'requireHibernateSupport': obj.requireHibernateSupport,
    'spotMaxPricePercentageOverLowestPrice': obj.spotMaxPricePercentageOverLowestPrice,
    'totalLocalStorageGb': obj.totalLocalStorageGb?.map(y => toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb(y)),
    'vcpuCount': obj.vcpuCount?.map(y => toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification {
  /**
   * ID of the launch template. Conflicts with launch_template_name.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification#launchTemplateId
   */
  readonly launchTemplateId?: string;

  /**
   * Reference to a LaunchTemplate in ec2 to populate launchTemplateId.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification#launchTemplateIdRef
   */
  readonly launchTemplateIdRef?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRef;

  /**
   * Selector for a LaunchTemplate in ec2 to populate launchTemplateId.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification#launchTemplateIdSelector
   */
  readonly launchTemplateIdSelector?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelector;

  /**
   * Name of the launch template. Conflicts with launch_template_id.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification#launchTemplateName
   */
  readonly launchTemplateName?: string;

  /**
   * Template version. Can be version number, $Latest, or $Default. (Default: $Default).
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'launchTemplateId': obj.launchTemplateId,
    'launchTemplateIdRef': toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRef(obj.launchTemplateIdRef),
    'launchTemplateIdSelector': toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelector(obj.launchTemplateIdSelector),
    'launchTemplateName': obj.launchTemplateName,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements
 */
export interface AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements {
  /**
   * Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
   *
   * @default no minimum or maximum.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#acceleratorCount
   */
  readonly acceleratorCount?: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount[];

  /**
   * List of accelerator manufacturer names. Default is any manufacturer.
   *
   * @default any manufacturer.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#acceleratorManufacturers
   */
  readonly acceleratorManufacturers?: string[];

  /**
   * List of accelerator names. Default is any acclerator.
   *
   * @default any acclerator.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#acceleratorNames
   */
  readonly acceleratorNames?: string[];

  /**
   * Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
   *
   * @default no minimum or maximum.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#acceleratorTotalMemoryMib
   */
  readonly acceleratorTotalMemoryMib?: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib[];

  /**
   * List of accelerator types. Default is any accelerator type.
   *
   * @default any accelerator type.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#acceleratorTypes
   */
  readonly acceleratorTypes?: string[];

  /**
   * List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (*), to allow an instance type, size, or generation. The following are examples: m5.8xlarge, c5*.*, m5a.*, r*, *3*. For example, if you specify c5*, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify m5a.*, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
   *
   * @default all instance types.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#allowedInstanceTypes
   */
  readonly allowedInstanceTypes?: string[];

  /**
   * Indicate whether bare metal instace types should be included, excluded, or required. Default is excluded.
   *
   * @default excluded.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#bareMetal
   */
  readonly bareMetal?: string;

  /**
   * Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
   *
   * @default no minimum or maximum.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#baselineEbsBandwidthMbps
   */
  readonly baselineEbsBandwidthMbps?: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps[];

  /**
   * Indicate whether burstable performance instance types should be included, excluded, or required. Default is excluded.
   *
   * @default excluded.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#burstablePerformance
   */
  readonly burstablePerformance?: string;

  /**
   * List of CPU manufacturer names. Default is any manufacturer.
   *
   * @default any manufacturer.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#cpuManufacturers
   */
  readonly cpuManufacturers?: string[];

  /**
   * List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (*), to exclude an instance type, size, or generation. The following are examples: m5.8xlarge, c5*.*, m5a.*, r*, *3*. For example, if you specify c5*, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify m5a.*, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
   *
   * @default no excluded instance types.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#excludedInstanceTypes
   */
  readonly excludedInstanceTypes?: string[];

  /**
   * List of instance generation names. Default is any generation.
   *
   * @default any generation.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#instanceGenerations
   */
  readonly instanceGenerations?: string[];

  /**
   * Indicate whether instance types with local storage volumes are included, excluded, or required. Default is included.
   *
   * @default included.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#localStorage
   */
  readonly localStorage?: string;

  /**
   * List of local storage type names. Default any storage type.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#localStorageTypes
   */
  readonly localStorageTypes?: string[];

  /**
   * Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
   *
   * @default no minimum or maximum.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#memoryGibPerVcpu
   */
  readonly memoryGibPerVcpu?: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu[];

  /**
   * Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
   *
   * @default no maximum.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#memoryMib
   */
  readonly memoryMib?: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib[];

  /**
   * Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
   *
   * @default no minimum or maximum.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#networkBandwidthGbps
   */
  readonly networkBandwidthGbps?: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps[];

  /**
   * Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
   *
   * @default no minimum or maximum.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#networkInterfaceCount
   */
  readonly networkInterfaceCount?: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount[];

  /**
   * Price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
   *
   * @default 20.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#onDemandMaxPricePercentageOverLowestPrice
   */
  readonly onDemandMaxPricePercentageOverLowestPrice?: number;

  /**
   * Indicate whether instance types must support On-Demand Instance Hibernation, either true or false. Default is false.
   *
   * @default false.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#requireHibernateSupport
   */
  readonly requireHibernateSupport?: boolean;

  /**
   * Price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
   *
   * @default 100.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#spotMaxPricePercentageOverLowestPrice
   */
  readonly spotMaxPricePercentageOverLowestPrice?: number;

  /**
   * Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
   *
   * @default no minimum or maximum.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#totalLocalStorageGb
   */
  readonly totalLocalStorageGb?: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb[];

  /**
   * Block describing the minimum and maximum number of vCPUs. Default is no maximum.
   *
   * @default no maximum.
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements#vcpuCount
   */
  readonly vcpuCount?: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount[];

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements(obj: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorCount': obj.acceleratorCount?.map(y => toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount(y)),
    'acceleratorManufacturers': obj.acceleratorManufacturers?.map(y => y),
    'acceleratorNames': obj.acceleratorNames?.map(y => y),
    'acceleratorTotalMemoryMib': obj.acceleratorTotalMemoryMib?.map(y => toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib(y)),
    'acceleratorTypes': obj.acceleratorTypes?.map(y => y),
    'allowedInstanceTypes': obj.allowedInstanceTypes?.map(y => y),
    'bareMetal': obj.bareMetal,
    'baselineEbsBandwidthMbps': obj.baselineEbsBandwidthMbps?.map(y => toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps(y)),
    'burstablePerformance': obj.burstablePerformance,
    'cpuManufacturers': obj.cpuManufacturers?.map(y => y),
    'excludedInstanceTypes': obj.excludedInstanceTypes?.map(y => y),
    'instanceGenerations': obj.instanceGenerations?.map(y => y),
    'localStorage': obj.localStorage,
    'localStorageTypes': obj.localStorageTypes?.map(y => y),
    'memoryGibPerVcpu': obj.memoryGibPerVcpu?.map(y => toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu(y)),
    'memoryMib': obj.memoryMib?.map(y => toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib(y)),
    'networkBandwidthGbps': obj.networkBandwidthGbps?.map(y => toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps(y)),
    'networkInterfaceCount': obj.networkInterfaceCount?.map(y => toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount(y)),
    'onDemandMaxPricePercentageOverLowestPrice': obj.onDemandMaxPricePercentageOverLowestPrice,
    'requireHibernateSupport': obj.requireHibernateSupport,
    'spotMaxPricePercentageOverLowestPrice': obj.spotMaxPricePercentageOverLowestPrice,
    'totalLocalStorageGb': obj.totalLocalStorageGb?.map(y => toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb(y)),
    'vcpuCount': obj.vcpuCount?.map(y => toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification
 */
export interface AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification {
  /**
   * Name of the launch template. Conflicts with launch_template_id.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification#launchTemplateName
   */
  readonly launchTemplateName?: string;

  /**
   * Template version. Can be version number, $Latest, or $Default. (Default: $Default).
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification(obj: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'launchTemplateName': obj.launchTemplateName,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRefPolicy
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRefPolicy#resolution
   */
  readonly resolution?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRefPolicy#resolve
   */
  readonly resolve?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRefPolicy(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy#resolution
   */
  readonly resolution?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy#resolve
   */
  readonly resolve?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LaunchTemplate in ec2 to populate launchTemplateId.
 *
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRef
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRef#policy
   */
  readonly policy?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRefPolicy;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRef(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LaunchTemplate in ec2 to populate launchTemplateId.
 *
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelector
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelector#policy
   */
  readonly policy?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelector(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount
 */
export interface AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount(obj: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib
 */
export interface AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib(obj: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps
 */
export interface AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps(obj: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu
 */
export interface AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu(obj: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib
 */
export interface AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib(obj: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps
 */
export interface AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps(obj: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount
 */
export interface AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount(obj: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb
 */
export interface AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb(obj: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount
 */
export interface AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount {
  /**
   * Maximum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount#max
   */
  readonly max?: number;

  /**
   * Minimum.
   *
   * @schema AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount(obj: AutoscalingGroupSpecInitProviderMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRefPolicyResolution
 */
export enum AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRefPolicyResolve
 */
export enum AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicyResolution
 */
export enum AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicyResolve
 */
export enum AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRefPolicy
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRefPolicy#resolution
   */
  readonly resolution?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRefPolicy#resolve
   */
  readonly resolve?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRefPolicy(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy
 */
export interface AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy#resolution
   */
  readonly resolution?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy#resolve
   */
  readonly resolve?: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy(obj: AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRefPolicyResolution
 */
export enum AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRefPolicyResolve
 */
export enum AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicyResolution
 */
export enum AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicyResolve
 */
export enum AutoscalingGroupSpecForProviderMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationLaunchTemplateIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GroupTag is the Schema for the GroupTags API. Manages an individual Autoscaling Group tag
 *
 * @schema GroupTag
 */
export class GroupTag extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GroupTag"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'autoscaling.aws.upbound.io/v1beta1',
    kind: 'GroupTag',
  }

  /**
   * Renders a Kubernetes manifest for "GroupTag".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GroupTagProps): any {
    return {
      ...GroupTag.GVK,
      ...toJson_GroupTagProps(props),
    };
  }

  /**
   * Defines a "GroupTag" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GroupTagProps) {
    super(scope, id, {
      ...GroupTag.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GroupTag.GVK,
      ...toJson_GroupTagProps(resolved),
    };
  }
}

/**
 * GroupTag is the Schema for the GroupTags API. Manages an individual Autoscaling Group tag
 *
 * @schema GroupTag
 */
export interface GroupTagProps {
  /**
   * @schema GroupTag#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GroupTagSpec defines the desired state of GroupTag
   *
   * @schema GroupTag#spec
   */
  readonly spec: GroupTagSpec;

}

/**
 * Converts an object of type 'GroupTagProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupTagProps(obj: GroupTagProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GroupTagSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupTagSpec defines the desired state of GroupTag
 *
 * @schema GroupTagSpec
 */
export interface GroupTagSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GroupTagSpec#deletionPolicy
   */
  readonly deletionPolicy?: GroupTagSpecDeletionPolicy;

  /**
   * @schema GroupTagSpec#forProvider
   */
  readonly forProvider: GroupTagSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema GroupTagSpec#initProvider
   */
  readonly initProvider?: GroupTagSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GroupTagSpec#managementPolicies
   */
  readonly managementPolicies?: GroupTagSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GroupTagSpec#providerConfigRef
   */
  readonly providerConfigRef?: GroupTagSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GroupTagSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GroupTagSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GroupTagSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GroupTagSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GroupTagSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupTagSpec(obj: GroupTagSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GroupTagSpecForProvider(obj.forProvider),
    'initProvider': toJson_GroupTagSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GroupTagSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GroupTagSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GroupTagSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GroupTagSpecDeletionPolicy
 */
export enum GroupTagSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GroupTagSpecForProvider
 */
export interface GroupTagSpecForProvider {
  /**
   * Name of the Autoscaling Group to apply the tag to.
   *
   * @schema GroupTagSpecForProvider#autoscalingGroupName
   */
  readonly autoscalingGroupName?: string;

  /**
   * Reference to a AutoscalingGroup in autoscaling to populate autoscalingGroupName.
   *
   * @schema GroupTagSpecForProvider#autoscalingGroupNameRef
   */
  readonly autoscalingGroupNameRef?: GroupTagSpecForProviderAutoscalingGroupNameRef;

  /**
   * Selector for a AutoscalingGroup in autoscaling to populate autoscalingGroupName.
   *
   * @schema GroupTagSpecForProvider#autoscalingGroupNameSelector
   */
  readonly autoscalingGroupNameSelector?: GroupTagSpecForProviderAutoscalingGroupNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GroupTagSpecForProvider#region
   */
  readonly region: string;

  /**
   * Tag to create. The tag block is documented below.
   *
   * @schema GroupTagSpecForProvider#tag
   */
  readonly tag?: GroupTagSpecForProviderTag[];

}

/**
 * Converts an object of type 'GroupTagSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupTagSpecForProvider(obj: GroupTagSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoscalingGroupName': obj.autoscalingGroupName,
    'autoscalingGroupNameRef': toJson_GroupTagSpecForProviderAutoscalingGroupNameRef(obj.autoscalingGroupNameRef),
    'autoscalingGroupNameSelector': toJson_GroupTagSpecForProviderAutoscalingGroupNameSelector(obj.autoscalingGroupNameSelector),
    'region': obj.region,
    'tag': obj.tag?.map(y => toJson_GroupTagSpecForProviderTag(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema GroupTagSpecInitProvider
 */
export interface GroupTagSpecInitProvider {
  /**
   * Tag to create. The tag block is documented below.
   *
   * @schema GroupTagSpecInitProvider#tag
   */
  readonly tag?: GroupTagSpecInitProviderTag[];

}

/**
 * Converts an object of type 'GroupTagSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupTagSpecInitProvider(obj: GroupTagSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tag': obj.tag?.map(y => toJson_GroupTagSpecInitProviderTag(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema GroupTagSpecManagementPolicies
 */
export enum GroupTagSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GroupTagSpecProviderConfigRef
 */
export interface GroupTagSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupTagSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupTagSpecProviderConfigRef#policy
   */
  readonly policy?: GroupTagSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GroupTagSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupTagSpecProviderConfigRef(obj: GroupTagSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupTagSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GroupTagSpecPublishConnectionDetailsTo
 */
export interface GroupTagSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GroupTagSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GroupTagSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GroupTagSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GroupTagSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GroupTagSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GroupTagSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupTagSpecPublishConnectionDetailsTo(obj: GroupTagSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GroupTagSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GroupTagSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GroupTagSpecWriteConnectionSecretToRef
 */
export interface GroupTagSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GroupTagSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GroupTagSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GroupTagSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupTagSpecWriteConnectionSecretToRef(obj: GroupTagSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a AutoscalingGroup in autoscaling to populate autoscalingGroupName.
 *
 * @schema GroupTagSpecForProviderAutoscalingGroupNameRef
 */
export interface GroupTagSpecForProviderAutoscalingGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupTagSpecForProviderAutoscalingGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupTagSpecForProviderAutoscalingGroupNameRef#policy
   */
  readonly policy?: GroupTagSpecForProviderAutoscalingGroupNameRefPolicy;

}

/**
 * Converts an object of type 'GroupTagSpecForProviderAutoscalingGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupTagSpecForProviderAutoscalingGroupNameRef(obj: GroupTagSpecForProviderAutoscalingGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupTagSpecForProviderAutoscalingGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a AutoscalingGroup in autoscaling to populate autoscalingGroupName.
 *
 * @schema GroupTagSpecForProviderAutoscalingGroupNameSelector
 */
export interface GroupTagSpecForProviderAutoscalingGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GroupTagSpecForProviderAutoscalingGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GroupTagSpecForProviderAutoscalingGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GroupTagSpecForProviderAutoscalingGroupNameSelector#policy
   */
  readonly policy?: GroupTagSpecForProviderAutoscalingGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'GroupTagSpecForProviderAutoscalingGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupTagSpecForProviderAutoscalingGroupNameSelector(obj: GroupTagSpecForProviderAutoscalingGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GroupTagSpecForProviderAutoscalingGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GroupTagSpecForProviderTag
 */
export interface GroupTagSpecForProviderTag {
  /**
   * Tag name.
   *
   * @schema GroupTagSpecForProviderTag#key
   */
  readonly key?: string;

  /**
   * Whether to propagate the tags to instances launched by the ASG.
   *
   * @schema GroupTagSpecForProviderTag#propagateAtLaunch
   */
  readonly propagateAtLaunch?: boolean;

  /**
   * Tag value.
   *
   * @schema GroupTagSpecForProviderTag#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'GroupTagSpecForProviderTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupTagSpecForProviderTag(obj: GroupTagSpecForProviderTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'propagateAtLaunch': obj.propagateAtLaunch,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GroupTagSpecInitProviderTag
 */
export interface GroupTagSpecInitProviderTag {
  /**
   * Tag name.
   *
   * @schema GroupTagSpecInitProviderTag#key
   */
  readonly key?: string;

  /**
   * Whether to propagate the tags to instances launched by the ASG.
   *
   * @schema GroupTagSpecInitProviderTag#propagateAtLaunch
   */
  readonly propagateAtLaunch?: boolean;

  /**
   * Tag value.
   *
   * @schema GroupTagSpecInitProviderTag#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'GroupTagSpecInitProviderTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupTagSpecInitProviderTag(obj: GroupTagSpecInitProviderTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'propagateAtLaunch': obj.propagateAtLaunch,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GroupTagSpecProviderConfigRefPolicy
 */
export interface GroupTagSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupTagSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GroupTagSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupTagSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GroupTagSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupTagSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupTagSpecProviderConfigRefPolicy(obj: GroupTagSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GroupTagSpecPublishConnectionDetailsToConfigRef
 */
export interface GroupTagSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupTagSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupTagSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GroupTagSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GroupTagSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupTagSpecPublishConnectionDetailsToConfigRef(obj: GroupTagSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupTagSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GroupTagSpecPublishConnectionDetailsToMetadata
 */
export interface GroupTagSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GroupTagSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GroupTagSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GroupTagSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GroupTagSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupTagSpecPublishConnectionDetailsToMetadata(obj: GroupTagSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GroupTagSpecForProviderAutoscalingGroupNameRefPolicy
 */
export interface GroupTagSpecForProviderAutoscalingGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupTagSpecForProviderAutoscalingGroupNameRefPolicy#resolution
   */
  readonly resolution?: GroupTagSpecForProviderAutoscalingGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupTagSpecForProviderAutoscalingGroupNameRefPolicy#resolve
   */
  readonly resolve?: GroupTagSpecForProviderAutoscalingGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupTagSpecForProviderAutoscalingGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupTagSpecForProviderAutoscalingGroupNameRefPolicy(obj: GroupTagSpecForProviderAutoscalingGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GroupTagSpecForProviderAutoscalingGroupNameSelectorPolicy
 */
export interface GroupTagSpecForProviderAutoscalingGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupTagSpecForProviderAutoscalingGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: GroupTagSpecForProviderAutoscalingGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupTagSpecForProviderAutoscalingGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: GroupTagSpecForProviderAutoscalingGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GroupTagSpecForProviderAutoscalingGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupTagSpecForProviderAutoscalingGroupNameSelectorPolicy(obj: GroupTagSpecForProviderAutoscalingGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupTagSpecProviderConfigRefPolicyResolution
 */
export enum GroupTagSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupTagSpecProviderConfigRefPolicyResolve
 */
export enum GroupTagSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GroupTagSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GroupTagSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupTagSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GroupTagSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupTagSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GroupTagSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupTagSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupTagSpecPublishConnectionDetailsToConfigRefPolicy(obj: GroupTagSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupTagSpecForProviderAutoscalingGroupNameRefPolicyResolution
 */
export enum GroupTagSpecForProviderAutoscalingGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupTagSpecForProviderAutoscalingGroupNameRefPolicyResolve
 */
export enum GroupTagSpecForProviderAutoscalingGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupTagSpecForProviderAutoscalingGroupNameSelectorPolicyResolution
 */
export enum GroupTagSpecForProviderAutoscalingGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupTagSpecForProviderAutoscalingGroupNameSelectorPolicyResolve
 */
export enum GroupTagSpecForProviderAutoscalingGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupTagSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GroupTagSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupTagSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GroupTagSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LaunchConfiguration is the Schema for the LaunchConfigurations API. Provides a resource to create a new launch configuration, used for autoscaling groups.
 *
 * @schema LaunchConfiguration
 */
export class LaunchConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LaunchConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'autoscaling.aws.upbound.io/v1beta1',
    kind: 'LaunchConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "LaunchConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LaunchConfigurationProps): any {
    return {
      ...LaunchConfiguration.GVK,
      ...toJson_LaunchConfigurationProps(props),
    };
  }

  /**
   * Defines a "LaunchConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LaunchConfigurationProps) {
    super(scope, id, {
      ...LaunchConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LaunchConfiguration.GVK,
      ...toJson_LaunchConfigurationProps(resolved),
    };
  }
}

/**
 * LaunchConfiguration is the Schema for the LaunchConfigurations API. Provides a resource to create a new launch configuration, used for autoscaling groups.
 *
 * @schema LaunchConfiguration
 */
export interface LaunchConfigurationProps {
  /**
   * @schema LaunchConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LaunchConfigurationSpec defines the desired state of LaunchConfiguration
   *
   * @schema LaunchConfiguration#spec
   */
  readonly spec: LaunchConfigurationSpec;

}

/**
 * Converts an object of type 'LaunchConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationProps(obj: LaunchConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LaunchConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LaunchConfigurationSpec defines the desired state of LaunchConfiguration
 *
 * @schema LaunchConfigurationSpec
 */
export interface LaunchConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LaunchConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: LaunchConfigurationSpecDeletionPolicy;

  /**
   * @schema LaunchConfigurationSpec#forProvider
   */
  readonly forProvider: LaunchConfigurationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema LaunchConfigurationSpec#initProvider
   */
  readonly initProvider?: LaunchConfigurationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema LaunchConfigurationSpec#managementPolicies
   */
  readonly managementPolicies?: LaunchConfigurationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LaunchConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: LaunchConfigurationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LaunchConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LaunchConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LaunchConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LaunchConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LaunchConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpec(obj: LaunchConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LaunchConfigurationSpecForProvider(obj.forProvider),
    'initProvider': toJson_LaunchConfigurationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_LaunchConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_LaunchConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LaunchConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LaunchConfigurationSpecDeletionPolicy
 */
export enum LaunchConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LaunchConfigurationSpecForProvider
 */
export interface LaunchConfigurationSpecForProvider {
  /**
   * Associate a public ip address with an instance in a VPC.
   *
   * @schema LaunchConfigurationSpecForProvider#associatePublicIpAddress
   */
  readonly associatePublicIpAddress?: boolean;

  /**
   * Additional EBS block devices to attach to the instance. See Block Devices below for details.
   *
   * @schema LaunchConfigurationSpecForProvider#ebsBlockDevice
   */
  readonly ebsBlockDevice?: LaunchConfigurationSpecForProviderEbsBlockDevice[];

  /**
   * If true, the launched EC2 instance will be EBS-optimized.
   *
   * @schema LaunchConfigurationSpecForProvider#ebsOptimized
   */
  readonly ebsOptimized?: boolean;

  /**
   * Enables/disables detailed monitoring. This is enabled by default.
   *
   * @schema LaunchConfigurationSpecForProvider#enableMonitoring
   */
  readonly enableMonitoring?: boolean;

  /**
   * Customize Ephemeral (also known as "Instance Store") volumes on the instance. See Block Devices below for details.
   *
   * @schema LaunchConfigurationSpecForProvider#ephemeralBlockDevice
   */
  readonly ephemeralBlockDevice?: LaunchConfigurationSpecForProviderEphemeralBlockDevice[];

  /**
   * The name attribute of the IAM instance profile to associate with launched instances.
   *
   * @schema LaunchConfigurationSpecForProvider#iamInstanceProfile
   */
  readonly iamInstanceProfile?: string;

  /**
   * The EC2 image ID to launch.
   *
   * @schema LaunchConfigurationSpecForProvider#imageId
   */
  readonly imageId?: string;

  /**
   * The size of instance to launch.
   *
   * @schema LaunchConfigurationSpecForProvider#instanceType
   */
  readonly instanceType?: string;

  /**
   * The key name that should be used for the instance.
   *
   * @schema LaunchConfigurationSpecForProvider#keyName
   */
  readonly keyName?: string;

  /**
   * The metadata options for the instance.
   *
   * @schema LaunchConfigurationSpecForProvider#metadataOptions
   */
  readonly metadataOptions?: LaunchConfigurationSpecForProviderMetadataOptions[];

  /**
   * The tenancy of the instance. Valid values are default or dedicated, see AWS's Create Launch Configuration for more details.
   *
   * @schema LaunchConfigurationSpecForProvider#placementTenancy
   */
  readonly placementTenancy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LaunchConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Customize details about the root block device of the instance. See Block Devices below for details.
   *
   * @schema LaunchConfigurationSpecForProvider#rootBlockDevice
   */
  readonly rootBlockDevice?: LaunchConfigurationSpecForProviderRootBlockDevice[];

  /**
   * A list of associated security group IDS.
   *
   * @schema LaunchConfigurationSpecForProvider#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * The maximum price to use for reserving spot instances.
   *
   * @schema LaunchConfigurationSpecForProvider#spotPrice
   */
  readonly spotPrice?: string;

  /**
   * The user data to provide when launching the instance. Do not pass gzip-compressed data via this argument; see user_data_base64 instead.
   *
   * @schema LaunchConfigurationSpecForProvider#userData
   */
  readonly userData?: string;

  /**
   * Can be used instead of user_data to pass base64-encoded binary data directly. Use this instead of user_data whenever the value is not a valid UTF-8 string. For example, gzip-encoded user data must be base64-encoded and passed via this argument to avoid corruption.
   *
   * @schema LaunchConfigurationSpecForProvider#userDataBase64
   */
  readonly userDataBase64?: string;

  /**
   * The ID of a ClassicLink-enabled VPC. Only applies to EC2-Classic instances. (eg. vpc-2730681a)
   *
   * @schema LaunchConfigurationSpecForProvider#vpcClassicLinkId
   */
  readonly vpcClassicLinkId?: string;

  /**
   * The IDs of one or more security groups for the specified ClassicLink-enabled VPC (eg. sg-46ae3d11).
   *
   * @schema LaunchConfigurationSpecForProvider#vpcClassicLinkSecurityGroups
   */
  readonly vpcClassicLinkSecurityGroups?: string[];

}

/**
 * Converts an object of type 'LaunchConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpecForProvider(obj: LaunchConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'associatePublicIpAddress': obj.associatePublicIpAddress,
    'ebsBlockDevice': obj.ebsBlockDevice?.map(y => toJson_LaunchConfigurationSpecForProviderEbsBlockDevice(y)),
    'ebsOptimized': obj.ebsOptimized,
    'enableMonitoring': obj.enableMonitoring,
    'ephemeralBlockDevice': obj.ephemeralBlockDevice?.map(y => toJson_LaunchConfigurationSpecForProviderEphemeralBlockDevice(y)),
    'iamInstanceProfile': obj.iamInstanceProfile,
    'imageId': obj.imageId,
    'instanceType': obj.instanceType,
    'keyName': obj.keyName,
    'metadataOptions': obj.metadataOptions?.map(y => toJson_LaunchConfigurationSpecForProviderMetadataOptions(y)),
    'placementTenancy': obj.placementTenancy,
    'region': obj.region,
    'rootBlockDevice': obj.rootBlockDevice?.map(y => toJson_LaunchConfigurationSpecForProviderRootBlockDevice(y)),
    'securityGroups': obj.securityGroups?.map(y => y),
    'spotPrice': obj.spotPrice,
    'userData': obj.userData,
    'userDataBase64': obj.userDataBase64,
    'vpcClassicLinkId': obj.vpcClassicLinkId,
    'vpcClassicLinkSecurityGroups': obj.vpcClassicLinkSecurityGroups?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema LaunchConfigurationSpecInitProvider
 */
export interface LaunchConfigurationSpecInitProvider {
  /**
   * Associate a public ip address with an instance in a VPC.
   *
   * @schema LaunchConfigurationSpecInitProvider#associatePublicIpAddress
   */
  readonly associatePublicIpAddress?: boolean;

  /**
   * Additional EBS block devices to attach to the instance. See Block Devices below for details.
   *
   * @schema LaunchConfigurationSpecInitProvider#ebsBlockDevice
   */
  readonly ebsBlockDevice?: LaunchConfigurationSpecInitProviderEbsBlockDevice[];

  /**
   * If true, the launched EC2 instance will be EBS-optimized.
   *
   * @schema LaunchConfigurationSpecInitProvider#ebsOptimized
   */
  readonly ebsOptimized?: boolean;

  /**
   * Enables/disables detailed monitoring. This is enabled by default.
   *
   * @schema LaunchConfigurationSpecInitProvider#enableMonitoring
   */
  readonly enableMonitoring?: boolean;

  /**
   * Customize Ephemeral (also known as "Instance Store") volumes on the instance. See Block Devices below for details.
   *
   * @schema LaunchConfigurationSpecInitProvider#ephemeralBlockDevice
   */
  readonly ephemeralBlockDevice?: LaunchConfigurationSpecInitProviderEphemeralBlockDevice[];

  /**
   * The name attribute of the IAM instance profile to associate with launched instances.
   *
   * @schema LaunchConfigurationSpecInitProvider#iamInstanceProfile
   */
  readonly iamInstanceProfile?: string;

  /**
   * The EC2 image ID to launch.
   *
   * @schema LaunchConfigurationSpecInitProvider#imageId
   */
  readonly imageId?: string;

  /**
   * The size of instance to launch.
   *
   * @schema LaunchConfigurationSpecInitProvider#instanceType
   */
  readonly instanceType?: string;

  /**
   * The key name that should be used for the instance.
   *
   * @schema LaunchConfigurationSpecInitProvider#keyName
   */
  readonly keyName?: string;

  /**
   * The metadata options for the instance.
   *
   * @schema LaunchConfigurationSpecInitProvider#metadataOptions
   */
  readonly metadataOptions?: LaunchConfigurationSpecInitProviderMetadataOptions[];

  /**
   * The tenancy of the instance. Valid values are default or dedicated, see AWS's Create Launch Configuration for more details.
   *
   * @schema LaunchConfigurationSpecInitProvider#placementTenancy
   */
  readonly placementTenancy?: string;

  /**
   * Customize details about the root block device of the instance. See Block Devices below for details.
   *
   * @schema LaunchConfigurationSpecInitProvider#rootBlockDevice
   */
  readonly rootBlockDevice?: LaunchConfigurationSpecInitProviderRootBlockDevice[];

  /**
   * A list of associated security group IDS.
   *
   * @schema LaunchConfigurationSpecInitProvider#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * The maximum price to use for reserving spot instances.
   *
   * @schema LaunchConfigurationSpecInitProvider#spotPrice
   */
  readonly spotPrice?: string;

  /**
   * The user data to provide when launching the instance. Do not pass gzip-compressed data via this argument; see user_data_base64 instead.
   *
   * @schema LaunchConfigurationSpecInitProvider#userData
   */
  readonly userData?: string;

  /**
   * Can be used instead of user_data to pass base64-encoded binary data directly. Use this instead of user_data whenever the value is not a valid UTF-8 string. For example, gzip-encoded user data must be base64-encoded and passed via this argument to avoid corruption.
   *
   * @schema LaunchConfigurationSpecInitProvider#userDataBase64
   */
  readonly userDataBase64?: string;

  /**
   * The ID of a ClassicLink-enabled VPC. Only applies to EC2-Classic instances. (eg. vpc-2730681a)
   *
   * @schema LaunchConfigurationSpecInitProvider#vpcClassicLinkId
   */
  readonly vpcClassicLinkId?: string;

  /**
   * The IDs of one or more security groups for the specified ClassicLink-enabled VPC (eg. sg-46ae3d11).
   *
   * @schema LaunchConfigurationSpecInitProvider#vpcClassicLinkSecurityGroups
   */
  readonly vpcClassicLinkSecurityGroups?: string[];

}

/**
 * Converts an object of type 'LaunchConfigurationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpecInitProvider(obj: LaunchConfigurationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'associatePublicIpAddress': obj.associatePublicIpAddress,
    'ebsBlockDevice': obj.ebsBlockDevice?.map(y => toJson_LaunchConfigurationSpecInitProviderEbsBlockDevice(y)),
    'ebsOptimized': obj.ebsOptimized,
    'enableMonitoring': obj.enableMonitoring,
    'ephemeralBlockDevice': obj.ephemeralBlockDevice?.map(y => toJson_LaunchConfigurationSpecInitProviderEphemeralBlockDevice(y)),
    'iamInstanceProfile': obj.iamInstanceProfile,
    'imageId': obj.imageId,
    'instanceType': obj.instanceType,
    'keyName': obj.keyName,
    'metadataOptions': obj.metadataOptions?.map(y => toJson_LaunchConfigurationSpecInitProviderMetadataOptions(y)),
    'placementTenancy': obj.placementTenancy,
    'rootBlockDevice': obj.rootBlockDevice?.map(y => toJson_LaunchConfigurationSpecInitProviderRootBlockDevice(y)),
    'securityGroups': obj.securityGroups?.map(y => y),
    'spotPrice': obj.spotPrice,
    'userData': obj.userData,
    'userDataBase64': obj.userDataBase64,
    'vpcClassicLinkId': obj.vpcClassicLinkId,
    'vpcClassicLinkSecurityGroups': obj.vpcClassicLinkSecurityGroups?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema LaunchConfigurationSpecManagementPolicies
 */
export enum LaunchConfigurationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LaunchConfigurationSpecProviderConfigRef
 */
export interface LaunchConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LaunchConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LaunchConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: LaunchConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LaunchConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpecProviderConfigRef(obj: LaunchConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LaunchConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LaunchConfigurationSpecPublishConnectionDetailsTo
 */
export interface LaunchConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LaunchConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LaunchConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LaunchConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LaunchConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LaunchConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LaunchConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpecPublishConnectionDetailsTo(obj: LaunchConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LaunchConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LaunchConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LaunchConfigurationSpecWriteConnectionSecretToRef
 */
export interface LaunchConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LaunchConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LaunchConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LaunchConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpecWriteConnectionSecretToRef(obj: LaunchConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchConfigurationSpecForProviderEbsBlockDevice
 */
export interface LaunchConfigurationSpecForProviderEbsBlockDevice {
  /**
   * Whether the volume should be destroyed on instance termination (Default: true).
   *
   * @schema LaunchConfigurationSpecForProviderEbsBlockDevice#deleteOnTermination
   */
  readonly deleteOnTermination?: boolean;

  /**
   * The name of the device to mount.
   *
   * @schema LaunchConfigurationSpecForProviderEbsBlockDevice#deviceName
   */
  readonly deviceName?: string;

  /**
   * Whether the volume should be encrypted or not. Defaults to false.
   *
   * @default false.
   * @schema LaunchConfigurationSpecForProviderEbsBlockDevice#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * The amount of provisioned IOPS. This must be set with a volume_type of "io1".
   *
   * @schema LaunchConfigurationSpecForProviderEbsBlockDevice#iops
   */
  readonly iops?: number;

  /**
   * Whether the device in the block device mapping of the AMI is suppressed.
   *
   * @schema LaunchConfigurationSpecForProviderEbsBlockDevice#noDevice
   */
  readonly noDevice?: boolean;

  /**
   * The Snapshot ID to mount.
   *
   * @schema LaunchConfigurationSpecForProviderEbsBlockDevice#snapshotId
   */
  readonly snapshotId?: string;

  /**
   * The throughput (MiBps) to provision for a gp3 volume.
   *
   * @schema LaunchConfigurationSpecForProviderEbsBlockDevice#throughput
   */
  readonly throughput?: number;

  /**
   * The size of the volume in gigabytes.
   *
   * @schema LaunchConfigurationSpecForProviderEbsBlockDevice#volumeSize
   */
  readonly volumeSize?: number;

  /**
   * The type of volume. Can be standard, gp2, gp3, st1, sc1 or io1.
   *
   * @schema LaunchConfigurationSpecForProviderEbsBlockDevice#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'LaunchConfigurationSpecForProviderEbsBlockDevice' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpecForProviderEbsBlockDevice(obj: LaunchConfigurationSpecForProviderEbsBlockDevice | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteOnTermination': obj.deleteOnTermination,
    'deviceName': obj.deviceName,
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'noDevice': obj.noDevice,
    'snapshotId': obj.snapshotId,
    'throughput': obj.throughput,
    'volumeSize': obj.volumeSize,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchConfigurationSpecForProviderEphemeralBlockDevice
 */
export interface LaunchConfigurationSpecForProviderEphemeralBlockDevice {
  /**
   * The name of the block device to mount on the instance.
   *
   * @schema LaunchConfigurationSpecForProviderEphemeralBlockDevice#deviceName
   */
  readonly deviceName?: string;

  /**
   * Whether the device in the block device mapping of the AMI is suppressed.
   *
   * @schema LaunchConfigurationSpecForProviderEphemeralBlockDevice#noDevice
   */
  readonly noDevice?: boolean;

  /**
   * The Instance Store Device Name.
   *
   * @schema LaunchConfigurationSpecForProviderEphemeralBlockDevice#virtualName
   */
  readonly virtualName?: string;

}

/**
 * Converts an object of type 'LaunchConfigurationSpecForProviderEphemeralBlockDevice' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpecForProviderEphemeralBlockDevice(obj: LaunchConfigurationSpecForProviderEphemeralBlockDevice | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deviceName': obj.deviceName,
    'noDevice': obj.noDevice,
    'virtualName': obj.virtualName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchConfigurationSpecForProviderMetadataOptions
 */
export interface LaunchConfigurationSpecForProviderMetadataOptions {
  /**
   * The state of the metadata service: enabled, disabled.
   *
   * @schema LaunchConfigurationSpecForProviderMetadataOptions#httpEndpoint
   */
  readonly httpEndpoint?: string;

  /**
   * The desired HTTP PUT response hop limit for instance metadata requests.
   *
   * @schema LaunchConfigurationSpecForProviderMetadataOptions#httpPutResponseHopLimit
   */
  readonly httpPutResponseHopLimit?: number;

  /**
   * If session tokens are required: optional, required.
   *
   * @schema LaunchConfigurationSpecForProviderMetadataOptions#httpTokens
   */
  readonly httpTokens?: string;

}

/**
 * Converts an object of type 'LaunchConfigurationSpecForProviderMetadataOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpecForProviderMetadataOptions(obj: LaunchConfigurationSpecForProviderMetadataOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpEndpoint': obj.httpEndpoint,
    'httpPutResponseHopLimit': obj.httpPutResponseHopLimit,
    'httpTokens': obj.httpTokens,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchConfigurationSpecForProviderRootBlockDevice
 */
export interface LaunchConfigurationSpecForProviderRootBlockDevice {
  /**
   * Whether the volume should be destroyed on instance termination. Defaults to true.
   *
   * @default true.
   * @schema LaunchConfigurationSpecForProviderRootBlockDevice#deleteOnTermination
   */
  readonly deleteOnTermination?: boolean;

  /**
   * Whether the volume should be encrypted or not. Defaults to false.
   *
   * @default false.
   * @schema LaunchConfigurationSpecForProviderRootBlockDevice#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * The amount of provisioned IOPS. This must be set with a volume_type of io1.
   *
   * @schema LaunchConfigurationSpecForProviderRootBlockDevice#iops
   */
  readonly iops?: number;

  /**
   * The throughput (MiBps) to provision for a gp3 volume.
   *
   * @schema LaunchConfigurationSpecForProviderRootBlockDevice#throughput
   */
  readonly throughput?: number;

  /**
   * The size of the volume in gigabytes.
   *
   * @schema LaunchConfigurationSpecForProviderRootBlockDevice#volumeSize
   */
  readonly volumeSize?: number;

  /**
   * The type of volume. Can be standard, gp2, gp3, st1, sc1 or io1.
   *
   * @schema LaunchConfigurationSpecForProviderRootBlockDevice#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'LaunchConfigurationSpecForProviderRootBlockDevice' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpecForProviderRootBlockDevice(obj: LaunchConfigurationSpecForProviderRootBlockDevice | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteOnTermination': obj.deleteOnTermination,
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'throughput': obj.throughput,
    'volumeSize': obj.volumeSize,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchConfigurationSpecInitProviderEbsBlockDevice
 */
export interface LaunchConfigurationSpecInitProviderEbsBlockDevice {
  /**
   * Whether the volume should be destroyed on instance termination (Default: true).
   *
   * @schema LaunchConfigurationSpecInitProviderEbsBlockDevice#deleteOnTermination
   */
  readonly deleteOnTermination?: boolean;

  /**
   * The name of the device to mount.
   *
   * @schema LaunchConfigurationSpecInitProviderEbsBlockDevice#deviceName
   */
  readonly deviceName?: string;

  /**
   * Whether the volume should be encrypted or not. Defaults to false.
   *
   * @default false.
   * @schema LaunchConfigurationSpecInitProviderEbsBlockDevice#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * The amount of provisioned IOPS. This must be set with a volume_type of "io1".
   *
   * @schema LaunchConfigurationSpecInitProviderEbsBlockDevice#iops
   */
  readonly iops?: number;

  /**
   * Whether the device in the block device mapping of the AMI is suppressed.
   *
   * @schema LaunchConfigurationSpecInitProviderEbsBlockDevice#noDevice
   */
  readonly noDevice?: boolean;

  /**
   * The Snapshot ID to mount.
   *
   * @schema LaunchConfigurationSpecInitProviderEbsBlockDevice#snapshotId
   */
  readonly snapshotId?: string;

  /**
   * The throughput (MiBps) to provision for a gp3 volume.
   *
   * @schema LaunchConfigurationSpecInitProviderEbsBlockDevice#throughput
   */
  readonly throughput?: number;

  /**
   * The size of the volume in gigabytes.
   *
   * @schema LaunchConfigurationSpecInitProviderEbsBlockDevice#volumeSize
   */
  readonly volumeSize?: number;

  /**
   * The type of volume. Can be standard, gp2, gp3, st1, sc1 or io1.
   *
   * @schema LaunchConfigurationSpecInitProviderEbsBlockDevice#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'LaunchConfigurationSpecInitProviderEbsBlockDevice' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpecInitProviderEbsBlockDevice(obj: LaunchConfigurationSpecInitProviderEbsBlockDevice | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteOnTermination': obj.deleteOnTermination,
    'deviceName': obj.deviceName,
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'noDevice': obj.noDevice,
    'snapshotId': obj.snapshotId,
    'throughput': obj.throughput,
    'volumeSize': obj.volumeSize,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchConfigurationSpecInitProviderEphemeralBlockDevice
 */
export interface LaunchConfigurationSpecInitProviderEphemeralBlockDevice {
  /**
   * The name of the block device to mount on the instance.
   *
   * @schema LaunchConfigurationSpecInitProviderEphemeralBlockDevice#deviceName
   */
  readonly deviceName?: string;

  /**
   * Whether the device in the block device mapping of the AMI is suppressed.
   *
   * @schema LaunchConfigurationSpecInitProviderEphemeralBlockDevice#noDevice
   */
  readonly noDevice?: boolean;

  /**
   * The Instance Store Device Name.
   *
   * @schema LaunchConfigurationSpecInitProviderEphemeralBlockDevice#virtualName
   */
  readonly virtualName?: string;

}

/**
 * Converts an object of type 'LaunchConfigurationSpecInitProviderEphemeralBlockDevice' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpecInitProviderEphemeralBlockDevice(obj: LaunchConfigurationSpecInitProviderEphemeralBlockDevice | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deviceName': obj.deviceName,
    'noDevice': obj.noDevice,
    'virtualName': obj.virtualName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchConfigurationSpecInitProviderMetadataOptions
 */
export interface LaunchConfigurationSpecInitProviderMetadataOptions {
  /**
   * The state of the metadata service: enabled, disabled.
   *
   * @schema LaunchConfigurationSpecInitProviderMetadataOptions#httpEndpoint
   */
  readonly httpEndpoint?: string;

  /**
   * The desired HTTP PUT response hop limit for instance metadata requests.
   *
   * @schema LaunchConfigurationSpecInitProviderMetadataOptions#httpPutResponseHopLimit
   */
  readonly httpPutResponseHopLimit?: number;

  /**
   * If session tokens are required: optional, required.
   *
   * @schema LaunchConfigurationSpecInitProviderMetadataOptions#httpTokens
   */
  readonly httpTokens?: string;

}

/**
 * Converts an object of type 'LaunchConfigurationSpecInitProviderMetadataOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpecInitProviderMetadataOptions(obj: LaunchConfigurationSpecInitProviderMetadataOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpEndpoint': obj.httpEndpoint,
    'httpPutResponseHopLimit': obj.httpPutResponseHopLimit,
    'httpTokens': obj.httpTokens,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LaunchConfigurationSpecInitProviderRootBlockDevice
 */
export interface LaunchConfigurationSpecInitProviderRootBlockDevice {
  /**
   * Whether the volume should be destroyed on instance termination. Defaults to true.
   *
   * @default true.
   * @schema LaunchConfigurationSpecInitProviderRootBlockDevice#deleteOnTermination
   */
  readonly deleteOnTermination?: boolean;

  /**
   * Whether the volume should be encrypted or not. Defaults to false.
   *
   * @default false.
   * @schema LaunchConfigurationSpecInitProviderRootBlockDevice#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * The amount of provisioned IOPS. This must be set with a volume_type of io1.
   *
   * @schema LaunchConfigurationSpecInitProviderRootBlockDevice#iops
   */
  readonly iops?: number;

  /**
   * The throughput (MiBps) to provision for a gp3 volume.
   *
   * @schema LaunchConfigurationSpecInitProviderRootBlockDevice#throughput
   */
  readonly throughput?: number;

  /**
   * The size of the volume in gigabytes.
   *
   * @schema LaunchConfigurationSpecInitProviderRootBlockDevice#volumeSize
   */
  readonly volumeSize?: number;

  /**
   * The type of volume. Can be standard, gp2, gp3, st1, sc1 or io1.
   *
   * @schema LaunchConfigurationSpecInitProviderRootBlockDevice#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'LaunchConfigurationSpecInitProviderRootBlockDevice' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpecInitProviderRootBlockDevice(obj: LaunchConfigurationSpecInitProviderRootBlockDevice | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteOnTermination': obj.deleteOnTermination,
    'encrypted': obj.encrypted,
    'iops': obj.iops,
    'throughput': obj.throughput,
    'volumeSize': obj.volumeSize,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LaunchConfigurationSpecProviderConfigRefPolicy
 */
export interface LaunchConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LaunchConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LaunchConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LaunchConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LaunchConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LaunchConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpecProviderConfigRefPolicy(obj: LaunchConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LaunchConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface LaunchConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LaunchConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LaunchConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LaunchConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LaunchConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpecPublishConnectionDetailsToConfigRef(obj: LaunchConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LaunchConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LaunchConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface LaunchConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LaunchConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LaunchConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LaunchConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LaunchConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpecPublishConnectionDetailsToMetadata(obj: LaunchConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LaunchConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum LaunchConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LaunchConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum LaunchConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LaunchConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LaunchConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LaunchConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LaunchConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LaunchConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LaunchConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LaunchConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LaunchConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: LaunchConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LaunchConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LaunchConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LaunchConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LaunchConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LifecycleHook is the Schema for the LifecycleHooks API. Provides an AutoScaling Lifecycle Hook resource.
 *
 * @schema LifecycleHook
 */
export class LifecycleHook extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LifecycleHook"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'autoscaling.aws.upbound.io/v1beta1',
    kind: 'LifecycleHook',
  }

  /**
   * Renders a Kubernetes manifest for "LifecycleHook".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LifecycleHookProps): any {
    return {
      ...LifecycleHook.GVK,
      ...toJson_LifecycleHookProps(props),
    };
  }

  /**
   * Defines a "LifecycleHook" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LifecycleHookProps) {
    super(scope, id, {
      ...LifecycleHook.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LifecycleHook.GVK,
      ...toJson_LifecycleHookProps(resolved),
    };
  }
}

/**
 * LifecycleHook is the Schema for the LifecycleHooks API. Provides an AutoScaling Lifecycle Hook resource.
 *
 * @schema LifecycleHook
 */
export interface LifecycleHookProps {
  /**
   * @schema LifecycleHook#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LifecycleHookSpec defines the desired state of LifecycleHook
   *
   * @schema LifecycleHook#spec
   */
  readonly spec: LifecycleHookSpec;

}

/**
 * Converts an object of type 'LifecycleHookProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookProps(obj: LifecycleHookProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LifecycleHookSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LifecycleHookSpec defines the desired state of LifecycleHook
 *
 * @schema LifecycleHookSpec
 */
export interface LifecycleHookSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LifecycleHookSpec#deletionPolicy
   */
  readonly deletionPolicy?: LifecycleHookSpecDeletionPolicy;

  /**
   * @schema LifecycleHookSpec#forProvider
   */
  readonly forProvider: LifecycleHookSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema LifecycleHookSpec#initProvider
   */
  readonly initProvider?: LifecycleHookSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema LifecycleHookSpec#managementPolicies
   */
  readonly managementPolicies?: LifecycleHookSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LifecycleHookSpec#providerConfigRef
   */
  readonly providerConfigRef?: LifecycleHookSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LifecycleHookSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LifecycleHookSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LifecycleHookSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LifecycleHookSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LifecycleHookSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpec(obj: LifecycleHookSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LifecycleHookSpecForProvider(obj.forProvider),
    'initProvider': toJson_LifecycleHookSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_LifecycleHookSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_LifecycleHookSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LifecycleHookSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LifecycleHookSpecDeletionPolicy
 */
export enum LifecycleHookSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LifecycleHookSpecForProvider
 */
export interface LifecycleHookSpecForProvider {
  /**
   * Name of the Auto Scaling group to which you want to assign the lifecycle hook
   *
   * @schema LifecycleHookSpecForProvider#autoscalingGroupName
   */
  readonly autoscalingGroupName?: string;

  /**
   * Reference to a AutoscalingGroup in autoscaling to populate autoscalingGroupName.
   *
   * @schema LifecycleHookSpecForProvider#autoscalingGroupNameRef
   */
  readonly autoscalingGroupNameRef?: LifecycleHookSpecForProviderAutoscalingGroupNameRef;

  /**
   * Selector for a AutoscalingGroup in autoscaling to populate autoscalingGroupName.
   *
   * @schema LifecycleHookSpecForProvider#autoscalingGroupNameSelector
   */
  readonly autoscalingGroupNameSelector?: LifecycleHookSpecForProviderAutoscalingGroupNameSelector;

  /**
   * Defines the action the Auto Scaling group should take when the lifecycle hook timeout elapses or if an unexpected failure occurs. The value for this parameter can be either CONTINUE or ABANDON. The default value for this parameter is ABANDON.
   *
   * @schema LifecycleHookSpecForProvider#defaultResult
   */
  readonly defaultResult?: string;

  /**
   * Defines the amount of time, in seconds, that can elapse before the lifecycle hook times out. When the lifecycle hook times out, Auto Scaling performs the action defined in the DefaultResult parameter
   *
   * @schema LifecycleHookSpecForProvider#heartbeatTimeout
   */
  readonly heartbeatTimeout?: number;

  /**
   * Instance state to which you want to attach the lifecycle hook. For a list of lifecycle hook types, see describe-lifecycle-hook-types
   *
   * @schema LifecycleHookSpecForProvider#lifecycleTransition
   */
  readonly lifecycleTransition?: string;

  /**
   * Contains additional information that you want to include any time Auto Scaling sends a message to the notification target.
   *
   * @schema LifecycleHookSpecForProvider#notificationMetadata
   */
  readonly notificationMetadata?: string;

  /**
   * ARN of the notification target that Auto Scaling will use to notify you when an instance is in the transition state for the lifecycle hook. This ARN target can be either an SQS queue or an SNS topic.
   *
   * @schema LifecycleHookSpecForProvider#notificationTargetArn
   */
  readonly notificationTargetArn?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LifecycleHookSpecForProvider#region
   */
  readonly region: string;

  /**
   * ARN of the IAM role that allows the Auto Scaling group to publish to the specified notification target.
   *
   * @schema LifecycleHookSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema LifecycleHookSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: LifecycleHookSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema LifecycleHookSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: LifecycleHookSpecForProviderRoleArnSelector;

}

/**
 * Converts an object of type 'LifecycleHookSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpecForProvider(obj: LifecycleHookSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoscalingGroupName': obj.autoscalingGroupName,
    'autoscalingGroupNameRef': toJson_LifecycleHookSpecForProviderAutoscalingGroupNameRef(obj.autoscalingGroupNameRef),
    'autoscalingGroupNameSelector': toJson_LifecycleHookSpecForProviderAutoscalingGroupNameSelector(obj.autoscalingGroupNameSelector),
    'defaultResult': obj.defaultResult,
    'heartbeatTimeout': obj.heartbeatTimeout,
    'lifecycleTransition': obj.lifecycleTransition,
    'notificationMetadata': obj.notificationMetadata,
    'notificationTargetArn': obj.notificationTargetArn,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_LifecycleHookSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_LifecycleHookSpecForProviderRoleArnSelector(obj.roleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema LifecycleHookSpecInitProvider
 */
export interface LifecycleHookSpecInitProvider {
  /**
   * Defines the action the Auto Scaling group should take when the lifecycle hook timeout elapses or if an unexpected failure occurs. The value for this parameter can be either CONTINUE or ABANDON. The default value for this parameter is ABANDON.
   *
   * @schema LifecycleHookSpecInitProvider#defaultResult
   */
  readonly defaultResult?: string;

  /**
   * Defines the amount of time, in seconds, that can elapse before the lifecycle hook times out. When the lifecycle hook times out, Auto Scaling performs the action defined in the DefaultResult parameter
   *
   * @schema LifecycleHookSpecInitProvider#heartbeatTimeout
   */
  readonly heartbeatTimeout?: number;

  /**
   * Instance state to which you want to attach the lifecycle hook. For a list of lifecycle hook types, see describe-lifecycle-hook-types
   *
   * @schema LifecycleHookSpecInitProvider#lifecycleTransition
   */
  readonly lifecycleTransition?: string;

  /**
   * Contains additional information that you want to include any time Auto Scaling sends a message to the notification target.
   *
   * @schema LifecycleHookSpecInitProvider#notificationMetadata
   */
  readonly notificationMetadata?: string;

  /**
   * ARN of the notification target that Auto Scaling will use to notify you when an instance is in the transition state for the lifecycle hook. This ARN target can be either an SQS queue or an SNS topic.
   *
   * @schema LifecycleHookSpecInitProvider#notificationTargetArn
   */
  readonly notificationTargetArn?: string;

}

/**
 * Converts an object of type 'LifecycleHookSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpecInitProvider(obj: LifecycleHookSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultResult': obj.defaultResult,
    'heartbeatTimeout': obj.heartbeatTimeout,
    'lifecycleTransition': obj.lifecycleTransition,
    'notificationMetadata': obj.notificationMetadata,
    'notificationTargetArn': obj.notificationTargetArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema LifecycleHookSpecManagementPolicies
 */
export enum LifecycleHookSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LifecycleHookSpecProviderConfigRef
 */
export interface LifecycleHookSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LifecycleHookSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LifecycleHookSpecProviderConfigRef#policy
   */
  readonly policy?: LifecycleHookSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LifecycleHookSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpecProviderConfigRef(obj: LifecycleHookSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LifecycleHookSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LifecycleHookSpecPublishConnectionDetailsTo
 */
export interface LifecycleHookSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LifecycleHookSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LifecycleHookSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LifecycleHookSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LifecycleHookSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LifecycleHookSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LifecycleHookSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpecPublishConnectionDetailsTo(obj: LifecycleHookSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LifecycleHookSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LifecycleHookSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LifecycleHookSpecWriteConnectionSecretToRef
 */
export interface LifecycleHookSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LifecycleHookSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LifecycleHookSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LifecycleHookSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpecWriteConnectionSecretToRef(obj: LifecycleHookSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a AutoscalingGroup in autoscaling to populate autoscalingGroupName.
 *
 * @schema LifecycleHookSpecForProviderAutoscalingGroupNameRef
 */
export interface LifecycleHookSpecForProviderAutoscalingGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema LifecycleHookSpecForProviderAutoscalingGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LifecycleHookSpecForProviderAutoscalingGroupNameRef#policy
   */
  readonly policy?: LifecycleHookSpecForProviderAutoscalingGroupNameRefPolicy;

}

/**
 * Converts an object of type 'LifecycleHookSpecForProviderAutoscalingGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpecForProviderAutoscalingGroupNameRef(obj: LifecycleHookSpecForProviderAutoscalingGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LifecycleHookSpecForProviderAutoscalingGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a AutoscalingGroup in autoscaling to populate autoscalingGroupName.
 *
 * @schema LifecycleHookSpecForProviderAutoscalingGroupNameSelector
 */
export interface LifecycleHookSpecForProviderAutoscalingGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LifecycleHookSpecForProviderAutoscalingGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LifecycleHookSpecForProviderAutoscalingGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LifecycleHookSpecForProviderAutoscalingGroupNameSelector#policy
   */
  readonly policy?: LifecycleHookSpecForProviderAutoscalingGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'LifecycleHookSpecForProviderAutoscalingGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpecForProviderAutoscalingGroupNameSelector(obj: LifecycleHookSpecForProviderAutoscalingGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LifecycleHookSpecForProviderAutoscalingGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema LifecycleHookSpecForProviderRoleArnRef
 */
export interface LifecycleHookSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LifecycleHookSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LifecycleHookSpecForProviderRoleArnRef#policy
   */
  readonly policy?: LifecycleHookSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'LifecycleHookSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpecForProviderRoleArnRef(obj: LifecycleHookSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LifecycleHookSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema LifecycleHookSpecForProviderRoleArnSelector
 */
export interface LifecycleHookSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LifecycleHookSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LifecycleHookSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LifecycleHookSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: LifecycleHookSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'LifecycleHookSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpecForProviderRoleArnSelector(obj: LifecycleHookSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LifecycleHookSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LifecycleHookSpecProviderConfigRefPolicy
 */
export interface LifecycleHookSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecycleHookSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LifecycleHookSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecycleHookSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LifecycleHookSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LifecycleHookSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpecProviderConfigRefPolicy(obj: LifecycleHookSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LifecycleHookSpecPublishConnectionDetailsToConfigRef
 */
export interface LifecycleHookSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LifecycleHookSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LifecycleHookSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LifecycleHookSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LifecycleHookSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpecPublishConnectionDetailsToConfigRef(obj: LifecycleHookSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LifecycleHookSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LifecycleHookSpecPublishConnectionDetailsToMetadata
 */
export interface LifecycleHookSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LifecycleHookSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LifecycleHookSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LifecycleHookSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LifecycleHookSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpecPublishConnectionDetailsToMetadata(obj: LifecycleHookSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LifecycleHookSpecForProviderAutoscalingGroupNameRefPolicy
 */
export interface LifecycleHookSpecForProviderAutoscalingGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecycleHookSpecForProviderAutoscalingGroupNameRefPolicy#resolution
   */
  readonly resolution?: LifecycleHookSpecForProviderAutoscalingGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecycleHookSpecForProviderAutoscalingGroupNameRefPolicy#resolve
   */
  readonly resolve?: LifecycleHookSpecForProviderAutoscalingGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'LifecycleHookSpecForProviderAutoscalingGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpecForProviderAutoscalingGroupNameRefPolicy(obj: LifecycleHookSpecForProviderAutoscalingGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LifecycleHookSpecForProviderAutoscalingGroupNameSelectorPolicy
 */
export interface LifecycleHookSpecForProviderAutoscalingGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecycleHookSpecForProviderAutoscalingGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: LifecycleHookSpecForProviderAutoscalingGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecycleHookSpecForProviderAutoscalingGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: LifecycleHookSpecForProviderAutoscalingGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LifecycleHookSpecForProviderAutoscalingGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpecForProviderAutoscalingGroupNameSelectorPolicy(obj: LifecycleHookSpecForProviderAutoscalingGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LifecycleHookSpecForProviderRoleArnRefPolicy
 */
export interface LifecycleHookSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecycleHookSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: LifecycleHookSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecycleHookSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: LifecycleHookSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LifecycleHookSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpecForProviderRoleArnRefPolicy(obj: LifecycleHookSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LifecycleHookSpecForProviderRoleArnSelectorPolicy
 */
export interface LifecycleHookSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecycleHookSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: LifecycleHookSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecycleHookSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: LifecycleHookSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LifecycleHookSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpecForProviderRoleArnSelectorPolicy(obj: LifecycleHookSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecycleHookSpecProviderConfigRefPolicyResolution
 */
export enum LifecycleHookSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecycleHookSpecProviderConfigRefPolicyResolve
 */
export enum LifecycleHookSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LifecycleHookSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LifecycleHookSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecycleHookSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LifecycleHookSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecycleHookSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LifecycleHookSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LifecycleHookSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecycleHookSpecPublishConnectionDetailsToConfigRefPolicy(obj: LifecycleHookSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecycleHookSpecForProviderAutoscalingGroupNameRefPolicyResolution
 */
export enum LifecycleHookSpecForProviderAutoscalingGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecycleHookSpecForProviderAutoscalingGroupNameRefPolicyResolve
 */
export enum LifecycleHookSpecForProviderAutoscalingGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecycleHookSpecForProviderAutoscalingGroupNameSelectorPolicyResolution
 */
export enum LifecycleHookSpecForProviderAutoscalingGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecycleHookSpecForProviderAutoscalingGroupNameSelectorPolicyResolve
 */
export enum LifecycleHookSpecForProviderAutoscalingGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecycleHookSpecForProviderRoleArnRefPolicyResolution
 */
export enum LifecycleHookSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecycleHookSpecForProviderRoleArnRefPolicyResolve
 */
export enum LifecycleHookSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecycleHookSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum LifecycleHookSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecycleHookSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum LifecycleHookSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecycleHookSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LifecycleHookSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecycleHookSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LifecycleHookSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Notification is the Schema for the Notifications API. Provides an AutoScaling Group with Notification support
 *
 * @schema Notification
 */
export class Notification extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Notification"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'autoscaling.aws.upbound.io/v1beta1',
    kind: 'Notification',
  }

  /**
   * Renders a Kubernetes manifest for "Notification".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NotificationProps): any {
    return {
      ...Notification.GVK,
      ...toJson_NotificationProps(props),
    };
  }

  /**
   * Defines a "Notification" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NotificationProps) {
    super(scope, id, {
      ...Notification.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Notification.GVK,
      ...toJson_NotificationProps(resolved),
    };
  }
}

/**
 * Notification is the Schema for the Notifications API. Provides an AutoScaling Group with Notification support
 *
 * @schema Notification
 */
export interface NotificationProps {
  /**
   * @schema Notification#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NotificationSpec defines the desired state of Notification
   *
   * @schema Notification#spec
   */
  readonly spec: NotificationSpec;

}

/**
 * Converts an object of type 'NotificationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationProps(obj: NotificationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NotificationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NotificationSpec defines the desired state of Notification
 *
 * @schema NotificationSpec
 */
export interface NotificationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NotificationSpec#deletionPolicy
   */
  readonly deletionPolicy?: NotificationSpecDeletionPolicy;

  /**
   * @schema NotificationSpec#forProvider
   */
  readonly forProvider: NotificationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema NotificationSpec#initProvider
   */
  readonly initProvider?: NotificationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema NotificationSpec#managementPolicies
   */
  readonly managementPolicies?: NotificationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema NotificationSpec#providerConfigRef
   */
  readonly providerConfigRef?: NotificationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema NotificationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: NotificationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema NotificationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NotificationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'NotificationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpec(obj: NotificationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NotificationSpecForProvider(obj.forProvider),
    'initProvider': toJson_NotificationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_NotificationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_NotificationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_NotificationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NotificationSpecDeletionPolicy
 */
export enum NotificationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema NotificationSpecForProvider
 */
export interface NotificationSpecForProvider {
  /**
   * List of AutoScaling Group Names
   *
   * @schema NotificationSpecForProvider#groupNames
   */
  readonly groupNames?: string[];

  /**
   * List of Notification Types that trigger notifications. Acceptable values are documented in the AWS documentation here
   *
   * @schema NotificationSpecForProvider#notifications
   */
  readonly notifications?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema NotificationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Topic ARN for notifications to be sent through
   *
   * @schema NotificationSpecForProvider#topicArn
   */
  readonly topicArn?: string;

  /**
   * Reference to a Topic in sns to populate topicArn.
   *
   * @schema NotificationSpecForProvider#topicArnRef
   */
  readonly topicArnRef?: NotificationSpecForProviderTopicArnRef;

  /**
   * Selector for a Topic in sns to populate topicArn.
   *
   * @schema NotificationSpecForProvider#topicArnSelector
   */
  readonly topicArnSelector?: NotificationSpecForProviderTopicArnSelector;

}

/**
 * Converts an object of type 'NotificationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecForProvider(obj: NotificationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupNames': obj.groupNames?.map(y => y),
    'notifications': obj.notifications?.map(y => y),
    'region': obj.region,
    'topicArn': obj.topicArn,
    'topicArnRef': toJson_NotificationSpecForProviderTopicArnRef(obj.topicArnRef),
    'topicArnSelector': toJson_NotificationSpecForProviderTopicArnSelector(obj.topicArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema NotificationSpecInitProvider
 */
export interface NotificationSpecInitProvider {
  /**
   * List of AutoScaling Group Names
   *
   * @schema NotificationSpecInitProvider#groupNames
   */
  readonly groupNames?: string[];

  /**
   * List of Notification Types that trigger notifications. Acceptable values are documented in the AWS documentation here
   *
   * @schema NotificationSpecInitProvider#notifications
   */
  readonly notifications?: string[];

}

/**
 * Converts an object of type 'NotificationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecInitProvider(obj: NotificationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupNames': obj.groupNames?.map(y => y),
    'notifications': obj.notifications?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema NotificationSpecManagementPolicies
 */
export enum NotificationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema NotificationSpecProviderConfigRef
 */
export interface NotificationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotificationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotificationSpecProviderConfigRef#policy
   */
  readonly policy?: NotificationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'NotificationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecProviderConfigRef(obj: NotificationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotificationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema NotificationSpecPublishConnectionDetailsTo
 */
export interface NotificationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema NotificationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: NotificationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema NotificationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: NotificationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema NotificationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'NotificationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecPublishConnectionDetailsTo(obj: NotificationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_NotificationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_NotificationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema NotificationSpecWriteConnectionSecretToRef
 */
export interface NotificationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NotificationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NotificationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NotificationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecWriteConnectionSecretToRef(obj: NotificationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate topicArn.
 *
 * @schema NotificationSpecForProviderTopicArnRef
 */
export interface NotificationSpecForProviderTopicArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotificationSpecForProviderTopicArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotificationSpecForProviderTopicArnRef#policy
   */
  readonly policy?: NotificationSpecForProviderTopicArnRefPolicy;

}

/**
 * Converts an object of type 'NotificationSpecForProviderTopicArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecForProviderTopicArnRef(obj: NotificationSpecForProviderTopicArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotificationSpecForProviderTopicArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate topicArn.
 *
 * @schema NotificationSpecForProviderTopicArnSelector
 */
export interface NotificationSpecForProviderTopicArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NotificationSpecForProviderTopicArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NotificationSpecForProviderTopicArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NotificationSpecForProviderTopicArnSelector#policy
   */
  readonly policy?: NotificationSpecForProviderTopicArnSelectorPolicy;

}

/**
 * Converts an object of type 'NotificationSpecForProviderTopicArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecForProviderTopicArnSelector(obj: NotificationSpecForProviderTopicArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NotificationSpecForProviderTopicArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NotificationSpecProviderConfigRefPolicy
 */
export interface NotificationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NotificationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NotificationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NotificationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecProviderConfigRefPolicy(obj: NotificationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema NotificationSpecPublishConnectionDetailsToConfigRef
 */
export interface NotificationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotificationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotificationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: NotificationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'NotificationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecPublishConnectionDetailsToConfigRef(obj: NotificationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotificationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema NotificationSpecPublishConnectionDetailsToMetadata
 */
export interface NotificationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema NotificationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema NotificationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema NotificationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NotificationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecPublishConnectionDetailsToMetadata(obj: NotificationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NotificationSpecForProviderTopicArnRefPolicy
 */
export interface NotificationSpecForProviderTopicArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationSpecForProviderTopicArnRefPolicy#resolution
   */
  readonly resolution?: NotificationSpecForProviderTopicArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationSpecForProviderTopicArnRefPolicy#resolve
   */
  readonly resolve?: NotificationSpecForProviderTopicArnRefPolicyResolve;

}

/**
 * Converts an object of type 'NotificationSpecForProviderTopicArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecForProviderTopicArnRefPolicy(obj: NotificationSpecForProviderTopicArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NotificationSpecForProviderTopicArnSelectorPolicy
 */
export interface NotificationSpecForProviderTopicArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationSpecForProviderTopicArnSelectorPolicy#resolution
   */
  readonly resolution?: NotificationSpecForProviderTopicArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationSpecForProviderTopicArnSelectorPolicy#resolve
   */
  readonly resolve?: NotificationSpecForProviderTopicArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NotificationSpecForProviderTopicArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecForProviderTopicArnSelectorPolicy(obj: NotificationSpecForProviderTopicArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationSpecProviderConfigRefPolicyResolution
 */
export enum NotificationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationSpecProviderConfigRefPolicyResolve
 */
export enum NotificationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NotificationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface NotificationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: NotificationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: NotificationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NotificationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationSpecPublishConnectionDetailsToConfigRefPolicy(obj: NotificationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationSpecForProviderTopicArnRefPolicyResolution
 */
export enum NotificationSpecForProviderTopicArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationSpecForProviderTopicArnRefPolicyResolve
 */
export enum NotificationSpecForProviderTopicArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationSpecForProviderTopicArnSelectorPolicyResolution
 */
export enum NotificationSpecForProviderTopicArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationSpecForProviderTopicArnSelectorPolicyResolve
 */
export enum NotificationSpecForProviderTopicArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum NotificationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum NotificationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Policy is the Schema for the Policys API. Provides an AutoScaling Scaling Group resource.
 *
 * @schema Policy
 */
export class Policy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Policy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'autoscaling.aws.upbound.io/v1beta1',
    kind: 'Policy',
  }

  /**
   * Renders a Kubernetes manifest for "Policy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PolicyProps): any {
    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(props),
    };
  }

  /**
   * Defines a "Policy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PolicyProps) {
    super(scope, id, {
      ...Policy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(resolved),
    };
  }
}

/**
 * Policy is the Schema for the Policys API. Provides an AutoScaling Scaling Group resource.
 *
 * @schema Policy
 */
export interface PolicyProps {
  /**
   * @schema Policy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PolicySpec defines the desired state of Policy
   *
   * @schema Policy#spec
   */
  readonly spec: PolicySpec;

}

/**
 * Converts an object of type 'PolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyProps(obj: PolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicySpec defines the desired state of Policy
 *
 * @schema PolicySpec
 */
export interface PolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: PolicySpecDeletionPolicy;

  /**
   * @schema PolicySpec#forProvider
   */
  readonly forProvider: PolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema PolicySpec#initProvider
   */
  readonly initProvider?: PolicySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PolicySpec#managementPolicies
   */
  readonly managementPolicies?: PolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: PolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpec(obj: PolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_PolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PolicySpecDeletionPolicy
 */
export enum PolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PolicySpecForProvider
 */
export interface PolicySpecForProvider {
  /**
   * Whether the adjustment is an absolute number or a percentage of the current capacity. Valid values are ChangeInCapacity, ExactCapacity, and PercentChangeInCapacity.
   *
   * @schema PolicySpecForProvider#adjustmentType
   */
  readonly adjustmentType?: string;

  /**
   * Name of the autoscaling group.
   *
   * @schema PolicySpecForProvider#autoscalingGroupName
   */
  readonly autoscalingGroupName?: string;

  /**
   * Reference to a AutoscalingGroup in autoscaling to populate autoscalingGroupName.
   *
   * @schema PolicySpecForProvider#autoscalingGroupNameRef
   */
  readonly autoscalingGroupNameRef?: PolicySpecForProviderAutoscalingGroupNameRef;

  /**
   * Selector for a AutoscalingGroup in autoscaling to populate autoscalingGroupName.
   *
   * @schema PolicySpecForProvider#autoscalingGroupNameSelector
   */
  readonly autoscalingGroupNameSelector?: PolicySpecForProviderAutoscalingGroupNameSelector;

  /**
   * Amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
   *
   * @schema PolicySpecForProvider#cooldown
   */
  readonly cooldown?: number;

  /**
   * Whether the scaling policy is enabled or disabled. Default: true.
   *
   * @schema PolicySpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Estimated time, in seconds, until a newly launched instance will contribute CloudWatch metrics. Without a value, AWS will default to the group's specified cooldown period.
   *
   * @schema PolicySpecForProvider#estimatedInstanceWarmup
   */
  readonly estimatedInstanceWarmup?: number;

  /**
   * Aggregation type for the policy's metrics. Valid values are "Minimum", "Maximum", and "Average". Without a value, AWS will treat the aggregation type as "Average".
   *
   * @schema PolicySpecForProvider#metricAggregationType
   */
  readonly metricAggregationType?: string;

  /**
   * Minimum value to scale by when adjustment_type is set to PercentChangeInCapacity.
   *
   * @schema PolicySpecForProvider#minAdjustmentMagnitude
   */
  readonly minAdjustmentMagnitude?: number;

  /**
   * Policy type, either "SimpleScaling", "StepScaling", "TargetTrackingScaling", or "PredictiveScaling". If this value isn't provided, AWS will default to "SimpleScaling."
   *
   * @schema PolicySpecForProvider#policyType
   */
  readonly policyType?: string;

  /**
   * Predictive scaling policy configuration to use with Amazon EC2 Auto Scaling.
   *
   * @schema PolicySpecForProvider#predictiveScalingConfiguration
   */
  readonly predictiveScalingConfiguration?: PolicySpecForProviderPredictiveScalingConfiguration[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * Number of instances by which to scale. adjustment_type determines the interpretation of this number (e.g., as an absolute number or as a percentage of the existing Auto Scaling group size). A positive increment adds to the current capacity and a negative value removes from the current capacity.
   *
   * @schema PolicySpecForProvider#scalingAdjustment
   */
  readonly scalingAdjustment?: number;

  /**
   * Set of adjustments that manage group scaling. These have the following structure:
   *
   * @schema PolicySpecForProvider#stepAdjustment
   */
  readonly stepAdjustment?: PolicySpecForProviderStepAdjustment[];

  /**
   * Target tracking policy. These have the following structure:
   *
   * @schema PolicySpecForProvider#targetTrackingConfiguration
   */
  readonly targetTrackingConfiguration?: PolicySpecForProviderTargetTrackingConfiguration[];

}

/**
 * Converts an object of type 'PolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProvider(obj: PolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adjustmentType': obj.adjustmentType,
    'autoscalingGroupName': obj.autoscalingGroupName,
    'autoscalingGroupNameRef': toJson_PolicySpecForProviderAutoscalingGroupNameRef(obj.autoscalingGroupNameRef),
    'autoscalingGroupNameSelector': toJson_PolicySpecForProviderAutoscalingGroupNameSelector(obj.autoscalingGroupNameSelector),
    'cooldown': obj.cooldown,
    'enabled': obj.enabled,
    'estimatedInstanceWarmup': obj.estimatedInstanceWarmup,
    'metricAggregationType': obj.metricAggregationType,
    'minAdjustmentMagnitude': obj.minAdjustmentMagnitude,
    'policyType': obj.policyType,
    'predictiveScalingConfiguration': obj.predictiveScalingConfiguration?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfiguration(y)),
    'region': obj.region,
    'scalingAdjustment': obj.scalingAdjustment,
    'stepAdjustment': obj.stepAdjustment?.map(y => toJson_PolicySpecForProviderStepAdjustment(y)),
    'targetTrackingConfiguration': obj.targetTrackingConfiguration?.map(y => toJson_PolicySpecForProviderTargetTrackingConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema PolicySpecInitProvider
 */
export interface PolicySpecInitProvider {
  /**
   * Whether the adjustment is an absolute number or a percentage of the current capacity. Valid values are ChangeInCapacity, ExactCapacity, and PercentChangeInCapacity.
   *
   * @schema PolicySpecInitProvider#adjustmentType
   */
  readonly adjustmentType?: string;

  /**
   * Amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
   *
   * @schema PolicySpecInitProvider#cooldown
   */
  readonly cooldown?: number;

  /**
   * Whether the scaling policy is enabled or disabled. Default: true.
   *
   * @schema PolicySpecInitProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Estimated time, in seconds, until a newly launched instance will contribute CloudWatch metrics. Without a value, AWS will default to the group's specified cooldown period.
   *
   * @schema PolicySpecInitProvider#estimatedInstanceWarmup
   */
  readonly estimatedInstanceWarmup?: number;

  /**
   * Aggregation type for the policy's metrics. Valid values are "Minimum", "Maximum", and "Average". Without a value, AWS will treat the aggregation type as "Average".
   *
   * @schema PolicySpecInitProvider#metricAggregationType
   */
  readonly metricAggregationType?: string;

  /**
   * Minimum value to scale by when adjustment_type is set to PercentChangeInCapacity.
   *
   * @schema PolicySpecInitProvider#minAdjustmentMagnitude
   */
  readonly minAdjustmentMagnitude?: number;

  /**
   * Policy type, either "SimpleScaling", "StepScaling", "TargetTrackingScaling", or "PredictiveScaling". If this value isn't provided, AWS will default to "SimpleScaling."
   *
   * @schema PolicySpecInitProvider#policyType
   */
  readonly policyType?: string;

  /**
   * Predictive scaling policy configuration to use with Amazon EC2 Auto Scaling.
   *
   * @schema PolicySpecInitProvider#predictiveScalingConfiguration
   */
  readonly predictiveScalingConfiguration?: PolicySpecInitProviderPredictiveScalingConfiguration[];

  /**
   * Number of instances by which to scale. adjustment_type determines the interpretation of this number (e.g., as an absolute number or as a percentage of the existing Auto Scaling group size). A positive increment adds to the current capacity and a negative value removes from the current capacity.
   *
   * @schema PolicySpecInitProvider#scalingAdjustment
   */
  readonly scalingAdjustment?: number;

  /**
   * Set of adjustments that manage group scaling. These have the following structure:
   *
   * @schema PolicySpecInitProvider#stepAdjustment
   */
  readonly stepAdjustment?: PolicySpecInitProviderStepAdjustment[];

  /**
   * Target tracking policy. These have the following structure:
   *
   * @schema PolicySpecInitProvider#targetTrackingConfiguration
   */
  readonly targetTrackingConfiguration?: PolicySpecInitProviderTargetTrackingConfiguration[];

}

/**
 * Converts an object of type 'PolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProvider(obj: PolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adjustmentType': obj.adjustmentType,
    'cooldown': obj.cooldown,
    'enabled': obj.enabled,
    'estimatedInstanceWarmup': obj.estimatedInstanceWarmup,
    'metricAggregationType': obj.metricAggregationType,
    'minAdjustmentMagnitude': obj.minAdjustmentMagnitude,
    'policyType': obj.policyType,
    'predictiveScalingConfiguration': obj.predictiveScalingConfiguration?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfiguration(y)),
    'scalingAdjustment': obj.scalingAdjustment,
    'stepAdjustment': obj.stepAdjustment?.map(y => toJson_PolicySpecInitProviderStepAdjustment(y)),
    'targetTrackingConfiguration': obj.targetTrackingConfiguration?.map(y => toJson_PolicySpecInitProviderTargetTrackingConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PolicySpecManagementPolicies
 */
export enum PolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PolicySpecProviderConfigRef
 */
export interface PolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecProviderConfigRef#policy
   */
  readonly policy?: PolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRef(obj: PolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PolicySpecPublishConnectionDetailsTo
 */
export interface PolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsTo(obj: PolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PolicySpecWriteConnectionSecretToRef
 */
export interface PolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecWriteConnectionSecretToRef(obj: PolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a AutoscalingGroup in autoscaling to populate autoscalingGroupName.
 *
 * @schema PolicySpecForProviderAutoscalingGroupNameRef
 */
export interface PolicySpecForProviderAutoscalingGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecForProviderAutoscalingGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecForProviderAutoscalingGroupNameRef#policy
   */
  readonly policy?: PolicySpecForProviderAutoscalingGroupNameRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderAutoscalingGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderAutoscalingGroupNameRef(obj: PolicySpecForProviderAutoscalingGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecForProviderAutoscalingGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a AutoscalingGroup in autoscaling to populate autoscalingGroupName.
 *
 * @schema PolicySpecForProviderAutoscalingGroupNameSelector
 */
export interface PolicySpecForProviderAutoscalingGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PolicySpecForProviderAutoscalingGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PolicySpecForProviderAutoscalingGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PolicySpecForProviderAutoscalingGroupNameSelector#policy
   */
  readonly policy?: PolicySpecForProviderAutoscalingGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderAutoscalingGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderAutoscalingGroupNameSelector(obj: PolicySpecForProviderAutoscalingGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PolicySpecForProviderAutoscalingGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfiguration
 */
export interface PolicySpecForProviderPredictiveScalingConfiguration {
  /**
   * Defines the behavior that should be applied if the forecast capacity approaches or exceeds the maximum capacity of the Auto Scaling group. Valid values are HonorMaxCapacity or IncreaseMaxCapacity. Default is HonorMaxCapacity.
   *
   * @default HonorMaxCapacity.
   * @schema PolicySpecForProviderPredictiveScalingConfiguration#maxCapacityBreachBehavior
   */
  readonly maxCapacityBreachBehavior?: string;

  /**
   * Size of the capacity buffer to use when the forecast capacity is close to or exceeds the maximum capacity. Valid range is 0 to 100. If set to 0, Amazon EC2 Auto Scaling may scale capacity higher than the maximum capacity to equal but not exceed forecast capacity.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfiguration#maxCapacityBuffer
   */
  readonly maxCapacityBuffer?: string;

  /**
   * This structure includes the metrics and target utilization to use for predictive scaling.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfiguration#metricSpecification
   */
  readonly metricSpecification?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecification[];

  /**
   * Predictive scaling mode. Valid values are ForecastAndScale and ForecastOnly. Default is ForecastOnly.
   *
   * @default ForecastOnly.
   * @schema PolicySpecForProviderPredictiveScalingConfiguration#mode
   */
  readonly mode?: string;

  /**
   * Amount of time, in seconds, by which the instance launch time can be advanced. Minimum is 0.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfiguration#schedulingBufferTime
   */
  readonly schedulingBufferTime?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfiguration(obj: PolicySpecForProviderPredictiveScalingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxCapacityBreachBehavior': obj.maxCapacityBreachBehavior,
    'maxCapacityBuffer': obj.maxCapacityBuffer,
    'metricSpecification': obj.metricSpecification?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecification(y)),
    'mode': obj.mode,
    'schedulingBufferTime': obj.schedulingBufferTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderStepAdjustment
 */
export interface PolicySpecForProviderStepAdjustment {
  /**
   * Lower bound for the difference between the alarm threshold and the CloudWatch metric. Without a value, AWS will treat this bound as negative infinity.
   *
   * @schema PolicySpecForProviderStepAdjustment#metricIntervalLowerBound
   */
  readonly metricIntervalLowerBound?: string;

  /**
   * Upper bound for the difference between the alarm threshold and the CloudWatch metric. Without a value, AWS will treat this bound as positive infinity. The upper bound must be greater than the lower bound.
   *
   * @schema PolicySpecForProviderStepAdjustment#metricIntervalUpperBound
   */
  readonly metricIntervalUpperBound?: string;

  /**
   * Number of instances by which to scale. adjustment_type determines the interpretation of this number (e.g., as an absolute number or as a percentage of the existing Auto Scaling group size). A positive increment adds to the current capacity and a negative value removes from the current capacity.
   *
   * @schema PolicySpecForProviderStepAdjustment#scalingAdjustment
   */
  readonly scalingAdjustment?: number;

}

/**
 * Converts an object of type 'PolicySpecForProviderStepAdjustment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderStepAdjustment(obj: PolicySpecForProviderStepAdjustment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricIntervalLowerBound': obj.metricIntervalLowerBound,
    'metricIntervalUpperBound': obj.metricIntervalUpperBound,
    'scalingAdjustment': obj.scalingAdjustment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingConfiguration
 */
export interface PolicySpecForProviderTargetTrackingConfiguration {
  /**
   * Customized metric. Conflicts with predefined_metric_specification.
   *
   * @schema PolicySpecForProviderTargetTrackingConfiguration#customizedMetricSpecification
   */
  readonly customizedMetricSpecification?: PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecification[];

  /**
   * Whether scale in by the target tracking policy is disabled.
   *
   * @schema PolicySpecForProviderTargetTrackingConfiguration#disableScaleIn
   */
  readonly disableScaleIn?: boolean;

  /**
   * Predefined metric. Conflicts with customized_metric_specification.
   *
   * @schema PolicySpecForProviderTargetTrackingConfiguration#predefinedMetricSpecification
   */
  readonly predefinedMetricSpecification?: PolicySpecForProviderTargetTrackingConfigurationPredefinedMetricSpecification[];

  /**
   * Target value for the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingConfiguration#targetValue
   */
  readonly targetValue?: number;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingConfiguration(obj: PolicySpecForProviderTargetTrackingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customizedMetricSpecification': obj.customizedMetricSpecification?.map(y => toJson_PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecification(y)),
    'disableScaleIn': obj.disableScaleIn,
    'predefinedMetricSpecification': obj.predefinedMetricSpecification?.map(y => toJson_PolicySpecForProviderTargetTrackingConfigurationPredefinedMetricSpecification(y)),
    'targetValue': obj.targetValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfiguration
 */
export interface PolicySpecInitProviderPredictiveScalingConfiguration {
  /**
   * Defines the behavior that should be applied if the forecast capacity approaches or exceeds the maximum capacity of the Auto Scaling group. Valid values are HonorMaxCapacity or IncreaseMaxCapacity. Default is HonorMaxCapacity.
   *
   * @default HonorMaxCapacity.
   * @schema PolicySpecInitProviderPredictiveScalingConfiguration#maxCapacityBreachBehavior
   */
  readonly maxCapacityBreachBehavior?: string;

  /**
   * Size of the capacity buffer to use when the forecast capacity is close to or exceeds the maximum capacity. Valid range is 0 to 100. If set to 0, Amazon EC2 Auto Scaling may scale capacity higher than the maximum capacity to equal but not exceed forecast capacity.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfiguration#maxCapacityBuffer
   */
  readonly maxCapacityBuffer?: string;

  /**
   * This structure includes the metrics and target utilization to use for predictive scaling.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfiguration#metricSpecification
   */
  readonly metricSpecification?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecification[];

  /**
   * Predictive scaling mode. Valid values are ForecastAndScale and ForecastOnly. Default is ForecastOnly.
   *
   * @default ForecastOnly.
   * @schema PolicySpecInitProviderPredictiveScalingConfiguration#mode
   */
  readonly mode?: string;

  /**
   * Amount of time, in seconds, by which the instance launch time can be advanced. Minimum is 0.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfiguration#schedulingBufferTime
   */
  readonly schedulingBufferTime?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfiguration(obj: PolicySpecInitProviderPredictiveScalingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxCapacityBreachBehavior': obj.maxCapacityBreachBehavior,
    'maxCapacityBuffer': obj.maxCapacityBuffer,
    'metricSpecification': obj.metricSpecification?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecification(y)),
    'mode': obj.mode,
    'schedulingBufferTime': obj.schedulingBufferTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderStepAdjustment
 */
export interface PolicySpecInitProviderStepAdjustment {
  /**
   * Lower bound for the difference between the alarm threshold and the CloudWatch metric. Without a value, AWS will treat this bound as negative infinity.
   *
   * @schema PolicySpecInitProviderStepAdjustment#metricIntervalLowerBound
   */
  readonly metricIntervalLowerBound?: string;

  /**
   * Upper bound for the difference between the alarm threshold and the CloudWatch metric. Without a value, AWS will treat this bound as positive infinity. The upper bound must be greater than the lower bound.
   *
   * @schema PolicySpecInitProviderStepAdjustment#metricIntervalUpperBound
   */
  readonly metricIntervalUpperBound?: string;

  /**
   * Number of instances by which to scale. adjustment_type determines the interpretation of this number (e.g., as an absolute number or as a percentage of the existing Auto Scaling group size). A positive increment adds to the current capacity and a negative value removes from the current capacity.
   *
   * @schema PolicySpecInitProviderStepAdjustment#scalingAdjustment
   */
  readonly scalingAdjustment?: number;

}

/**
 * Converts an object of type 'PolicySpecInitProviderStepAdjustment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderStepAdjustment(obj: PolicySpecInitProviderStepAdjustment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricIntervalLowerBound': obj.metricIntervalLowerBound,
    'metricIntervalUpperBound': obj.metricIntervalUpperBound,
    'scalingAdjustment': obj.scalingAdjustment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderTargetTrackingConfiguration
 */
export interface PolicySpecInitProviderTargetTrackingConfiguration {
  /**
   * Customized metric. Conflicts with predefined_metric_specification.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfiguration#customizedMetricSpecification
   */
  readonly customizedMetricSpecification?: PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecification[];

  /**
   * Whether scale in by the target tracking policy is disabled.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfiguration#disableScaleIn
   */
  readonly disableScaleIn?: boolean;

  /**
   * Predefined metric. Conflicts with customized_metric_specification.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfiguration#predefinedMetricSpecification
   */
  readonly predefinedMetricSpecification?: PolicySpecInitProviderTargetTrackingConfigurationPredefinedMetricSpecification[];

  /**
   * Target value for the metric.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfiguration#targetValue
   */
  readonly targetValue?: number;

}

/**
 * Converts an object of type 'PolicySpecInitProviderTargetTrackingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderTargetTrackingConfiguration(obj: PolicySpecInitProviderTargetTrackingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customizedMetricSpecification': obj.customizedMetricSpecification?.map(y => toJson_PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecification(y)),
    'disableScaleIn': obj.disableScaleIn,
    'predefinedMetricSpecification': obj.predefinedMetricSpecification?.map(y => toJson_PolicySpecInitProviderTargetTrackingConfigurationPredefinedMetricSpecification(y)),
    'targetValue': obj.targetValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecProviderConfigRefPolicy
 */
export interface PolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRefPolicy(obj: PolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRef
 */
export interface PolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj: PolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PolicySpecPublishConnectionDetailsToMetadata
 */
export interface PolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToMetadata(obj: PolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecForProviderAutoscalingGroupNameRefPolicy
 */
export interface PolicySpecForProviderAutoscalingGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderAutoscalingGroupNameRefPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderAutoscalingGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderAutoscalingGroupNameRefPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderAutoscalingGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderAutoscalingGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderAutoscalingGroupNameRefPolicy(obj: PolicySpecForProviderAutoscalingGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PolicySpecForProviderAutoscalingGroupNameSelectorPolicy
 */
export interface PolicySpecForProviderAutoscalingGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderAutoscalingGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderAutoscalingGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderAutoscalingGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderAutoscalingGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderAutoscalingGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderAutoscalingGroupNameSelectorPolicy(obj: PolicySpecForProviderAutoscalingGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecification
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecification {
  /**
   * Customized capacity metric specification. The field is only valid when you use customized_load_metric_specification
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecification#customizedCapacityMetricSpecification
   */
  readonly customizedCapacityMetricSpecification?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification[];

  /**
   * Customized load metric specification.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecification#customizedLoadMetricSpecification
   */
  readonly customizedLoadMetricSpecification?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification[];

  /**
   * Customized scaling metric specification.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecification#customizedScalingMetricSpecification
   */
  readonly customizedScalingMetricSpecification?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification[];

  /**
   * Predefined load metric specification.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecification#predefinedLoadMetricSpecification
   */
  readonly predefinedLoadMetricSpecification?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification[];

  /**
   * Metric pair specification from which Amazon EC2 Auto Scaling determines the appropriate scaling metric and load metric to use.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecification#predefinedMetricPairSpecification
   */
  readonly predefinedMetricPairSpecification?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification[];

  /**
   * Predefined scaling metric specification.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecification#predefinedScalingMetricSpecification
   */
  readonly predefinedScalingMetricSpecification?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification[];

  /**
   * Target value for the metric.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecification#targetValue
   */
  readonly targetValue?: number;

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecification(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customizedCapacityMetricSpecification': obj.customizedCapacityMetricSpecification?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification(y)),
    'customizedLoadMetricSpecification': obj.customizedLoadMetricSpecification?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification(y)),
    'customizedScalingMetricSpecification': obj.customizedScalingMetricSpecification?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification(y)),
    'predefinedLoadMetricSpecification': obj.predefinedLoadMetricSpecification?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification(y)),
    'predefinedMetricPairSpecification': obj.predefinedMetricPairSpecification?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification(y)),
    'predefinedScalingMetricSpecification': obj.predefinedScalingMetricSpecification?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification(y)),
    'targetValue': obj.targetValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecification
 */
export interface PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecification {
  /**
   * Dimensions of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecification#metricDimension
   */
  readonly metricDimension?: PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension[];

  /**
   * Name of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecification#metricName
   */
  readonly metricName?: string;

  /**
   * Metrics to include, as a metric data query.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecification#metrics
   */
  readonly metrics?: PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics[];

  /**
   * Namespace of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecification#namespace
   */
  readonly namespace?: string;

  /**
   * Statistic of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecification#statistic
   */
  readonly statistic?: string;

  /**
   * Unit of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecification#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecification(obj: PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricDimension': obj.metricDimension?.map(y => toJson_PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension(y)),
    'metricName': obj.metricName,
    'metrics': obj.metrics?.map(y => toJson_PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics(y)),
    'namespace': obj.namespace,
    'statistic': obj.statistic,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingConfigurationPredefinedMetricSpecification
 */
export interface PolicySpecForProviderTargetTrackingConfigurationPredefinedMetricSpecification {
  /**
   * Describes a scaling metric for a predictive scaling policy. Valid values are ASGAverageCPUUtilization, ASGAverageNetworkIn, ASGAverageNetworkOut, or ALBRequestCountPerTarget.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationPredefinedMetricSpecification#predefinedMetricType
   */
  readonly predefinedMetricType?: string;

  /**
   * Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationPredefinedMetricSpecification#resourceLabel
   */
  readonly resourceLabel?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingConfigurationPredefinedMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingConfigurationPredefinedMetricSpecification(obj: PolicySpecForProviderTargetTrackingConfigurationPredefinedMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'predefinedMetricType': obj.predefinedMetricType,
    'resourceLabel': obj.resourceLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecification
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecification {
  /**
   * Customized capacity metric specification. The field is only valid when you use customized_load_metric_specification
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecification#customizedCapacityMetricSpecification
   */
  readonly customizedCapacityMetricSpecification?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification[];

  /**
   * Customized load metric specification.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecification#customizedLoadMetricSpecification
   */
  readonly customizedLoadMetricSpecification?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification[];

  /**
   * Customized scaling metric specification.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecification#customizedScalingMetricSpecification
   */
  readonly customizedScalingMetricSpecification?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification[];

  /**
   * Predefined load metric specification.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecification#predefinedLoadMetricSpecification
   */
  readonly predefinedLoadMetricSpecification?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification[];

  /**
   * Metric pair specification from which Amazon EC2 Auto Scaling determines the appropriate scaling metric and load metric to use.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecification#predefinedMetricPairSpecification
   */
  readonly predefinedMetricPairSpecification?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification[];

  /**
   * Predefined scaling metric specification.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecification#predefinedScalingMetricSpecification
   */
  readonly predefinedScalingMetricSpecification?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification[];

  /**
   * Target value for the metric.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecification#targetValue
   */
  readonly targetValue?: number;

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecification(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customizedCapacityMetricSpecification': obj.customizedCapacityMetricSpecification?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification(y)),
    'customizedLoadMetricSpecification': obj.customizedLoadMetricSpecification?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification(y)),
    'customizedScalingMetricSpecification': obj.customizedScalingMetricSpecification?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification(y)),
    'predefinedLoadMetricSpecification': obj.predefinedLoadMetricSpecification?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification(y)),
    'predefinedMetricPairSpecification': obj.predefinedMetricPairSpecification?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification(y)),
    'predefinedScalingMetricSpecification': obj.predefinedScalingMetricSpecification?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification(y)),
    'targetValue': obj.targetValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecification
 */
export interface PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecification {
  /**
   * Dimensions of the metric.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecification#metricDimension
   */
  readonly metricDimension?: PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension[];

  /**
   * Name of the metric.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecification#metricName
   */
  readonly metricName?: string;

  /**
   * Metrics to include, as a metric data query.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecification#metrics
   */
  readonly metrics?: PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics[];

  /**
   * Namespace of the metric.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecification#namespace
   */
  readonly namespace?: string;

  /**
   * Statistic of the metric.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecification#statistic
   */
  readonly statistic?: string;

  /**
   * Unit of the metric.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecification#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecification(obj: PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricDimension': obj.metricDimension?.map(y => toJson_PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension(y)),
    'metricName': obj.metricName,
    'metrics': obj.metrics?.map(y => toJson_PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics(y)),
    'namespace': obj.namespace,
    'statistic': obj.statistic,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderTargetTrackingConfigurationPredefinedMetricSpecification
 */
export interface PolicySpecInitProviderTargetTrackingConfigurationPredefinedMetricSpecification {
  /**
   * Describes a scaling metric for a predictive scaling policy. Valid values are ASGAverageCPUUtilization, ASGAverageNetworkIn, ASGAverageNetworkOut, or ALBRequestCountPerTarget.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationPredefinedMetricSpecification#predefinedMetricType
   */
  readonly predefinedMetricType?: string;

  /**
   * Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationPredefinedMetricSpecification#resourceLabel
   */
  readonly resourceLabel?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderTargetTrackingConfigurationPredefinedMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderTargetTrackingConfigurationPredefinedMetricSpecification(obj: PolicySpecInitProviderTargetTrackingConfigurationPredefinedMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'predefinedMetricType': obj.predefinedMetricType,
    'resourceLabel': obj.resourceLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolution
 */
export enum PolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolve
 */
export enum PolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: PolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderAutoscalingGroupNameRefPolicyResolution
 */
export enum PolicySpecForProviderAutoscalingGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderAutoscalingGroupNameRefPolicyResolve
 */
export enum PolicySpecForProviderAutoscalingGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderAutoscalingGroupNameSelectorPolicyResolution
 */
export enum PolicySpecForProviderAutoscalingGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderAutoscalingGroupNameSelectorPolicyResolve
 */
export enum PolicySpecForProviderAutoscalingGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification {
  /**
   * List of up to 10 structures that defines custom capacity metric in predictive scaling policy
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification#metricDataQueries
   */
  readonly metricDataQueries?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries[];

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricDataQueries': obj.metricDataQueries?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification {
  /**
   * List of up to 10 structures that defines custom load metric in predictive scaling policy
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification#metricDataQueries
   */
  readonly metricDataQueries?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries[];

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricDataQueries': obj.metricDataQueries?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification {
  /**
   * List of up to 10 structures that defines custom scaling metric in predictive scaling policy
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification#metricDataQueries
   */
  readonly metricDataQueries?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries[];

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricDataQueries': obj.metricDataQueries?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification {
  /**
   * Metric type. Valid values are ASGTotalCPUUtilization, ASGTotalNetworkIn, ASGTotalNetworkOut, or ALBTargetGroupRequestCount.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification#predefinedMetricType
   */
  readonly predefinedMetricType?: string;

  /**
   * Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification#resourceLabel
   */
  readonly resourceLabel?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'predefinedMetricType': obj.predefinedMetricType,
    'resourceLabel': obj.resourceLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification {
  /**
   * Which metrics to use. There are two different types of metrics for each metric type: one is a load metric and one is a scaling metric. For example, if the metric type is ASGCPUUtilization, the Auto Scaling group's total CPU metric is used as the load metric, and the average CPU metric is used for the scaling metric. Valid values are ASGCPUUtilization, ASGNetworkIn, ASGNetworkOut, or ALBRequestCount.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification#predefinedMetricType
   */
  readonly predefinedMetricType?: string;

  /**
   * Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification#resourceLabel
   */
  readonly resourceLabel?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'predefinedMetricType': obj.predefinedMetricType,
    'resourceLabel': obj.resourceLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification {
  /**
   * Describes a scaling metric for a predictive scaling policy. Valid values are ASGAverageCPUUtilization, ASGAverageNetworkIn, ASGAverageNetworkOut, or ALBRequestCountPerTarget.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification#predefinedMetricType
   */
  readonly predefinedMetricType?: string;

  /**
   * Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification#resourceLabel
   */
  readonly resourceLabel?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'predefinedMetricType': obj.predefinedMetricType,
    'resourceLabel': obj.resourceLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension
 */
export interface PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension {
  /**
   * Name of the policy.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension#name
   */
  readonly name?: string;

  /**
   * Value of the dimension.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension(obj: PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics
 */
export interface PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics {
  /**
   * Math expression used on the returned metric. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics#expression
   */
  readonly expression?: string;

  /**
   * Short name for the metric used in predictive scaling policy.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics#id
   */
  readonly id?: string;

  /**
   * Human-readable label for this metric or expression.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics#label
   */
  readonly label?: string;

  /**
   * Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics#metricStat
   */
  readonly metricStat?: PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat[];

  /**
   * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics#returnData
   */
  readonly returnData?: boolean;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics(obj: PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'id': obj.id,
    'label': obj.label,
    'metricStat': obj.metricStat?.map(y => toJson_PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat(y)),
    'returnData': obj.returnData,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification {
  /**
   * List of up to 10 structures that defines custom capacity metric in predictive scaling policy
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification#metricDataQueries
   */
  readonly metricDataQueries?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries[];

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricDataQueries': obj.metricDataQueries?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification {
  /**
   * List of up to 10 structures that defines custom load metric in predictive scaling policy
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification#metricDataQueries
   */
  readonly metricDataQueries?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries[];

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricDataQueries': obj.metricDataQueries?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification {
  /**
   * List of up to 10 structures that defines custom scaling metric in predictive scaling policy
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification#metricDataQueries
   */
  readonly metricDataQueries?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries[];

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricDataQueries': obj.metricDataQueries?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification {
  /**
   * Metric type. Valid values are ASGTotalCPUUtilization, ASGTotalNetworkIn, ASGTotalNetworkOut, or ALBTargetGroupRequestCount.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification#predefinedMetricType
   */
  readonly predefinedMetricType?: string;

  /**
   * Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification#resourceLabel
   */
  readonly resourceLabel?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'predefinedMetricType': obj.predefinedMetricType,
    'resourceLabel': obj.resourceLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification {
  /**
   * Which metrics to use. There are two different types of metrics for each metric type: one is a load metric and one is a scaling metric. For example, if the metric type is ASGCPUUtilization, the Auto Scaling group's total CPU metric is used as the load metric, and the average CPU metric is used for the scaling metric. Valid values are ASGCPUUtilization, ASGNetworkIn, ASGNetworkOut, or ALBRequestCount.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification#predefinedMetricType
   */
  readonly predefinedMetricType?: string;

  /**
   * Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification#resourceLabel
   */
  readonly resourceLabel?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'predefinedMetricType': obj.predefinedMetricType,
    'resourceLabel': obj.resourceLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification {
  /**
   * Describes a scaling metric for a predictive scaling policy. Valid values are ASGAverageCPUUtilization, ASGAverageNetworkIn, ASGAverageNetworkOut, or ALBRequestCountPerTarget.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification#predefinedMetricType
   */
  readonly predefinedMetricType?: string;

  /**
   * Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification#resourceLabel
   */
  readonly resourceLabel?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'predefinedMetricType': obj.predefinedMetricType,
    'resourceLabel': obj.resourceLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension
 */
export interface PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension {
  /**
   * Name of the policy.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension#name
   */
  readonly name?: string;

  /**
   * Value of the dimension.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension(obj: PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics
 */
export interface PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics {
  /**
   * Math expression used on the returned metric. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics#expression
   */
  readonly expression?: string;

  /**
   * Short name for the metric used in predictive scaling policy.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics#id
   */
  readonly id?: string;

  /**
   * Human-readable label for this metric or expression.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics#label
   */
  readonly label?: string;

  /**
   * Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics#metricStat
   */
  readonly metricStat?: PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat[];

  /**
   * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics#returnData
   */
  readonly returnData?: boolean;

}

/**
 * Converts an object of type 'PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics(obj: PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'id': obj.id,
    'label': obj.label,
    'metricStat': obj.metricStat?.map(y => toJson_PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat(y)),
    'returnData': obj.returnData,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries {
  /**
   * Math expression used on the returned metric. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries#expression
   */
  readonly expression?: string;

  /**
   * Short name for the metric used in predictive scaling policy.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries#id
   */
  readonly id?: string;

  /**
   * Human-readable label for this metric or expression.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries#label
   */
  readonly label?: string;

  /**
   * Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries#metricStat
   */
  readonly metricStat?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat[];

  /**
   * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries#returnData
   */
  readonly returnData?: boolean;

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'id': obj.id,
    'label': obj.label,
    'metricStat': obj.metricStat?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat(y)),
    'returnData': obj.returnData,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries {
  /**
   * Math expression used on the returned metric. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries#expression
   */
  readonly expression?: string;

  /**
   * Short name for the metric used in predictive scaling policy.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries#id
   */
  readonly id?: string;

  /**
   * Human-readable label for this metric or expression.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries#label
   */
  readonly label?: string;

  /**
   * Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries#metricStat
   */
  readonly metricStat?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat[];

  /**
   * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries#returnData
   */
  readonly returnData?: boolean;

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'id': obj.id,
    'label': obj.label,
    'metricStat': obj.metricStat?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat(y)),
    'returnData': obj.returnData,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries {
  /**
   * Math expression used on the returned metric. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries#expression
   */
  readonly expression?: string;

  /**
   * Short name for the metric used in predictive scaling policy.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries#id
   */
  readonly id?: string;

  /**
   * Human-readable label for this metric or expression.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries#label
   */
  readonly label?: string;

  /**
   * Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries#metricStat
   */
  readonly metricStat?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat[];

  /**
   * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries#returnData
   */
  readonly returnData?: boolean;

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'id': obj.id,
    'label': obj.label,
    'metricStat': obj.metricStat?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat(y)),
    'returnData': obj.returnData,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat
 */
export interface PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat {
  /**
   * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat#metric
   */
  readonly metric?: PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric[];

  /**
   * Statistic of the metrics to return.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat#stat
   */
  readonly stat?: string;

  /**
   * Unit of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat(obj: PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metric': obj.metric?.map(y => toJson_PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric(y)),
    'stat': obj.stat,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries {
  /**
   * Math expression used on the returned metric. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries#expression
   */
  readonly expression?: string;

  /**
   * Short name for the metric used in predictive scaling policy.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries#id
   */
  readonly id?: string;

  /**
   * Human-readable label for this metric or expression.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries#label
   */
  readonly label?: string;

  /**
   * Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries#metricStat
   */
  readonly metricStat?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat[];

  /**
   * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries#returnData
   */
  readonly returnData?: boolean;

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'id': obj.id,
    'label': obj.label,
    'metricStat': obj.metricStat?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat(y)),
    'returnData': obj.returnData,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries {
  /**
   * Math expression used on the returned metric. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries#expression
   */
  readonly expression?: string;

  /**
   * Short name for the metric used in predictive scaling policy.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries#id
   */
  readonly id?: string;

  /**
   * Human-readable label for this metric or expression.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries#label
   */
  readonly label?: string;

  /**
   * Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries#metricStat
   */
  readonly metricStat?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat[];

  /**
   * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries#returnData
   */
  readonly returnData?: boolean;

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'id': obj.id,
    'label': obj.label,
    'metricStat': obj.metricStat?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat(y)),
    'returnData': obj.returnData,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries {
  /**
   * Math expression used on the returned metric. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries#expression
   */
  readonly expression?: string;

  /**
   * Short name for the metric used in predictive scaling policy.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries#id
   */
  readonly id?: string;

  /**
   * Human-readable label for this metric or expression.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries#label
   */
  readonly label?: string;

  /**
   * Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries#metricStat
   */
  readonly metricStat?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat[];

  /**
   * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries#returnData
   */
  readonly returnData?: boolean;

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'id': obj.id,
    'label': obj.label,
    'metricStat': obj.metricStat?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat(y)),
    'returnData': obj.returnData,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat
 */
export interface PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat {
  /**
   * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat#metric
   */
  readonly metric?: PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric[];

  /**
   * Statistic of the metrics to return.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat#stat
   */
  readonly stat?: string;

  /**
   * Unit of the metric.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat(obj: PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metric': obj.metric?.map(y => toJson_PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric(y)),
    'stat': obj.stat,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat {
  /**
   * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat#metric
   */
  readonly metric?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric[];

  /**
   * Statistic of the metrics to return.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat#stat
   */
  readonly stat?: string;

  /**
   * Unit of the metric.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metric': obj.metric?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric(y)),
    'stat': obj.stat,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat {
  /**
   * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat#metric
   */
  readonly metric?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric[];

  /**
   * Statistic of the metrics to return.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat#stat
   */
  readonly stat?: string;

  /**
   * Unit of the metric.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metric': obj.metric?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric(y)),
    'stat': obj.stat,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat {
  /**
   * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat#metric
   */
  readonly metric?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric[];

  /**
   * Statistic of the metrics to return.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat#stat
   */
  readonly stat?: string;

  /**
   * Unit of the metric.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metric': obj.metric?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric(y)),
    'stat': obj.stat,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric
 */
export interface PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric {
  /**
   * Dimensions of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric#dimensions
   */
  readonly dimensions?: PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions[];

  /**
   * Name of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric#metricName
   */
  readonly metricName?: string;

  /**
   * Namespace of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric(obj: PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': obj.dimensions?.map(y => toJson_PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions(y)),
    'metricName': obj.metricName,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat {
  /**
   * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat#metric
   */
  readonly metric?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric[];

  /**
   * Statistic of the metrics to return.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat#stat
   */
  readonly stat?: string;

  /**
   * Unit of the metric.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metric': obj.metric?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric(y)),
    'stat': obj.stat,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat {
  /**
   * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat#metric
   */
  readonly metric?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric[];

  /**
   * Statistic of the metrics to return.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat#stat
   */
  readonly stat?: string;

  /**
   * Unit of the metric.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metric': obj.metric?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric(y)),
    'stat': obj.stat,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat {
  /**
   * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat#metric
   */
  readonly metric?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric[];

  /**
   * Statistic of the metrics to return.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat#stat
   */
  readonly stat?: string;

  /**
   * Unit of the metric.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metric': obj.metric?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric(y)),
    'stat': obj.stat,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric
 */
export interface PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric {
  /**
   * Dimensions of the metric.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric#dimensions
   */
  readonly dimensions?: PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions[];

  /**
   * Name of the metric.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric#metricName
   */
  readonly metricName?: string;

  /**
   * Namespace of the metric.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric(obj: PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': obj.dimensions?.map(y => toJson_PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions(y)),
    'metricName': obj.metricName,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric {
  /**
   * Dimensions of the metric.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric#dimensions
   */
  readonly dimensions?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions[];

  /**
   * Name of the metric.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric#metricName
   */
  readonly metricName?: string;

  /**
   * Namespace of the metric.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': obj.dimensions?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions(y)),
    'metricName': obj.metricName,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric {
  /**
   * Dimensions of the metric.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric#dimensions
   */
  readonly dimensions?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions[];

  /**
   * Name of the metric.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric#metricName
   */
  readonly metricName?: string;

  /**
   * Namespace of the metric.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': obj.dimensions?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions(y)),
    'metricName': obj.metricName,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric {
  /**
   * Dimensions of the metric.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric#dimensions
   */
  readonly dimensions?: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions[];

  /**
   * Name of the metric.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric#metricName
   */
  readonly metricName?: string;

  /**
   * Namespace of the metric.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': obj.dimensions?.map(y => toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions(y)),
    'metricName': obj.metricName,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions
 */
export interface PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions {
  /**
   * Name of the policy.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions#name
   */
  readonly name?: string;

  /**
   * Value of the dimension.
   *
   * @schema PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions(obj: PolicySpecForProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric {
  /**
   * Dimensions of the metric.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric#dimensions
   */
  readonly dimensions?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions[];

  /**
   * Name of the metric.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric#metricName
   */
  readonly metricName?: string;

  /**
   * Namespace of the metric.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': obj.dimensions?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions(y)),
    'metricName': obj.metricName,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric {
  /**
   * Dimensions of the metric.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric#dimensions
   */
  readonly dimensions?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions[];

  /**
   * Name of the metric.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric#metricName
   */
  readonly metricName?: string;

  /**
   * Namespace of the metric.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': obj.dimensions?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions(y)),
    'metricName': obj.metricName,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric {
  /**
   * Dimensions of the metric.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric#dimensions
   */
  readonly dimensions?: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions[];

  /**
   * Name of the metric.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric#metricName
   */
  readonly metricName?: string;

  /**
   * Namespace of the metric.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': obj.dimensions?.map(y => toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions(y)),
    'metricName': obj.metricName,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions
 */
export interface PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions {
  /**
   * Name of the policy.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions#name
   */
  readonly name?: string;

  /**
   * Value of the dimension.
   *
   * @schema PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions(obj: PolicySpecInitProviderTargetTrackingConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions {
  /**
   * Name of the policy.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions#name
   */
  readonly name?: string;

  /**
   * Value of the dimension.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions {
  /**
   * Name of the policy.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions#name
   */
  readonly name?: string;

  /**
   * Value of the dimension.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions
 */
export interface PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions {
  /**
   * Name of the policy.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions#name
   */
  readonly name?: string;

  /**
   * Value of the dimension.
   *
   * @schema PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions(obj: PolicySpecForProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions {
  /**
   * Name of the policy.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions#name
   */
  readonly name?: string;

  /**
   * Value of the dimension.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueriesMetricStatMetricDimensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions {
  /**
   * Name of the policy.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions#name
   */
  readonly name?: string;

  /**
   * Value of the dimension.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueriesMetricStatMetricDimensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions
 */
export interface PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions {
  /**
   * Name of the policy.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions#name
   */
  readonly name?: string;

  /**
   * Value of the dimension.
   *
   * @schema PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions(obj: PolicySpecInitProviderPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueriesMetricStatMetricDimensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Schedule is the Schema for the Schedules API. Provides an AutoScaling Schedule resource.
 *
 * @schema Schedule
 */
export class Schedule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Schedule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'autoscaling.aws.upbound.io/v1beta1',
    kind: 'Schedule',
  }

  /**
   * Renders a Kubernetes manifest for "Schedule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ScheduleProps): any {
    return {
      ...Schedule.GVK,
      ...toJson_ScheduleProps(props),
    };
  }

  /**
   * Defines a "Schedule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ScheduleProps) {
    super(scope, id, {
      ...Schedule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Schedule.GVK,
      ...toJson_ScheduleProps(resolved),
    };
  }
}

/**
 * Schedule is the Schema for the Schedules API. Provides an AutoScaling Schedule resource.
 *
 * @schema Schedule
 */
export interface ScheduleProps {
  /**
   * @schema Schedule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ScheduleSpec defines the desired state of Schedule
   *
   * @schema Schedule#spec
   */
  readonly spec: ScheduleSpec;

}

/**
 * Converts an object of type 'ScheduleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleProps(obj: ScheduleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ScheduleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScheduleSpec defines the desired state of Schedule
 *
 * @schema ScheduleSpec
 */
export interface ScheduleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ScheduleSpec#deletionPolicy
   */
  readonly deletionPolicy?: ScheduleSpecDeletionPolicy;

  /**
   * @schema ScheduleSpec#forProvider
   */
  readonly forProvider: ScheduleSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ScheduleSpec#initProvider
   */
  readonly initProvider?: ScheduleSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ScheduleSpec#managementPolicies
   */
  readonly managementPolicies?: ScheduleSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ScheduleSpec#providerConfigRef
   */
  readonly providerConfigRef?: ScheduleSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ScheduleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ScheduleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ScheduleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ScheduleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ScheduleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpec(obj: ScheduleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ScheduleSpecForProvider(obj.forProvider),
    'initProvider': toJson_ScheduleSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ScheduleSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ScheduleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ScheduleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ScheduleSpecDeletionPolicy
 */
export enum ScheduleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ScheduleSpecForProvider
 */
export interface ScheduleSpecForProvider {
  /**
   * The name of the Auto Scaling group.
   *
   * @schema ScheduleSpecForProvider#autoscalingGroupName
   */
  readonly autoscalingGroupName?: string;

  /**
   * Reference to a AutoscalingGroup in autoscaling to populate autoscalingGroupName.
   *
   * @schema ScheduleSpecForProvider#autoscalingGroupNameRef
   */
  readonly autoscalingGroupNameRef?: ScheduleSpecForProviderAutoscalingGroupNameRef;

  /**
   * Selector for a AutoscalingGroup in autoscaling to populate autoscalingGroupName.
   *
   * @schema ScheduleSpecForProvider#autoscalingGroupNameSelector
   */
  readonly autoscalingGroupNameSelector?: ScheduleSpecForProviderAutoscalingGroupNameSelector;

  /**
   * The initial capacity of the Auto Scaling group after the scheduled action runs and the capacity it attempts to maintain. Set to -1 if you don't want to change the desired capacity at the scheduled time. Defaults to 0.
   *
   * @default 0.
   * @schema ScheduleSpecForProvider#desiredCapacity
   */
  readonly desiredCapacity?: number;

  /**
   * The date and time for the recurring schedule to end, in UTC with the format "YYYY-MM-DDThh:mm:ssZ" (e.g. "2021-06-01T00:00:00Z").
   *
   * @schema ScheduleSpecForProvider#endTime
   */
  readonly endTime?: string;

  /**
   * The maximum size of the Auto Scaling group. Set to -1 if you don't want to change the maximum size at the scheduled time. Defaults to 0.
   *
   * @default 0.
   * @schema ScheduleSpecForProvider#maxSize
   */
  readonly maxSize?: number;

  /**
   * The minimum size of the Auto Scaling group. Set to -1 if you don't want to change the minimum size at the scheduled time. Defaults to 0.
   *
   * @default 0.
   * @schema ScheduleSpecForProvider#minSize
   */
  readonly minSize?: number;

  /**
   * The recurring schedule for this action specified using the Unix cron syntax format.
   *
   * @schema ScheduleSpecForProvider#recurrence
   */
  readonly recurrence?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ScheduleSpecForProvider#region
   */
  readonly region: string;

  /**
   * The date and time for the recurring schedule to start, in UTC with the format "YYYY-MM-DDThh:mm:ssZ" (e.g. "2021-06-01T00:00:00Z").
   *
   * @schema ScheduleSpecForProvider#startTime
   */
  readonly startTime?: string;

  /**
   * Specifies the time zone for a cron expression. Valid values are the canonical names of the IANA time zones (such as Etc/GMT+9 or Pacific/Tahiti).
   *
   * @schema ScheduleSpecForProvider#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'ScheduleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProvider(obj: ScheduleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoscalingGroupName': obj.autoscalingGroupName,
    'autoscalingGroupNameRef': toJson_ScheduleSpecForProviderAutoscalingGroupNameRef(obj.autoscalingGroupNameRef),
    'autoscalingGroupNameSelector': toJson_ScheduleSpecForProviderAutoscalingGroupNameSelector(obj.autoscalingGroupNameSelector),
    'desiredCapacity': obj.desiredCapacity,
    'endTime': obj.endTime,
    'maxSize': obj.maxSize,
    'minSize': obj.minSize,
    'recurrence': obj.recurrence,
    'region': obj.region,
    'startTime': obj.startTime,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ScheduleSpecInitProvider
 */
export interface ScheduleSpecInitProvider {
  /**
   * The initial capacity of the Auto Scaling group after the scheduled action runs and the capacity it attempts to maintain. Set to -1 if you don't want to change the desired capacity at the scheduled time. Defaults to 0.
   *
   * @default 0.
   * @schema ScheduleSpecInitProvider#desiredCapacity
   */
  readonly desiredCapacity?: number;

  /**
   * The date and time for the recurring schedule to end, in UTC with the format "YYYY-MM-DDThh:mm:ssZ" (e.g. "2021-06-01T00:00:00Z").
   *
   * @schema ScheduleSpecInitProvider#endTime
   */
  readonly endTime?: string;

  /**
   * The maximum size of the Auto Scaling group. Set to -1 if you don't want to change the maximum size at the scheduled time. Defaults to 0.
   *
   * @default 0.
   * @schema ScheduleSpecInitProvider#maxSize
   */
  readonly maxSize?: number;

  /**
   * The minimum size of the Auto Scaling group. Set to -1 if you don't want to change the minimum size at the scheduled time. Defaults to 0.
   *
   * @default 0.
   * @schema ScheduleSpecInitProvider#minSize
   */
  readonly minSize?: number;

  /**
   * The recurring schedule for this action specified using the Unix cron syntax format.
   *
   * @schema ScheduleSpecInitProvider#recurrence
   */
  readonly recurrence?: string;

  /**
   * The date and time for the recurring schedule to start, in UTC with the format "YYYY-MM-DDThh:mm:ssZ" (e.g. "2021-06-01T00:00:00Z").
   *
   * @schema ScheduleSpecInitProvider#startTime
   */
  readonly startTime?: string;

  /**
   * Specifies the time zone for a cron expression. Valid values are the canonical names of the IANA time zones (such as Etc/GMT+9 or Pacific/Tahiti).
   *
   * @schema ScheduleSpecInitProvider#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'ScheduleSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecInitProvider(obj: ScheduleSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'desiredCapacity': obj.desiredCapacity,
    'endTime': obj.endTime,
    'maxSize': obj.maxSize,
    'minSize': obj.minSize,
    'recurrence': obj.recurrence,
    'startTime': obj.startTime,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ScheduleSpecManagementPolicies
 */
export enum ScheduleSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ScheduleSpecProviderConfigRef
 */
export interface ScheduleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduleSpecProviderConfigRef#policy
   */
  readonly policy?: ScheduleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ScheduleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecProviderConfigRef(obj: ScheduleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ScheduleSpecPublishConnectionDetailsTo
 */
export interface ScheduleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ScheduleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ScheduleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ScheduleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ScheduleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ScheduleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ScheduleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPublishConnectionDetailsTo(obj: ScheduleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ScheduleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ScheduleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ScheduleSpecWriteConnectionSecretToRef
 */
export interface ScheduleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ScheduleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ScheduleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ScheduleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecWriteConnectionSecretToRef(obj: ScheduleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a AutoscalingGroup in autoscaling to populate autoscalingGroupName.
 *
 * @schema ScheduleSpecForProviderAutoscalingGroupNameRef
 */
export interface ScheduleSpecForProviderAutoscalingGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduleSpecForProviderAutoscalingGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduleSpecForProviderAutoscalingGroupNameRef#policy
   */
  readonly policy?: ScheduleSpecForProviderAutoscalingGroupNameRefPolicy;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderAutoscalingGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderAutoscalingGroupNameRef(obj: ScheduleSpecForProviderAutoscalingGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduleSpecForProviderAutoscalingGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a AutoscalingGroup in autoscaling to populate autoscalingGroupName.
 *
 * @schema ScheduleSpecForProviderAutoscalingGroupNameSelector
 */
export interface ScheduleSpecForProviderAutoscalingGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ScheduleSpecForProviderAutoscalingGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ScheduleSpecForProviderAutoscalingGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ScheduleSpecForProviderAutoscalingGroupNameSelector#policy
   */
  readonly policy?: ScheduleSpecForProviderAutoscalingGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderAutoscalingGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderAutoscalingGroupNameSelector(obj: ScheduleSpecForProviderAutoscalingGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ScheduleSpecForProviderAutoscalingGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduleSpecProviderConfigRefPolicy
 */
export interface ScheduleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ScheduleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ScheduleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecProviderConfigRefPolicy(obj: ScheduleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ScheduleSpecPublishConnectionDetailsToConfigRef
 */
export interface ScheduleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ScheduleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ScheduleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPublishConnectionDetailsToConfigRef(obj: ScheduleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ScheduleSpecPublishConnectionDetailsToMetadata
 */
export interface ScheduleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ScheduleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ScheduleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ScheduleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScheduleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPublishConnectionDetailsToMetadata(obj: ScheduleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduleSpecForProviderAutoscalingGroupNameRefPolicy
 */
export interface ScheduleSpecForProviderAutoscalingGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduleSpecForProviderAutoscalingGroupNameRefPolicy#resolution
   */
  readonly resolution?: ScheduleSpecForProviderAutoscalingGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduleSpecForProviderAutoscalingGroupNameRefPolicy#resolve
   */
  readonly resolve?: ScheduleSpecForProviderAutoscalingGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderAutoscalingGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderAutoscalingGroupNameRefPolicy(obj: ScheduleSpecForProviderAutoscalingGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ScheduleSpecForProviderAutoscalingGroupNameSelectorPolicy
 */
export interface ScheduleSpecForProviderAutoscalingGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduleSpecForProviderAutoscalingGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: ScheduleSpecForProviderAutoscalingGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduleSpecForProviderAutoscalingGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: ScheduleSpecForProviderAutoscalingGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ScheduleSpecForProviderAutoscalingGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecForProviderAutoscalingGroupNameSelectorPolicy(obj: ScheduleSpecForProviderAutoscalingGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduleSpecProviderConfigRefPolicyResolution
 */
export enum ScheduleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduleSpecProviderConfigRefPolicyResolve
 */
export enum ScheduleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ScheduleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ScheduleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPublishConnectionDetailsToConfigRefPolicy(obj: ScheduleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduleSpecForProviderAutoscalingGroupNameRefPolicyResolution
 */
export enum ScheduleSpecForProviderAutoscalingGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduleSpecForProviderAutoscalingGroupNameRefPolicyResolve
 */
export enum ScheduleSpecForProviderAutoscalingGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduleSpecForProviderAutoscalingGroupNameSelectorPolicyResolution
 */
export enum ScheduleSpecForProviderAutoscalingGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduleSpecForProviderAutoscalingGroupNameSelectorPolicyResolve
 */
export enum ScheduleSpecForProviderAutoscalingGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ScheduleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

