// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AccessLevel is the Schema for the AccessLevels API. An AccessLevel is a label that can be applied to requests to GCP services, along with a list of requirements necessary for the label to be applied.
 *
 * @schema AccessLevel
 */
export class AccessLevel extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AccessLevel"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'accesscontextmanager.gcp.upbound.io/v1beta1',
    kind: 'AccessLevel',
  }

  /**
   * Renders a Kubernetes manifest for "AccessLevel".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccessLevelProps): any {
    return {
      ...AccessLevel.GVK,
      ...toJson_AccessLevelProps(props),
    };
  }

  /**
   * Defines a "AccessLevel" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccessLevelProps) {
    super(scope, id, {
      ...AccessLevel.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AccessLevel.GVK,
      ...toJson_AccessLevelProps(resolved),
    };
  }
}

/**
 * AccessLevel is the Schema for the AccessLevels API. An AccessLevel is a label that can be applied to requests to GCP services, along with a list of requirements necessary for the label to be applied.
 *
 * @schema AccessLevel
 */
export interface AccessLevelProps {
  /**
   * @schema AccessLevel#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccessLevelSpec defines the desired state of AccessLevel
   *
   * @schema AccessLevel#spec
   */
  readonly spec: AccessLevelSpec;

}

/**
 * Converts an object of type 'AccessLevelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelProps(obj: AccessLevelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccessLevelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessLevelSpec defines the desired state of AccessLevel
 *
 * @schema AccessLevelSpec
 */
export interface AccessLevelSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccessLevelSpec#deletionPolicy
   */
  readonly deletionPolicy?: AccessLevelSpecDeletionPolicy;

  /**
   * @schema AccessLevelSpec#forProvider
   */
  readonly forProvider: AccessLevelSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AccessLevelSpec#initProvider
   */
  readonly initProvider?: AccessLevelSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AccessLevelSpec#managementPolicies
   */
  readonly managementPolicies?: AccessLevelSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AccessLevelSpec#providerConfigRef
   */
  readonly providerConfigRef?: AccessLevelSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AccessLevelSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccessLevelSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AccessLevelSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccessLevelSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccessLevelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpec(obj: AccessLevelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccessLevelSpecForProvider(obj.forProvider),
    'initProvider': toJson_AccessLevelSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AccessLevelSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AccessLevelSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccessLevelSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccessLevelSpecDeletionPolicy
 */
export enum AccessLevelSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AccessLevelSpecForProvider
 */
export interface AccessLevelSpecForProvider {
  /**
   * A set of predefined conditions for the access level and a combining function. Structure is documented below.
   *
   * @schema AccessLevelSpecForProvider#basic
   */
  readonly basic?: AccessLevelSpecForProviderBasic[];

  /**
   * Custom access level conditions are set using the Cloud Common Expression Language to represent the necessary conditions for the level to apply to a request. See CEL spec at: https://github.com/google/cel-spec. Structure is documented below.
   *
   * @schema AccessLevelSpecForProvider#custom
   */
  readonly custom?: AccessLevelSpecForProviderCustom[];

  /**
   * Description of the AccessLevel and its use. Does not affect behavior.
   *
   * @schema AccessLevelSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Resource name for the Access Level. The short_name component must begin with a letter and only include alphanumeric and '_'. Format: accessPolicies/{policy_id}/accessLevels/{short_name}
   *
   * @schema AccessLevelSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The AccessPolicy this AccessLevel lives in. Format: accessPolicies/{policy_id}
   *
   * @schema AccessLevelSpecForProvider#parent
   */
  readonly parent?: string;

  /**
   * Human readable title. Must be unique within the Policy.
   *
   * @schema AccessLevelSpecForProvider#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'AccessLevelSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecForProvider(obj: AccessLevelSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basic': obj.basic?.map(y => toJson_AccessLevelSpecForProviderBasic(y)),
    'custom': obj.custom?.map(y => toJson_AccessLevelSpecForProviderCustom(y)),
    'description': obj.description,
    'name': obj.name,
    'parent': obj.parent,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AccessLevelSpecInitProvider
 */
export interface AccessLevelSpecInitProvider {
  /**
   * A set of predefined conditions for the access level and a combining function. Structure is documented below.
   *
   * @schema AccessLevelSpecInitProvider#basic
   */
  readonly basic?: AccessLevelSpecInitProviderBasic[];

  /**
   * Custom access level conditions are set using the Cloud Common Expression Language to represent the necessary conditions for the level to apply to a request. See CEL spec at: https://github.com/google/cel-spec. Structure is documented below.
   *
   * @schema AccessLevelSpecInitProvider#custom
   */
  readonly custom?: AccessLevelSpecInitProviderCustom[];

  /**
   * Description of the AccessLevel and its use. Does not affect behavior.
   *
   * @schema AccessLevelSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Resource name for the Access Level. The short_name component must begin with a letter and only include alphanumeric and '_'. Format: accessPolicies/{policy_id}/accessLevels/{short_name}
   *
   * @schema AccessLevelSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The AccessPolicy this AccessLevel lives in. Format: accessPolicies/{policy_id}
   *
   * @schema AccessLevelSpecInitProvider#parent
   */
  readonly parent?: string;

  /**
   * Human readable title. Must be unique within the Policy.
   *
   * @schema AccessLevelSpecInitProvider#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'AccessLevelSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecInitProvider(obj: AccessLevelSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basic': obj.basic?.map(y => toJson_AccessLevelSpecInitProviderBasic(y)),
    'custom': obj.custom?.map(y => toJson_AccessLevelSpecInitProviderCustom(y)),
    'description': obj.description,
    'name': obj.name,
    'parent': obj.parent,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AccessLevelSpecManagementPolicies
 */
export enum AccessLevelSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AccessLevelSpecProviderConfigRef
 */
export interface AccessLevelSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessLevelSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessLevelSpecProviderConfigRef#policy
   */
  readonly policy?: AccessLevelSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessLevelSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecProviderConfigRef(obj: AccessLevelSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessLevelSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AccessLevelSpecPublishConnectionDetailsTo
 */
export interface AccessLevelSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AccessLevelSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccessLevelSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccessLevelSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccessLevelSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccessLevelSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccessLevelSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecPublishConnectionDetailsTo(obj: AccessLevelSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccessLevelSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccessLevelSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AccessLevelSpecWriteConnectionSecretToRef
 */
export interface AccessLevelSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccessLevelSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccessLevelSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccessLevelSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecWriteConnectionSecretToRef(obj: AccessLevelSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessLevelSpecForProviderBasic
 */
export interface AccessLevelSpecForProviderBasic {
  /**
   * How the conditions list should be combined to determine if a request is granted this AccessLevel. If AND is used, each Condition in conditions must be satisfied for the AccessLevel to be applied. If OR is used, at least one Condition in conditions must be satisfied for the AccessLevel to be applied. Default value is AND. Possible values are: AND, OR.
   *
   * @schema AccessLevelSpecForProviderBasic#combiningFunction
   */
  readonly combiningFunction?: string;

  /**
   * A set of requirements for the AccessLevel to be granted. Structure is documented below.
   *
   * @schema AccessLevelSpecForProviderBasic#conditions
   */
  readonly conditions?: AccessLevelSpecForProviderBasicConditions[];

}

/**
 * Converts an object of type 'AccessLevelSpecForProviderBasic' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecForProviderBasic(obj: AccessLevelSpecForProviderBasic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'combiningFunction': obj.combiningFunction,
    'conditions': obj.conditions?.map(y => toJson_AccessLevelSpecForProviderBasicConditions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessLevelSpecForProviderCustom
 */
export interface AccessLevelSpecForProviderCustom {
  /**
   * Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. This page details the objects and attributes that are used to the build the CEL expressions for custom access levels - https://cloud.google.com/access-context-manager/docs/custom-access-level-spec. Structure is documented below.
   *
   * @schema AccessLevelSpecForProviderCustom#expr
   */
  readonly expr?: AccessLevelSpecForProviderCustomExpr[];

}

/**
 * Converts an object of type 'AccessLevelSpecForProviderCustom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecForProviderCustom(obj: AccessLevelSpecForProviderCustom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expr': obj.expr?.map(y => toJson_AccessLevelSpecForProviderCustomExpr(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessLevelSpecInitProviderBasic
 */
export interface AccessLevelSpecInitProviderBasic {
  /**
   * How the conditions list should be combined to determine if a request is granted this AccessLevel. If AND is used, each Condition in conditions must be satisfied for the AccessLevel to be applied. If OR is used, at least one Condition in conditions must be satisfied for the AccessLevel to be applied. Default value is AND. Possible values are: AND, OR.
   *
   * @schema AccessLevelSpecInitProviderBasic#combiningFunction
   */
  readonly combiningFunction?: string;

  /**
   * A set of requirements for the AccessLevel to be granted. Structure is documented below.
   *
   * @schema AccessLevelSpecInitProviderBasic#conditions
   */
  readonly conditions?: AccessLevelSpecInitProviderBasicConditions[];

}

/**
 * Converts an object of type 'AccessLevelSpecInitProviderBasic' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecInitProviderBasic(obj: AccessLevelSpecInitProviderBasic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'combiningFunction': obj.combiningFunction,
    'conditions': obj.conditions?.map(y => toJson_AccessLevelSpecInitProviderBasicConditions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessLevelSpecInitProviderCustom
 */
export interface AccessLevelSpecInitProviderCustom {
  /**
   * Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. This page details the objects and attributes that are used to the build the CEL expressions for custom access levels - https://cloud.google.com/access-context-manager/docs/custom-access-level-spec. Structure is documented below.
   *
   * @schema AccessLevelSpecInitProviderCustom#expr
   */
  readonly expr?: AccessLevelSpecInitProviderCustomExpr[];

}

/**
 * Converts an object of type 'AccessLevelSpecInitProviderCustom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecInitProviderCustom(obj: AccessLevelSpecInitProviderCustom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expr': obj.expr?.map(y => toJson_AccessLevelSpecInitProviderCustomExpr(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessLevelSpecProviderConfigRefPolicy
 */
export interface AccessLevelSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessLevelSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccessLevelSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessLevelSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccessLevelSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessLevelSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecProviderConfigRefPolicy(obj: AccessLevelSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AccessLevelSpecPublishConnectionDetailsToConfigRef
 */
export interface AccessLevelSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessLevelSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessLevelSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccessLevelSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessLevelSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecPublishConnectionDetailsToConfigRef(obj: AccessLevelSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessLevelSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccessLevelSpecPublishConnectionDetailsToMetadata
 */
export interface AccessLevelSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessLevelSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessLevelSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccessLevelSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccessLevelSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecPublishConnectionDetailsToMetadata(obj: AccessLevelSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessLevelSpecForProviderBasicConditions
 */
export interface AccessLevelSpecForProviderBasicConditions {
  /**
   * Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are allowed. Structure is documented below.
   *
   * @schema AccessLevelSpecForProviderBasicConditions#devicePolicy
   */
  readonly devicePolicy?: AccessLevelSpecForProviderBasicConditionsDevicePolicy[];

  /**
   * A list of CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order for this Condition to be true. If empty, all IP addresses are allowed.
   *
   * @schema AccessLevelSpecForProviderBasicConditions#ipSubnetworks
   */
  readonly ipSubnetworks?: string[];

  /**
   * An allowed list of members (users, service accounts). Using groups is not supported yet. The signed-in user originating the request must be a part of one of the provided members. If not specified, a request may come from any user (logged in/not logged in, not present in any groups, etc.). Formats: user:{emailid}, serviceAccount:{emailid}
   *
   * @schema AccessLevelSpecForProviderBasicConditions#members
   */
  readonly members?: string[];

  /**
   * Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be false for the Condition overall to be satisfied. Defaults to false.
   *
   * @default false.
   * @schema AccessLevelSpecForProviderBasicConditions#negate
   */
  readonly negate?: boolean;

  /**
   * The request must originate from one of the provided countries/regions. Format: A valid ISO 3166-1 alpha-2 code.
   *
   * @schema AccessLevelSpecForProviderBasicConditions#regions
   */
  readonly regions?: string[];

  /**
   * A list of other access levels defined in the same Policy, referenced by resource name. Referencing an AccessLevel which does not exist is an error. All access levels listed must be granted for the Condition to be true. Format: accessPolicies/{policy_id}/accessLevels/{short_name}
   *
   * @schema AccessLevelSpecForProviderBasicConditions#requiredAccessLevels
   */
  readonly requiredAccessLevels?: string[];

}

/**
 * Converts an object of type 'AccessLevelSpecForProviderBasicConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecForProviderBasicConditions(obj: AccessLevelSpecForProviderBasicConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePolicy': obj.devicePolicy?.map(y => toJson_AccessLevelSpecForProviderBasicConditionsDevicePolicy(y)),
    'ipSubnetworks': obj.ipSubnetworks?.map(y => y),
    'members': obj.members?.map(y => y),
    'negate': obj.negate,
    'regions': obj.regions?.map(y => y),
    'requiredAccessLevels': obj.requiredAccessLevels?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessLevelSpecForProviderCustomExpr
 */
export interface AccessLevelSpecForProviderCustomExpr {
  /**
   * Description of the expression
   *
   * @schema AccessLevelSpecForProviderCustomExpr#description
   */
  readonly description?: string;

  /**
   * Textual representation of an expression in Common Expression Language syntax.
   *
   * @schema AccessLevelSpecForProviderCustomExpr#expression
   */
  readonly expression?: string;

  /**
   * String indicating the location of the expression for error reporting, e.g. a file name and a position in the file
   *
   * @schema AccessLevelSpecForProviderCustomExpr#location
   */
  readonly location?: string;

  /**
   * Title for the expression, i.e. a short string describing its purpose.
   *
   * @schema AccessLevelSpecForProviderCustomExpr#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'AccessLevelSpecForProviderCustomExpr' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecForProviderCustomExpr(obj: AccessLevelSpecForProviderCustomExpr | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'location': obj.location,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessLevelSpecInitProviderBasicConditions
 */
export interface AccessLevelSpecInitProviderBasicConditions {
  /**
   * Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are allowed. Structure is documented below.
   *
   * @schema AccessLevelSpecInitProviderBasicConditions#devicePolicy
   */
  readonly devicePolicy?: AccessLevelSpecInitProviderBasicConditionsDevicePolicy[];

  /**
   * A list of CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order for this Condition to be true. If empty, all IP addresses are allowed.
   *
   * @schema AccessLevelSpecInitProviderBasicConditions#ipSubnetworks
   */
  readonly ipSubnetworks?: string[];

  /**
   * An allowed list of members (users, service accounts). Using groups is not supported yet. The signed-in user originating the request must be a part of one of the provided members. If not specified, a request may come from any user (logged in/not logged in, not present in any groups, etc.). Formats: user:{emailid}, serviceAccount:{emailid}
   *
   * @schema AccessLevelSpecInitProviderBasicConditions#members
   */
  readonly members?: string[];

  /**
   * Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be false for the Condition overall to be satisfied. Defaults to false.
   *
   * @default false.
   * @schema AccessLevelSpecInitProviderBasicConditions#negate
   */
  readonly negate?: boolean;

  /**
   * The request must originate from one of the provided countries/regions. Format: A valid ISO 3166-1 alpha-2 code.
   *
   * @schema AccessLevelSpecInitProviderBasicConditions#regions
   */
  readonly regions?: string[];

  /**
   * A list of other access levels defined in the same Policy, referenced by resource name. Referencing an AccessLevel which does not exist is an error. All access levels listed must be granted for the Condition to be true. Format: accessPolicies/{policy_id}/accessLevels/{short_name}
   *
   * @schema AccessLevelSpecInitProviderBasicConditions#requiredAccessLevels
   */
  readonly requiredAccessLevels?: string[];

}

/**
 * Converts an object of type 'AccessLevelSpecInitProviderBasicConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecInitProviderBasicConditions(obj: AccessLevelSpecInitProviderBasicConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePolicy': obj.devicePolicy?.map(y => toJson_AccessLevelSpecInitProviderBasicConditionsDevicePolicy(y)),
    'ipSubnetworks': obj.ipSubnetworks?.map(y => y),
    'members': obj.members?.map(y => y),
    'negate': obj.negate,
    'regions': obj.regions?.map(y => y),
    'requiredAccessLevels': obj.requiredAccessLevels?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessLevelSpecInitProviderCustomExpr
 */
export interface AccessLevelSpecInitProviderCustomExpr {
  /**
   * Description of the expression
   *
   * @schema AccessLevelSpecInitProviderCustomExpr#description
   */
  readonly description?: string;

  /**
   * Textual representation of an expression in Common Expression Language syntax.
   *
   * @schema AccessLevelSpecInitProviderCustomExpr#expression
   */
  readonly expression?: string;

  /**
   * String indicating the location of the expression for error reporting, e.g. a file name and a position in the file
   *
   * @schema AccessLevelSpecInitProviderCustomExpr#location
   */
  readonly location?: string;

  /**
   * Title for the expression, i.e. a short string describing its purpose.
   *
   * @schema AccessLevelSpecInitProviderCustomExpr#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'AccessLevelSpecInitProviderCustomExpr' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecInitProviderCustomExpr(obj: AccessLevelSpecInitProviderCustomExpr | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'location': obj.location,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessLevelSpecProviderConfigRefPolicyResolution
 */
export enum AccessLevelSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessLevelSpecProviderConfigRefPolicyResolve
 */
export enum AccessLevelSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccessLevelSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccessLevelSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessLevelSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccessLevelSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessLevelSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccessLevelSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessLevelSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecPublishConnectionDetailsToConfigRefPolicy(obj: AccessLevelSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessLevelSpecForProviderBasicConditionsDevicePolicy
 */
export interface AccessLevelSpecForProviderBasicConditionsDevicePolicy {
  /**
   * A list of allowed device management levels. An empty list allows all management levels. Each value may be one of: MANAGEMENT_UNSPECIFIED, NONE, BASIC, COMPLETE.
   *
   * @schema AccessLevelSpecForProviderBasicConditionsDevicePolicy#allowedDeviceManagementLevels
   */
  readonly allowedDeviceManagementLevels?: string[];

  /**
   * A list of allowed encryptions statuses. An empty list allows all statuses. Each value may be one of: ENCRYPTION_UNSPECIFIED, ENCRYPTION_UNSUPPORTED, UNENCRYPTED, ENCRYPTED.
   *
   * @schema AccessLevelSpecForProviderBasicConditionsDevicePolicy#allowedEncryptionStatuses
   */
  readonly allowedEncryptionStatuses?: string[];

  /**
   * A list of allowed OS versions. An empty list allows all types and all versions. Structure is documented below.
   *
   * @schema AccessLevelSpecForProviderBasicConditionsDevicePolicy#osConstraints
   */
  readonly osConstraints?: AccessLevelSpecForProviderBasicConditionsDevicePolicyOsConstraints[];

  /**
   * Whether the device needs to be approved by the customer admin.
   *
   * @schema AccessLevelSpecForProviderBasicConditionsDevicePolicy#requireAdminApproval
   */
  readonly requireAdminApproval?: boolean;

  /**
   * Whether the device needs to be corp owned.
   *
   * @schema AccessLevelSpecForProviderBasicConditionsDevicePolicy#requireCorpOwned
   */
  readonly requireCorpOwned?: boolean;

  /**
   * Whether or not screenlock is required for the DevicePolicy to be true. Defaults to false.
   *
   * @default false.
   * @schema AccessLevelSpecForProviderBasicConditionsDevicePolicy#requireScreenLock
   */
  readonly requireScreenLock?: boolean;

}

/**
 * Converts an object of type 'AccessLevelSpecForProviderBasicConditionsDevicePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecForProviderBasicConditionsDevicePolicy(obj: AccessLevelSpecForProviderBasicConditionsDevicePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedDeviceManagementLevels': obj.allowedDeviceManagementLevels?.map(y => y),
    'allowedEncryptionStatuses': obj.allowedEncryptionStatuses?.map(y => y),
    'osConstraints': obj.osConstraints?.map(y => toJson_AccessLevelSpecForProviderBasicConditionsDevicePolicyOsConstraints(y)),
    'requireAdminApproval': obj.requireAdminApproval,
    'requireCorpOwned': obj.requireCorpOwned,
    'requireScreenLock': obj.requireScreenLock,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessLevelSpecInitProviderBasicConditionsDevicePolicy
 */
export interface AccessLevelSpecInitProviderBasicConditionsDevicePolicy {
  /**
   * A list of allowed device management levels. An empty list allows all management levels. Each value may be one of: MANAGEMENT_UNSPECIFIED, NONE, BASIC, COMPLETE.
   *
   * @schema AccessLevelSpecInitProviderBasicConditionsDevicePolicy#allowedDeviceManagementLevels
   */
  readonly allowedDeviceManagementLevels?: string[];

  /**
   * A list of allowed encryptions statuses. An empty list allows all statuses. Each value may be one of: ENCRYPTION_UNSPECIFIED, ENCRYPTION_UNSUPPORTED, UNENCRYPTED, ENCRYPTED.
   *
   * @schema AccessLevelSpecInitProviderBasicConditionsDevicePolicy#allowedEncryptionStatuses
   */
  readonly allowedEncryptionStatuses?: string[];

  /**
   * A list of allowed OS versions. An empty list allows all types and all versions. Structure is documented below.
   *
   * @schema AccessLevelSpecInitProviderBasicConditionsDevicePolicy#osConstraints
   */
  readonly osConstraints?: AccessLevelSpecInitProviderBasicConditionsDevicePolicyOsConstraints[];

  /**
   * Whether the device needs to be approved by the customer admin.
   *
   * @schema AccessLevelSpecInitProviderBasicConditionsDevicePolicy#requireAdminApproval
   */
  readonly requireAdminApproval?: boolean;

  /**
   * Whether the device needs to be corp owned.
   *
   * @schema AccessLevelSpecInitProviderBasicConditionsDevicePolicy#requireCorpOwned
   */
  readonly requireCorpOwned?: boolean;

  /**
   * Whether or not screenlock is required for the DevicePolicy to be true. Defaults to false.
   *
   * @default false.
   * @schema AccessLevelSpecInitProviderBasicConditionsDevicePolicy#requireScreenLock
   */
  readonly requireScreenLock?: boolean;

}

/**
 * Converts an object of type 'AccessLevelSpecInitProviderBasicConditionsDevicePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecInitProviderBasicConditionsDevicePolicy(obj: AccessLevelSpecInitProviderBasicConditionsDevicePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedDeviceManagementLevels': obj.allowedDeviceManagementLevels?.map(y => y),
    'allowedEncryptionStatuses': obj.allowedEncryptionStatuses?.map(y => y),
    'osConstraints': obj.osConstraints?.map(y => toJson_AccessLevelSpecInitProviderBasicConditionsDevicePolicyOsConstraints(y)),
    'requireAdminApproval': obj.requireAdminApproval,
    'requireCorpOwned': obj.requireCorpOwned,
    'requireScreenLock': obj.requireScreenLock,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessLevelSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccessLevelSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessLevelSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccessLevelSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema AccessLevelSpecForProviderBasicConditionsDevicePolicyOsConstraints
 */
export interface AccessLevelSpecForProviderBasicConditionsDevicePolicyOsConstraints {
  /**
   * The minimum allowed OS version. If not set, any version of this OS satisfies the constraint. Format: "major.minor.patch" such as "10.5.301", "9.2.1".
   *
   * @schema AccessLevelSpecForProviderBasicConditionsDevicePolicyOsConstraints#minimumVersion
   */
  readonly minimumVersion?: string;

  /**
   * The operating system type of the device. Possible values are: OS_UNSPECIFIED, DESKTOP_MAC, DESKTOP_WINDOWS, DESKTOP_LINUX, DESKTOP_CHROME_OS, ANDROID, IOS.
   *
   * @schema AccessLevelSpecForProviderBasicConditionsDevicePolicyOsConstraints#osType
   */
  readonly osType?: string;

  /**
   * If you specify DESKTOP_CHROME_OS for osType, you can optionally include requireVerifiedChromeOs to require Chrome Verified Access.
   *
   * @schema AccessLevelSpecForProviderBasicConditionsDevicePolicyOsConstraints#requireVerifiedChromeOs
   */
  readonly requireVerifiedChromeOs?: boolean;

}

/**
 * Converts an object of type 'AccessLevelSpecForProviderBasicConditionsDevicePolicyOsConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecForProviderBasicConditionsDevicePolicyOsConstraints(obj: AccessLevelSpecForProviderBasicConditionsDevicePolicyOsConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumVersion': obj.minimumVersion,
    'osType': obj.osType,
    'requireVerifiedChromeOs': obj.requireVerifiedChromeOs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessLevelSpecInitProviderBasicConditionsDevicePolicyOsConstraints
 */
export interface AccessLevelSpecInitProviderBasicConditionsDevicePolicyOsConstraints {
  /**
   * The minimum allowed OS version. If not set, any version of this OS satisfies the constraint. Format: "major.minor.patch" such as "10.5.301", "9.2.1".
   *
   * @schema AccessLevelSpecInitProviderBasicConditionsDevicePolicyOsConstraints#minimumVersion
   */
  readonly minimumVersion?: string;

  /**
   * The operating system type of the device. Possible values are: OS_UNSPECIFIED, DESKTOP_MAC, DESKTOP_WINDOWS, DESKTOP_LINUX, DESKTOP_CHROME_OS, ANDROID, IOS.
   *
   * @schema AccessLevelSpecInitProviderBasicConditionsDevicePolicyOsConstraints#osType
   */
  readonly osType?: string;

  /**
   * If you specify DESKTOP_CHROME_OS for osType, you can optionally include requireVerifiedChromeOs to require Chrome Verified Access.
   *
   * @schema AccessLevelSpecInitProviderBasicConditionsDevicePolicyOsConstraints#requireVerifiedChromeOs
   */
  readonly requireVerifiedChromeOs?: boolean;

}

/**
 * Converts an object of type 'AccessLevelSpecInitProviderBasicConditionsDevicePolicyOsConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelSpecInitProviderBasicConditionsDevicePolicyOsConstraints(obj: AccessLevelSpecInitProviderBasicConditionsDevicePolicyOsConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumVersion': obj.minimumVersion,
    'osType': obj.osType,
    'requireVerifiedChromeOs': obj.requireVerifiedChromeOs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * AccessLevelCondition is the Schema for the AccessLevelConditions API. Allows configuring a single access level condition to be appended to an access level's conditions.
 *
 * @schema AccessLevelCondition
 */
export class AccessLevelCondition extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AccessLevelCondition"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'accesscontextmanager.gcp.upbound.io/v1beta1',
    kind: 'AccessLevelCondition',
  }

  /**
   * Renders a Kubernetes manifest for "AccessLevelCondition".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccessLevelConditionProps): any {
    return {
      ...AccessLevelCondition.GVK,
      ...toJson_AccessLevelConditionProps(props),
    };
  }

  /**
   * Defines a "AccessLevelCondition" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccessLevelConditionProps) {
    super(scope, id, {
      ...AccessLevelCondition.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AccessLevelCondition.GVK,
      ...toJson_AccessLevelConditionProps(resolved),
    };
  }
}

/**
 * AccessLevelCondition is the Schema for the AccessLevelConditions API. Allows configuring a single access level condition to be appended to an access level's conditions.
 *
 * @schema AccessLevelCondition
 */
export interface AccessLevelConditionProps {
  /**
   * @schema AccessLevelCondition#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccessLevelConditionSpec defines the desired state of AccessLevelCondition
   *
   * @schema AccessLevelCondition#spec
   */
  readonly spec: AccessLevelConditionSpec;

}

/**
 * Converts an object of type 'AccessLevelConditionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionProps(obj: AccessLevelConditionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccessLevelConditionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessLevelConditionSpec defines the desired state of AccessLevelCondition
 *
 * @schema AccessLevelConditionSpec
 */
export interface AccessLevelConditionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccessLevelConditionSpec#deletionPolicy
   */
  readonly deletionPolicy?: AccessLevelConditionSpecDeletionPolicy;

  /**
   * @schema AccessLevelConditionSpec#forProvider
   */
  readonly forProvider: AccessLevelConditionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AccessLevelConditionSpec#initProvider
   */
  readonly initProvider?: AccessLevelConditionSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AccessLevelConditionSpec#managementPolicies
   */
  readonly managementPolicies?: AccessLevelConditionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AccessLevelConditionSpec#providerConfigRef
   */
  readonly providerConfigRef?: AccessLevelConditionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AccessLevelConditionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccessLevelConditionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AccessLevelConditionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccessLevelConditionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccessLevelConditionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpec(obj: AccessLevelConditionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccessLevelConditionSpecForProvider(obj.forProvider),
    'initProvider': toJson_AccessLevelConditionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AccessLevelConditionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AccessLevelConditionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccessLevelConditionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccessLevelConditionSpecDeletionPolicy
 */
export enum AccessLevelConditionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AccessLevelConditionSpecForProvider
 */
export interface AccessLevelConditionSpecForProvider {
  /**
   * The name of the Access Level to add this condition to.
   *
   * @schema AccessLevelConditionSpecForProvider#accessLevel
   */
  readonly accessLevel?: string;

  /**
   * Reference to a AccessLevel in accesscontextmanager to populate accessLevel.
   *
   * @schema AccessLevelConditionSpecForProvider#accessLevelRef
   */
  readonly accessLevelRef?: AccessLevelConditionSpecForProviderAccessLevelRef;

  /**
   * Selector for a AccessLevel in accesscontextmanager to populate accessLevel.
   *
   * @schema AccessLevelConditionSpecForProvider#accessLevelSelector
   */
  readonly accessLevelSelector?: AccessLevelConditionSpecForProviderAccessLevelSelector;

  /**
   * Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are allowed. Structure is documented below.
   *
   * @schema AccessLevelConditionSpecForProvider#devicePolicy
   */
  readonly devicePolicy?: AccessLevelConditionSpecForProviderDevicePolicy[];

  /**
   * A list of CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order for this Condition to be true. If empty, all IP addresses are allowed.
   *
   * @schema AccessLevelConditionSpecForProvider#ipSubnetworks
   */
  readonly ipSubnetworks?: string[];

  /**
   * An allowed list of members (users, service accounts). Using groups is not supported yet. The signed-in user originating the request must be a part of one of the provided members. If not specified, a request may come from any user (logged in/not logged in, not present in any groups, etc.). Formats: user:{emailid}, serviceAccount:{emailid}
   *
   * @schema AccessLevelConditionSpecForProvider#members
   */
  readonly members?: string[];

  /**
   * Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be false for the Condition overall to be satisfied. Defaults to false.
   *
   * @default false.
   * @schema AccessLevelConditionSpecForProvider#negate
   */
  readonly negate?: boolean;

  /**
   * The request must originate from one of the provided countries/regions. Format: A valid ISO 3166-1 alpha-2 code.
   *
   * @schema AccessLevelConditionSpecForProvider#regions
   */
  readonly regions?: string[];

  /**
   * A list of other access levels defined in the same Policy, referenced by resource name. Referencing an AccessLevel which does not exist is an error. All access levels listed must be granted for the Condition to be true. Format: accessPolicies/{policy_id}/accessLevels/{short_name}
   *
   * @schema AccessLevelConditionSpecForProvider#requiredAccessLevels
   */
  readonly requiredAccessLevels?: string[];

}

/**
 * Converts an object of type 'AccessLevelConditionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpecForProvider(obj: AccessLevelConditionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLevel': obj.accessLevel,
    'accessLevelRef': toJson_AccessLevelConditionSpecForProviderAccessLevelRef(obj.accessLevelRef),
    'accessLevelSelector': toJson_AccessLevelConditionSpecForProviderAccessLevelSelector(obj.accessLevelSelector),
    'devicePolicy': obj.devicePolicy?.map(y => toJson_AccessLevelConditionSpecForProviderDevicePolicy(y)),
    'ipSubnetworks': obj.ipSubnetworks?.map(y => y),
    'members': obj.members?.map(y => y),
    'negate': obj.negate,
    'regions': obj.regions?.map(y => y),
    'requiredAccessLevels': obj.requiredAccessLevels?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AccessLevelConditionSpecInitProvider
 */
export interface AccessLevelConditionSpecInitProvider {
  /**
   * Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are allowed. Structure is documented below.
   *
   * @schema AccessLevelConditionSpecInitProvider#devicePolicy
   */
  readonly devicePolicy?: AccessLevelConditionSpecInitProviderDevicePolicy[];

  /**
   * A list of CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order for this Condition to be true. If empty, all IP addresses are allowed.
   *
   * @schema AccessLevelConditionSpecInitProvider#ipSubnetworks
   */
  readonly ipSubnetworks?: string[];

  /**
   * An allowed list of members (users, service accounts). Using groups is not supported yet. The signed-in user originating the request must be a part of one of the provided members. If not specified, a request may come from any user (logged in/not logged in, not present in any groups, etc.). Formats: user:{emailid}, serviceAccount:{emailid}
   *
   * @schema AccessLevelConditionSpecInitProvider#members
   */
  readonly members?: string[];

  /**
   * Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be false for the Condition overall to be satisfied. Defaults to false.
   *
   * @default false.
   * @schema AccessLevelConditionSpecInitProvider#negate
   */
  readonly negate?: boolean;

  /**
   * The request must originate from one of the provided countries/regions. Format: A valid ISO 3166-1 alpha-2 code.
   *
   * @schema AccessLevelConditionSpecInitProvider#regions
   */
  readonly regions?: string[];

  /**
   * A list of other access levels defined in the same Policy, referenced by resource name. Referencing an AccessLevel which does not exist is an error. All access levels listed must be granted for the Condition to be true. Format: accessPolicies/{policy_id}/accessLevels/{short_name}
   *
   * @schema AccessLevelConditionSpecInitProvider#requiredAccessLevels
   */
  readonly requiredAccessLevels?: string[];

}

/**
 * Converts an object of type 'AccessLevelConditionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpecInitProvider(obj: AccessLevelConditionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePolicy': obj.devicePolicy?.map(y => toJson_AccessLevelConditionSpecInitProviderDevicePolicy(y)),
    'ipSubnetworks': obj.ipSubnetworks?.map(y => y),
    'members': obj.members?.map(y => y),
    'negate': obj.negate,
    'regions': obj.regions?.map(y => y),
    'requiredAccessLevels': obj.requiredAccessLevels?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AccessLevelConditionSpecManagementPolicies
 */
export enum AccessLevelConditionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AccessLevelConditionSpecProviderConfigRef
 */
export interface AccessLevelConditionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessLevelConditionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessLevelConditionSpecProviderConfigRef#policy
   */
  readonly policy?: AccessLevelConditionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessLevelConditionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpecProviderConfigRef(obj: AccessLevelConditionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessLevelConditionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AccessLevelConditionSpecPublishConnectionDetailsTo
 */
export interface AccessLevelConditionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AccessLevelConditionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccessLevelConditionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccessLevelConditionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccessLevelConditionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccessLevelConditionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccessLevelConditionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpecPublishConnectionDetailsTo(obj: AccessLevelConditionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccessLevelConditionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccessLevelConditionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AccessLevelConditionSpecWriteConnectionSecretToRef
 */
export interface AccessLevelConditionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccessLevelConditionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccessLevelConditionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccessLevelConditionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpecWriteConnectionSecretToRef(obj: AccessLevelConditionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a AccessLevel in accesscontextmanager to populate accessLevel.
 *
 * @schema AccessLevelConditionSpecForProviderAccessLevelRef
 */
export interface AccessLevelConditionSpecForProviderAccessLevelRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessLevelConditionSpecForProviderAccessLevelRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessLevelConditionSpecForProviderAccessLevelRef#policy
   */
  readonly policy?: AccessLevelConditionSpecForProviderAccessLevelRefPolicy;

}

/**
 * Converts an object of type 'AccessLevelConditionSpecForProviderAccessLevelRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpecForProviderAccessLevelRef(obj: AccessLevelConditionSpecForProviderAccessLevelRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessLevelConditionSpecForProviderAccessLevelRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a AccessLevel in accesscontextmanager to populate accessLevel.
 *
 * @schema AccessLevelConditionSpecForProviderAccessLevelSelector
 */
export interface AccessLevelConditionSpecForProviderAccessLevelSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AccessLevelConditionSpecForProviderAccessLevelSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AccessLevelConditionSpecForProviderAccessLevelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AccessLevelConditionSpecForProviderAccessLevelSelector#policy
   */
  readonly policy?: AccessLevelConditionSpecForProviderAccessLevelSelectorPolicy;

}

/**
 * Converts an object of type 'AccessLevelConditionSpecForProviderAccessLevelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpecForProviderAccessLevelSelector(obj: AccessLevelConditionSpecForProviderAccessLevelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AccessLevelConditionSpecForProviderAccessLevelSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessLevelConditionSpecForProviderDevicePolicy
 */
export interface AccessLevelConditionSpecForProviderDevicePolicy {
  /**
   * A list of allowed device management levels. An empty list allows all management levels. Each value may be one of: MANAGEMENT_UNSPECIFIED, NONE, BASIC, COMPLETE.
   *
   * @schema AccessLevelConditionSpecForProviderDevicePolicy#allowedDeviceManagementLevels
   */
  readonly allowedDeviceManagementLevels?: string[];

  /**
   * A list of allowed encryptions statuses. An empty list allows all statuses. Each value may be one of: ENCRYPTION_UNSPECIFIED, ENCRYPTION_UNSUPPORTED, UNENCRYPTED, ENCRYPTED.
   *
   * @schema AccessLevelConditionSpecForProviderDevicePolicy#allowedEncryptionStatuses
   */
  readonly allowedEncryptionStatuses?: string[];

  /**
   * A list of allowed OS versions. An empty list allows all types and all versions. Structure is documented below.
   *
   * @schema AccessLevelConditionSpecForProviderDevicePolicy#osConstraints
   */
  readonly osConstraints?: AccessLevelConditionSpecForProviderDevicePolicyOsConstraints[];

  /**
   * Whether the device needs to be approved by the customer admin.
   *
   * @schema AccessLevelConditionSpecForProviderDevicePolicy#requireAdminApproval
   */
  readonly requireAdminApproval?: boolean;

  /**
   * Whether the device needs to be corp owned.
   *
   * @schema AccessLevelConditionSpecForProviderDevicePolicy#requireCorpOwned
   */
  readonly requireCorpOwned?: boolean;

  /**
   * Whether or not screenlock is required for the DevicePolicy to be true. Defaults to false.
   *
   * @default false.
   * @schema AccessLevelConditionSpecForProviderDevicePolicy#requireScreenLock
   */
  readonly requireScreenLock?: boolean;

}

/**
 * Converts an object of type 'AccessLevelConditionSpecForProviderDevicePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpecForProviderDevicePolicy(obj: AccessLevelConditionSpecForProviderDevicePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedDeviceManagementLevels': obj.allowedDeviceManagementLevels?.map(y => y),
    'allowedEncryptionStatuses': obj.allowedEncryptionStatuses?.map(y => y),
    'osConstraints': obj.osConstraints?.map(y => toJson_AccessLevelConditionSpecForProviderDevicePolicyOsConstraints(y)),
    'requireAdminApproval': obj.requireAdminApproval,
    'requireCorpOwned': obj.requireCorpOwned,
    'requireScreenLock': obj.requireScreenLock,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessLevelConditionSpecInitProviderDevicePolicy
 */
export interface AccessLevelConditionSpecInitProviderDevicePolicy {
  /**
   * A list of allowed device management levels. An empty list allows all management levels. Each value may be one of: MANAGEMENT_UNSPECIFIED, NONE, BASIC, COMPLETE.
   *
   * @schema AccessLevelConditionSpecInitProviderDevicePolicy#allowedDeviceManagementLevels
   */
  readonly allowedDeviceManagementLevels?: string[];

  /**
   * A list of allowed encryptions statuses. An empty list allows all statuses. Each value may be one of: ENCRYPTION_UNSPECIFIED, ENCRYPTION_UNSUPPORTED, UNENCRYPTED, ENCRYPTED.
   *
   * @schema AccessLevelConditionSpecInitProviderDevicePolicy#allowedEncryptionStatuses
   */
  readonly allowedEncryptionStatuses?: string[];

  /**
   * A list of allowed OS versions. An empty list allows all types and all versions. Structure is documented below.
   *
   * @schema AccessLevelConditionSpecInitProviderDevicePolicy#osConstraints
   */
  readonly osConstraints?: AccessLevelConditionSpecInitProviderDevicePolicyOsConstraints[];

  /**
   * Whether the device needs to be approved by the customer admin.
   *
   * @schema AccessLevelConditionSpecInitProviderDevicePolicy#requireAdminApproval
   */
  readonly requireAdminApproval?: boolean;

  /**
   * Whether the device needs to be corp owned.
   *
   * @schema AccessLevelConditionSpecInitProviderDevicePolicy#requireCorpOwned
   */
  readonly requireCorpOwned?: boolean;

  /**
   * Whether or not screenlock is required for the DevicePolicy to be true. Defaults to false.
   *
   * @default false.
   * @schema AccessLevelConditionSpecInitProviderDevicePolicy#requireScreenLock
   */
  readonly requireScreenLock?: boolean;

}

/**
 * Converts an object of type 'AccessLevelConditionSpecInitProviderDevicePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpecInitProviderDevicePolicy(obj: AccessLevelConditionSpecInitProviderDevicePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedDeviceManagementLevels': obj.allowedDeviceManagementLevels?.map(y => y),
    'allowedEncryptionStatuses': obj.allowedEncryptionStatuses?.map(y => y),
    'osConstraints': obj.osConstraints?.map(y => toJson_AccessLevelConditionSpecInitProviderDevicePolicyOsConstraints(y)),
    'requireAdminApproval': obj.requireAdminApproval,
    'requireCorpOwned': obj.requireCorpOwned,
    'requireScreenLock': obj.requireScreenLock,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessLevelConditionSpecProviderConfigRefPolicy
 */
export interface AccessLevelConditionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessLevelConditionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccessLevelConditionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessLevelConditionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccessLevelConditionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessLevelConditionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpecProviderConfigRefPolicy(obj: AccessLevelConditionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AccessLevelConditionSpecPublishConnectionDetailsToConfigRef
 */
export interface AccessLevelConditionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessLevelConditionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessLevelConditionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccessLevelConditionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessLevelConditionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpecPublishConnectionDetailsToConfigRef(obj: AccessLevelConditionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessLevelConditionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccessLevelConditionSpecPublishConnectionDetailsToMetadata
 */
export interface AccessLevelConditionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessLevelConditionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessLevelConditionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccessLevelConditionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccessLevelConditionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpecPublishConnectionDetailsToMetadata(obj: AccessLevelConditionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessLevelConditionSpecForProviderAccessLevelRefPolicy
 */
export interface AccessLevelConditionSpecForProviderAccessLevelRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessLevelConditionSpecForProviderAccessLevelRefPolicy#resolution
   */
  readonly resolution?: AccessLevelConditionSpecForProviderAccessLevelRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessLevelConditionSpecForProviderAccessLevelRefPolicy#resolve
   */
  readonly resolve?: AccessLevelConditionSpecForProviderAccessLevelRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessLevelConditionSpecForProviderAccessLevelRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpecForProviderAccessLevelRefPolicy(obj: AccessLevelConditionSpecForProviderAccessLevelRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AccessLevelConditionSpecForProviderAccessLevelSelectorPolicy
 */
export interface AccessLevelConditionSpecForProviderAccessLevelSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessLevelConditionSpecForProviderAccessLevelSelectorPolicy#resolution
   */
  readonly resolution?: AccessLevelConditionSpecForProviderAccessLevelSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessLevelConditionSpecForProviderAccessLevelSelectorPolicy#resolve
   */
  readonly resolve?: AccessLevelConditionSpecForProviderAccessLevelSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AccessLevelConditionSpecForProviderAccessLevelSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpecForProviderAccessLevelSelectorPolicy(obj: AccessLevelConditionSpecForProviderAccessLevelSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessLevelConditionSpecForProviderDevicePolicyOsConstraints
 */
export interface AccessLevelConditionSpecForProviderDevicePolicyOsConstraints {
  /**
   * The minimum allowed OS version. If not set, any version of this OS satisfies the constraint. Format: "major.minor.patch" such as "10.5.301", "9.2.1".
   *
   * @schema AccessLevelConditionSpecForProviderDevicePolicyOsConstraints#minimumVersion
   */
  readonly minimumVersion?: string;

  /**
   * The operating system type of the device. Possible values are: OS_UNSPECIFIED, DESKTOP_MAC, DESKTOP_WINDOWS, DESKTOP_LINUX, DESKTOP_CHROME_OS, ANDROID, IOS.
   *
   * @schema AccessLevelConditionSpecForProviderDevicePolicyOsConstraints#osType
   */
  readonly osType?: string;

}

/**
 * Converts an object of type 'AccessLevelConditionSpecForProviderDevicePolicyOsConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpecForProviderDevicePolicyOsConstraints(obj: AccessLevelConditionSpecForProviderDevicePolicyOsConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumVersion': obj.minimumVersion,
    'osType': obj.osType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessLevelConditionSpecInitProviderDevicePolicyOsConstraints
 */
export interface AccessLevelConditionSpecInitProviderDevicePolicyOsConstraints {
  /**
   * The minimum allowed OS version. If not set, any version of this OS satisfies the constraint. Format: "major.minor.patch" such as "10.5.301", "9.2.1".
   *
   * @schema AccessLevelConditionSpecInitProviderDevicePolicyOsConstraints#minimumVersion
   */
  readonly minimumVersion?: string;

  /**
   * The operating system type of the device. Possible values are: OS_UNSPECIFIED, DESKTOP_MAC, DESKTOP_WINDOWS, DESKTOP_LINUX, DESKTOP_CHROME_OS, ANDROID, IOS.
   *
   * @schema AccessLevelConditionSpecInitProviderDevicePolicyOsConstraints#osType
   */
  readonly osType?: string;

}

/**
 * Converts an object of type 'AccessLevelConditionSpecInitProviderDevicePolicyOsConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpecInitProviderDevicePolicyOsConstraints(obj: AccessLevelConditionSpecInitProviderDevicePolicyOsConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumVersion': obj.minimumVersion,
    'osType': obj.osType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessLevelConditionSpecProviderConfigRefPolicyResolution
 */
export enum AccessLevelConditionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessLevelConditionSpecProviderConfigRefPolicyResolve
 */
export enum AccessLevelConditionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccessLevelConditionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccessLevelConditionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessLevelConditionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccessLevelConditionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessLevelConditionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccessLevelConditionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessLevelConditionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessLevelConditionSpecPublishConnectionDetailsToConfigRefPolicy(obj: AccessLevelConditionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessLevelConditionSpecForProviderAccessLevelRefPolicyResolution
 */
export enum AccessLevelConditionSpecForProviderAccessLevelRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessLevelConditionSpecForProviderAccessLevelRefPolicyResolve
 */
export enum AccessLevelConditionSpecForProviderAccessLevelRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessLevelConditionSpecForProviderAccessLevelSelectorPolicyResolution
 */
export enum AccessLevelConditionSpecForProviderAccessLevelSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessLevelConditionSpecForProviderAccessLevelSelectorPolicyResolve
 */
export enum AccessLevelConditionSpecForProviderAccessLevelSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessLevelConditionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccessLevelConditionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessLevelConditionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccessLevelConditionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * AccessPolicy is the Schema for the AccessPolicys API. AccessPolicy is a container for AccessLevels (which define the necessary attributes to use GCP services) and ServicePerimeters (which define regions of services able to freely pass data within a perimeter).
 *
 * @schema AccessPolicy
 */
export class AccessPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AccessPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'accesscontextmanager.gcp.upbound.io/v1beta1',
    kind: 'AccessPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "AccessPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccessPolicyProps): any {
    return {
      ...AccessPolicy.GVK,
      ...toJson_AccessPolicyProps(props),
    };
  }

  /**
   * Defines a "AccessPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccessPolicyProps) {
    super(scope, id, {
      ...AccessPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AccessPolicy.GVK,
      ...toJson_AccessPolicyProps(resolved),
    };
  }
}

/**
 * AccessPolicy is the Schema for the AccessPolicys API. AccessPolicy is a container for AccessLevels (which define the necessary attributes to use GCP services) and ServicePerimeters (which define regions of services able to freely pass data within a perimeter).
 *
 * @schema AccessPolicy
 */
export interface AccessPolicyProps {
  /**
   * @schema AccessPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccessPolicySpec defines the desired state of AccessPolicy
   *
   * @schema AccessPolicy#spec
   */
  readonly spec: AccessPolicySpec;

}

/**
 * Converts an object of type 'AccessPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicyProps(obj: AccessPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccessPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessPolicySpec defines the desired state of AccessPolicy
 *
 * @schema AccessPolicySpec
 */
export interface AccessPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccessPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: AccessPolicySpecDeletionPolicy;

  /**
   * @schema AccessPolicySpec#forProvider
   */
  readonly forProvider: AccessPolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AccessPolicySpec#initProvider
   */
  readonly initProvider?: AccessPolicySpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AccessPolicySpec#managementPolicies
   */
  readonly managementPolicies?: AccessPolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AccessPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: AccessPolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AccessPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccessPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AccessPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccessPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccessPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicySpec(obj: AccessPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccessPolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_AccessPolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AccessPolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AccessPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccessPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccessPolicySpecDeletionPolicy
 */
export enum AccessPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AccessPolicySpecForProvider
 */
export interface AccessPolicySpecForProvider {
  /**
   * The parent of this AccessPolicy in the Cloud Resource Hierarchy. Format: organizations/{organization_id}
   *
   * @schema AccessPolicySpecForProvider#parent
   */
  readonly parent?: string;

  /**
   * Folder or project on which this policy is applicable. Format: folders/{{folder_id}} or projects/{{project_id}}
   *
   * @schema AccessPolicySpecForProvider#scopes
   */
  readonly scopes?: string[];

  /**
   * Human readable title. Does not affect behavior.
   *
   * @schema AccessPolicySpecForProvider#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'AccessPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicySpecForProvider(obj: AccessPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parent': obj.parent,
    'scopes': obj.scopes?.map(y => y),
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AccessPolicySpecInitProvider
 */
export interface AccessPolicySpecInitProvider {
  /**
   * The parent of this AccessPolicy in the Cloud Resource Hierarchy. Format: organizations/{organization_id}
   *
   * @schema AccessPolicySpecInitProvider#parent
   */
  readonly parent?: string;

  /**
   * Folder or project on which this policy is applicable. Format: folders/{{folder_id}} or projects/{{project_id}}
   *
   * @schema AccessPolicySpecInitProvider#scopes
   */
  readonly scopes?: string[];

  /**
   * Human readable title. Does not affect behavior.
   *
   * @schema AccessPolicySpecInitProvider#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'AccessPolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicySpecInitProvider(obj: AccessPolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parent': obj.parent,
    'scopes': obj.scopes?.map(y => y),
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AccessPolicySpecManagementPolicies
 */
export enum AccessPolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AccessPolicySpecProviderConfigRef
 */
export interface AccessPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPolicySpecProviderConfigRef#policy
   */
  readonly policy?: AccessPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicySpecProviderConfigRef(obj: AccessPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AccessPolicySpecPublishConnectionDetailsTo
 */
export interface AccessPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AccessPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccessPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccessPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccessPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccessPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccessPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicySpecPublishConnectionDetailsTo(obj: AccessPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccessPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccessPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AccessPolicySpecWriteConnectionSecretToRef
 */
export interface AccessPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccessPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccessPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccessPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicySpecWriteConnectionSecretToRef(obj: AccessPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPolicySpecProviderConfigRefPolicy
 */
export interface AccessPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccessPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccessPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicySpecProviderConfigRefPolicy(obj: AccessPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AccessPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface AccessPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccessPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicySpecPublishConnectionDetailsToConfigRef(obj: AccessPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccessPolicySpecPublishConnectionDetailsToMetadata
 */
export interface AccessPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccessPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccessPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicySpecPublishConnectionDetailsToMetadata(obj: AccessPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPolicySpecProviderConfigRefPolicyResolution
 */
export enum AccessPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPolicySpecProviderConfigRefPolicyResolve
 */
export enum AccessPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccessPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccessPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: AccessPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * AccessPolicyIAMMember is the Schema for the AccessPolicyIAMMembers API. <no value>
 *
 * @schema AccessPolicyIAMMember
 */
export class AccessPolicyIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AccessPolicyIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'accesscontextmanager.gcp.upbound.io/v1beta1',
    kind: 'AccessPolicyIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "AccessPolicyIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccessPolicyIamMemberProps): any {
    return {
      ...AccessPolicyIamMember.GVK,
      ...toJson_AccessPolicyIamMemberProps(props),
    };
  }

  /**
   * Defines a "AccessPolicyIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccessPolicyIamMemberProps) {
    super(scope, id, {
      ...AccessPolicyIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AccessPolicyIamMember.GVK,
      ...toJson_AccessPolicyIamMemberProps(resolved),
    };
  }
}

/**
 * AccessPolicyIAMMember is the Schema for the AccessPolicyIAMMembers API. <no value>
 *
 * @schema AccessPolicyIAMMember
 */
export interface AccessPolicyIamMemberProps {
  /**
   * @schema AccessPolicyIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccessPolicyIAMMemberSpec defines the desired state of AccessPolicyIAMMember
   *
   * @schema AccessPolicyIAMMember#spec
   */
  readonly spec: AccessPolicyIamMemberSpec;

}

/**
 * Converts an object of type 'AccessPolicyIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicyIamMemberProps(obj: AccessPolicyIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccessPolicyIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessPolicyIAMMemberSpec defines the desired state of AccessPolicyIAMMember
 *
 * @schema AccessPolicyIamMemberSpec
 */
export interface AccessPolicyIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccessPolicyIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: AccessPolicyIamMemberSpecDeletionPolicy;

  /**
   * @schema AccessPolicyIamMemberSpec#forProvider
   */
  readonly forProvider: AccessPolicyIamMemberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AccessPolicyIamMemberSpec#initProvider
   */
  readonly initProvider?: AccessPolicyIamMemberSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AccessPolicyIamMemberSpec#managementPolicies
   */
  readonly managementPolicies?: AccessPolicyIamMemberSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AccessPolicyIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: AccessPolicyIamMemberSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AccessPolicyIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccessPolicyIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AccessPolicyIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccessPolicyIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccessPolicyIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicyIamMemberSpec(obj: AccessPolicyIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccessPolicyIamMemberSpecForProvider(obj.forProvider),
    'initProvider': toJson_AccessPolicyIamMemberSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AccessPolicyIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AccessPolicyIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccessPolicyIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccessPolicyIamMemberSpecDeletionPolicy
 */
export enum AccessPolicyIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AccessPolicyIamMemberSpecForProvider
 */
export interface AccessPolicyIamMemberSpecForProvider {
  /**
   * @schema AccessPolicyIamMemberSpecForProvider#condition
   */
  readonly condition?: AccessPolicyIamMemberSpecForProviderCondition[];

  /**
   * @schema AccessPolicyIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema AccessPolicyIamMemberSpecForProvider#name
   */
  readonly name?: string;

  /**
   * @schema AccessPolicyIamMemberSpecForProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'AccessPolicyIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicyIamMemberSpecForProvider(obj: AccessPolicyIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_AccessPolicyIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'name': obj.name,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AccessPolicyIamMemberSpecInitProvider
 */
export interface AccessPolicyIamMemberSpecInitProvider {
  /**
   * @schema AccessPolicyIamMemberSpecInitProvider#condition
   */
  readonly condition?: AccessPolicyIamMemberSpecInitProviderCondition[];

  /**
   * @schema AccessPolicyIamMemberSpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema AccessPolicyIamMemberSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * @schema AccessPolicyIamMemberSpecInitProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'AccessPolicyIamMemberSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicyIamMemberSpecInitProvider(obj: AccessPolicyIamMemberSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_AccessPolicyIamMemberSpecInitProviderCondition(y)),
    'member': obj.member,
    'name': obj.name,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AccessPolicyIamMemberSpecManagementPolicies
 */
export enum AccessPolicyIamMemberSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AccessPolicyIamMemberSpecProviderConfigRef
 */
export interface AccessPolicyIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPolicyIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPolicyIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: AccessPolicyIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessPolicyIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicyIamMemberSpecProviderConfigRef(obj: AccessPolicyIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPolicyIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AccessPolicyIamMemberSpecPublishConnectionDetailsTo
 */
export interface AccessPolicyIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AccessPolicyIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccessPolicyIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccessPolicyIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccessPolicyIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccessPolicyIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicyIamMemberSpecPublishConnectionDetailsTo(obj: AccessPolicyIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccessPolicyIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AccessPolicyIamMemberSpecWriteConnectionSecretToRef
 */
export interface AccessPolicyIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccessPolicyIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccessPolicyIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccessPolicyIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicyIamMemberSpecWriteConnectionSecretToRef(obj: AccessPolicyIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessPolicyIamMemberSpecForProviderCondition
 */
export interface AccessPolicyIamMemberSpecForProviderCondition {
  /**
   * @schema AccessPolicyIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema AccessPolicyIamMemberSpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema AccessPolicyIamMemberSpecForProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'AccessPolicyIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicyIamMemberSpecForProviderCondition(obj: AccessPolicyIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessPolicyIamMemberSpecInitProviderCondition
 */
export interface AccessPolicyIamMemberSpecInitProviderCondition {
  /**
   * @schema AccessPolicyIamMemberSpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema AccessPolicyIamMemberSpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema AccessPolicyIamMemberSpecInitProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'AccessPolicyIamMemberSpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicyIamMemberSpecInitProviderCondition(obj: AccessPolicyIamMemberSpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPolicyIamMemberSpecProviderConfigRefPolicy
 */
export interface AccessPolicyIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPolicyIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccessPolicyIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPolicyIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccessPolicyIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPolicyIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicyIamMemberSpecProviderConfigRefPolicy(obj: AccessPolicyIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRef(obj: AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccessPolicyIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface AccessPolicyIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessPolicyIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessPolicyIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccessPolicyIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccessPolicyIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicyIamMemberSpecPublishConnectionDetailsToMetadata(obj: AccessPolicyIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPolicyIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum AccessPolicyIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPolicyIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum AccessPolicyIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccessPolicyIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ServicePerimeter is the Schema for the ServicePerimeters API. ServicePerimeter describes a set of GCP resources which can freely import and export data amongst themselves, but not export outside of the ServicePerimeter.
 *
 * @schema ServicePerimeter
 */
export class ServicePerimeter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServicePerimeter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'accesscontextmanager.gcp.upbound.io/v1beta1',
    kind: 'ServicePerimeter',
  }

  /**
   * Renders a Kubernetes manifest for "ServicePerimeter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServicePerimeterProps): any {
    return {
      ...ServicePerimeter.GVK,
      ...toJson_ServicePerimeterProps(props),
    };
  }

  /**
   * Defines a "ServicePerimeter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServicePerimeterProps) {
    super(scope, id, {
      ...ServicePerimeter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServicePerimeter.GVK,
      ...toJson_ServicePerimeterProps(resolved),
    };
  }
}

/**
 * ServicePerimeter is the Schema for the ServicePerimeters API. ServicePerimeter describes a set of GCP resources which can freely import and export data amongst themselves, but not export outside of the ServicePerimeter.
 *
 * @schema ServicePerimeter
 */
export interface ServicePerimeterProps {
  /**
   * @schema ServicePerimeter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServicePerimeterSpec defines the desired state of ServicePerimeter
   *
   * @schema ServicePerimeter#spec
   */
  readonly spec: ServicePerimeterSpec;

}

/**
 * Converts an object of type 'ServicePerimeterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterProps(obj: ServicePerimeterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServicePerimeterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServicePerimeterSpec defines the desired state of ServicePerimeter
 *
 * @schema ServicePerimeterSpec
 */
export interface ServicePerimeterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServicePerimeterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServicePerimeterSpecDeletionPolicy;

  /**
   * @schema ServicePerimeterSpec#forProvider
   */
  readonly forProvider: ServicePerimeterSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ServicePerimeterSpec#initProvider
   */
  readonly initProvider?: ServicePerimeterSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServicePerimeterSpec#managementPolicies
   */
  readonly managementPolicies?: ServicePerimeterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServicePerimeterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServicePerimeterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServicePerimeterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServicePerimeterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServicePerimeterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServicePerimeterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServicePerimeterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpec(obj: ServicePerimeterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServicePerimeterSpecForProvider(obj.forProvider),
    'initProvider': toJson_ServicePerimeterSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServicePerimeterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ServicePerimeterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServicePerimeterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServicePerimeterSpecDeletionPolicy
 */
export enum ServicePerimeterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServicePerimeterSpecForProvider
 */
export interface ServicePerimeterSpecForProvider {
  /**
   * Description of the ServicePerimeter and its use. Does not affect behavior.
   *
   * @schema ServicePerimeterSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Resource name for the ServicePerimeter. The short_name component must begin with a letter and only include alphanumeric and '_'. Format: accessPolicies/{policy_id}/servicePerimeters/{short_name}
   *
   * @schema ServicePerimeterSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The AccessPolicy this ServicePerimeter lives in. Format: accessPolicies/{policy_id}
   *
   * @schema ServicePerimeterSpecForProvider#parent
   */
  readonly parent?: string;

  /**
   * Specifies the type of the Perimeter. There are two types: regular and bridge. Regular Service Perimeter contains resources, access levels, and restricted services. Every resource can be in at most ONE regular Service Perimeter. In addition to being in a regular service perimeter, a resource can also be in zero or more perimeter bridges. A perimeter bridge only contains resources. Cross project operations are permitted if all effected resources share some perimeter (whether bridge or regular). Perimeter Bridge does not contain access levels or services: those are governed entirely by the regular perimeter that resource is in. Perimeter Bridges are typically useful when building more complex topologies with many independent perimeters that need to share some data with a common perimeter, but should not be able to share data among themselves. Default value is PERIMETER_TYPE_REGULAR. Possible values are: PERIMETER_TYPE_REGULAR, PERIMETER_TYPE_BRIDGE.
   *
   * @schema ServicePerimeterSpecForProvider#perimeterType
   */
  readonly perimeterType?: string;

  /**
   * Proposed (or dry run) ServicePerimeter configuration. This configuration allows to specify and test ServicePerimeter configuration without enforcing actual access restrictions. Only allowed to be set when the useExplicitDryRunSpec flag is set. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProvider#spec
   */
  readonly spec?: ServicePerimeterSpecForProviderSpec[];

  /**
   * ServicePerimeter configuration. Specifies sets of resources, restricted services and access levels that determine perimeter content and boundaries. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProvider#status
   */
  readonly status?: ServicePerimeterSpecForProviderStatus[];

  /**
   * Human readable title. Must be unique within the Policy.
   *
   * @schema ServicePerimeterSpecForProvider#title
   */
  readonly title?: string;

  /**
   * Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly exists for all Service Perimeters, and that spec is identical to the status for those Service Perimeters. When this flag is set, it inhibits the generation of the implicit spec, thereby allowing the user to explicitly provide a configuration ("spec") to use in a dry-run version of the Service Perimeter. This allows the user to test changes to the enforced config ("status") without actually enforcing them. This testing is done through analyzing the differences between currently enforced and suggested restrictions. useExplicitDryRunSpec must bet set to True if any of the fields in the spec are set to non-default values.
   *
   * @schema ServicePerimeterSpecForProvider#useExplicitDryRunSpec
   */
  readonly useExplicitDryRunSpec?: boolean;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProvider(obj: ServicePerimeterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'parent': obj.parent,
    'perimeterType': obj.perimeterType,
    'spec': obj.spec?.map(y => toJson_ServicePerimeterSpecForProviderSpec(y)),
    'status': obj.status?.map(y => toJson_ServicePerimeterSpecForProviderStatus(y)),
    'title': obj.title,
    'useExplicitDryRunSpec': obj.useExplicitDryRunSpec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ServicePerimeterSpecInitProvider
 */
export interface ServicePerimeterSpecInitProvider {
  /**
   * Description of the ServicePerimeter and its use. Does not affect behavior.
   *
   * @schema ServicePerimeterSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Resource name for the ServicePerimeter. The short_name component must begin with a letter and only include alphanumeric and '_'. Format: accessPolicies/{policy_id}/servicePerimeters/{short_name}
   *
   * @schema ServicePerimeterSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The AccessPolicy this ServicePerimeter lives in. Format: accessPolicies/{policy_id}
   *
   * @schema ServicePerimeterSpecInitProvider#parent
   */
  readonly parent?: string;

  /**
   * Specifies the type of the Perimeter. There are two types: regular and bridge. Regular Service Perimeter contains resources, access levels, and restricted services. Every resource can be in at most ONE regular Service Perimeter. In addition to being in a regular service perimeter, a resource can also be in zero or more perimeter bridges. A perimeter bridge only contains resources. Cross project operations are permitted if all effected resources share some perimeter (whether bridge or regular). Perimeter Bridge does not contain access levels or services: those are governed entirely by the regular perimeter that resource is in. Perimeter Bridges are typically useful when building more complex topologies with many independent perimeters that need to share some data with a common perimeter, but should not be able to share data among themselves. Default value is PERIMETER_TYPE_REGULAR. Possible values are: PERIMETER_TYPE_REGULAR, PERIMETER_TYPE_BRIDGE.
   *
   * @schema ServicePerimeterSpecInitProvider#perimeterType
   */
  readonly perimeterType?: string;

  /**
   * Proposed (or dry run) ServicePerimeter configuration. This configuration allows to specify and test ServicePerimeter configuration without enforcing actual access restrictions. Only allowed to be set when the useExplicitDryRunSpec flag is set. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProvider#spec
   */
  readonly spec?: ServicePerimeterSpecInitProviderSpec[];

  /**
   * ServicePerimeter configuration. Specifies sets of resources, restricted services and access levels that determine perimeter content and boundaries. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProvider#status
   */
  readonly status?: ServicePerimeterSpecInitProviderStatus[];

  /**
   * Human readable title. Must be unique within the Policy.
   *
   * @schema ServicePerimeterSpecInitProvider#title
   */
  readonly title?: string;

  /**
   * Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly exists for all Service Perimeters, and that spec is identical to the status for those Service Perimeters. When this flag is set, it inhibits the generation of the implicit spec, thereby allowing the user to explicitly provide a configuration ("spec") to use in a dry-run version of the Service Perimeter. This allows the user to test changes to the enforced config ("status") without actually enforcing them. This testing is done through analyzing the differences between currently enforced and suggested restrictions. useExplicitDryRunSpec must bet set to True if any of the fields in the spec are set to non-default values.
   *
   * @schema ServicePerimeterSpecInitProvider#useExplicitDryRunSpec
   */
  readonly useExplicitDryRunSpec?: boolean;

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProvider(obj: ServicePerimeterSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'parent': obj.parent,
    'perimeterType': obj.perimeterType,
    'spec': obj.spec?.map(y => toJson_ServicePerimeterSpecInitProviderSpec(y)),
    'status': obj.status?.map(y => toJson_ServicePerimeterSpecInitProviderStatus(y)),
    'title': obj.title,
    'useExplicitDryRunSpec': obj.useExplicitDryRunSpec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ServicePerimeterSpecManagementPolicies
 */
export enum ServicePerimeterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServicePerimeterSpecProviderConfigRef
 */
export interface ServicePerimeterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServicePerimeterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServicePerimeterSpecProviderConfigRef#policy
   */
  readonly policy?: ServicePerimeterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServicePerimeterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecProviderConfigRef(obj: ServicePerimeterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServicePerimeterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServicePerimeterSpecPublishConnectionDetailsTo
 */
export interface ServicePerimeterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServicePerimeterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServicePerimeterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServicePerimeterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServicePerimeterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServicePerimeterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecPublishConnectionDetailsTo(obj: ServicePerimeterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServicePerimeterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServicePerimeterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServicePerimeterSpecWriteConnectionSecretToRef
 */
export interface ServicePerimeterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServicePerimeterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServicePerimeterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecWriteConnectionSecretToRef(obj: ServicePerimeterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderSpec
 */
export interface ServicePerimeterSpecForProviderSpec {
  /**
   * A list of AccessLevel resource names that allow resources within the ServicePerimeter to be accessed from the internet. AccessLevels listed must be in the same policy as this ServicePerimeter. Referencing a nonexistent AccessLevel is a syntax error. If no AccessLevel names are listed, resources within the perimeter can only be accessed via GCP calls with request origins within the perimeter. For Service Perimeter Bridge, must be empty. Format: accessPolicies/{policy_id}/accessLevels/{access_level_name}
   *
   * @schema ServicePerimeterSpecForProviderSpec#accessLevels
   */
  readonly accessLevels?: string[];

  /**
   * References to AccessLevel to populate accessLevels.
   *
   * @schema ServicePerimeterSpecForProviderSpec#accessLevelsRefs
   */
  readonly accessLevelsRefs?: ServicePerimeterSpecForProviderSpecAccessLevelsRefs[];

  /**
   * Selector for a list of AccessLevel to populate accessLevels.
   *
   * @schema ServicePerimeterSpecForProviderSpec#accessLevelsSelector
   */
  readonly accessLevelsSelector?: ServicePerimeterSpecForProviderSpecAccessLevelsSelector;

  /**
   * List of EgressPolicies to apply to the perimeter. A perimeter may have multiple EgressPolicies, each of which is evaluated separately. Access is granted if any EgressPolicy grants it. Must be empty for a perimeter bridge. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderSpec#egressPolicies
   */
  readonly egressPolicies?: ServicePerimeterSpecForProviderSpecEgressPolicies[];

  /**
   * List of IngressPolicies to apply to the perimeter. A perimeter may have multiple IngressPolicies, each of which is evaluated separately. Access is granted if any Ingress Policy grants it. Must be empty for a perimeter bridge. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderSpec#ingressPolicies
   */
  readonly ingressPolicies?: ServicePerimeterSpecForProviderSpecIngressPolicies[];

  /**
   * A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}
   *
   * @schema ServicePerimeterSpecForProviderSpec#resources
   */
  readonly resources?: string[];

  /**
   * GCP services that are subject to the Service Perimeter restrictions. Must contain a list of services. For example, if storage.googleapis.com is specified, access to the storage buckets inside the perimeter must meet the perimeter's access restrictions.
   *
   * @schema ServicePerimeterSpecForProviderSpec#restrictedServices
   */
  readonly restrictedServices?: string[];

  /**
   * Specifies how APIs are allowed to communicate within the Service Perimeter. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderSpec#vpcAccessibleServices
   */
  readonly vpcAccessibleServices?: ServicePerimeterSpecForProviderSpecVpcAccessibleServices[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderSpec(obj: ServicePerimeterSpecForProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLevels': obj.accessLevels?.map(y => y),
    'accessLevelsRefs': obj.accessLevelsRefs?.map(y => toJson_ServicePerimeterSpecForProviderSpecAccessLevelsRefs(y)),
    'accessLevelsSelector': toJson_ServicePerimeterSpecForProviderSpecAccessLevelsSelector(obj.accessLevelsSelector),
    'egressPolicies': obj.egressPolicies?.map(y => toJson_ServicePerimeterSpecForProviderSpecEgressPolicies(y)),
    'ingressPolicies': obj.ingressPolicies?.map(y => toJson_ServicePerimeterSpecForProviderSpecIngressPolicies(y)),
    'resources': obj.resources?.map(y => y),
    'restrictedServices': obj.restrictedServices?.map(y => y),
    'vpcAccessibleServices': obj.vpcAccessibleServices?.map(y => toJson_ServicePerimeterSpecForProviderSpecVpcAccessibleServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderStatus
 */
export interface ServicePerimeterSpecForProviderStatus {
  /**
   * A list of AccessLevel resource names that allow resources within the ServicePerimeter to be accessed from the internet. AccessLevels listed must be in the same policy as this ServicePerimeter. Referencing a nonexistent AccessLevel is a syntax error. If no AccessLevel names are listed, resources within the perimeter can only be accessed via GCP calls with request origins within the perimeter. For Service Perimeter Bridge, must be empty. Format: accessPolicies/{policy_id}/accessLevels/{access_level_name}
   *
   * @schema ServicePerimeterSpecForProviderStatus#accessLevels
   */
  readonly accessLevels?: string[];

  /**
   * References to AccessLevel to populate accessLevels.
   *
   * @schema ServicePerimeterSpecForProviderStatus#accessLevelsRefs
   */
  readonly accessLevelsRefs?: ServicePerimeterSpecForProviderStatusAccessLevelsRefs[];

  /**
   * Selector for a list of AccessLevel to populate accessLevels.
   *
   * @schema ServicePerimeterSpecForProviderStatus#accessLevelsSelector
   */
  readonly accessLevelsSelector?: ServicePerimeterSpecForProviderStatusAccessLevelsSelector;

  /**
   * List of EgressPolicies to apply to the perimeter. A perimeter may have multiple EgressPolicies, each of which is evaluated separately. Access is granted if any EgressPolicy grants it. Must be empty for a perimeter bridge. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderStatus#egressPolicies
   */
  readonly egressPolicies?: ServicePerimeterSpecForProviderStatusEgressPolicies[];

  /**
   * List of IngressPolicies to apply to the perimeter. A perimeter may have multiple IngressPolicies, each of which is evaluated separately. Access is granted if any Ingress Policy grants it. Must be empty for a perimeter bridge. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderStatus#ingressPolicies
   */
  readonly ingressPolicies?: ServicePerimeterSpecForProviderStatusIngressPolicies[];

  /**
   * A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}
   *
   * @schema ServicePerimeterSpecForProviderStatus#resources
   */
  readonly resources?: string[];

  /**
   * GCP services that are subject to the Service Perimeter restrictions. Must contain a list of services. For example, if storage.googleapis.com is specified, access to the storage buckets inside the perimeter must meet the perimeter's access restrictions.
   *
   * @schema ServicePerimeterSpecForProviderStatus#restrictedServices
   */
  readonly restrictedServices?: string[];

  /**
   * Specifies how APIs are allowed to communicate within the Service Perimeter. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderStatus#vpcAccessibleServices
   */
  readonly vpcAccessibleServices?: ServicePerimeterSpecForProviderStatusVpcAccessibleServices[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatus(obj: ServicePerimeterSpecForProviderStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLevels': obj.accessLevels?.map(y => y),
    'accessLevelsRefs': obj.accessLevelsRefs?.map(y => toJson_ServicePerimeterSpecForProviderStatusAccessLevelsRefs(y)),
    'accessLevelsSelector': toJson_ServicePerimeterSpecForProviderStatusAccessLevelsSelector(obj.accessLevelsSelector),
    'egressPolicies': obj.egressPolicies?.map(y => toJson_ServicePerimeterSpecForProviderStatusEgressPolicies(y)),
    'ingressPolicies': obj.ingressPolicies?.map(y => toJson_ServicePerimeterSpecForProviderStatusIngressPolicies(y)),
    'resources': obj.resources?.map(y => y),
    'restrictedServices': obj.restrictedServices?.map(y => y),
    'vpcAccessibleServices': obj.vpcAccessibleServices?.map(y => toJson_ServicePerimeterSpecForProviderStatusVpcAccessibleServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderSpec
 */
export interface ServicePerimeterSpecInitProviderSpec {
  /**
   * List of EgressPolicies to apply to the perimeter. A perimeter may have multiple EgressPolicies, each of which is evaluated separately. Access is granted if any EgressPolicy grants it. Must be empty for a perimeter bridge. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderSpec#egressPolicies
   */
  readonly egressPolicies?: ServicePerimeterSpecInitProviderSpecEgressPolicies[];

  /**
   * List of IngressPolicies to apply to the perimeter. A perimeter may have multiple IngressPolicies, each of which is evaluated separately. Access is granted if any Ingress Policy grants it. Must be empty for a perimeter bridge. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderSpec#ingressPolicies
   */
  readonly ingressPolicies?: ServicePerimeterSpecInitProviderSpecIngressPolicies[];

  /**
   * A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}
   *
   * @schema ServicePerimeterSpecInitProviderSpec#resources
   */
  readonly resources?: string[];

  /**
   * GCP services that are subject to the Service Perimeter restrictions. Must contain a list of services. For example, if storage.googleapis.com is specified, access to the storage buckets inside the perimeter must meet the perimeter's access restrictions.
   *
   * @schema ServicePerimeterSpecInitProviderSpec#restrictedServices
   */
  readonly restrictedServices?: string[];

  /**
   * Specifies how APIs are allowed to communicate within the Service Perimeter. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderSpec#vpcAccessibleServices
   */
  readonly vpcAccessibleServices?: ServicePerimeterSpecInitProviderSpecVpcAccessibleServices[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderSpec(obj: ServicePerimeterSpecInitProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egressPolicies': obj.egressPolicies?.map(y => toJson_ServicePerimeterSpecInitProviderSpecEgressPolicies(y)),
    'ingressPolicies': obj.ingressPolicies?.map(y => toJson_ServicePerimeterSpecInitProviderSpecIngressPolicies(y)),
    'resources': obj.resources?.map(y => y),
    'restrictedServices': obj.restrictedServices?.map(y => y),
    'vpcAccessibleServices': obj.vpcAccessibleServices?.map(y => toJson_ServicePerimeterSpecInitProviderSpecVpcAccessibleServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderStatus
 */
export interface ServicePerimeterSpecInitProviderStatus {
  /**
   * List of EgressPolicies to apply to the perimeter. A perimeter may have multiple EgressPolicies, each of which is evaluated separately. Access is granted if any EgressPolicy grants it. Must be empty for a perimeter bridge. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderStatus#egressPolicies
   */
  readonly egressPolicies?: ServicePerimeterSpecInitProviderStatusEgressPolicies[];

  /**
   * List of IngressPolicies to apply to the perimeter. A perimeter may have multiple IngressPolicies, each of which is evaluated separately. Access is granted if any Ingress Policy grants it. Must be empty for a perimeter bridge. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderStatus#ingressPolicies
   */
  readonly ingressPolicies?: ServicePerimeterSpecInitProviderStatusIngressPolicies[];

  /**
   * A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}
   *
   * @schema ServicePerimeterSpecInitProviderStatus#resources
   */
  readonly resources?: string[];

  /**
   * GCP services that are subject to the Service Perimeter restrictions. Must contain a list of services. For example, if storage.googleapis.com is specified, access to the storage buckets inside the perimeter must meet the perimeter's access restrictions.
   *
   * @schema ServicePerimeterSpecInitProviderStatus#restrictedServices
   */
  readonly restrictedServices?: string[];

  /**
   * Specifies how APIs are allowed to communicate within the Service Perimeter. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderStatus#vpcAccessibleServices
   */
  readonly vpcAccessibleServices?: ServicePerimeterSpecInitProviderStatusVpcAccessibleServices[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderStatus(obj: ServicePerimeterSpecInitProviderStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egressPolicies': obj.egressPolicies?.map(y => toJson_ServicePerimeterSpecInitProviderStatusEgressPolicies(y)),
    'ingressPolicies': obj.ingressPolicies?.map(y => toJson_ServicePerimeterSpecInitProviderStatusIngressPolicies(y)),
    'resources': obj.resources?.map(y => y),
    'restrictedServices': obj.restrictedServices?.map(y => y),
    'vpcAccessibleServices': obj.vpcAccessibleServices?.map(y => toJson_ServicePerimeterSpecInitProviderStatusVpcAccessibleServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServicePerimeterSpecProviderConfigRefPolicy
 */
export interface ServicePerimeterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServicePerimeterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServicePerimeterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServicePerimeterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServicePerimeterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServicePerimeterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecProviderConfigRefPolicy(obj: ServicePerimeterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServicePerimeterSpecPublishConnectionDetailsToConfigRef
 */
export interface ServicePerimeterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServicePerimeterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServicePerimeterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServicePerimeterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServicePerimeterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecPublishConnectionDetailsToConfigRef(obj: ServicePerimeterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServicePerimeterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServicePerimeterSpecPublishConnectionDetailsToMetadata
 */
export interface ServicePerimeterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServicePerimeterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServicePerimeterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServicePerimeterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecPublishConnectionDetailsToMetadata(obj: ServicePerimeterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ServicePerimeterSpecForProviderSpecAccessLevelsRefs
 */
export interface ServicePerimeterSpecForProviderSpecAccessLevelsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ServicePerimeterSpecForProviderSpecAccessLevelsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServicePerimeterSpecForProviderSpecAccessLevelsRefs#policy
   */
  readonly policy?: ServicePerimeterSpecForProviderSpecAccessLevelsRefsPolicy;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderSpecAccessLevelsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderSpecAccessLevelsRefs(obj: ServicePerimeterSpecForProviderSpecAccessLevelsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServicePerimeterSpecForProviderSpecAccessLevelsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of AccessLevel to populate accessLevels.
 *
 * @schema ServicePerimeterSpecForProviderSpecAccessLevelsSelector
 */
export interface ServicePerimeterSpecForProviderSpecAccessLevelsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServicePerimeterSpecForProviderSpecAccessLevelsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServicePerimeterSpecForProviderSpecAccessLevelsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServicePerimeterSpecForProviderSpecAccessLevelsSelector#policy
   */
  readonly policy?: ServicePerimeterSpecForProviderSpecAccessLevelsSelectorPolicy;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderSpecAccessLevelsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderSpecAccessLevelsSelector(obj: ServicePerimeterSpecForProviderSpecAccessLevelsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServicePerimeterSpecForProviderSpecAccessLevelsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderSpecEgressPolicies
 */
export interface ServicePerimeterSpecForProviderSpecEgressPolicies {
  /**
   * Defines conditions on the source of a request causing this EgressPolicy to apply. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderSpecEgressPolicies#egressFrom
   */
  readonly egressFrom?: ServicePerimeterSpecForProviderSpecEgressPoliciesEgressFrom[];

  /**
   * Defines the conditions on the ApiOperation and destination resources that cause this EgressPolicy to apply. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderSpecEgressPolicies#egressTo
   */
  readonly egressTo?: ServicePerimeterSpecForProviderSpecEgressPoliciesEgressTo[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderSpecEgressPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderSpecEgressPolicies(obj: ServicePerimeterSpecForProviderSpecEgressPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egressFrom': obj.egressFrom?.map(y => toJson_ServicePerimeterSpecForProviderSpecEgressPoliciesEgressFrom(y)),
    'egressTo': obj.egressTo?.map(y => toJson_ServicePerimeterSpecForProviderSpecEgressPoliciesEgressTo(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderSpecIngressPolicies
 */
export interface ServicePerimeterSpecForProviderSpecIngressPolicies {
  /**
   * Defines the conditions on the source of a request causing this IngressPolicy to apply. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderSpecIngressPolicies#ingressFrom
   */
  readonly ingressFrom?: ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFrom[];

  /**
   * Defines the conditions on the ApiOperation and request destination that cause this IngressPolicy to apply. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderSpecIngressPolicies#ingressTo
   */
  readonly ingressTo?: ServicePerimeterSpecForProviderSpecIngressPoliciesIngressTo[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderSpecIngressPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderSpecIngressPolicies(obj: ServicePerimeterSpecForProviderSpecIngressPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ingressFrom': obj.ingressFrom?.map(y => toJson_ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFrom(y)),
    'ingressTo': obj.ingressTo?.map(y => toJson_ServicePerimeterSpecForProviderSpecIngressPoliciesIngressTo(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderSpecVpcAccessibleServices
 */
export interface ServicePerimeterSpecForProviderSpecVpcAccessibleServices {
  /**
   * The list of APIs usable within the Service Perimeter. Must be empty unless enableRestriction is True.
   *
   * @schema ServicePerimeterSpecForProviderSpecVpcAccessibleServices#allowedServices
   */
  readonly allowedServices?: string[];

  /**
   * Whether to restrict API calls within the Service Perimeter to the list of APIs specified in 'allowedServices'.
   *
   * @schema ServicePerimeterSpecForProviderSpecVpcAccessibleServices#enableRestriction
   */
  readonly enableRestriction?: boolean;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderSpecVpcAccessibleServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderSpecVpcAccessibleServices(obj: ServicePerimeterSpecForProviderSpecVpcAccessibleServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedServices': obj.allowedServices?.map(y => y),
    'enableRestriction': obj.enableRestriction,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ServicePerimeterSpecForProviderStatusAccessLevelsRefs
 */
export interface ServicePerimeterSpecForProviderStatusAccessLevelsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ServicePerimeterSpecForProviderStatusAccessLevelsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServicePerimeterSpecForProviderStatusAccessLevelsRefs#policy
   */
  readonly policy?: ServicePerimeterSpecForProviderStatusAccessLevelsRefsPolicy;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusAccessLevelsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusAccessLevelsRefs(obj: ServicePerimeterSpecForProviderStatusAccessLevelsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServicePerimeterSpecForProviderStatusAccessLevelsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of AccessLevel to populate accessLevels.
 *
 * @schema ServicePerimeterSpecForProviderStatusAccessLevelsSelector
 */
export interface ServicePerimeterSpecForProviderStatusAccessLevelsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServicePerimeterSpecForProviderStatusAccessLevelsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServicePerimeterSpecForProviderStatusAccessLevelsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServicePerimeterSpecForProviderStatusAccessLevelsSelector#policy
   */
  readonly policy?: ServicePerimeterSpecForProviderStatusAccessLevelsSelectorPolicy;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusAccessLevelsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusAccessLevelsSelector(obj: ServicePerimeterSpecForProviderStatusAccessLevelsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServicePerimeterSpecForProviderStatusAccessLevelsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderStatusEgressPolicies
 */
export interface ServicePerimeterSpecForProviderStatusEgressPolicies {
  /**
   * Defines conditions on the source of a request causing this EgressPolicy to apply. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderStatusEgressPolicies#egressFrom
   */
  readonly egressFrom?: ServicePerimeterSpecForProviderStatusEgressPoliciesEgressFrom[];

  /**
   * Defines the conditions on the ApiOperation and destination resources that cause this EgressPolicy to apply. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderStatusEgressPolicies#egressTo
   */
  readonly egressTo?: ServicePerimeterSpecForProviderStatusEgressPoliciesEgressTo[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusEgressPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusEgressPolicies(obj: ServicePerimeterSpecForProviderStatusEgressPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egressFrom': obj.egressFrom?.map(y => toJson_ServicePerimeterSpecForProviderStatusEgressPoliciesEgressFrom(y)),
    'egressTo': obj.egressTo?.map(y => toJson_ServicePerimeterSpecForProviderStatusEgressPoliciesEgressTo(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderStatusIngressPolicies
 */
export interface ServicePerimeterSpecForProviderStatusIngressPolicies {
  /**
   * Defines the conditions on the source of a request causing this IngressPolicy to apply. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPolicies#ingressFrom
   */
  readonly ingressFrom?: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFrom[];

  /**
   * Defines the conditions on the ApiOperation and request destination that cause this IngressPolicy to apply. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPolicies#ingressTo
   */
  readonly ingressTo?: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressTo[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusIngressPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusIngressPolicies(obj: ServicePerimeterSpecForProviderStatusIngressPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ingressFrom': obj.ingressFrom?.map(y => toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFrom(y)),
    'ingressTo': obj.ingressTo?.map(y => toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressTo(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderStatusVpcAccessibleServices
 */
export interface ServicePerimeterSpecForProviderStatusVpcAccessibleServices {
  /**
   * The list of APIs usable within the Service Perimeter. Must be empty unless enableRestriction is True.
   *
   * @schema ServicePerimeterSpecForProviderStatusVpcAccessibleServices#allowedServices
   */
  readonly allowedServices?: string[];

  /**
   * Whether to restrict API calls within the Service Perimeter to the list of APIs specified in 'allowedServices'.
   *
   * @schema ServicePerimeterSpecForProviderStatusVpcAccessibleServices#enableRestriction
   */
  readonly enableRestriction?: boolean;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusVpcAccessibleServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusVpcAccessibleServices(obj: ServicePerimeterSpecForProviderStatusVpcAccessibleServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedServices': obj.allowedServices?.map(y => y),
    'enableRestriction': obj.enableRestriction,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderSpecEgressPolicies
 */
export interface ServicePerimeterSpecInitProviderSpecEgressPolicies {
  /**
   * Defines conditions on the source of a request causing this EgressPolicy to apply. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderSpecEgressPolicies#egressFrom
   */
  readonly egressFrom?: ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressFrom[];

  /**
   * Defines the conditions on the ApiOperation and destination resources that cause this EgressPolicy to apply. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderSpecEgressPolicies#egressTo
   */
  readonly egressTo?: ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressTo[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderSpecEgressPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderSpecEgressPolicies(obj: ServicePerimeterSpecInitProviderSpecEgressPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egressFrom': obj.egressFrom?.map(y => toJson_ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressFrom(y)),
    'egressTo': obj.egressTo?.map(y => toJson_ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressTo(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderSpecIngressPolicies
 */
export interface ServicePerimeterSpecInitProviderSpecIngressPolicies {
  /**
   * Defines the conditions on the source of a request causing this IngressPolicy to apply. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderSpecIngressPolicies#ingressFrom
   */
  readonly ingressFrom?: ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFrom[];

  /**
   * Defines the conditions on the ApiOperation and request destination that cause this IngressPolicy to apply. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderSpecIngressPolicies#ingressTo
   */
  readonly ingressTo?: ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressTo[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderSpecIngressPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderSpecIngressPolicies(obj: ServicePerimeterSpecInitProviderSpecIngressPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ingressFrom': obj.ingressFrom?.map(y => toJson_ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFrom(y)),
    'ingressTo': obj.ingressTo?.map(y => toJson_ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressTo(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderSpecVpcAccessibleServices
 */
export interface ServicePerimeterSpecInitProviderSpecVpcAccessibleServices {
  /**
   * The list of APIs usable within the Service Perimeter. Must be empty unless enableRestriction is True.
   *
   * @schema ServicePerimeterSpecInitProviderSpecVpcAccessibleServices#allowedServices
   */
  readonly allowedServices?: string[];

  /**
   * Whether to restrict API calls within the Service Perimeter to the list of APIs specified in 'allowedServices'.
   *
   * @schema ServicePerimeterSpecInitProviderSpecVpcAccessibleServices#enableRestriction
   */
  readonly enableRestriction?: boolean;

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderSpecVpcAccessibleServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderSpecVpcAccessibleServices(obj: ServicePerimeterSpecInitProviderSpecVpcAccessibleServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedServices': obj.allowedServices?.map(y => y),
    'enableRestriction': obj.enableRestriction,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderStatusEgressPolicies
 */
export interface ServicePerimeterSpecInitProviderStatusEgressPolicies {
  /**
   * Defines conditions on the source of a request causing this EgressPolicy to apply. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderStatusEgressPolicies#egressFrom
   */
  readonly egressFrom?: ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressFrom[];

  /**
   * Defines the conditions on the ApiOperation and destination resources that cause this EgressPolicy to apply. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderStatusEgressPolicies#egressTo
   */
  readonly egressTo?: ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressTo[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderStatusEgressPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderStatusEgressPolicies(obj: ServicePerimeterSpecInitProviderStatusEgressPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egressFrom': obj.egressFrom?.map(y => toJson_ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressFrom(y)),
    'egressTo': obj.egressTo?.map(y => toJson_ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressTo(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderStatusIngressPolicies
 */
export interface ServicePerimeterSpecInitProviderStatusIngressPolicies {
  /**
   * Defines the conditions on the source of a request causing this IngressPolicy to apply. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderStatusIngressPolicies#ingressFrom
   */
  readonly ingressFrom?: ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFrom[];

  /**
   * Defines the conditions on the ApiOperation and request destination that cause this IngressPolicy to apply. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderStatusIngressPolicies#ingressTo
   */
  readonly ingressTo?: ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressTo[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderStatusIngressPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderStatusIngressPolicies(obj: ServicePerimeterSpecInitProviderStatusIngressPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ingressFrom': obj.ingressFrom?.map(y => toJson_ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFrom(y)),
    'ingressTo': obj.ingressTo?.map(y => toJson_ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressTo(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderStatusVpcAccessibleServices
 */
export interface ServicePerimeterSpecInitProviderStatusVpcAccessibleServices {
  /**
   * The list of APIs usable within the Service Perimeter. Must be empty unless enableRestriction is True.
   *
   * @schema ServicePerimeterSpecInitProviderStatusVpcAccessibleServices#allowedServices
   */
  readonly allowedServices?: string[];

  /**
   * Whether to restrict API calls within the Service Perimeter to the list of APIs specified in 'allowedServices'.
   *
   * @schema ServicePerimeterSpecInitProviderStatusVpcAccessibleServices#enableRestriction
   */
  readonly enableRestriction?: boolean;

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderStatusVpcAccessibleServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderStatusVpcAccessibleServices(obj: ServicePerimeterSpecInitProviderStatusVpcAccessibleServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedServices': obj.allowedServices?.map(y => y),
    'enableRestriction': obj.enableRestriction,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServicePerimeterSpecProviderConfigRefPolicyResolution
 */
export enum ServicePerimeterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServicePerimeterSpecProviderConfigRefPolicyResolve
 */
export enum ServicePerimeterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServicePerimeterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServicePerimeterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServicePerimeterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServicePerimeterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServicePerimeterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServicePerimeterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServicePerimeterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServicePerimeterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServicePerimeterSpecForProviderSpecAccessLevelsRefsPolicy
 */
export interface ServicePerimeterSpecForProviderSpecAccessLevelsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServicePerimeterSpecForProviderSpecAccessLevelsRefsPolicy#resolution
   */
  readonly resolution?: ServicePerimeterSpecForProviderSpecAccessLevelsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServicePerimeterSpecForProviderSpecAccessLevelsRefsPolicy#resolve
   */
  readonly resolve?: ServicePerimeterSpecForProviderSpecAccessLevelsRefsPolicyResolve;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderSpecAccessLevelsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderSpecAccessLevelsRefsPolicy(obj: ServicePerimeterSpecForProviderSpecAccessLevelsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServicePerimeterSpecForProviderSpecAccessLevelsSelectorPolicy
 */
export interface ServicePerimeterSpecForProviderSpecAccessLevelsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServicePerimeterSpecForProviderSpecAccessLevelsSelectorPolicy#resolution
   */
  readonly resolution?: ServicePerimeterSpecForProviderSpecAccessLevelsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServicePerimeterSpecForProviderSpecAccessLevelsSelectorPolicy#resolve
   */
  readonly resolve?: ServicePerimeterSpecForProviderSpecAccessLevelsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderSpecAccessLevelsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderSpecAccessLevelsSelectorPolicy(obj: ServicePerimeterSpecForProviderSpecAccessLevelsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderSpecEgressPoliciesEgressFrom
 */
export interface ServicePerimeterSpecForProviderSpecEgressPoliciesEgressFrom {
  /**
   * A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.
   *
   * @schema ServicePerimeterSpecForProviderSpecEgressPoliciesEgressFrom#identities
   */
  readonly identities?: string[];

  /**
   * Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of identities field will be allowed access. Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
   *
   * @schema ServicePerimeterSpecForProviderSpecEgressPoliciesEgressFrom#identityType
   */
  readonly identityType?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderSpecEgressPoliciesEgressFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderSpecEgressPoliciesEgressFrom(obj: ServicePerimeterSpecForProviderSpecEgressPoliciesEgressFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identities': obj.identities?.map(y => y),
    'identityType': obj.identityType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderSpecEgressPoliciesEgressTo
 */
export interface ServicePerimeterSpecForProviderSpecEgressPoliciesEgressTo {
  /**
   * A list of external resources that are allowed to be accessed. A request matches if it contains an external resource in this list (Example: s3://bucket/path). Currently '*' is not allowed.
   *
   * @schema ServicePerimeterSpecForProviderSpecEgressPoliciesEgressTo#externalResources
   */
  readonly externalResources?: string[];

  /**
   * A list of ApiOperations the sources specified in corresponding IngressFrom are allowed to perform in this ServicePerimeter. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderSpecEgressPoliciesEgressTo#operations
   */
  readonly operations?: ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperations[];

  /**
   * A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}
   *
   * @schema ServicePerimeterSpecForProviderSpecEgressPoliciesEgressTo#resources
   */
  readonly resources?: string[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderSpecEgressPoliciesEgressTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderSpecEgressPoliciesEgressTo(obj: ServicePerimeterSpecForProviderSpecEgressPoliciesEgressTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalResources': obj.externalResources?.map(y => y),
    'operations': obj.operations?.map(y => toJson_ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperations(y)),
    'resources': obj.resources?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFrom
 */
export interface ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFrom {
  /**
   * A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.
   *
   * @schema ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFrom#identities
   */
  readonly identities?: string[];

  /**
   * Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of identities field will be allowed access. Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
   *
   * @schema ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFrom#identityType
   */
  readonly identityType?: string;

  /**
   * Sources that this IngressPolicy authorizes access from. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFrom#sources
   */
  readonly sources?: ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFromSources[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFrom(obj: ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identities': obj.identities?.map(y => y),
    'identityType': obj.identityType,
    'sources': obj.sources?.map(y => toJson_ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFromSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderSpecIngressPoliciesIngressTo
 */
export interface ServicePerimeterSpecForProviderSpecIngressPoliciesIngressTo {
  /**
   * A list of ApiOperations the sources specified in corresponding IngressFrom are allowed to perform in this ServicePerimeter. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderSpecIngressPoliciesIngressTo#operations
   */
  readonly operations?: ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperations[];

  /**
   * A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}
   *
   * @schema ServicePerimeterSpecForProviderSpecIngressPoliciesIngressTo#resources
   */
  readonly resources?: string[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderSpecIngressPoliciesIngressTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderSpecIngressPoliciesIngressTo(obj: ServicePerimeterSpecForProviderSpecIngressPoliciesIngressTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operations': obj.operations?.map(y => toJson_ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperations(y)),
    'resources': obj.resources?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServicePerimeterSpecForProviderStatusAccessLevelsRefsPolicy
 */
export interface ServicePerimeterSpecForProviderStatusAccessLevelsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServicePerimeterSpecForProviderStatusAccessLevelsRefsPolicy#resolution
   */
  readonly resolution?: ServicePerimeterSpecForProviderStatusAccessLevelsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServicePerimeterSpecForProviderStatusAccessLevelsRefsPolicy#resolve
   */
  readonly resolve?: ServicePerimeterSpecForProviderStatusAccessLevelsRefsPolicyResolve;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusAccessLevelsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusAccessLevelsRefsPolicy(obj: ServicePerimeterSpecForProviderStatusAccessLevelsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServicePerimeterSpecForProviderStatusAccessLevelsSelectorPolicy
 */
export interface ServicePerimeterSpecForProviderStatusAccessLevelsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServicePerimeterSpecForProviderStatusAccessLevelsSelectorPolicy#resolution
   */
  readonly resolution?: ServicePerimeterSpecForProviderStatusAccessLevelsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServicePerimeterSpecForProviderStatusAccessLevelsSelectorPolicy#resolve
   */
  readonly resolve?: ServicePerimeterSpecForProviderStatusAccessLevelsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusAccessLevelsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusAccessLevelsSelectorPolicy(obj: ServicePerimeterSpecForProviderStatusAccessLevelsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderStatusEgressPoliciesEgressFrom
 */
export interface ServicePerimeterSpecForProviderStatusEgressPoliciesEgressFrom {
  /**
   * A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.
   *
   * @schema ServicePerimeterSpecForProviderStatusEgressPoliciesEgressFrom#identities
   */
  readonly identities?: string[];

  /**
   * Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of identities field will be allowed access. Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
   *
   * @schema ServicePerimeterSpecForProviderStatusEgressPoliciesEgressFrom#identityType
   */
  readonly identityType?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusEgressPoliciesEgressFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusEgressPoliciesEgressFrom(obj: ServicePerimeterSpecForProviderStatusEgressPoliciesEgressFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identities': obj.identities?.map(y => y),
    'identityType': obj.identityType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderStatusEgressPoliciesEgressTo
 */
export interface ServicePerimeterSpecForProviderStatusEgressPoliciesEgressTo {
  /**
   * A list of external resources that are allowed to be accessed. A request matches if it contains an external resource in this list (Example: s3://bucket/path). Currently '*' is not allowed.
   *
   * @schema ServicePerimeterSpecForProviderStatusEgressPoliciesEgressTo#externalResources
   */
  readonly externalResources?: string[];

  /**
   * A list of ApiOperations the sources specified in corresponding IngressFrom are allowed to perform in this ServicePerimeter. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderStatusEgressPoliciesEgressTo#operations
   */
  readonly operations?: ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperations[];

  /**
   * A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}
   *
   * @schema ServicePerimeterSpecForProviderStatusEgressPoliciesEgressTo#resources
   */
  readonly resources?: string[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusEgressPoliciesEgressTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusEgressPoliciesEgressTo(obj: ServicePerimeterSpecForProviderStatusEgressPoliciesEgressTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalResources': obj.externalResources?.map(y => y),
    'operations': obj.operations?.map(y => toJson_ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperations(y)),
    'resources': obj.resources?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFrom
 */
export interface ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFrom {
  /**
   * A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFrom#identities
   */
  readonly identities?: string[];

  /**
   * Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of identities field will be allowed access. Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFrom#identityType
   */
  readonly identityType?: string;

  /**
   * Sources that this IngressPolicy authorizes access from. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFrom#sources
   */
  readonly sources?: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSources[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFrom(obj: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identities': obj.identities?.map(y => y),
    'identityType': obj.identityType,
    'sources': obj.sources?.map(y => toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressTo
 */
export interface ServicePerimeterSpecForProviderStatusIngressPoliciesIngressTo {
  /**
   * A list of ApiOperations the sources specified in corresponding IngressFrom are allowed to perform in this ServicePerimeter. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressTo#operations
   */
  readonly operations?: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperations[];

  /**
   * A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressTo#resources
   */
  readonly resources?: string[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusIngressPoliciesIngressTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressTo(obj: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operations': obj.operations?.map(y => toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperations(y)),
    'resources': obj.resources?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressFrom
 */
export interface ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressFrom {
  /**
   * A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.
   *
   * @schema ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressFrom#identities
   */
  readonly identities?: string[];

  /**
   * Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of identities field will be allowed access. Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
   *
   * @schema ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressFrom#identityType
   */
  readonly identityType?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressFrom(obj: ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identities': obj.identities?.map(y => y),
    'identityType': obj.identityType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressTo
 */
export interface ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressTo {
  /**
   * A list of external resources that are allowed to be accessed. A request matches if it contains an external resource in this list (Example: s3://bucket/path). Currently '*' is not allowed.
   *
   * @schema ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressTo#externalResources
   */
  readonly externalResources?: string[];

  /**
   * A list of ApiOperations the sources specified in corresponding IngressFrom are allowed to perform in this ServicePerimeter. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressTo#operations
   */
  readonly operations?: ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperations[];

  /**
   * A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}
   *
   * @schema ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressTo#resources
   */
  readonly resources?: string[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressTo(obj: ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalResources': obj.externalResources?.map(y => y),
    'operations': obj.operations?.map(y => toJson_ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperations(y)),
    'resources': obj.resources?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFrom
 */
export interface ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFrom {
  /**
   * A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.
   *
   * @schema ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFrom#identities
   */
  readonly identities?: string[];

  /**
   * Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of identities field will be allowed access. Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
   *
   * @schema ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFrom#identityType
   */
  readonly identityType?: string;

  /**
   * Sources that this IngressPolicy authorizes access from. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFrom#sources
   */
  readonly sources?: ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFromSources[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFrom(obj: ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identities': obj.identities?.map(y => y),
    'identityType': obj.identityType,
    'sources': obj.sources?.map(y => toJson_ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFromSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressTo
 */
export interface ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressTo {
  /**
   * A list of ApiOperations the sources specified in corresponding IngressFrom are allowed to perform in this ServicePerimeter. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressTo#operations
   */
  readonly operations?: ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperations[];

  /**
   * A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}
   *
   * @schema ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressTo#resources
   */
  readonly resources?: string[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressTo(obj: ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operations': obj.operations?.map(y => toJson_ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperations(y)),
    'resources': obj.resources?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressFrom
 */
export interface ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressFrom {
  /**
   * A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.
   *
   * @schema ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressFrom#identities
   */
  readonly identities?: string[];

  /**
   * Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of identities field will be allowed access. Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
   *
   * @schema ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressFrom#identityType
   */
  readonly identityType?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressFrom(obj: ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identities': obj.identities?.map(y => y),
    'identityType': obj.identityType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressTo
 */
export interface ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressTo {
  /**
   * A list of external resources that are allowed to be accessed. A request matches if it contains an external resource in this list (Example: s3://bucket/path). Currently '*' is not allowed.
   *
   * @schema ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressTo#externalResources
   */
  readonly externalResources?: string[];

  /**
   * A list of ApiOperations the sources specified in corresponding IngressFrom are allowed to perform in this ServicePerimeter. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressTo#operations
   */
  readonly operations?: ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperations[];

  /**
   * A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}
   *
   * @schema ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressTo#resources
   */
  readonly resources?: string[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressTo(obj: ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalResources': obj.externalResources?.map(y => y),
    'operations': obj.operations?.map(y => toJson_ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperations(y)),
    'resources': obj.resources?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFrom
 */
export interface ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFrom {
  /**
   * A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.
   *
   * @schema ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFrom#identities
   */
  readonly identities?: string[];

  /**
   * Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of identities field will be allowed access. Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.
   *
   * @schema ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFrom#identityType
   */
  readonly identityType?: string;

  /**
   * Sources that this IngressPolicy authorizes access from. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFrom#sources
   */
  readonly sources?: ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFromSources[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFrom(obj: ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identities': obj.identities?.map(y => y),
    'identityType': obj.identityType,
    'sources': obj.sources?.map(y => toJson_ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFromSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressTo
 */
export interface ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressTo {
  /**
   * A list of ApiOperations the sources specified in corresponding IngressFrom are allowed to perform in this ServicePerimeter. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressTo#operations
   */
  readonly operations?: ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperations[];

  /**
   * A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}
   *
   * @schema ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressTo#resources
   */
  readonly resources?: string[];

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressTo(obj: ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operations': obj.operations?.map(y => toJson_ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperations(y)),
    'resources': obj.resources?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServicePerimeterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServicePerimeterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServicePerimeterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServicePerimeterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServicePerimeterSpecForProviderSpecAccessLevelsRefsPolicyResolution
 */
export enum ServicePerimeterSpecForProviderSpecAccessLevelsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServicePerimeterSpecForProviderSpecAccessLevelsRefsPolicyResolve
 */
export enum ServicePerimeterSpecForProviderSpecAccessLevelsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServicePerimeterSpecForProviderSpecAccessLevelsSelectorPolicyResolution
 */
export enum ServicePerimeterSpecForProviderSpecAccessLevelsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServicePerimeterSpecForProviderSpecAccessLevelsSelectorPolicyResolve
 */
export enum ServicePerimeterSpecForProviderSpecAccessLevelsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperations
 */
export interface ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperations {
  /**
   * API methods or permissions to allow. Method or permission must belong to the service specified by serviceName field. A single MethodSelector entry with * specified for the method field will allow all methods AND permissions for the service specified in serviceName. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperations#methodSelectors
   */
  readonly methodSelectors?: ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperationsMethodSelectors[];

  /**
   * The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with serviceName field set to * will allow all methods AND permissions for all services.
   *
   * @schema ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperations#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperations(obj: ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'methodSelectors': obj.methodSelectors?.map(y => toJson_ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperationsMethodSelectors(y)),
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFromSources
 */
export interface ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFromSources {
  /**
   * An AccessLevel resource name that allow resources within the ServicePerimeters to be accessed from the internet. AccessLevels listed must be in the same policy as this ServicePerimeter. Referencing a nonexistent AccessLevel will cause an error. If no AccessLevel names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL. If * is specified, then all IngressSources will be allowed.
   *
   * @schema ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFromSources#accessLevel
   */
  readonly accessLevel?: string;

  /**
   * A Google Cloud resource that is allowed to ingress the perimeter. Requests from these resources will be allowed to access perimeter data. Currently only projects are allowed. Format projects/{project_number} The project may be in any Google Cloud organization, not just the organization that the perimeter is defined in. * is not allowed, the case of allowing all Google Cloud resources only is not supported.
   *
   * @schema ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFromSources#resource
   */
  readonly resource?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFromSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFromSources(obj: ServicePerimeterSpecForProviderSpecIngressPoliciesIngressFromSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLevel': obj.accessLevel,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperations
 */
export interface ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperations {
  /**
   * API methods or permissions to allow. Method or permission must belong to the service specified by serviceName field. A single MethodSelector entry with * specified for the method field will allow all methods AND permissions for the service specified in serviceName. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperations#methodSelectors
   */
  readonly methodSelectors?: ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperationsMethodSelectors[];

  /**
   * The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with serviceName field set to * will allow all methods AND permissions for all services.
   *
   * @schema ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperations#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperations(obj: ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'methodSelectors': obj.methodSelectors?.map(y => toJson_ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperationsMethodSelectors(y)),
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServicePerimeterSpecForProviderStatusAccessLevelsRefsPolicyResolution
 */
export enum ServicePerimeterSpecForProviderStatusAccessLevelsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServicePerimeterSpecForProviderStatusAccessLevelsRefsPolicyResolve
 */
export enum ServicePerimeterSpecForProviderStatusAccessLevelsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServicePerimeterSpecForProviderStatusAccessLevelsSelectorPolicyResolution
 */
export enum ServicePerimeterSpecForProviderStatusAccessLevelsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServicePerimeterSpecForProviderStatusAccessLevelsSelectorPolicyResolve
 */
export enum ServicePerimeterSpecForProviderStatusAccessLevelsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperations
 */
export interface ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperations {
  /**
   * API methods or permissions to allow. Method or permission must belong to the service specified by serviceName field. A single MethodSelector entry with * specified for the method field will allow all methods AND permissions for the service specified in serviceName. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperations#methodSelectors
   */
  readonly methodSelectors?: ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperationsMethodSelectors[];

  /**
   * The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with serviceName field set to * will allow all methods AND permissions for all services.
   *
   * @schema ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperations#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperations(obj: ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'methodSelectors': obj.methodSelectors?.map(y => toJson_ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperationsMethodSelectors(y)),
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSources
 */
export interface ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSources {
  /**
   * An AccessLevel resource name that allow resources within the ServicePerimeters to be accessed from the internet. AccessLevels listed must be in the same policy as this ServicePerimeter. Referencing a nonexistent AccessLevel will cause an error. If no AccessLevel names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL. If * is specified, then all IngressSources will be allowed.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSources#accessLevel
   */
  readonly accessLevel?: string;

  /**
   * Reference to a AccessLevel in accesscontextmanager to populate accessLevel.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSources#accessLevelRef
   */
  readonly accessLevelRef?: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRef;

  /**
   * Selector for a AccessLevel in accesscontextmanager to populate accessLevel.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSources#accessLevelSelector
   */
  readonly accessLevelSelector?: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelector;

  /**
   * A Google Cloud resource that is allowed to ingress the perimeter. Requests from these resources will be allowed to access perimeter data. Currently only projects are allowed. Format projects/{project_number} The project may be in any Google Cloud organization, not just the organization that the perimeter is defined in. * is not allowed, the case of allowing all Google Cloud resources only is not supported.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSources#resource
   */
  readonly resource?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSources(obj: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLevel': obj.accessLevel,
    'accessLevelRef': toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRef(obj.accessLevelRef),
    'accessLevelSelector': toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelector(obj.accessLevelSelector),
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperations
 */
export interface ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperations {
  /**
   * API methods or permissions to allow. Method or permission must belong to the service specified by serviceName field. A single MethodSelector entry with * specified for the method field will allow all methods AND permissions for the service specified in serviceName. Structure is documented below.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperations#methodSelectors
   */
  readonly methodSelectors?: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperationsMethodSelectors[];

  /**
   * The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with serviceName field set to * will allow all methods AND permissions for all services.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperations#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperations(obj: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'methodSelectors': obj.methodSelectors?.map(y => toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperationsMethodSelectors(y)),
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperations
 */
export interface ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperations {
  /**
   * API methods or permissions to allow. Method or permission must belong to the service specified by serviceName field. A single MethodSelector entry with * specified for the method field will allow all methods AND permissions for the service specified in serviceName. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperations#methodSelectors
   */
  readonly methodSelectors?: ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperationsMethodSelectors[];

  /**
   * The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with serviceName field set to * will allow all methods AND permissions for all services.
   *
   * @schema ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperations#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperations(obj: ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'methodSelectors': obj.methodSelectors?.map(y => toJson_ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperationsMethodSelectors(y)),
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFromSources
 */
export interface ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFromSources {
  /**
   * An AccessLevel resource name that allow resources within the ServicePerimeters to be accessed from the internet. AccessLevels listed must be in the same policy as this ServicePerimeter. Referencing a nonexistent AccessLevel will cause an error. If no AccessLevel names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL. If * is specified, then all IngressSources will be allowed.
   *
   * @schema ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFromSources#accessLevel
   */
  readonly accessLevel?: string;

  /**
   * A Google Cloud resource that is allowed to ingress the perimeter. Requests from these resources will be allowed to access perimeter data. Currently only projects are allowed. Format projects/{project_number} The project may be in any Google Cloud organization, not just the organization that the perimeter is defined in. * is not allowed, the case of allowing all Google Cloud resources only is not supported.
   *
   * @schema ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFromSources#resource
   */
  readonly resource?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFromSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFromSources(obj: ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressFromSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLevel': obj.accessLevel,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperations
 */
export interface ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperations {
  /**
   * API methods or permissions to allow. Method or permission must belong to the service specified by serviceName field. A single MethodSelector entry with * specified for the method field will allow all methods AND permissions for the service specified in serviceName. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperations#methodSelectors
   */
  readonly methodSelectors?: ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperationsMethodSelectors[];

  /**
   * The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with serviceName field set to * will allow all methods AND permissions for all services.
   *
   * @schema ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperations#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperations(obj: ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'methodSelectors': obj.methodSelectors?.map(y => toJson_ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperationsMethodSelectors(y)),
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperations
 */
export interface ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperations {
  /**
   * API methods or permissions to allow. Method or permission must belong to the service specified by serviceName field. A single MethodSelector entry with * specified for the method field will allow all methods AND permissions for the service specified in serviceName. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperations#methodSelectors
   */
  readonly methodSelectors?: ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperationsMethodSelectors[];

  /**
   * The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with serviceName field set to * will allow all methods AND permissions for all services.
   *
   * @schema ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperations#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperations(obj: ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'methodSelectors': obj.methodSelectors?.map(y => toJson_ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperationsMethodSelectors(y)),
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFromSources
 */
export interface ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFromSources {
  /**
   * A Google Cloud resource that is allowed to ingress the perimeter. Requests from these resources will be allowed to access perimeter data. Currently only projects are allowed. Format projects/{project_number} The project may be in any Google Cloud organization, not just the organization that the perimeter is defined in. * is not allowed, the case of allowing all Google Cloud resources only is not supported.
   *
   * @schema ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFromSources#resource
   */
  readonly resource?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFromSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFromSources(obj: ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressFromSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperations
 */
export interface ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperations {
  /**
   * API methods or permissions to allow. Method or permission must belong to the service specified by serviceName field. A single MethodSelector entry with * specified for the method field will allow all methods AND permissions for the service specified in serviceName. Structure is documented below.
   *
   * @schema ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperations#methodSelectors
   */
  readonly methodSelectors?: ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperationsMethodSelectors[];

  /**
   * The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with serviceName field set to * will allow all methods AND permissions for all services.
   *
   * @schema ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperations#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperations(obj: ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'methodSelectors': obj.methodSelectors?.map(y => toJson_ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperationsMethodSelectors(y)),
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperationsMethodSelectors
 */
export interface ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperationsMethodSelectors {
  /**
   * Value for method should be a valid method name for the corresponding serviceName in ApiOperation. If * used as value for method, then ALL methods and permissions are allowed.
   *
   * @schema ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperationsMethodSelectors#method
   */
  readonly method?: string;

  /**
   * Value for permission should be a valid Cloud IAM permission for the corresponding serviceName in ApiOperation.
   *
   * @schema ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperationsMethodSelectors#permission
   */
  readonly permission?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperationsMethodSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperationsMethodSelectors(obj: ServicePerimeterSpecForProviderSpecEgressPoliciesEgressToOperationsMethodSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'method': obj.method,
    'permission': obj.permission,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperationsMethodSelectors
 */
export interface ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperationsMethodSelectors {
  /**
   * Value for method should be a valid method name for the corresponding serviceName in ApiOperation. If * used as value for method, then ALL methods and permissions are allowed.
   *
   * @schema ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperationsMethodSelectors#method
   */
  readonly method?: string;

  /**
   * Value for permission should be a valid Cloud IAM permission for the corresponding serviceName in ApiOperation.
   *
   * @schema ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperationsMethodSelectors#permission
   */
  readonly permission?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperationsMethodSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperationsMethodSelectors(obj: ServicePerimeterSpecForProviderSpecIngressPoliciesIngressToOperationsMethodSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'method': obj.method,
    'permission': obj.permission,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperationsMethodSelectors
 */
export interface ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperationsMethodSelectors {
  /**
   * Value for method should be a valid method name for the corresponding serviceName in ApiOperation. If * used as value for method, then ALL methods and permissions are allowed.
   *
   * @schema ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperationsMethodSelectors#method
   */
  readonly method?: string;

  /**
   * Value for permission should be a valid Cloud IAM permission for the corresponding serviceName in ApiOperation.
   *
   * @schema ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperationsMethodSelectors#permission
   */
  readonly permission?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperationsMethodSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperationsMethodSelectors(obj: ServicePerimeterSpecForProviderStatusEgressPoliciesEgressToOperationsMethodSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'method': obj.method,
    'permission': obj.permission,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a AccessLevel in accesscontextmanager to populate accessLevel.
 *
 * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRef
 */
export interface ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRef#policy
   */
  readonly policy?: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicy;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRef(obj: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a AccessLevel in accesscontextmanager to populate accessLevel.
 *
 * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelector
 */
export interface ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelector#policy
   */
  readonly policy?: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicy;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelector(obj: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperationsMethodSelectors
 */
export interface ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperationsMethodSelectors {
  /**
   * Value for method should be a valid method name for the corresponding serviceName in ApiOperation. If * used as value for method, then ALL methods and permissions are allowed.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperationsMethodSelectors#method
   */
  readonly method?: string;

  /**
   * Value for permission should be a valid Cloud IAM permission for the corresponding serviceName in ApiOperation.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperationsMethodSelectors#permission
   */
  readonly permission?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperationsMethodSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperationsMethodSelectors(obj: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressToOperationsMethodSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'method': obj.method,
    'permission': obj.permission,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperationsMethodSelectors
 */
export interface ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperationsMethodSelectors {
  /**
   * Value for method should be a valid method name for the corresponding serviceName in ApiOperation. If * used as value for method, then ALL methods and permissions are allowed.
   *
   * @schema ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperationsMethodSelectors#method
   */
  readonly method?: string;

  /**
   * Value for permission should be a valid Cloud IAM permission for the corresponding serviceName in ApiOperation.
   *
   * @schema ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperationsMethodSelectors#permission
   */
  readonly permission?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperationsMethodSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperationsMethodSelectors(obj: ServicePerimeterSpecInitProviderSpecEgressPoliciesEgressToOperationsMethodSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'method': obj.method,
    'permission': obj.permission,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperationsMethodSelectors
 */
export interface ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperationsMethodSelectors {
  /**
   * Value for method should be a valid method name for the corresponding serviceName in ApiOperation. If * used as value for method, then ALL methods and permissions are allowed.
   *
   * @schema ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperationsMethodSelectors#method
   */
  readonly method?: string;

  /**
   * Value for permission should be a valid Cloud IAM permission for the corresponding serviceName in ApiOperation.
   *
   * @schema ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperationsMethodSelectors#permission
   */
  readonly permission?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperationsMethodSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperationsMethodSelectors(obj: ServicePerimeterSpecInitProviderSpecIngressPoliciesIngressToOperationsMethodSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'method': obj.method,
    'permission': obj.permission,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperationsMethodSelectors
 */
export interface ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperationsMethodSelectors {
  /**
   * Value for method should be a valid method name for the corresponding serviceName in ApiOperation. If * used as value for method, then ALL methods and permissions are allowed.
   *
   * @schema ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperationsMethodSelectors#method
   */
  readonly method?: string;

  /**
   * Value for permission should be a valid Cloud IAM permission for the corresponding serviceName in ApiOperation.
   *
   * @schema ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperationsMethodSelectors#permission
   */
  readonly permission?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperationsMethodSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperationsMethodSelectors(obj: ServicePerimeterSpecInitProviderStatusEgressPoliciesEgressToOperationsMethodSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'method': obj.method,
    'permission': obj.permission,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperationsMethodSelectors
 */
export interface ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperationsMethodSelectors {
  /**
   * Value for method should be a valid method name for the corresponding serviceName in ApiOperation. If * used as value for method, then ALL methods and permissions are allowed.
   *
   * @schema ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperationsMethodSelectors#method
   */
  readonly method?: string;

  /**
   * Value for permission should be a valid Cloud IAM permission for the corresponding serviceName in ApiOperation.
   *
   * @schema ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperationsMethodSelectors#permission
   */
  readonly permission?: string;

}

/**
 * Converts an object of type 'ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperationsMethodSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperationsMethodSelectors(obj: ServicePerimeterSpecInitProviderStatusIngressPoliciesIngressToOperationsMethodSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'method': obj.method,
    'permission': obj.permission,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicy
 */
export interface ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicy#resolution
   */
  readonly resolution?: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicy#resolve
   */
  readonly resolve?: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicyResolve;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicy(obj: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicy
 */
export interface ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicy#resolution
   */
  readonly resolution?: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicy#resolve
   */
  readonly resolve?: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicy(obj: ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicyResolution
 */
export enum ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicyResolve
 */
export enum ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicyResolution
 */
export enum ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicyResolve
 */
export enum ServicePerimeterSpecForProviderStatusIngressPoliciesIngressFromSourcesAccessLevelSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ServicePerimeterResource is the Schema for the ServicePerimeterResources API. Allows configuring a single GCP resource that should be inside of a service perimeter.
 *
 * @schema ServicePerimeterResource
 */
export class ServicePerimeterResource extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServicePerimeterResource"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'accesscontextmanager.gcp.upbound.io/v1beta1',
    kind: 'ServicePerimeterResource',
  }

  /**
   * Renders a Kubernetes manifest for "ServicePerimeterResource".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServicePerimeterResourceProps): any {
    return {
      ...ServicePerimeterResource.GVK,
      ...toJson_ServicePerimeterResourceProps(props),
    };
  }

  /**
   * Defines a "ServicePerimeterResource" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServicePerimeterResourceProps) {
    super(scope, id, {
      ...ServicePerimeterResource.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServicePerimeterResource.GVK,
      ...toJson_ServicePerimeterResourceProps(resolved),
    };
  }
}

/**
 * ServicePerimeterResource is the Schema for the ServicePerimeterResources API. Allows configuring a single GCP resource that should be inside of a service perimeter.
 *
 * @schema ServicePerimeterResource
 */
export interface ServicePerimeterResourceProps {
  /**
   * @schema ServicePerimeterResource#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServicePerimeterResourceSpec defines the desired state of ServicePerimeterResource
   *
   * @schema ServicePerimeterResource#spec
   */
  readonly spec: ServicePerimeterResourceSpec;

}

/**
 * Converts an object of type 'ServicePerimeterResourceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterResourceProps(obj: ServicePerimeterResourceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServicePerimeterResourceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServicePerimeterResourceSpec defines the desired state of ServicePerimeterResource
 *
 * @schema ServicePerimeterResourceSpec
 */
export interface ServicePerimeterResourceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServicePerimeterResourceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServicePerimeterResourceSpecDeletionPolicy;

  /**
   * @schema ServicePerimeterResourceSpec#forProvider
   */
  readonly forProvider: ServicePerimeterResourceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ServicePerimeterResourceSpec#initProvider
   */
  readonly initProvider?: ServicePerimeterResourceSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServicePerimeterResourceSpec#managementPolicies
   */
  readonly managementPolicies?: ServicePerimeterResourceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServicePerimeterResourceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServicePerimeterResourceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServicePerimeterResourceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServicePerimeterResourceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServicePerimeterResourceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServicePerimeterResourceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServicePerimeterResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterResourceSpec(obj: ServicePerimeterResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServicePerimeterResourceSpecForProvider(obj.forProvider),
    'initProvider': toJson_ServicePerimeterResourceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServicePerimeterResourceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ServicePerimeterResourceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServicePerimeterResourceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServicePerimeterResourceSpecDeletionPolicy
 */
export enum ServicePerimeterResourceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServicePerimeterResourceSpecForProvider
 */
export interface ServicePerimeterResourceSpecForProvider {
  /**
   * The name of the Service Perimeter to add this resource to.
   *
   * @schema ServicePerimeterResourceSpecForProvider#perimeterName
   */
  readonly perimeterName?: string;

  /**
   * Reference to a ServicePerimeter in accesscontextmanager to populate perimeterName.
   *
   * @schema ServicePerimeterResourceSpecForProvider#perimeterNameRef
   */
  readonly perimeterNameRef?: ServicePerimeterResourceSpecForProviderPerimeterNameRef;

  /**
   * Selector for a ServicePerimeter in accesscontextmanager to populate perimeterName.
   *
   * @schema ServicePerimeterResourceSpecForProvider#perimeterNameSelector
   */
  readonly perimeterNameSelector?: ServicePerimeterResourceSpecForProviderPerimeterNameSelector;

  /**
   * A GCP resource that is inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}
   *
   * @schema ServicePerimeterResourceSpecForProvider#resource
   */
  readonly resource?: string;

}

/**
 * Converts an object of type 'ServicePerimeterResourceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterResourceSpecForProvider(obj: ServicePerimeterResourceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'perimeterName': obj.perimeterName,
    'perimeterNameRef': toJson_ServicePerimeterResourceSpecForProviderPerimeterNameRef(obj.perimeterNameRef),
    'perimeterNameSelector': toJson_ServicePerimeterResourceSpecForProviderPerimeterNameSelector(obj.perimeterNameSelector),
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ServicePerimeterResourceSpecInitProvider
 */
export interface ServicePerimeterResourceSpecInitProvider {
  /**
   * A GCP resource that is inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}
   *
   * @schema ServicePerimeterResourceSpecInitProvider#resource
   */
  readonly resource?: string;

}

/**
 * Converts an object of type 'ServicePerimeterResourceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterResourceSpecInitProvider(obj: ServicePerimeterResourceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ServicePerimeterResourceSpecManagementPolicies
 */
export enum ServicePerimeterResourceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServicePerimeterResourceSpecProviderConfigRef
 */
export interface ServicePerimeterResourceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServicePerimeterResourceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServicePerimeterResourceSpecProviderConfigRef#policy
   */
  readonly policy?: ServicePerimeterResourceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServicePerimeterResourceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterResourceSpecProviderConfigRef(obj: ServicePerimeterResourceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServicePerimeterResourceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServicePerimeterResourceSpecPublishConnectionDetailsTo
 */
export interface ServicePerimeterResourceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServicePerimeterResourceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServicePerimeterResourceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServicePerimeterResourceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServicePerimeterResourceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServicePerimeterResourceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterResourceSpecPublishConnectionDetailsTo(obj: ServicePerimeterResourceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServicePerimeterResourceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServicePerimeterResourceSpecWriteConnectionSecretToRef
 */
export interface ServicePerimeterResourceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServicePerimeterResourceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServicePerimeterResourceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServicePerimeterResourceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterResourceSpecWriteConnectionSecretToRef(obj: ServicePerimeterResourceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ServicePerimeter in accesscontextmanager to populate perimeterName.
 *
 * @schema ServicePerimeterResourceSpecForProviderPerimeterNameRef
 */
export interface ServicePerimeterResourceSpecForProviderPerimeterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServicePerimeterResourceSpecForProviderPerimeterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServicePerimeterResourceSpecForProviderPerimeterNameRef#policy
   */
  readonly policy?: ServicePerimeterResourceSpecForProviderPerimeterNameRefPolicy;

}

/**
 * Converts an object of type 'ServicePerimeterResourceSpecForProviderPerimeterNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterResourceSpecForProviderPerimeterNameRef(obj: ServicePerimeterResourceSpecForProviderPerimeterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServicePerimeterResourceSpecForProviderPerimeterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ServicePerimeter in accesscontextmanager to populate perimeterName.
 *
 * @schema ServicePerimeterResourceSpecForProviderPerimeterNameSelector
 */
export interface ServicePerimeterResourceSpecForProviderPerimeterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServicePerimeterResourceSpecForProviderPerimeterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServicePerimeterResourceSpecForProviderPerimeterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServicePerimeterResourceSpecForProviderPerimeterNameSelector#policy
   */
  readonly policy?: ServicePerimeterResourceSpecForProviderPerimeterNameSelectorPolicy;

}

/**
 * Converts an object of type 'ServicePerimeterResourceSpecForProviderPerimeterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterResourceSpecForProviderPerimeterNameSelector(obj: ServicePerimeterResourceSpecForProviderPerimeterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServicePerimeterResourceSpecForProviderPerimeterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServicePerimeterResourceSpecProviderConfigRefPolicy
 */
export interface ServicePerimeterResourceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServicePerimeterResourceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServicePerimeterResourceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServicePerimeterResourceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServicePerimeterResourceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServicePerimeterResourceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterResourceSpecProviderConfigRefPolicy(obj: ServicePerimeterResourceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRef
 */
export interface ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRef(obj: ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServicePerimeterResourceSpecPublishConnectionDetailsToMetadata
 */
export interface ServicePerimeterResourceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServicePerimeterResourceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServicePerimeterResourceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServicePerimeterResourceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServicePerimeterResourceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterResourceSpecPublishConnectionDetailsToMetadata(obj: ServicePerimeterResourceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServicePerimeterResourceSpecForProviderPerimeterNameRefPolicy
 */
export interface ServicePerimeterResourceSpecForProviderPerimeterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServicePerimeterResourceSpecForProviderPerimeterNameRefPolicy#resolution
   */
  readonly resolution?: ServicePerimeterResourceSpecForProviderPerimeterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServicePerimeterResourceSpecForProviderPerimeterNameRefPolicy#resolve
   */
  readonly resolve?: ServicePerimeterResourceSpecForProviderPerimeterNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ServicePerimeterResourceSpecForProviderPerimeterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterResourceSpecForProviderPerimeterNameRefPolicy(obj: ServicePerimeterResourceSpecForProviderPerimeterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServicePerimeterResourceSpecForProviderPerimeterNameSelectorPolicy
 */
export interface ServicePerimeterResourceSpecForProviderPerimeterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServicePerimeterResourceSpecForProviderPerimeterNameSelectorPolicy#resolution
   */
  readonly resolution?: ServicePerimeterResourceSpecForProviderPerimeterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServicePerimeterResourceSpecForProviderPerimeterNameSelectorPolicy#resolve
   */
  readonly resolve?: ServicePerimeterResourceSpecForProviderPerimeterNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServicePerimeterResourceSpecForProviderPerimeterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterResourceSpecForProviderPerimeterNameSelectorPolicy(obj: ServicePerimeterResourceSpecForProviderPerimeterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServicePerimeterResourceSpecProviderConfigRefPolicyResolution
 */
export enum ServicePerimeterResourceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServicePerimeterResourceSpecProviderConfigRefPolicyResolve
 */
export enum ServicePerimeterResourceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServicePerimeterResourceSpecForProviderPerimeterNameRefPolicyResolution
 */
export enum ServicePerimeterResourceSpecForProviderPerimeterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServicePerimeterResourceSpecForProviderPerimeterNameRefPolicyResolve
 */
export enum ServicePerimeterResourceSpecForProviderPerimeterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServicePerimeterResourceSpecForProviderPerimeterNameSelectorPolicyResolution
 */
export enum ServicePerimeterResourceSpecForProviderPerimeterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServicePerimeterResourceSpecForProviderPerimeterNameSelectorPolicyResolve
 */
export enum ServicePerimeterResourceSpecForProviderPerimeterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServicePerimeterResourceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

