// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Account is the Schema for the Accounts API. Provides a resource to create a member account in the current AWS Organization.
 *
 * @schema Account
 */
export class Account extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Account"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'organizations.aws.upbound.io/v1beta1',
    kind: 'Account',
  }

  /**
   * Renders a Kubernetes manifest for "Account".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccountProps): any {
    return {
      ...Account.GVK,
      ...toJson_AccountProps(props),
    };
  }

  /**
   * Defines a "Account" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccountProps) {
    super(scope, id, {
      ...Account.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Account.GVK,
      ...toJson_AccountProps(resolved),
    };
  }
}

/**
 * Account is the Schema for the Accounts API. Provides a resource to create a member account in the current AWS Organization.
 *
 * @schema Account
 */
export interface AccountProps {
  /**
   * @schema Account#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccountSpec defines the desired state of Account
   *
   * @schema Account#spec
   */
  readonly spec: AccountSpec;

}

/**
 * Converts an object of type 'AccountProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountProps(obj: AccountProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccountSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccountSpec defines the desired state of Account
 *
 * @schema AccountSpec
 */
export interface AccountSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccountSpec#deletionPolicy
   */
  readonly deletionPolicy?: AccountSpecDeletionPolicy;

  /**
   * @schema AccountSpec#forProvider
   */
  readonly forProvider: AccountSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccountSpec#managementPolicy
   */
  readonly managementPolicy?: AccountSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AccountSpec#providerConfigRef
   */
  readonly providerConfigRef?: AccountSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AccountSpec#providerRef
   */
  readonly providerRef?: AccountSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AccountSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccountSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AccountSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccountSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccountSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpec(obj: AccountSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccountSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AccountSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AccountSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AccountSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccountSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccountSpecDeletionPolicy
 */
export enum AccountSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AccountSpecForProvider
 */
export interface AccountSpecForProvider {
  /**
   * If true, a deletion event will close the account. Otherwise, it will only remove from the organization. This is not supported for GovCloud accounts.
   *
   * @schema AccountSpecForProvider#closeOnDeletion
   */
  readonly closeOnDeletion?: boolean;

  /**
   * Whether to also create a GovCloud account. The GovCloud account is tied to the main (commercial) account this resource creates. If true, the GovCloud account ID is available in the govcloud_id attribute.
   *
   * @schema AccountSpecForProvider#createGovcloud
   */
  readonly createGovcloud?: boolean;

  /**
   * Email address of the owner to assign to the new member account. This email address must not already be associated with another AWS account.
   *
   * @schema AccountSpecForProvider#email
   */
  readonly email?: string;

  /**
   * If set to ALLOW, the new account enables IAM users and roles to access account billing information if they have the required permissions. If set to DENY, then only the root user (and no roles) of the new account can access account billing information. If this is unset, the AWS API will default this to ALLOW. If the resource is created and this option is changed, it will try to recreate the account.
   *
   * @schema AccountSpecForProvider#iamUserAccessToBilling
   */
  readonly iamUserAccessToBilling?: string;

  /**
   * Friendly name for the member account.
   *
   * @schema AccountSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Parent Organizational Unit ID or Root ID for the account. Defaults to the Organization default Root ID. A configuration must be present for this argument to perform drift detection.
   *
   * @default the Organization default Root ID. A configuration must be present for this argument to perform drift detection.
   * @schema AccountSpecForProvider#parentId
   */
  readonly parentId?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AccountSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema AccountSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AccountSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecForProvider(obj: AccountSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'closeOnDeletion': obj.closeOnDeletion,
    'createGovcloud': obj.createGovcloud,
    'email': obj.email,
    'iamUserAccessToBilling': obj.iamUserAccessToBilling,
    'name': obj.name,
    'parentId': obj.parentId,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccountSpecManagementPolicy
 */
export enum AccountSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AccountSpecProviderConfigRef
 */
export interface AccountSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountSpecProviderConfigRef#policy
   */
  readonly policy?: AccountSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderConfigRef(obj: AccountSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AccountSpecProviderRef
 */
export interface AccountSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountSpecProviderRef#policy
   */
  readonly policy?: AccountSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AccountSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderRef(obj: AccountSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AccountSpecPublishConnectionDetailsTo
 */
export interface AccountSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AccountSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccountSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccountSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccountSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccountSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsTo(obj: AccountSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccountSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccountSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AccountSpecWriteConnectionSecretToRef
 */
export interface AccountSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccountSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccountSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccountSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecWriteConnectionSecretToRef(obj: AccountSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountSpecProviderConfigRefPolicy
 */
export interface AccountSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccountSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccountSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderConfigRefPolicy(obj: AccountSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountSpecProviderRefPolicy
 */
export interface AccountSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AccountSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AccountSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderRefPolicy(obj: AccountSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRef
 */
export interface AccountSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccountSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsToConfigRef(obj: AccountSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccountSpecPublishConnectionDetailsToMetadata
 */
export interface AccountSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccountSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsToMetadata(obj: AccountSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSpecProviderConfigRefPolicyResolution
 */
export enum AccountSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSpecProviderConfigRefPolicyResolve
 */
export enum AccountSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSpecProviderRefPolicyResolution
 */
export enum AccountSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSpecProviderRefPolicyResolve
 */
export enum AccountSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccountSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccountSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccountSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsToConfigRefPolicy(obj: AccountSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccountSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccountSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DelegatedAdministrator is the Schema for the DelegatedAdministrators API. Provides a resource to manage an AWS Organizations Delegated Administrator.
 *
 * @schema DelegatedAdministrator
 */
export class DelegatedAdministrator extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DelegatedAdministrator"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'organizations.aws.upbound.io/v1beta1',
    kind: 'DelegatedAdministrator',
  }

  /**
   * Renders a Kubernetes manifest for "DelegatedAdministrator".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DelegatedAdministratorProps): any {
    return {
      ...DelegatedAdministrator.GVK,
      ...toJson_DelegatedAdministratorProps(props),
    };
  }

  /**
   * Defines a "DelegatedAdministrator" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DelegatedAdministratorProps) {
    super(scope, id, {
      ...DelegatedAdministrator.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DelegatedAdministrator.GVK,
      ...toJson_DelegatedAdministratorProps(resolved),
    };
  }
}

/**
 * DelegatedAdministrator is the Schema for the DelegatedAdministrators API. Provides a resource to manage an AWS Organizations Delegated Administrator.
 *
 * @schema DelegatedAdministrator
 */
export interface DelegatedAdministratorProps {
  /**
   * @schema DelegatedAdministrator#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DelegatedAdministratorSpec defines the desired state of DelegatedAdministrator
   *
   * @schema DelegatedAdministrator#spec
   */
  readonly spec: DelegatedAdministratorSpec;

}

/**
 * Converts an object of type 'DelegatedAdministratorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegatedAdministratorProps(obj: DelegatedAdministratorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DelegatedAdministratorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DelegatedAdministratorSpec defines the desired state of DelegatedAdministrator
 *
 * @schema DelegatedAdministratorSpec
 */
export interface DelegatedAdministratorSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DelegatedAdministratorSpec#deletionPolicy
   */
  readonly deletionPolicy?: DelegatedAdministratorSpecDeletionPolicy;

  /**
   * @schema DelegatedAdministratorSpec#forProvider
   */
  readonly forProvider: DelegatedAdministratorSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DelegatedAdministratorSpec#managementPolicy
   */
  readonly managementPolicy?: DelegatedAdministratorSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DelegatedAdministratorSpec#providerConfigRef
   */
  readonly providerConfigRef?: DelegatedAdministratorSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DelegatedAdministratorSpec#providerRef
   */
  readonly providerRef?: DelegatedAdministratorSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DelegatedAdministratorSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DelegatedAdministratorSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DelegatedAdministratorSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DelegatedAdministratorSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DelegatedAdministratorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegatedAdministratorSpec(obj: DelegatedAdministratorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DelegatedAdministratorSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DelegatedAdministratorSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DelegatedAdministratorSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DelegatedAdministratorSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DelegatedAdministratorSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DelegatedAdministratorSpecDeletionPolicy
 */
export enum DelegatedAdministratorSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DelegatedAdministratorSpecForProvider
 */
export interface DelegatedAdministratorSpecForProvider {
  /**
   * The account ID number of the member account in the organization to register as a delegated administrator.
   *
   * @schema DelegatedAdministratorSpecForProvider#accountId
   */
  readonly accountId?: string;

  /**
   * Reference to a Account in organizations to populate accountId.
   *
   * @schema DelegatedAdministratorSpecForProvider#accountIdRef
   */
  readonly accountIdRef?: DelegatedAdministratorSpecForProviderAccountIdRef;

  /**
   * Selector for a Account in organizations to populate accountId.
   *
   * @schema DelegatedAdministratorSpecForProvider#accountIdSelector
   */
  readonly accountIdSelector?: DelegatedAdministratorSpecForProviderAccountIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DelegatedAdministratorSpecForProvider#region
   */
  readonly region: string;

  /**
   * The service principal of the AWS service for which you want to make the member account a delegated administrator.
   *
   * @schema DelegatedAdministratorSpecForProvider#servicePrincipal
   */
  readonly servicePrincipal?: string;

}

/**
 * Converts an object of type 'DelegatedAdministratorSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegatedAdministratorSpecForProvider(obj: DelegatedAdministratorSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'accountIdRef': toJson_DelegatedAdministratorSpecForProviderAccountIdRef(obj.accountIdRef),
    'accountIdSelector': toJson_DelegatedAdministratorSpecForProviderAccountIdSelector(obj.accountIdSelector),
    'region': obj.region,
    'servicePrincipal': obj.servicePrincipal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DelegatedAdministratorSpecManagementPolicy
 */
export enum DelegatedAdministratorSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DelegatedAdministratorSpecProviderConfigRef
 */
export interface DelegatedAdministratorSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DelegatedAdministratorSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DelegatedAdministratorSpecProviderConfigRef#policy
   */
  readonly policy?: DelegatedAdministratorSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DelegatedAdministratorSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegatedAdministratorSpecProviderConfigRef(obj: DelegatedAdministratorSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DelegatedAdministratorSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DelegatedAdministratorSpecProviderRef
 */
export interface DelegatedAdministratorSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DelegatedAdministratorSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DelegatedAdministratorSpecProviderRef#policy
   */
  readonly policy?: DelegatedAdministratorSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DelegatedAdministratorSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegatedAdministratorSpecProviderRef(obj: DelegatedAdministratorSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DelegatedAdministratorSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DelegatedAdministratorSpecPublishConnectionDetailsTo
 */
export interface DelegatedAdministratorSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DelegatedAdministratorSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DelegatedAdministratorSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DelegatedAdministratorSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DelegatedAdministratorSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DelegatedAdministratorSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DelegatedAdministratorSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegatedAdministratorSpecPublishConnectionDetailsTo(obj: DelegatedAdministratorSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DelegatedAdministratorSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DelegatedAdministratorSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DelegatedAdministratorSpecWriteConnectionSecretToRef
 */
export interface DelegatedAdministratorSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DelegatedAdministratorSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DelegatedAdministratorSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DelegatedAdministratorSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegatedAdministratorSpecWriteConnectionSecretToRef(obj: DelegatedAdministratorSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Account in organizations to populate accountId.
 *
 * @schema DelegatedAdministratorSpecForProviderAccountIdRef
 */
export interface DelegatedAdministratorSpecForProviderAccountIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DelegatedAdministratorSpecForProviderAccountIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DelegatedAdministratorSpecForProviderAccountIdRef#policy
   */
  readonly policy?: DelegatedAdministratorSpecForProviderAccountIdRefPolicy;

}

/**
 * Converts an object of type 'DelegatedAdministratorSpecForProviderAccountIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegatedAdministratorSpecForProviderAccountIdRef(obj: DelegatedAdministratorSpecForProviderAccountIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DelegatedAdministratorSpecForProviderAccountIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Account in organizations to populate accountId.
 *
 * @schema DelegatedAdministratorSpecForProviderAccountIdSelector
 */
export interface DelegatedAdministratorSpecForProviderAccountIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DelegatedAdministratorSpecForProviderAccountIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DelegatedAdministratorSpecForProviderAccountIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DelegatedAdministratorSpecForProviderAccountIdSelector#policy
   */
  readonly policy?: DelegatedAdministratorSpecForProviderAccountIdSelectorPolicy;

}

/**
 * Converts an object of type 'DelegatedAdministratorSpecForProviderAccountIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegatedAdministratorSpecForProviderAccountIdSelector(obj: DelegatedAdministratorSpecForProviderAccountIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DelegatedAdministratorSpecForProviderAccountIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DelegatedAdministratorSpecProviderConfigRefPolicy
 */
export interface DelegatedAdministratorSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DelegatedAdministratorSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DelegatedAdministratorSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DelegatedAdministratorSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DelegatedAdministratorSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DelegatedAdministratorSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegatedAdministratorSpecProviderConfigRefPolicy(obj: DelegatedAdministratorSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DelegatedAdministratorSpecProviderRefPolicy
 */
export interface DelegatedAdministratorSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DelegatedAdministratorSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DelegatedAdministratorSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DelegatedAdministratorSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DelegatedAdministratorSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DelegatedAdministratorSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegatedAdministratorSpecProviderRefPolicy(obj: DelegatedAdministratorSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DelegatedAdministratorSpecPublishConnectionDetailsToConfigRef
 */
export interface DelegatedAdministratorSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DelegatedAdministratorSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DelegatedAdministratorSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DelegatedAdministratorSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DelegatedAdministratorSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegatedAdministratorSpecPublishConnectionDetailsToConfigRef(obj: DelegatedAdministratorSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DelegatedAdministratorSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DelegatedAdministratorSpecPublishConnectionDetailsToMetadata
 */
export interface DelegatedAdministratorSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DelegatedAdministratorSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DelegatedAdministratorSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DelegatedAdministratorSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DelegatedAdministratorSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegatedAdministratorSpecPublishConnectionDetailsToMetadata(obj: DelegatedAdministratorSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DelegatedAdministratorSpecForProviderAccountIdRefPolicy
 */
export interface DelegatedAdministratorSpecForProviderAccountIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DelegatedAdministratorSpecForProviderAccountIdRefPolicy#resolution
   */
  readonly resolution?: DelegatedAdministratorSpecForProviderAccountIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DelegatedAdministratorSpecForProviderAccountIdRefPolicy#resolve
   */
  readonly resolve?: DelegatedAdministratorSpecForProviderAccountIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DelegatedAdministratorSpecForProviderAccountIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegatedAdministratorSpecForProviderAccountIdRefPolicy(obj: DelegatedAdministratorSpecForProviderAccountIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DelegatedAdministratorSpecForProviderAccountIdSelectorPolicy
 */
export interface DelegatedAdministratorSpecForProviderAccountIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DelegatedAdministratorSpecForProviderAccountIdSelectorPolicy#resolution
   */
  readonly resolution?: DelegatedAdministratorSpecForProviderAccountIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DelegatedAdministratorSpecForProviderAccountIdSelectorPolicy#resolve
   */
  readonly resolve?: DelegatedAdministratorSpecForProviderAccountIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DelegatedAdministratorSpecForProviderAccountIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegatedAdministratorSpecForProviderAccountIdSelectorPolicy(obj: DelegatedAdministratorSpecForProviderAccountIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DelegatedAdministratorSpecProviderConfigRefPolicyResolution
 */
export enum DelegatedAdministratorSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DelegatedAdministratorSpecProviderConfigRefPolicyResolve
 */
export enum DelegatedAdministratorSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DelegatedAdministratorSpecProviderRefPolicyResolution
 */
export enum DelegatedAdministratorSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DelegatedAdministratorSpecProviderRefPolicyResolve
 */
export enum DelegatedAdministratorSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DelegatedAdministratorSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DelegatedAdministratorSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DelegatedAdministratorSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DelegatedAdministratorSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DelegatedAdministratorSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DelegatedAdministratorSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DelegatedAdministratorSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegatedAdministratorSpecPublishConnectionDetailsToConfigRefPolicy(obj: DelegatedAdministratorSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DelegatedAdministratorSpecForProviderAccountIdRefPolicyResolution
 */
export enum DelegatedAdministratorSpecForProviderAccountIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DelegatedAdministratorSpecForProviderAccountIdRefPolicyResolve
 */
export enum DelegatedAdministratorSpecForProviderAccountIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DelegatedAdministratorSpecForProviderAccountIdSelectorPolicyResolution
 */
export enum DelegatedAdministratorSpecForProviderAccountIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DelegatedAdministratorSpecForProviderAccountIdSelectorPolicyResolve
 */
export enum DelegatedAdministratorSpecForProviderAccountIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DelegatedAdministratorSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DelegatedAdministratorSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DelegatedAdministratorSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DelegatedAdministratorSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Organization is the Schema for the Organizations API. Provides a resource to create an organization.
 *
 * @schema Organization
 */
export class Organization extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Organization"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'organizations.aws.upbound.io/v1beta1',
    kind: 'Organization',
  }

  /**
   * Renders a Kubernetes manifest for "Organization".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OrganizationProps): any {
    return {
      ...Organization.GVK,
      ...toJson_OrganizationProps(props),
    };
  }

  /**
   * Defines a "Organization" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OrganizationProps) {
    super(scope, id, {
      ...Organization.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Organization.GVK,
      ...toJson_OrganizationProps(resolved),
    };
  }
}

/**
 * Organization is the Schema for the Organizations API. Provides a resource to create an organization.
 *
 * @schema Organization
 */
export interface OrganizationProps {
  /**
   * @schema Organization#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OrganizationSpec defines the desired state of Organization
   *
   * @schema Organization#spec
   */
  readonly spec: OrganizationSpec;

}

/**
 * Converts an object of type 'OrganizationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationProps(obj: OrganizationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OrganizationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OrganizationSpec defines the desired state of Organization
 *
 * @schema OrganizationSpec
 */
export interface OrganizationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OrganizationSpec#deletionPolicy
   */
  readonly deletionPolicy?: OrganizationSpecDeletionPolicy;

  /**
   * @schema OrganizationSpec#forProvider
   */
  readonly forProvider: OrganizationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OrganizationSpec#managementPolicy
   */
  readonly managementPolicy?: OrganizationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema OrganizationSpec#providerConfigRef
   */
  readonly providerConfigRef?: OrganizationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema OrganizationSpec#providerRef
   */
  readonly providerRef?: OrganizationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema OrganizationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: OrganizationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema OrganizationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: OrganizationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'OrganizationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpec(obj: OrganizationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_OrganizationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_OrganizationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_OrganizationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_OrganizationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_OrganizationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OrganizationSpecDeletionPolicy
 */
export enum OrganizationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema OrganizationSpecForProvider
 */
export interface OrganizationSpecForProvider {
  /**
   * List of AWS service principal names for which you want to enable integration with your organization. This is typically in the form of a URL, such as service-abbreviation.amazonaws.com. Organization must have feature_set set to ALL. Some services do not support enablement via this endpoint, see warning in aws docs.
   *
   * @schema OrganizationSpecForProvider#awsServiceAccessPrincipals
   */
  readonly awsServiceAccessPrincipals?: string[];

  /**
   * List of Organizations policy types to enable in the Organization Root. Organization must have feature_set set to ALL. For additional information about valid policy types (e.g., AISERVICES_OPT_OUT_POLICY, BACKUP_POLICY, SERVICE_CONTROL_POLICY, and TAG_POLICY), see the AWS Organizations API Reference.
   *
   * @schema OrganizationSpecForProvider#enabledPolicyTypes
   */
  readonly enabledPolicyTypes?: string[];

  /**
   * Specify "ALL" (default) or "CONSOLIDATED_BILLING".
   *
   * @schema OrganizationSpecForProvider#featureSet
   */
  readonly featureSet?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema OrganizationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'OrganizationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecForProvider(obj: OrganizationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsServiceAccessPrincipals': obj.awsServiceAccessPrincipals?.map(y => y),
    'enabledPolicyTypes': obj.enabledPolicyTypes?.map(y => y),
    'featureSet': obj.featureSet,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OrganizationSpecManagementPolicy
 */
export enum OrganizationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema OrganizationSpecProviderConfigRef
 */
export interface OrganizationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OrganizationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OrganizationSpecProviderConfigRef#policy
   */
  readonly policy?: OrganizationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'OrganizationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecProviderConfigRef(obj: OrganizationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OrganizationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema OrganizationSpecProviderRef
 */
export interface OrganizationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema OrganizationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OrganizationSpecProviderRef#policy
   */
  readonly policy?: OrganizationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'OrganizationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecProviderRef(obj: OrganizationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OrganizationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema OrganizationSpecPublishConnectionDetailsTo
 */
export interface OrganizationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema OrganizationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: OrganizationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema OrganizationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: OrganizationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema OrganizationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OrganizationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecPublishConnectionDetailsTo(obj: OrganizationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_OrganizationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_OrganizationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema OrganizationSpecWriteConnectionSecretToRef
 */
export interface OrganizationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema OrganizationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OrganizationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OrganizationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecWriteConnectionSecretToRef(obj: OrganizationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OrganizationSpecProviderConfigRefPolicy
 */
export interface OrganizationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: OrganizationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: OrganizationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecProviderConfigRefPolicy(obj: OrganizationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OrganizationSpecProviderRefPolicy
 */
export interface OrganizationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: OrganizationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: OrganizationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecProviderRefPolicy(obj: OrganizationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema OrganizationSpecPublishConnectionDetailsToConfigRef
 */
export interface OrganizationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OrganizationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OrganizationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: OrganizationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'OrganizationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecPublishConnectionDetailsToConfigRef(obj: OrganizationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OrganizationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema OrganizationSpecPublishConnectionDetailsToMetadata
 */
export interface OrganizationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema OrganizationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema OrganizationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema OrganizationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'OrganizationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecPublishConnectionDetailsToMetadata(obj: OrganizationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationSpecProviderConfigRefPolicyResolution
 */
export enum OrganizationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationSpecProviderConfigRefPolicyResolve
 */
export enum OrganizationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationSpecProviderRefPolicyResolution
 */
export enum OrganizationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationSpecProviderRefPolicyResolve
 */
export enum OrganizationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema OrganizationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface OrganizationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: OrganizationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: OrganizationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecPublishConnectionDetailsToConfigRefPolicy(obj: OrganizationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum OrganizationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum OrganizationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * OrganizationalUnit is the Schema for the OrganizationalUnits API. Provides a resource to create an organizational unit.
 *
 * @schema OrganizationalUnit
 */
export class OrganizationalUnit extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OrganizationalUnit"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'organizations.aws.upbound.io/v1beta1',
    kind: 'OrganizationalUnit',
  }

  /**
   * Renders a Kubernetes manifest for "OrganizationalUnit".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OrganizationalUnitProps): any {
    return {
      ...OrganizationalUnit.GVK,
      ...toJson_OrganizationalUnitProps(props),
    };
  }

  /**
   * Defines a "OrganizationalUnit" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OrganizationalUnitProps) {
    super(scope, id, {
      ...OrganizationalUnit.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OrganizationalUnit.GVK,
      ...toJson_OrganizationalUnitProps(resolved),
    };
  }
}

/**
 * OrganizationalUnit is the Schema for the OrganizationalUnits API. Provides a resource to create an organizational unit.
 *
 * @schema OrganizationalUnit
 */
export interface OrganizationalUnitProps {
  /**
   * @schema OrganizationalUnit#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OrganizationalUnitSpec defines the desired state of OrganizationalUnit
   *
   * @schema OrganizationalUnit#spec
   */
  readonly spec: OrganizationalUnitSpec;

}

/**
 * Converts an object of type 'OrganizationalUnitProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationalUnitProps(obj: OrganizationalUnitProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OrganizationalUnitSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OrganizationalUnitSpec defines the desired state of OrganizationalUnit
 *
 * @schema OrganizationalUnitSpec
 */
export interface OrganizationalUnitSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OrganizationalUnitSpec#deletionPolicy
   */
  readonly deletionPolicy?: OrganizationalUnitSpecDeletionPolicy;

  /**
   * @schema OrganizationalUnitSpec#forProvider
   */
  readonly forProvider: OrganizationalUnitSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OrganizationalUnitSpec#managementPolicy
   */
  readonly managementPolicy?: OrganizationalUnitSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema OrganizationalUnitSpec#providerConfigRef
   */
  readonly providerConfigRef?: OrganizationalUnitSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema OrganizationalUnitSpec#providerRef
   */
  readonly providerRef?: OrganizationalUnitSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema OrganizationalUnitSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: OrganizationalUnitSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema OrganizationalUnitSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: OrganizationalUnitSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'OrganizationalUnitSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationalUnitSpec(obj: OrganizationalUnitSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_OrganizationalUnitSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_OrganizationalUnitSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_OrganizationalUnitSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_OrganizationalUnitSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_OrganizationalUnitSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OrganizationalUnitSpecDeletionPolicy
 */
export enum OrganizationalUnitSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema OrganizationalUnitSpecForProvider
 */
export interface OrganizationalUnitSpecForProvider {
  /**
   * The name for the organizational unit
   *
   * @schema OrganizationalUnitSpecForProvider#name
   */
  readonly name?: string;

  /**
   * ID of the parent organizational unit, which may be the root
   *
   * @schema OrganizationalUnitSpecForProvider#parentId
   */
  readonly parentId?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema OrganizationalUnitSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema OrganizationalUnitSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'OrganizationalUnitSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationalUnitSpecForProvider(obj: OrganizationalUnitSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'parentId': obj.parentId,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OrganizationalUnitSpecManagementPolicy
 */
export enum OrganizationalUnitSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema OrganizationalUnitSpecProviderConfigRef
 */
export interface OrganizationalUnitSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OrganizationalUnitSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OrganizationalUnitSpecProviderConfigRef#policy
   */
  readonly policy?: OrganizationalUnitSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'OrganizationalUnitSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationalUnitSpecProviderConfigRef(obj: OrganizationalUnitSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OrganizationalUnitSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema OrganizationalUnitSpecProviderRef
 */
export interface OrganizationalUnitSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema OrganizationalUnitSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OrganizationalUnitSpecProviderRef#policy
   */
  readonly policy?: OrganizationalUnitSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'OrganizationalUnitSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationalUnitSpecProviderRef(obj: OrganizationalUnitSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OrganizationalUnitSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema OrganizationalUnitSpecPublishConnectionDetailsTo
 */
export interface OrganizationalUnitSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema OrganizationalUnitSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: OrganizationalUnitSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema OrganizationalUnitSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: OrganizationalUnitSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema OrganizationalUnitSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OrganizationalUnitSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationalUnitSpecPublishConnectionDetailsTo(obj: OrganizationalUnitSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_OrganizationalUnitSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_OrganizationalUnitSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema OrganizationalUnitSpecWriteConnectionSecretToRef
 */
export interface OrganizationalUnitSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema OrganizationalUnitSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OrganizationalUnitSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OrganizationalUnitSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationalUnitSpecWriteConnectionSecretToRef(obj: OrganizationalUnitSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OrganizationalUnitSpecProviderConfigRefPolicy
 */
export interface OrganizationalUnitSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationalUnitSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: OrganizationalUnitSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationalUnitSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: OrganizationalUnitSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationalUnitSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationalUnitSpecProviderConfigRefPolicy(obj: OrganizationalUnitSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OrganizationalUnitSpecProviderRefPolicy
 */
export interface OrganizationalUnitSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationalUnitSpecProviderRefPolicy#resolution
   */
  readonly resolution?: OrganizationalUnitSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationalUnitSpecProviderRefPolicy#resolve
   */
  readonly resolve?: OrganizationalUnitSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationalUnitSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationalUnitSpecProviderRefPolicy(obj: OrganizationalUnitSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema OrganizationalUnitSpecPublishConnectionDetailsToConfigRef
 */
export interface OrganizationalUnitSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OrganizationalUnitSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OrganizationalUnitSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: OrganizationalUnitSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'OrganizationalUnitSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationalUnitSpecPublishConnectionDetailsToConfigRef(obj: OrganizationalUnitSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OrganizationalUnitSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema OrganizationalUnitSpecPublishConnectionDetailsToMetadata
 */
export interface OrganizationalUnitSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema OrganizationalUnitSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema OrganizationalUnitSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema OrganizationalUnitSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'OrganizationalUnitSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationalUnitSpecPublishConnectionDetailsToMetadata(obj: OrganizationalUnitSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationalUnitSpecProviderConfigRefPolicyResolution
 */
export enum OrganizationalUnitSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationalUnitSpecProviderConfigRefPolicyResolve
 */
export enum OrganizationalUnitSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationalUnitSpecProviderRefPolicyResolution
 */
export enum OrganizationalUnitSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationalUnitSpecProviderRefPolicyResolve
 */
export enum OrganizationalUnitSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema OrganizationalUnitSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface OrganizationalUnitSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationalUnitSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: OrganizationalUnitSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationalUnitSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: OrganizationalUnitSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationalUnitSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationalUnitSpecPublishConnectionDetailsToConfigRefPolicy(obj: OrganizationalUnitSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationalUnitSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum OrganizationalUnitSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationalUnitSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum OrganizationalUnitSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Policy is the Schema for the Policys API. Provides a resource to manage an AWS Organizations policy.
 *
 * @schema Policy
 */
export class Policy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Policy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'organizations.aws.upbound.io/v1beta1',
    kind: 'Policy',
  }

  /**
   * Renders a Kubernetes manifest for "Policy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PolicyProps): any {
    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(props),
    };
  }

  /**
   * Defines a "Policy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PolicyProps) {
    super(scope, id, {
      ...Policy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(resolved),
    };
  }
}

/**
 * Policy is the Schema for the Policys API. Provides a resource to manage an AWS Organizations policy.
 *
 * @schema Policy
 */
export interface PolicyProps {
  /**
   * @schema Policy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PolicySpec defines the desired state of Policy
   *
   * @schema Policy#spec
   */
  readonly spec: PolicySpec;

}

/**
 * Converts an object of type 'PolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyProps(obj: PolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicySpec defines the desired state of Policy
 *
 * @schema PolicySpec
 */
export interface PolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: PolicySpecDeletionPolicy;

  /**
   * @schema PolicySpec#forProvider
   */
  readonly forProvider: PolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PolicySpec#managementPolicy
   */
  readonly managementPolicy?: PolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: PolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PolicySpec#providerRef
   */
  readonly providerRef?: PolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpec(obj: PolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PolicySpecDeletionPolicy
 */
export enum PolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PolicySpecForProvider
 */
export interface PolicySpecForProvider {
  /**
   * The policy content to add to the new policy. For example, if you create a service control policy (SCP), this string must be JSON text that specifies the permissions that admins in attached accounts can delegate to their users, groups, and roles. For more information about the SCP syntax, see the Service Control Policy Syntax documentation and for more information on the Tag Policy syntax, see the Tag Policy Syntax documentation.
   *
   * @schema PolicySpecForProvider#content
   */
  readonly content?: string;

  /**
   * A description to assign to the policy.
   *
   * @schema PolicySpecForProvider#description
   */
  readonly description?: string;

  /**
   * The friendly name to assign to the policy.
   *
   * @schema PolicySpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * If set to true, destroy will not delete the policy and instead just remove the resource from state. This can be useful in situations where the policies (and the associated attachment) must be preserved to meet the AWS minimum requirement of 1 attached policy.
   *
   * @schema PolicySpecForProvider#skipDestroy
   */
  readonly skipDestroy?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema PolicySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The type of policy to create. Valid values are AISERVICES_OPT_OUT_POLICY, BACKUP_POLICY, SERVICE_CONTROL_POLICY (SCP), and TAG_POLICY. Defaults to SERVICE_CONTROL_POLICY.
   *
   * @default SERVICE_CONTROL_POLICY.
   * @schema PolicySpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProvider(obj: PolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'skipDestroy': obj.skipDestroy,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PolicySpecManagementPolicy
 */
export enum PolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PolicySpecProviderConfigRef
 */
export interface PolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecProviderConfigRef#policy
   */
  readonly policy?: PolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRef(obj: PolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PolicySpecProviderRef
 */
export interface PolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecProviderRef#policy
   */
  readonly policy?: PolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderRef(obj: PolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PolicySpecPublishConnectionDetailsTo
 */
export interface PolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsTo(obj: PolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PolicySpecWriteConnectionSecretToRef
 */
export interface PolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecWriteConnectionSecretToRef(obj: PolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecProviderConfigRefPolicy
 */
export interface PolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRefPolicy(obj: PolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecProviderRefPolicy
 */
export interface PolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: PolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: PolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderRefPolicy(obj: PolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRef
 */
export interface PolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj: PolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PolicySpecPublishConnectionDetailsToMetadata
 */
export interface PolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToMetadata(obj: PolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolution
 */
export enum PolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolve
 */
export enum PolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecProviderRefPolicyResolution
 */
export enum PolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecProviderRefPolicyResolve
 */
export enum PolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: PolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PolicyAttachment is the Schema for the PolicyAttachments API. Provides a resource to attach an AWS Organizations policy to an organization account, root, or unit.
 *
 * @schema PolicyAttachment
 */
export class PolicyAttachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PolicyAttachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'organizations.aws.upbound.io/v1beta1',
    kind: 'PolicyAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "PolicyAttachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PolicyAttachmentProps): any {
    return {
      ...PolicyAttachment.GVK,
      ...toJson_PolicyAttachmentProps(props),
    };
  }

  /**
   * Defines a "PolicyAttachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PolicyAttachmentProps) {
    super(scope, id, {
      ...PolicyAttachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PolicyAttachment.GVK,
      ...toJson_PolicyAttachmentProps(resolved),
    };
  }
}

/**
 * PolicyAttachment is the Schema for the PolicyAttachments API. Provides a resource to attach an AWS Organizations policy to an organization account, root, or unit.
 *
 * @schema PolicyAttachment
 */
export interface PolicyAttachmentProps {
  /**
   * @schema PolicyAttachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PolicyAttachmentSpec defines the desired state of PolicyAttachment
   *
   * @schema PolicyAttachment#spec
   */
  readonly spec: PolicyAttachmentSpec;

}

/**
 * Converts an object of type 'PolicyAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentProps(obj: PolicyAttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PolicyAttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicyAttachmentSpec defines the desired state of PolicyAttachment
 *
 * @schema PolicyAttachmentSpec
 */
export interface PolicyAttachmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PolicyAttachmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: PolicyAttachmentSpecDeletionPolicy;

  /**
   * @schema PolicyAttachmentSpec#forProvider
   */
  readonly forProvider: PolicyAttachmentSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PolicyAttachmentSpec#managementPolicy
   */
  readonly managementPolicy?: PolicyAttachmentSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PolicyAttachmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: PolicyAttachmentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PolicyAttachmentSpec#providerRef
   */
  readonly providerRef?: PolicyAttachmentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PolicyAttachmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PolicyAttachmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PolicyAttachmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PolicyAttachmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PolicyAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpec(obj: PolicyAttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PolicyAttachmentSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PolicyAttachmentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PolicyAttachmentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PolicyAttachmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PolicyAttachmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PolicyAttachmentSpecDeletionPolicy
 */
export enum PolicyAttachmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PolicyAttachmentSpecForProvider
 */
export interface PolicyAttachmentSpecForProvider {
  /**
   * The unique identifier (ID) of the policy that you want to attach to the target.
   *
   * @schema PolicyAttachmentSpecForProvider#policyId
   */
  readonly policyId?: string;

  /**
   * Reference to a Policy in organizations to populate policyId.
   *
   * @schema PolicyAttachmentSpecForProvider#policyIdRef
   */
  readonly policyIdRef?: PolicyAttachmentSpecForProviderPolicyIdRef;

  /**
   * Selector for a Policy in organizations to populate policyId.
   *
   * @schema PolicyAttachmentSpecForProvider#policyIdSelector
   */
  readonly policyIdSelector?: PolicyAttachmentSpecForProviderPolicyIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PolicyAttachmentSpecForProvider#region
   */
  readonly region: string;

  /**
   * If set to true, destroy will not detach the policy and instead just remove the resource from state. This can be useful in situations where the attachment must be preserved to meet the AWS minimum requirement of 1 attached policy.
   *
   * @schema PolicyAttachmentSpecForProvider#skipDestroy
   */
  readonly skipDestroy?: boolean;

  /**
   * The unique identifier (ID) of the root, organizational unit, or account number that you want to attach the policy to.
   *
   * @schema PolicyAttachmentSpecForProvider#targetId
   */
  readonly targetId?: string;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecForProvider(obj: PolicyAttachmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policyId': obj.policyId,
    'policyIdRef': toJson_PolicyAttachmentSpecForProviderPolicyIdRef(obj.policyIdRef),
    'policyIdSelector': toJson_PolicyAttachmentSpecForProviderPolicyIdSelector(obj.policyIdSelector),
    'region': obj.region,
    'skipDestroy': obj.skipDestroy,
    'targetId': obj.targetId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PolicyAttachmentSpecManagementPolicy
 */
export enum PolicyAttachmentSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PolicyAttachmentSpecProviderConfigRef
 */
export interface PolicyAttachmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicyAttachmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicyAttachmentSpecProviderConfigRef#policy
   */
  readonly policy?: PolicyAttachmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecProviderConfigRef(obj: PolicyAttachmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicyAttachmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PolicyAttachmentSpecProviderRef
 */
export interface PolicyAttachmentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicyAttachmentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicyAttachmentSpecProviderRef#policy
   */
  readonly policy?: PolicyAttachmentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecProviderRef(obj: PolicyAttachmentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicyAttachmentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PolicyAttachmentSpecPublishConnectionDetailsTo
 */
export interface PolicyAttachmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PolicyAttachmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PolicyAttachmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecPublishConnectionDetailsTo(obj: PolicyAttachmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PolicyAttachmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PolicyAttachmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PolicyAttachmentSpecWriteConnectionSecretToRef
 */
export interface PolicyAttachmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PolicyAttachmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PolicyAttachmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecWriteConnectionSecretToRef(obj: PolicyAttachmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Policy in organizations to populate policyId.
 *
 * @schema PolicyAttachmentSpecForProviderPolicyIdRef
 */
export interface PolicyAttachmentSpecForProviderPolicyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicyAttachmentSpecForProviderPolicyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicyAttachmentSpecForProviderPolicyIdRef#policy
   */
  readonly policy?: PolicyAttachmentSpecForProviderPolicyIdRefPolicy;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecForProviderPolicyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecForProviderPolicyIdRef(obj: PolicyAttachmentSpecForProviderPolicyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicyAttachmentSpecForProviderPolicyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Policy in organizations to populate policyId.
 *
 * @schema PolicyAttachmentSpecForProviderPolicyIdSelector
 */
export interface PolicyAttachmentSpecForProviderPolicyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PolicyAttachmentSpecForProviderPolicyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PolicyAttachmentSpecForProviderPolicyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PolicyAttachmentSpecForProviderPolicyIdSelector#policy
   */
  readonly policy?: PolicyAttachmentSpecForProviderPolicyIdSelectorPolicy;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecForProviderPolicyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecForProviderPolicyIdSelector(obj: PolicyAttachmentSpecForProviderPolicyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PolicyAttachmentSpecForProviderPolicyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicyAttachmentSpecProviderConfigRefPolicy
 */
export interface PolicyAttachmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicyAttachmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PolicyAttachmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicyAttachmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PolicyAttachmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecProviderConfigRefPolicy(obj: PolicyAttachmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicyAttachmentSpecProviderRefPolicy
 */
export interface PolicyAttachmentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicyAttachmentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PolicyAttachmentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicyAttachmentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PolicyAttachmentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecProviderRefPolicy(obj: PolicyAttachmentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PolicyAttachmentSpecPublishConnectionDetailsToConfigRef
 */
export interface PolicyAttachmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecPublishConnectionDetailsToConfigRef(obj: PolicyAttachmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PolicyAttachmentSpecPublishConnectionDetailsToMetadata
 */
export interface PolicyAttachmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecPublishConnectionDetailsToMetadata(obj: PolicyAttachmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicyAttachmentSpecForProviderPolicyIdRefPolicy
 */
export interface PolicyAttachmentSpecForProviderPolicyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicyAttachmentSpecForProviderPolicyIdRefPolicy#resolution
   */
  readonly resolution?: PolicyAttachmentSpecForProviderPolicyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicyAttachmentSpecForProviderPolicyIdRefPolicy#resolve
   */
  readonly resolve?: PolicyAttachmentSpecForProviderPolicyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecForProviderPolicyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecForProviderPolicyIdRefPolicy(obj: PolicyAttachmentSpecForProviderPolicyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PolicyAttachmentSpecForProviderPolicyIdSelectorPolicy
 */
export interface PolicyAttachmentSpecForProviderPolicyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicyAttachmentSpecForProviderPolicyIdSelectorPolicy#resolution
   */
  readonly resolution?: PolicyAttachmentSpecForProviderPolicyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicyAttachmentSpecForProviderPolicyIdSelectorPolicy#resolve
   */
  readonly resolve?: PolicyAttachmentSpecForProviderPolicyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecForProviderPolicyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecForProviderPolicyIdSelectorPolicy(obj: PolicyAttachmentSpecForProviderPolicyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicyAttachmentSpecProviderConfigRefPolicyResolution
 */
export enum PolicyAttachmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicyAttachmentSpecProviderConfigRefPolicyResolve
 */
export enum PolicyAttachmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicyAttachmentSpecProviderRefPolicyResolution
 */
export enum PolicyAttachmentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicyAttachmentSpecProviderRefPolicyResolve
 */
export enum PolicyAttachmentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicyAttachmentSpecForProviderPolicyIdRefPolicyResolution
 */
export enum PolicyAttachmentSpecForProviderPolicyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicyAttachmentSpecForProviderPolicyIdRefPolicyResolve
 */
export enum PolicyAttachmentSpecForProviderPolicyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicyAttachmentSpecForProviderPolicyIdSelectorPolicyResolution
 */
export enum PolicyAttachmentSpecForProviderPolicyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicyAttachmentSpecForProviderPolicyIdSelectorPolicyResolve
 */
export enum PolicyAttachmentSpecForProviderPolicyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

