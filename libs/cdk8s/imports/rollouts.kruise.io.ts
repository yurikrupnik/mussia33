// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Rollout is the Schema for the rollouts API
 *
 * @schema Rollout
 */
export class Rollout extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Rollout"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rollouts.kruise.io/v1alpha1',
    kind: 'Rollout',
  }

  /**
   * Renders a Kubernetes manifest for "Rollout".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RolloutProps = {}): any {
    return {
      ...Rollout.GVK,
      ...toJson_RolloutProps(props),
    };
  }

  /**
   * Defines a "Rollout" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RolloutProps = {}) {
    super(scope, id, {
      ...Rollout.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Rollout.GVK,
      ...toJson_RolloutProps(resolved),
    };
  }
}

/**
 * Rollout is the Schema for the rollouts API
 *
 * @schema Rollout
 */
export interface RolloutProps {
  /**
   * @schema Rollout#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RolloutSpec defines the desired state of Rollout
   *
   * @schema Rollout#spec
   */
  readonly spec?: RolloutSpec;

}

/**
 * Converts an object of type 'RolloutProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RolloutProps(obj: RolloutProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RolloutSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RolloutSpec defines the desired state of Rollout
 *
 * @schema RolloutSpec
 */
export interface RolloutSpec {
  /**
   * INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "make" to regenerate code after modifying this file ObjectRef indicates workload
   *
   * @schema RolloutSpec#objectRef
   */
  readonly objectRef: RolloutSpecObjectRef;

  /**
   * rollout strategy
   *
   * @schema RolloutSpec#strategy
   */
  readonly strategy: RolloutSpecStrategy;

}

/**
 * Converts an object of type 'RolloutSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RolloutSpec(obj: RolloutSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectRef': toJson_RolloutSpecObjectRef(obj.objectRef),
    'strategy': toJson_RolloutSpecStrategy(obj.strategy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "make" to regenerate code after modifying this file ObjectRef indicates workload
 *
 * @schema RolloutSpecObjectRef
 */
export interface RolloutSpecObjectRef {
  /**
   * WorkloadRef contains enough information to let you identify a workload for Rollout Batch release of the bypass
   *
   * @schema RolloutSpecObjectRef#workloadRef
   */
  readonly workloadRef?: RolloutSpecObjectRefWorkloadRef;

}

/**
 * Converts an object of type 'RolloutSpecObjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RolloutSpecObjectRef(obj: RolloutSpecObjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'workloadRef': toJson_RolloutSpecObjectRefWorkloadRef(obj.workloadRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * rollout strategy
 *
 * @schema RolloutSpecStrategy
 */
export interface RolloutSpecStrategy {
  /**
   * CanaryStrategy defines parameters for a Replica Based Canary
   *
   * @schema RolloutSpecStrategy#canary
   */
  readonly canary?: RolloutSpecStrategyCanary;

  /**
   * Paused indicates that the Rollout is paused. Default value is false
   *
   * @schema RolloutSpecStrategy#paused
   */
  readonly paused?: boolean;

}

/**
 * Converts an object of type 'RolloutSpecStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RolloutSpecStrategy(obj: RolloutSpecStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'canary': toJson_RolloutSpecStrategyCanary(obj.canary),
    'paused': obj.paused,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkloadRef contains enough information to let you identify a workload for Rollout Batch release of the bypass
 *
 * @schema RolloutSpecObjectRefWorkloadRef
 */
export interface RolloutSpecObjectRefWorkloadRef {
  /**
   * API Version of the referent
   *
   * @schema RolloutSpecObjectRefWorkloadRef#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind of the referent
   *
   * @schema RolloutSpecObjectRefWorkloadRef#kind
   */
  readonly kind: string;

  /**
   * Name of the referent
   *
   * @schema RolloutSpecObjectRefWorkloadRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RolloutSpecObjectRefWorkloadRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RolloutSpecObjectRefWorkloadRef(obj: RolloutSpecObjectRefWorkloadRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CanaryStrategy defines parameters for a Replica Based Canary
 *
 * @schema RolloutSpecStrategyCanary
 */
export interface RolloutSpecStrategyCanary {
  /**
   * Steps define the order of phases to execute release in batches(20%, 40%, 60%, 80%, 100%)
   *
   * @schema RolloutSpecStrategyCanary#steps
   */
  readonly steps?: RolloutSpecStrategyCanarySteps[];

  /**
   * TrafficRoutings hosts all the supported service meshes supported to enable more fine-grained traffic routing todo current only support one
   *
   * @schema RolloutSpecStrategyCanary#trafficRoutings
   */
  readonly trafficRoutings?: RolloutSpecStrategyCanaryTrafficRoutings[];

}

/**
 * Converts an object of type 'RolloutSpecStrategyCanary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RolloutSpecStrategyCanary(obj: RolloutSpecStrategyCanary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'steps': obj.steps?.map(y => toJson_RolloutSpecStrategyCanarySteps(y)),
    'trafficRoutings': obj.trafficRoutings?.map(y => toJson_RolloutSpecStrategyCanaryTrafficRoutings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CanaryStep defines a step of a canary workload.
 *
 * @schema RolloutSpecStrategyCanarySteps
 */
export interface RolloutSpecStrategyCanarySteps {
  /**
   * Pause defines a pause stage for a rollout, manual or auto
   *
   * @schema RolloutSpecStrategyCanarySteps#pause
   */
  readonly pause?: RolloutSpecStrategyCanaryStepsPause;

  /**
   * Replicas is the number of expected canary pods in this batch it can be an absolute number (ex: 5) or a percentage of total pods.
   *
   * @schema RolloutSpecStrategyCanarySteps#replicas
   */
  readonly replicas?: RolloutSpecStrategyCanaryStepsReplicas;

  /**
   * SetWeight sets what percentage of the canary pods should receive
   *
   * @schema RolloutSpecStrategyCanarySteps#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'RolloutSpecStrategyCanarySteps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RolloutSpecStrategyCanarySteps(obj: RolloutSpecStrategyCanarySteps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pause': toJson_RolloutSpecStrategyCanaryStepsPause(obj.pause),
    'replicas': obj.replicas?.value,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TrafficRouting hosts all the different configuration for supported service meshes to enable more fine-grained traffic routing
 *
 * @schema RolloutSpecStrategyCanaryTrafficRoutings
 */
export interface RolloutSpecStrategyCanaryTrafficRoutings {
  /**
   * Optional duration in seconds the traffic provider(e.g. nginx ingress controller) consumes the service, ingress configuration changes gracefully.
   *
   * @schema RolloutSpecStrategyCanaryTrafficRoutings#gracePeriodSeconds
   */
  readonly gracePeriodSeconds?: number;

  /**
   * Ingress holds Ingress specific configuration to route traffic, e.g. Nginx, Alb.
   *
   * @schema RolloutSpecStrategyCanaryTrafficRoutings#ingress
   */
  readonly ingress?: RolloutSpecStrategyCanaryTrafficRoutingsIngress;

  /**
   * Service holds the name of a service which selects pods with stable version and don't select any pods with canary version.
   *
   * @schema RolloutSpecStrategyCanaryTrafficRoutings#service
   */
  readonly service: string;

  /**
   * nginx, alb, istio etc.
   *
   * @schema RolloutSpecStrategyCanaryTrafficRoutings#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RolloutSpecStrategyCanaryTrafficRoutings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RolloutSpecStrategyCanaryTrafficRoutings(obj: RolloutSpecStrategyCanaryTrafficRoutings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gracePeriodSeconds': obj.gracePeriodSeconds,
    'ingress': toJson_RolloutSpecStrategyCanaryTrafficRoutingsIngress(obj.ingress),
    'service': obj.service,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pause defines a pause stage for a rollout, manual or auto
 *
 * @schema RolloutSpecStrategyCanaryStepsPause
 */
export interface RolloutSpecStrategyCanaryStepsPause {
  /**
   * Duration the amount of time to wait before moving to the next step.
   *
   * @schema RolloutSpecStrategyCanaryStepsPause#duration
   */
  readonly duration?: number;

}

/**
 * Converts an object of type 'RolloutSpecStrategyCanaryStepsPause' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RolloutSpecStrategyCanaryStepsPause(obj: RolloutSpecStrategyCanaryStepsPause | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'duration': obj.duration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Replicas is the number of expected canary pods in this batch it can be an absolute number (ex: 5) or a percentage of total pods.
 *
 * @schema RolloutSpecStrategyCanaryStepsReplicas
 */
export class RolloutSpecStrategyCanaryStepsReplicas {
  public static fromNumber(value: number): RolloutSpecStrategyCanaryStepsReplicas {
    return new RolloutSpecStrategyCanaryStepsReplicas(value);
  }
  public static fromString(value: string): RolloutSpecStrategyCanaryStepsReplicas {
    return new RolloutSpecStrategyCanaryStepsReplicas(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Ingress holds Ingress specific configuration to route traffic, e.g. Nginx, Alb.
 *
 * @schema RolloutSpecStrategyCanaryTrafficRoutingsIngress
 */
export interface RolloutSpecStrategyCanaryTrafficRoutingsIngress {
  /**
   * Name refers to the name of an `Ingress` resource in the same namespace as the `Rollout`
   *
   * @schema RolloutSpecStrategyCanaryTrafficRoutingsIngress#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RolloutSpecStrategyCanaryTrafficRoutingsIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RolloutSpecStrategyCanaryTrafficRoutingsIngress(obj: RolloutSpecStrategyCanaryTrafficRoutingsIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

