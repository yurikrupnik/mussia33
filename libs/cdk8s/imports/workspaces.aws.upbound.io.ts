// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Directory is the Schema for the Directorys API. Provides a WorkSpaces directory in AWS WorkSpaces Service.
 *
 * @schema Directory
 */
export class Directory extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Directory"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'workspaces.aws.upbound.io/v1beta1',
    kind: 'Directory',
  }

  /**
   * Renders a Kubernetes manifest for "Directory".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DirectoryProps): any {
    return {
      ...Directory.GVK,
      ...toJson_DirectoryProps(props),
    };
  }

  /**
   * Defines a "Directory" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DirectoryProps) {
    super(scope, id, {
      ...Directory.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Directory.GVK,
      ...toJson_DirectoryProps(resolved),
    };
  }
}

/**
 * Directory is the Schema for the Directorys API. Provides a WorkSpaces directory in AWS WorkSpaces Service.
 *
 * @schema Directory
 */
export interface DirectoryProps {
  /**
   * @schema Directory#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DirectorySpec defines the desired state of Directory
   *
   * @schema Directory#spec
   */
  readonly spec: DirectorySpec;

}

/**
 * Converts an object of type 'DirectoryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectoryProps(obj: DirectoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DirectorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DirectorySpec defines the desired state of Directory
 *
 * @schema DirectorySpec
 */
export interface DirectorySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DirectorySpec#deletionPolicy
   */
  readonly deletionPolicy?: DirectorySpecDeletionPolicy;

  /**
   * @schema DirectorySpec#forProvider
   */
  readonly forProvider: DirectorySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DirectorySpec#managementPolicy
   */
  readonly managementPolicy?: DirectorySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DirectorySpec#providerConfigRef
   */
  readonly providerConfigRef?: DirectorySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DirectorySpec#providerRef
   */
  readonly providerRef?: DirectorySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DirectorySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DirectorySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DirectorySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DirectorySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DirectorySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpec(obj: DirectorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DirectorySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DirectorySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DirectorySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DirectorySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DirectorySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DirectorySpecDeletionPolicy
 */
export enum DirectorySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DirectorySpecForProvider
 */
export interface DirectorySpecForProvider {
  /**
   * The directory identifier for registration in WorkSpaces service.
   *
   * @schema DirectorySpecForProvider#directoryId
   */
  readonly directoryId?: string;

  /**
   * Reference to a Directory in ds to populate directoryId.
   *
   * @schema DirectorySpecForProvider#directoryIdRef
   */
  readonly directoryIdRef?: DirectorySpecForProviderDirectoryIdRef;

  /**
   * Selector for a Directory in ds to populate directoryId.
   *
   * @schema DirectorySpecForProvider#directoryIdSelector
   */
  readonly directoryIdSelector?: DirectorySpecForProviderDirectoryIdSelector;

  /**
   * The identifiers of the IP access control groups associated with the directory.
   *
   * @schema DirectorySpecForProvider#ipGroupIds
   */
  readonly ipGroupIds?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DirectorySpecForProvider#region
   */
  readonly region: string;

  /**
   * service capabilities. Defined below.
   *
   * @schema DirectorySpecForProvider#selfServicePermissions
   */
  readonly selfServicePermissions?: DirectorySpecForProviderSelfServicePermissions[];

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema DirectorySpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: DirectorySpecForProviderSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema DirectorySpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: DirectorySpecForProviderSubnetIdSelector;

  /**
   * The identifiers of the subnets where the directory resides.
   *
   * @schema DirectorySpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema DirectorySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * –  Specifies which devices and operating systems users can use to access their WorkSpaces. Defined below.
   *
   * @schema DirectorySpecForProvider#workspaceAccessProperties
   */
  readonly workspaceAccessProperties?: DirectorySpecForProviderWorkspaceAccessProperties[];

  /**
   * –  Default properties that are used for creating WorkSpaces. Defined below.
   *
   * @schema DirectorySpecForProvider#workspaceCreationProperties
   */
  readonly workspaceCreationProperties?: DirectorySpecForProviderWorkspaceCreationProperties[];

}

/**
 * Converts an object of type 'DirectorySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProvider(obj: DirectorySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directoryId': obj.directoryId,
    'directoryIdRef': toJson_DirectorySpecForProviderDirectoryIdRef(obj.directoryIdRef),
    'directoryIdSelector': toJson_DirectorySpecForProviderDirectoryIdSelector(obj.directoryIdSelector),
    'ipGroupIds': obj.ipGroupIds?.map(y => y),
    'region': obj.region,
    'selfServicePermissions': obj.selfServicePermissions?.map(y => toJson_DirectorySpecForProviderSelfServicePermissions(y)),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_DirectorySpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_DirectorySpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'workspaceAccessProperties': obj.workspaceAccessProperties?.map(y => toJson_DirectorySpecForProviderWorkspaceAccessProperties(y)),
    'workspaceCreationProperties': obj.workspaceCreationProperties?.map(y => toJson_DirectorySpecForProviderWorkspaceCreationProperties(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DirectorySpecManagementPolicy
 */
export enum DirectorySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DirectorySpecProviderConfigRef
 */
export interface DirectorySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DirectorySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DirectorySpecProviderConfigRef#policy
   */
  readonly policy?: DirectorySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DirectorySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecProviderConfigRef(obj: DirectorySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DirectorySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DirectorySpecProviderRef
 */
export interface DirectorySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DirectorySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DirectorySpecProviderRef#policy
   */
  readonly policy?: DirectorySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DirectorySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecProviderRef(obj: DirectorySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DirectorySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DirectorySpecPublishConnectionDetailsTo
 */
export interface DirectorySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DirectorySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DirectorySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DirectorySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DirectorySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DirectorySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DirectorySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecPublishConnectionDetailsTo(obj: DirectorySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DirectorySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DirectorySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DirectorySpecWriteConnectionSecretToRef
 */
export interface DirectorySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DirectorySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DirectorySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DirectorySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecWriteConnectionSecretToRef(obj: DirectorySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Directory in ds to populate directoryId.
 *
 * @schema DirectorySpecForProviderDirectoryIdRef
 */
export interface DirectorySpecForProviderDirectoryIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DirectorySpecForProviderDirectoryIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DirectorySpecForProviderDirectoryIdRef#policy
   */
  readonly policy?: DirectorySpecForProviderDirectoryIdRefPolicy;

}

/**
 * Converts an object of type 'DirectorySpecForProviderDirectoryIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderDirectoryIdRef(obj: DirectorySpecForProviderDirectoryIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DirectorySpecForProviderDirectoryIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Directory in ds to populate directoryId.
 *
 * @schema DirectorySpecForProviderDirectoryIdSelector
 */
export interface DirectorySpecForProviderDirectoryIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DirectorySpecForProviderDirectoryIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DirectorySpecForProviderDirectoryIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DirectorySpecForProviderDirectoryIdSelector#policy
   */
  readonly policy?: DirectorySpecForProviderDirectoryIdSelectorPolicy;

}

/**
 * Converts an object of type 'DirectorySpecForProviderDirectoryIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderDirectoryIdSelector(obj: DirectorySpecForProviderDirectoryIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DirectorySpecForProviderDirectoryIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DirectorySpecForProviderSelfServicePermissions
 */
export interface DirectorySpecForProviderSelfServicePermissions {
  /**
   * –  Whether WorkSpaces directory users can change the compute type (bundle) for their workspace. Default false.
   *
   * @schema DirectorySpecForProviderSelfServicePermissions#changeComputeType
   */
  readonly changeComputeType?: boolean;

  /**
   * –  Whether WorkSpaces directory users can increase the volume size of the drives on their workspace. Default false.
   *
   * @schema DirectorySpecForProviderSelfServicePermissions#increaseVolumeSize
   */
  readonly increaseVolumeSize?: boolean;

  /**
   * –  Whether WorkSpaces directory users can rebuild the operating system of a workspace to its original state. Default false.
   *
   * @schema DirectorySpecForProviderSelfServicePermissions#rebuildWorkspace
   */
  readonly rebuildWorkspace?: boolean;

  /**
   * –  Whether WorkSpaces directory users can restart their workspace. Default true.
   *
   * @schema DirectorySpecForProviderSelfServicePermissions#restartWorkspace
   */
  readonly restartWorkspace?: boolean;

  /**
   * –  Whether WorkSpaces directory users can switch the running mode of their workspace. Default false.
   *
   * @schema DirectorySpecForProviderSelfServicePermissions#switchRunningMode
   */
  readonly switchRunningMode?: boolean;

}

/**
 * Converts an object of type 'DirectorySpecForProviderSelfServicePermissions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderSelfServicePermissions(obj: DirectorySpecForProviderSelfServicePermissions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'changeComputeType': obj.changeComputeType,
    'increaseVolumeSize': obj.increaseVolumeSize,
    'rebuildWorkspace': obj.rebuildWorkspace,
    'restartWorkspace': obj.restartWorkspace,
    'switchRunningMode': obj.switchRunningMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema DirectorySpecForProviderSubnetIdRefs
 */
export interface DirectorySpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema DirectorySpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DirectorySpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: DirectorySpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'DirectorySpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderSubnetIdRefs(obj: DirectorySpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DirectorySpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema DirectorySpecForProviderSubnetIdSelector
 */
export interface DirectorySpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DirectorySpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DirectorySpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DirectorySpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: DirectorySpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'DirectorySpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderSubnetIdSelector(obj: DirectorySpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DirectorySpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DirectorySpecForProviderWorkspaceAccessProperties
 */
export interface DirectorySpecForProviderWorkspaceAccessProperties {
  /**
   * –  Indicates whether users can use Android devices to access their WorkSpaces.
   *
   * @schema DirectorySpecForProviderWorkspaceAccessProperties#deviceTypeAndroid
   */
  readonly deviceTypeAndroid?: string;

  /**
   * –  Indicates whether users can use Chromebooks to access their WorkSpaces.
   *
   * @schema DirectorySpecForProviderWorkspaceAccessProperties#deviceTypeChromeos
   */
  readonly deviceTypeChromeos?: string;

  /**
   * –  Indicates whether users can use iOS devices to access their WorkSpaces.
   *
   * @schema DirectorySpecForProviderWorkspaceAccessProperties#deviceTypeIos
   */
  readonly deviceTypeIos?: string;

  /**
   * –  Indicates whether users can use Linux clients to access their WorkSpaces.
   *
   * @schema DirectorySpecForProviderWorkspaceAccessProperties#deviceTypeLinux
   */
  readonly deviceTypeLinux?: string;

  /**
   * –  Indicates whether users can use macOS clients to access their WorkSpaces.
   *
   * @schema DirectorySpecForProviderWorkspaceAccessProperties#deviceTypeOsx
   */
  readonly deviceTypeOsx?: string;

  /**
   * –  Indicates whether users can access their WorkSpaces through a web browser.
   *
   * @schema DirectorySpecForProviderWorkspaceAccessProperties#deviceTypeWeb
   */
  readonly deviceTypeWeb?: string;

  /**
   * –  Indicates whether users can use Windows clients to access their WorkSpaces.
   *
   * @schema DirectorySpecForProviderWorkspaceAccessProperties#deviceTypeWindows
   */
  readonly deviceTypeWindows?: string;

  /**
   * –  Indicates whether users can use zero client devices to access their WorkSpaces.
   *
   * @schema DirectorySpecForProviderWorkspaceAccessProperties#deviceTypeZeroclient
   */
  readonly deviceTypeZeroclient?: string;

}

/**
 * Converts an object of type 'DirectorySpecForProviderWorkspaceAccessProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderWorkspaceAccessProperties(obj: DirectorySpecForProviderWorkspaceAccessProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deviceTypeAndroid': obj.deviceTypeAndroid,
    'deviceTypeChromeos': obj.deviceTypeChromeos,
    'deviceTypeIos': obj.deviceTypeIos,
    'deviceTypeLinux': obj.deviceTypeLinux,
    'deviceTypeOsx': obj.deviceTypeOsx,
    'deviceTypeWeb': obj.deviceTypeWeb,
    'deviceTypeWindows': obj.deviceTypeWindows,
    'deviceTypeZeroclient': obj.deviceTypeZeroclient,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DirectorySpecForProviderWorkspaceCreationProperties
 */
export interface DirectorySpecForProviderWorkspaceCreationProperties {
  /**
   * –  The identifier of your custom security group. Should relate to the same VPC, where workspaces reside in.
   *
   * @schema DirectorySpecForProviderWorkspaceCreationProperties#customSecurityGroupId
   */
  readonly customSecurityGroupId?: string;

  /**
   * Reference to a SecurityGroup in ec2 to populate customSecurityGroupId.
   *
   * @schema DirectorySpecForProviderWorkspaceCreationProperties#customSecurityGroupIdRef
   */
  readonly customSecurityGroupIdRef?: DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRef;

  /**
   * Selector for a SecurityGroup in ec2 to populate customSecurityGroupId.
   *
   * @schema DirectorySpecForProviderWorkspaceCreationProperties#customSecurityGroupIdSelector
   */
  readonly customSecurityGroupIdSelector?: DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelector;

  /**
   * –  The default organizational unit (OU) for your WorkSpace directories. Should conform "OU=<value>,DC=<value>,...,DC=<value>" pattern.
   *
   * @schema DirectorySpecForProviderWorkspaceCreationProperties#defaultOu
   */
  readonly defaultOu?: string;

  /**
   * –  Indicates whether internet access is enabled for your WorkSpaces.
   *
   * @schema DirectorySpecForProviderWorkspaceCreationProperties#enableInternetAccess
   */
  readonly enableInternetAccess?: boolean;

  /**
   * –  Indicates whether maintenance mode is enabled for your WorkSpaces. For more information, see WorkSpace Maintenance..
   *
   * @schema DirectorySpecForProviderWorkspaceCreationProperties#enableMaintenanceMode
   */
  readonly enableMaintenanceMode?: boolean;

  /**
   * –  Indicates whether users are local administrators of their WorkSpaces.
   *
   * @schema DirectorySpecForProviderWorkspaceCreationProperties#userEnabledAsLocalAdministrator
   */
  readonly userEnabledAsLocalAdministrator?: boolean;

}

/**
 * Converts an object of type 'DirectorySpecForProviderWorkspaceCreationProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderWorkspaceCreationProperties(obj: DirectorySpecForProviderWorkspaceCreationProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customSecurityGroupId': obj.customSecurityGroupId,
    'customSecurityGroupIdRef': toJson_DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRef(obj.customSecurityGroupIdRef),
    'customSecurityGroupIdSelector': toJson_DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelector(obj.customSecurityGroupIdSelector),
    'defaultOu': obj.defaultOu,
    'enableInternetAccess': obj.enableInternetAccess,
    'enableMaintenanceMode': obj.enableMaintenanceMode,
    'userEnabledAsLocalAdministrator': obj.userEnabledAsLocalAdministrator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DirectorySpecProviderConfigRefPolicy
 */
export interface DirectorySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DirectorySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DirectorySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecProviderConfigRefPolicy(obj: DirectorySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DirectorySpecProviderRefPolicy
 */
export interface DirectorySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecProviderRefPolicy#resolution
   */
  readonly resolution?: DirectorySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecProviderRefPolicy#resolve
   */
  readonly resolve?: DirectorySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecProviderRefPolicy(obj: DirectorySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DirectorySpecPublishConnectionDetailsToConfigRef
 */
export interface DirectorySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DirectorySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DirectorySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DirectorySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DirectorySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecPublishConnectionDetailsToConfigRef(obj: DirectorySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DirectorySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DirectorySpecPublishConnectionDetailsToMetadata
 */
export interface DirectorySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DirectorySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DirectorySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DirectorySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DirectorySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecPublishConnectionDetailsToMetadata(obj: DirectorySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DirectorySpecForProviderDirectoryIdRefPolicy
 */
export interface DirectorySpecForProviderDirectoryIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecForProviderDirectoryIdRefPolicy#resolution
   */
  readonly resolution?: DirectorySpecForProviderDirectoryIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecForProviderDirectoryIdRefPolicy#resolve
   */
  readonly resolve?: DirectorySpecForProviderDirectoryIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecForProviderDirectoryIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderDirectoryIdRefPolicy(obj: DirectorySpecForProviderDirectoryIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DirectorySpecForProviderDirectoryIdSelectorPolicy
 */
export interface DirectorySpecForProviderDirectoryIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecForProviderDirectoryIdSelectorPolicy#resolution
   */
  readonly resolution?: DirectorySpecForProviderDirectoryIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecForProviderDirectoryIdSelectorPolicy#resolve
   */
  readonly resolve?: DirectorySpecForProviderDirectoryIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecForProviderDirectoryIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderDirectoryIdSelectorPolicy(obj: DirectorySpecForProviderDirectoryIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DirectorySpecForProviderSubnetIdRefsPolicy
 */
export interface DirectorySpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: DirectorySpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: DirectorySpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderSubnetIdRefsPolicy(obj: DirectorySpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DirectorySpecForProviderSubnetIdSelectorPolicy
 */
export interface DirectorySpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: DirectorySpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: DirectorySpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderSubnetIdSelectorPolicy(obj: DirectorySpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a SecurityGroup in ec2 to populate customSecurityGroupId.
 *
 * @schema DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRef
 */
export interface DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRef#policy
   */
  readonly policy?: DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRefPolicy;

}

/**
 * Converts an object of type 'DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRef(obj: DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a SecurityGroup in ec2 to populate customSecurityGroupId.
 *
 * @schema DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelector
 */
export interface DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelector#policy
   */
  readonly policy?: DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelector(obj: DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecProviderConfigRefPolicyResolution
 */
export enum DirectorySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecProviderConfigRefPolicyResolve
 */
export enum DirectorySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecProviderRefPolicyResolution
 */
export enum DirectorySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecProviderRefPolicyResolve
 */
export enum DirectorySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DirectorySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DirectorySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DirectorySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DirectorySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecPublishConnectionDetailsToConfigRefPolicy(obj: DirectorySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecForProviderDirectoryIdRefPolicyResolution
 */
export enum DirectorySpecForProviderDirectoryIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecForProviderDirectoryIdRefPolicyResolve
 */
export enum DirectorySpecForProviderDirectoryIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecForProviderDirectoryIdSelectorPolicyResolution
 */
export enum DirectorySpecForProviderDirectoryIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecForProviderDirectoryIdSelectorPolicyResolve
 */
export enum DirectorySpecForProviderDirectoryIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecForProviderSubnetIdRefsPolicyResolution
 */
export enum DirectorySpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecForProviderSubnetIdRefsPolicyResolve
 */
export enum DirectorySpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum DirectorySpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum DirectorySpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRefPolicy
 */
export interface DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRefPolicy#resolution
   */
  readonly resolution?: DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRefPolicy#resolve
   */
  readonly resolve?: DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRefPolicy(obj: DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelectorPolicy
 */
export interface DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelectorPolicy(obj: DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DirectorySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DirectorySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRefPolicyResolution
 */
export enum DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRefPolicyResolve
 */
export enum DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelectorPolicyResolution
 */
export enum DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelectorPolicyResolve
 */
export enum DirectorySpecForProviderWorkspaceCreationPropertiesCustomSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * IPGroup is the Schema for the IPGroups API. Provides an IP access control group in AWS WorkSpaces Service.
 *
 * @schema IPGroup
 */
export class IpGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IPGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'workspaces.aws.upbound.io/v1beta1',
    kind: 'IPGroup',
  }

  /**
   * Renders a Kubernetes manifest for "IPGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IpGroupProps): any {
    return {
      ...IpGroup.GVK,
      ...toJson_IpGroupProps(props),
    };
  }

  /**
   * Defines a "IPGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IpGroupProps) {
    super(scope, id, {
      ...IpGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IpGroup.GVK,
      ...toJson_IpGroupProps(resolved),
    };
  }
}

/**
 * IPGroup is the Schema for the IPGroups API. Provides an IP access control group in AWS WorkSpaces Service.
 *
 * @schema IPGroup
 */
export interface IpGroupProps {
  /**
   * @schema IPGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IPGroupSpec defines the desired state of IPGroup
   *
   * @schema IPGroup#spec
   */
  readonly spec: IpGroupSpec;

}

/**
 * Converts an object of type 'IpGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpGroupProps(obj: IpGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IpGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPGroupSpec defines the desired state of IPGroup
 *
 * @schema IpGroupSpec
 */
export interface IpGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IpGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: IpGroupSpecDeletionPolicy;

  /**
   * @schema IpGroupSpec#forProvider
   */
  readonly forProvider: IpGroupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IpGroupSpec#managementPolicy
   */
  readonly managementPolicy?: IpGroupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IpGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: IpGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema IpGroupSpec#providerRef
   */
  readonly providerRef?: IpGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IpGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IpGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IpGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IpGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IpGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpGroupSpec(obj: IpGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IpGroupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_IpGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_IpGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_IpGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IpGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IpGroupSpecDeletionPolicy
 */
export enum IpGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema IpGroupSpecForProvider
 */
export interface IpGroupSpecForProvider {
  /**
   * The description of the IP group.
   *
   * @schema IpGroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name of the IP group.
   *
   * @schema IpGroupSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema IpGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * One or more pairs specifying the IP group rule (in CIDR format) from which web requests originate.
   *
   * @schema IpGroupSpecForProvider#rules
   */
  readonly rules?: IpGroupSpecForProviderRules[];

  /**
   * Key-value map of resource tags.
   *
   * @schema IpGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'IpGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpGroupSpecForProvider(obj: IpGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'rules': obj.rules?.map(y => toJson_IpGroupSpecForProviderRules(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IpGroupSpecManagementPolicy
 */
export enum IpGroupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IpGroupSpecProviderConfigRef
 */
export interface IpGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IpGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IpGroupSpecProviderConfigRef#policy
   */
  readonly policy?: IpGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IpGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpGroupSpecProviderConfigRef(obj: IpGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IpGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema IpGroupSpecProviderRef
 */
export interface IpGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema IpGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IpGroupSpecProviderRef#policy
   */
  readonly policy?: IpGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'IpGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpGroupSpecProviderRef(obj: IpGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IpGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IpGroupSpecPublishConnectionDetailsTo
 */
export interface IpGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IpGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IpGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IpGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IpGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IpGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IpGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpGroupSpecPublishConnectionDetailsTo(obj: IpGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IpGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IpGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IpGroupSpecWriteConnectionSecretToRef
 */
export interface IpGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IpGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IpGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IpGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpGroupSpecWriteConnectionSecretToRef(obj: IpGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IpGroupSpecForProviderRules
 */
export interface IpGroupSpecForProviderRules {
  /**
   * The description of the IP group.
   *
   * @schema IpGroupSpecForProviderRules#description
   */
  readonly description?: string;

  /**
   * The IP address range, in CIDR notation, e.g., 10.0.0.0/16
   *
   * @schema IpGroupSpecForProviderRules#source
   */
  readonly source: string;

}

/**
 * Converts an object of type 'IpGroupSpecForProviderRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpGroupSpecForProviderRules(obj: IpGroupSpecForProviderRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IpGroupSpecProviderConfigRefPolicy
 */
export interface IpGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IpGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IpGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IpGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IpGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IpGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpGroupSpecProviderConfigRefPolicy(obj: IpGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IpGroupSpecProviderRefPolicy
 */
export interface IpGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IpGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: IpGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IpGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: IpGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'IpGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpGroupSpecProviderRefPolicy(obj: IpGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IpGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface IpGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IpGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IpGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IpGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IpGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpGroupSpecPublishConnectionDetailsToConfigRef(obj: IpGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IpGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IpGroupSpecPublishConnectionDetailsToMetadata
 */
export interface IpGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IpGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IpGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IpGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IpGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpGroupSpecPublishConnectionDetailsToMetadata(obj: IpGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IpGroupSpecProviderConfigRefPolicyResolution
 */
export enum IpGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IpGroupSpecProviderConfigRefPolicyResolve
 */
export enum IpGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IpGroupSpecProviderRefPolicyResolution
 */
export enum IpGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IpGroupSpecProviderRefPolicyResolve
 */
export enum IpGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IpGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IpGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IpGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IpGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IpGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IpGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IpGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: IpGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IpGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IpGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IpGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IpGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

