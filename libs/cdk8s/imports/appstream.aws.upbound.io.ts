// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * DirectoryConfig is the Schema for the DirectoryConfigs API. Provides an AppStream Directory Config
 *
 * @schema DirectoryConfig
 */
export class DirectoryConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DirectoryConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appstream.aws.upbound.io/v1beta1',
    kind: 'DirectoryConfig',
  }

  /**
   * Renders a Kubernetes manifest for "DirectoryConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DirectoryConfigProps): any {
    return {
      ...DirectoryConfig.GVK,
      ...toJson_DirectoryConfigProps(props),
    };
  }

  /**
   * Defines a "DirectoryConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DirectoryConfigProps) {
    super(scope, id, {
      ...DirectoryConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DirectoryConfig.GVK,
      ...toJson_DirectoryConfigProps(resolved),
    };
  }
}

/**
 * DirectoryConfig is the Schema for the DirectoryConfigs API. Provides an AppStream Directory Config
 *
 * @schema DirectoryConfig
 */
export interface DirectoryConfigProps {
  /**
   * @schema DirectoryConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DirectoryConfigSpec defines the desired state of DirectoryConfig
   *
   * @schema DirectoryConfig#spec
   */
  readonly spec: DirectoryConfigSpec;

}

/**
 * Converts an object of type 'DirectoryConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectoryConfigProps(obj: DirectoryConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DirectoryConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DirectoryConfigSpec defines the desired state of DirectoryConfig
 *
 * @schema DirectoryConfigSpec
 */
export interface DirectoryConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DirectoryConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: DirectoryConfigSpecDeletionPolicy;

  /**
   * @schema DirectoryConfigSpec#forProvider
   */
  readonly forProvider: DirectoryConfigSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DirectoryConfigSpec#managementPolicy
   */
  readonly managementPolicy?: DirectoryConfigSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DirectoryConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: DirectoryConfigSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DirectoryConfigSpec#providerRef
   */
  readonly providerRef?: DirectoryConfigSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DirectoryConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DirectoryConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DirectoryConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DirectoryConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DirectoryConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectoryConfigSpec(obj: DirectoryConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DirectoryConfigSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DirectoryConfigSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DirectoryConfigSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DirectoryConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DirectoryConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DirectoryConfigSpecDeletionPolicy
 */
export enum DirectoryConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DirectoryConfigSpecForProvider
 */
export interface DirectoryConfigSpecForProvider {
  /**
   * Fully qualified name of the directory.
   *
   * @schema DirectoryConfigSpecForProvider#directoryName
   */
  readonly directoryName?: string;

  /**
   * Distinguished names of the organizational units for computer accounts.
   *
   * @schema DirectoryConfigSpecForProvider#organizationalUnitDistinguishedNames
   */
  readonly organizationalUnitDistinguishedNames?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DirectoryConfigSpecForProvider#region
   */
  readonly region: string;

  /**
   * Configuration block for the name of the directory and organizational unit (OU) to use to join the directory config to a Microsoft Active Directory domain. See service_account_credentials below.
   *
   * @schema DirectoryConfigSpecForProvider#serviceAccountCredentials
   */
  readonly serviceAccountCredentials?: DirectoryConfigSpecForProviderServiceAccountCredentials[];

}

/**
 * Converts an object of type 'DirectoryConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectoryConfigSpecForProvider(obj: DirectoryConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directoryName': obj.directoryName,
    'organizationalUnitDistinguishedNames': obj.organizationalUnitDistinguishedNames?.map(y => y),
    'region': obj.region,
    'serviceAccountCredentials': obj.serviceAccountCredentials?.map(y => toJson_DirectoryConfigSpecForProviderServiceAccountCredentials(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DirectoryConfigSpecManagementPolicy
 */
export enum DirectoryConfigSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DirectoryConfigSpecProviderConfigRef
 */
export interface DirectoryConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DirectoryConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DirectoryConfigSpecProviderConfigRef#policy
   */
  readonly policy?: DirectoryConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DirectoryConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectoryConfigSpecProviderConfigRef(obj: DirectoryConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DirectoryConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DirectoryConfigSpecProviderRef
 */
export interface DirectoryConfigSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DirectoryConfigSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DirectoryConfigSpecProviderRef#policy
   */
  readonly policy?: DirectoryConfigSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DirectoryConfigSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectoryConfigSpecProviderRef(obj: DirectoryConfigSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DirectoryConfigSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DirectoryConfigSpecPublishConnectionDetailsTo
 */
export interface DirectoryConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DirectoryConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DirectoryConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DirectoryConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DirectoryConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DirectoryConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DirectoryConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectoryConfigSpecPublishConnectionDetailsTo(obj: DirectoryConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DirectoryConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DirectoryConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DirectoryConfigSpecWriteConnectionSecretToRef
 */
export interface DirectoryConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DirectoryConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DirectoryConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DirectoryConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectoryConfigSpecWriteConnectionSecretToRef(obj: DirectoryConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DirectoryConfigSpecForProviderServiceAccountCredentials
 */
export interface DirectoryConfigSpecForProviderServiceAccountCredentials {
  /**
   * User name of the account. This account must have the following privileges: create computer objects, join computers to the domain, and change/reset the password on descendant computer objects for the organizational units specified.
   *
   * @schema DirectoryConfigSpecForProviderServiceAccountCredentials#accountName
   */
  readonly accountName: string;

  /**
   * Password for the account.
   *
   * @schema DirectoryConfigSpecForProviderServiceAccountCredentials#accountPasswordSecretRef
   */
  readonly accountPasswordSecretRef: DirectoryConfigSpecForProviderServiceAccountCredentialsAccountPasswordSecretRef;

}

/**
 * Converts an object of type 'DirectoryConfigSpecForProviderServiceAccountCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectoryConfigSpecForProviderServiceAccountCredentials(obj: DirectoryConfigSpecForProviderServiceAccountCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountName': obj.accountName,
    'accountPasswordSecretRef': toJson_DirectoryConfigSpecForProviderServiceAccountCredentialsAccountPasswordSecretRef(obj.accountPasswordSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DirectoryConfigSpecProviderConfigRefPolicy
 */
export interface DirectoryConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectoryConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DirectoryConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectoryConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DirectoryConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DirectoryConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectoryConfigSpecProviderConfigRefPolicy(obj: DirectoryConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DirectoryConfigSpecProviderRefPolicy
 */
export interface DirectoryConfigSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectoryConfigSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DirectoryConfigSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectoryConfigSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DirectoryConfigSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DirectoryConfigSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectoryConfigSpecProviderRefPolicy(obj: DirectoryConfigSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DirectoryConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface DirectoryConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DirectoryConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DirectoryConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DirectoryConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DirectoryConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectoryConfigSpecPublishConnectionDetailsToConfigRef(obj: DirectoryConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DirectoryConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DirectoryConfigSpecPublishConnectionDetailsToMetadata
 */
export interface DirectoryConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DirectoryConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DirectoryConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DirectoryConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DirectoryConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectoryConfigSpecPublishConnectionDetailsToMetadata(obj: DirectoryConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Password for the account.
 *
 * @schema DirectoryConfigSpecForProviderServiceAccountCredentialsAccountPasswordSecretRef
 */
export interface DirectoryConfigSpecForProviderServiceAccountCredentialsAccountPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema DirectoryConfigSpecForProviderServiceAccountCredentialsAccountPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DirectoryConfigSpecForProviderServiceAccountCredentialsAccountPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DirectoryConfigSpecForProviderServiceAccountCredentialsAccountPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DirectoryConfigSpecForProviderServiceAccountCredentialsAccountPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectoryConfigSpecForProviderServiceAccountCredentialsAccountPasswordSecretRef(obj: DirectoryConfigSpecForProviderServiceAccountCredentialsAccountPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectoryConfigSpecProviderConfigRefPolicyResolution
 */
export enum DirectoryConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectoryConfigSpecProviderConfigRefPolicyResolve
 */
export enum DirectoryConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectoryConfigSpecProviderRefPolicyResolution
 */
export enum DirectoryConfigSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectoryConfigSpecProviderRefPolicyResolve
 */
export enum DirectoryConfigSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DirectoryConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DirectoryConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DirectoryConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DirectoryConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DirectoryConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DirectoryConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DirectoryConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DirectoryConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: DirectoryConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DirectoryConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DirectoryConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DirectoryConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DirectoryConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Fleet is the Schema for the Fleets API. Provides an AppStream fleet
 *
 * @schema Fleet
 */
export class Fleet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Fleet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appstream.aws.upbound.io/v1beta1',
    kind: 'Fleet',
  }

  /**
   * Renders a Kubernetes manifest for "Fleet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FleetProps): any {
    return {
      ...Fleet.GVK,
      ...toJson_FleetProps(props),
    };
  }

  /**
   * Defines a "Fleet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FleetProps) {
    super(scope, id, {
      ...Fleet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Fleet.GVK,
      ...toJson_FleetProps(resolved),
    };
  }
}

/**
 * Fleet is the Schema for the Fleets API. Provides an AppStream fleet
 *
 * @schema Fleet
 */
export interface FleetProps {
  /**
   * @schema Fleet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FleetSpec defines the desired state of Fleet
   *
   * @schema Fleet#spec
   */
  readonly spec: FleetSpec;

}

/**
 * Converts an object of type 'FleetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetProps(obj: FleetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FleetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FleetSpec defines the desired state of Fleet
 *
 * @schema FleetSpec
 */
export interface FleetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FleetSpec#deletionPolicy
   */
  readonly deletionPolicy?: FleetSpecDeletionPolicy;

  /**
   * @schema FleetSpec#forProvider
   */
  readonly forProvider: FleetSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FleetSpec#managementPolicy
   */
  readonly managementPolicy?: FleetSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FleetSpec#providerConfigRef
   */
  readonly providerConfigRef?: FleetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema FleetSpec#providerRef
   */
  readonly providerRef?: FleetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FleetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FleetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FleetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FleetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FleetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpec(obj: FleetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FleetSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_FleetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_FleetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_FleetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FleetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FleetSpecDeletionPolicy
 */
export enum FleetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FleetSpecForProvider
 */
export interface FleetSpecForProvider {
  /**
   * Configuration block for the desired capacity of the fleet. See below.
   *
   * @schema FleetSpecForProvider#computeCapacity
   */
  readonly computeCapacity?: FleetSpecForProviderComputeCapacity[];

  /**
   * Description to display.
   *
   * @schema FleetSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Amount of time that a streaming session remains active after users disconnect.
   *
   * @schema FleetSpecForProvider#disconnectTimeoutInSeconds
   */
  readonly disconnectTimeoutInSeconds?: number;

  /**
   * Human-readable friendly name for the AppStream fleet.
   *
   * @schema FleetSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Configuration block for the name of the directory and organizational unit (OU) to use to join the fleet to a Microsoft Active Directory domain. See below.
   *
   * @schema FleetSpecForProvider#domainJoinInfo
   */
  readonly domainJoinInfo?: FleetSpecForProviderDomainJoinInfo[];

  /**
   * Enables or disables default internet access for the fleet.
   *
   * @schema FleetSpecForProvider#enableDefaultInternetAccess
   */
  readonly enableDefaultInternetAccess?: boolean;

  /**
   * Fleet type. Valid values are: ON_DEMAND, ALWAYS_ON
   *
   * @schema FleetSpecForProvider#fleetType
   */
  readonly fleetType?: string;

  /**
   * ARN of the IAM role to apply to the fleet.
   *
   * @schema FleetSpecForProvider#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * Reference to a Role in iam to populate iamRoleArn.
   *
   * @schema FleetSpecForProvider#iamRoleArnRef
   */
  readonly iamRoleArnRef?: FleetSpecForProviderIamRoleArnRef;

  /**
   * Selector for a Role in iam to populate iamRoleArn.
   *
   * @schema FleetSpecForProvider#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: FleetSpecForProviderIamRoleArnSelector;

  /**
   * Amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect_timeout_in_seconds time interval begins.
   *
   * @schema FleetSpecForProvider#idleDisconnectTimeoutInSeconds
   */
  readonly idleDisconnectTimeoutInSeconds?: number;

  /**
   * ARN of the public, private, or shared image to use.
   *
   * @schema FleetSpecForProvider#imageArn
   */
  readonly imageArn?: string;

  /**
   * Name of the image used to create the fleet.
   *
   * @schema FleetSpecForProvider#imageName
   */
  readonly imageName?: string;

  /**
   * Instance type to use when launching fleet instances.
   *
   * @schema FleetSpecForProvider#instanceType
   */
  readonly instanceType?: string;

  /**
   * Maximum amount of time that a streaming session can remain active, in seconds.
   *
   * @schema FleetSpecForProvider#maxUserDurationInSeconds
   */
  readonly maxUserDurationInSeconds?: number;

  /**
   * Unique name for the fleet.
   *
   * @schema FleetSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FleetSpecForProvider#region
   */
  readonly region: string;

  /**
   * AppStream 2.0 view that is displayed to your users when they stream from the fleet. When APP is specified, only the windows of applications opened by users display. When DESKTOP is specified, the standard desktop that is provided by the operating system displays. If not specified, defaults to APP.
   *
   * @schema FleetSpecForProvider#streamView
   */
  readonly streamView?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema FleetSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Configuration block for the VPC configuration for the image builder. See below.
   *
   * @schema FleetSpecForProvider#vpcConfig
   */
  readonly vpcConfig?: FleetSpecForProviderVpcConfig[];

}

/**
 * Converts an object of type 'FleetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProvider(obj: FleetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'computeCapacity': obj.computeCapacity?.map(y => toJson_FleetSpecForProviderComputeCapacity(y)),
    'description': obj.description,
    'disconnectTimeoutInSeconds': obj.disconnectTimeoutInSeconds,
    'displayName': obj.displayName,
    'domainJoinInfo': obj.domainJoinInfo?.map(y => toJson_FleetSpecForProviderDomainJoinInfo(y)),
    'enableDefaultInternetAccess': obj.enableDefaultInternetAccess,
    'fleetType': obj.fleetType,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_FleetSpecForProviderIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_FleetSpecForProviderIamRoleArnSelector(obj.iamRoleArnSelector),
    'idleDisconnectTimeoutInSeconds': obj.idleDisconnectTimeoutInSeconds,
    'imageArn': obj.imageArn,
    'imageName': obj.imageName,
    'instanceType': obj.instanceType,
    'maxUserDurationInSeconds': obj.maxUserDurationInSeconds,
    'name': obj.name,
    'region': obj.region,
    'streamView': obj.streamView,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcConfig': obj.vpcConfig?.map(y => toJson_FleetSpecForProviderVpcConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FleetSpecManagementPolicy
 */
export enum FleetSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FleetSpecProviderConfigRef
 */
export interface FleetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FleetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FleetSpecProviderConfigRef#policy
   */
  readonly policy?: FleetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FleetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecProviderConfigRef(obj: FleetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FleetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema FleetSpecProviderRef
 */
export interface FleetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FleetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FleetSpecProviderRef#policy
   */
  readonly policy?: FleetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'FleetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecProviderRef(obj: FleetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FleetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FleetSpecPublishConnectionDetailsTo
 */
export interface FleetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FleetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FleetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FleetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FleetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FleetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FleetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecPublishConnectionDetailsTo(obj: FleetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FleetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FleetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FleetSpecWriteConnectionSecretToRef
 */
export interface FleetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FleetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FleetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FleetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecWriteConnectionSecretToRef(obj: FleetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FleetSpecForProviderComputeCapacity
 */
export interface FleetSpecForProviderComputeCapacity {
  /**
   * Desired number of streaming instances.
   *
   * @schema FleetSpecForProviderComputeCapacity#desiredInstances
   */
  readonly desiredInstances: number;

}

/**
 * Converts an object of type 'FleetSpecForProviderComputeCapacity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderComputeCapacity(obj: FleetSpecForProviderComputeCapacity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'desiredInstances': obj.desiredInstances,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FleetSpecForProviderDomainJoinInfo
 */
export interface FleetSpecForProviderDomainJoinInfo {
  /**
   * Fully qualified name of the directory (for example, corp.example.com).
   *
   * @schema FleetSpecForProviderDomainJoinInfo#directoryName
   */
  readonly directoryName?: string;

  /**
   * Distinguished name of the organizational unit for computer accounts.
   *
   * @schema FleetSpecForProviderDomainJoinInfo#organizationalUnitDistinguishedName
   */
  readonly organizationalUnitDistinguishedName?: string;

}

/**
 * Converts an object of type 'FleetSpecForProviderDomainJoinInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderDomainJoinInfo(obj: FleetSpecForProviderDomainJoinInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directoryName': obj.directoryName,
    'organizationalUnitDistinguishedName': obj.organizationalUnitDistinguishedName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate iamRoleArn.
 *
 * @schema FleetSpecForProviderIamRoleArnRef
 */
export interface FleetSpecForProviderIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema FleetSpecForProviderIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FleetSpecForProviderIamRoleArnRef#policy
   */
  readonly policy?: FleetSpecForProviderIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'FleetSpecForProviderIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderIamRoleArnRef(obj: FleetSpecForProviderIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FleetSpecForProviderIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate iamRoleArn.
 *
 * @schema FleetSpecForProviderIamRoleArnSelector
 */
export interface FleetSpecForProviderIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FleetSpecForProviderIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FleetSpecForProviderIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FleetSpecForProviderIamRoleArnSelector#policy
   */
  readonly policy?: FleetSpecForProviderIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'FleetSpecForProviderIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderIamRoleArnSelector(obj: FleetSpecForProviderIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FleetSpecForProviderIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FleetSpecForProviderVpcConfig
 */
export interface FleetSpecForProviderVpcConfig {
  /**
   * Identifiers of the security groups for the fleet or image builder.
   *
   * @schema FleetSpecForProviderVpcConfig#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema FleetSpecForProviderVpcConfig#subnetIdRefs
   */
  readonly subnetIdRefs?: FleetSpecForProviderVpcConfigSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema FleetSpecForProviderVpcConfig#subnetIdSelector
   */
  readonly subnetIdSelector?: FleetSpecForProviderVpcConfigSubnetIdSelector;

  /**
   * Identifiers of the subnets to which a network interface is attached from the fleet instance or image builder instance.
   *
   * @schema FleetSpecForProviderVpcConfig#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'FleetSpecForProviderVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderVpcConfig(obj: FleetSpecForProviderVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_FleetSpecForProviderVpcConfigSubnetIdRefs(y)),
    'subnetIdSelector': toJson_FleetSpecForProviderVpcConfigSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FleetSpecProviderConfigRefPolicy
 */
export interface FleetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FleetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FleetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FleetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecProviderConfigRefPolicy(obj: FleetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FleetSpecProviderRefPolicy
 */
export interface FleetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: FleetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: FleetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'FleetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecProviderRefPolicy(obj: FleetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FleetSpecPublishConnectionDetailsToConfigRef
 */
export interface FleetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FleetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FleetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FleetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FleetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecPublishConnectionDetailsToConfigRef(obj: FleetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FleetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FleetSpecPublishConnectionDetailsToMetadata
 */
export interface FleetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FleetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FleetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FleetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FleetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecPublishConnectionDetailsToMetadata(obj: FleetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FleetSpecForProviderIamRoleArnRefPolicy
 */
export interface FleetSpecForProviderIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetSpecForProviderIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: FleetSpecForProviderIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetSpecForProviderIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: FleetSpecForProviderIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'FleetSpecForProviderIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderIamRoleArnRefPolicy(obj: FleetSpecForProviderIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FleetSpecForProviderIamRoleArnSelectorPolicy
 */
export interface FleetSpecForProviderIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetSpecForProviderIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: FleetSpecForProviderIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetSpecForProviderIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: FleetSpecForProviderIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FleetSpecForProviderIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderIamRoleArnSelectorPolicy(obj: FleetSpecForProviderIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema FleetSpecForProviderVpcConfigSubnetIdRefs
 */
export interface FleetSpecForProviderVpcConfigSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema FleetSpecForProviderVpcConfigSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FleetSpecForProviderVpcConfigSubnetIdRefs#policy
   */
  readonly policy?: FleetSpecForProviderVpcConfigSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'FleetSpecForProviderVpcConfigSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderVpcConfigSubnetIdRefs(obj: FleetSpecForProviderVpcConfigSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FleetSpecForProviderVpcConfigSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema FleetSpecForProviderVpcConfigSubnetIdSelector
 */
export interface FleetSpecForProviderVpcConfigSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FleetSpecForProviderVpcConfigSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FleetSpecForProviderVpcConfigSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FleetSpecForProviderVpcConfigSubnetIdSelector#policy
   */
  readonly policy?: FleetSpecForProviderVpcConfigSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'FleetSpecForProviderVpcConfigSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderVpcConfigSubnetIdSelector(obj: FleetSpecForProviderVpcConfigSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FleetSpecForProviderVpcConfigSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetSpecProviderConfigRefPolicyResolution
 */
export enum FleetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetSpecProviderConfigRefPolicyResolve
 */
export enum FleetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetSpecProviderRefPolicyResolution
 */
export enum FleetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetSpecProviderRefPolicyResolve
 */
export enum FleetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FleetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FleetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FleetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FleetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FleetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecPublishConnectionDetailsToConfigRefPolicy(obj: FleetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetSpecForProviderIamRoleArnRefPolicyResolution
 */
export enum FleetSpecForProviderIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetSpecForProviderIamRoleArnRefPolicyResolve
 */
export enum FleetSpecForProviderIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetSpecForProviderIamRoleArnSelectorPolicyResolution
 */
export enum FleetSpecForProviderIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetSpecForProviderIamRoleArnSelectorPolicyResolve
 */
export enum FleetSpecForProviderIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FleetSpecForProviderVpcConfigSubnetIdRefsPolicy
 */
export interface FleetSpecForProviderVpcConfigSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetSpecForProviderVpcConfigSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: FleetSpecForProviderVpcConfigSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetSpecForProviderVpcConfigSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: FleetSpecForProviderVpcConfigSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'FleetSpecForProviderVpcConfigSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderVpcConfigSubnetIdRefsPolicy(obj: FleetSpecForProviderVpcConfigSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FleetSpecForProviderVpcConfigSubnetIdSelectorPolicy
 */
export interface FleetSpecForProviderVpcConfigSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetSpecForProviderVpcConfigSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: FleetSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetSpecForProviderVpcConfigSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: FleetSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FleetSpecForProviderVpcConfigSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetSpecForProviderVpcConfigSubnetIdSelectorPolicy(obj: FleetSpecForProviderVpcConfigSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FleetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FleetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetSpecForProviderVpcConfigSubnetIdRefsPolicyResolution
 */
export enum FleetSpecForProviderVpcConfigSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetSpecForProviderVpcConfigSubnetIdRefsPolicyResolve
 */
export enum FleetSpecForProviderVpcConfigSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution
 */
export enum FleetSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve
 */
export enum FleetSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FleetStackAssociation is the Schema for the FleetStackAssociations API. Manages an AppStream Fleet Stack association.
 *
 * @schema FleetStackAssociation
 */
export class FleetStackAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FleetStackAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appstream.aws.upbound.io/v1beta1',
    kind: 'FleetStackAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "FleetStackAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FleetStackAssociationProps): any {
    return {
      ...FleetStackAssociation.GVK,
      ...toJson_FleetStackAssociationProps(props),
    };
  }

  /**
   * Defines a "FleetStackAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FleetStackAssociationProps) {
    super(scope, id, {
      ...FleetStackAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FleetStackAssociation.GVK,
      ...toJson_FleetStackAssociationProps(resolved),
    };
  }
}

/**
 * FleetStackAssociation is the Schema for the FleetStackAssociations API. Manages an AppStream Fleet Stack association.
 *
 * @schema FleetStackAssociation
 */
export interface FleetStackAssociationProps {
  /**
   * @schema FleetStackAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FleetStackAssociationSpec defines the desired state of FleetStackAssociation
   *
   * @schema FleetStackAssociation#spec
   */
  readonly spec: FleetStackAssociationSpec;

}

/**
 * Converts an object of type 'FleetStackAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationProps(obj: FleetStackAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FleetStackAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FleetStackAssociationSpec defines the desired state of FleetStackAssociation
 *
 * @schema FleetStackAssociationSpec
 */
export interface FleetStackAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FleetStackAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: FleetStackAssociationSpecDeletionPolicy;

  /**
   * @schema FleetStackAssociationSpec#forProvider
   */
  readonly forProvider: FleetStackAssociationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FleetStackAssociationSpec#managementPolicy
   */
  readonly managementPolicy?: FleetStackAssociationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FleetStackAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: FleetStackAssociationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema FleetStackAssociationSpec#providerRef
   */
  readonly providerRef?: FleetStackAssociationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FleetStackAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FleetStackAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FleetStackAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FleetStackAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FleetStackAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpec(obj: FleetStackAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FleetStackAssociationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_FleetStackAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_FleetStackAssociationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_FleetStackAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FleetStackAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FleetStackAssociationSpecDeletionPolicy
 */
export enum FleetStackAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FleetStackAssociationSpecForProvider
 */
export interface FleetStackAssociationSpecForProvider {
  /**
   * Name of the fleet.
   *
   * @schema FleetStackAssociationSpecForProvider#fleetName
   */
  readonly fleetName?: string;

  /**
   * Reference to a Fleet in appstream to populate fleetName.
   *
   * @schema FleetStackAssociationSpecForProvider#fleetNameRef
   */
  readonly fleetNameRef?: FleetStackAssociationSpecForProviderFleetNameRef;

  /**
   * Selector for a Fleet in appstream to populate fleetName.
   *
   * @schema FleetStackAssociationSpecForProvider#fleetNameSelector
   */
  readonly fleetNameSelector?: FleetStackAssociationSpecForProviderFleetNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FleetStackAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Name of the stack.
   *
   * @schema FleetStackAssociationSpecForProvider#stackName
   */
  readonly stackName?: string;

  /**
   * Reference to a Stack in appstream to populate stackName.
   *
   * @schema FleetStackAssociationSpecForProvider#stackNameRef
   */
  readonly stackNameRef?: FleetStackAssociationSpecForProviderStackNameRef;

  /**
   * Selector for a Stack in appstream to populate stackName.
   *
   * @schema FleetStackAssociationSpecForProvider#stackNameSelector
   */
  readonly stackNameSelector?: FleetStackAssociationSpecForProviderStackNameSelector;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecForProvider(obj: FleetStackAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fleetName': obj.fleetName,
    'fleetNameRef': toJson_FleetStackAssociationSpecForProviderFleetNameRef(obj.fleetNameRef),
    'fleetNameSelector': toJson_FleetStackAssociationSpecForProviderFleetNameSelector(obj.fleetNameSelector),
    'region': obj.region,
    'stackName': obj.stackName,
    'stackNameRef': toJson_FleetStackAssociationSpecForProviderStackNameRef(obj.stackNameRef),
    'stackNameSelector': toJson_FleetStackAssociationSpecForProviderStackNameSelector(obj.stackNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FleetStackAssociationSpecManagementPolicy
 */
export enum FleetStackAssociationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FleetStackAssociationSpecProviderConfigRef
 */
export interface FleetStackAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FleetStackAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FleetStackAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: FleetStackAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecProviderConfigRef(obj: FleetStackAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FleetStackAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema FleetStackAssociationSpecProviderRef
 */
export interface FleetStackAssociationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FleetStackAssociationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FleetStackAssociationSpecProviderRef#policy
   */
  readonly policy?: FleetStackAssociationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecProviderRef(obj: FleetStackAssociationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FleetStackAssociationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FleetStackAssociationSpecPublishConnectionDetailsTo
 */
export interface FleetStackAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FleetStackAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FleetStackAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FleetStackAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FleetStackAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FleetStackAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecPublishConnectionDetailsTo(obj: FleetStackAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FleetStackAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FleetStackAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FleetStackAssociationSpecWriteConnectionSecretToRef
 */
export interface FleetStackAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FleetStackAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FleetStackAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecWriteConnectionSecretToRef(obj: FleetStackAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Fleet in appstream to populate fleetName.
 *
 * @schema FleetStackAssociationSpecForProviderFleetNameRef
 */
export interface FleetStackAssociationSpecForProviderFleetNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema FleetStackAssociationSpecForProviderFleetNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FleetStackAssociationSpecForProviderFleetNameRef#policy
   */
  readonly policy?: FleetStackAssociationSpecForProviderFleetNameRefPolicy;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecForProviderFleetNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecForProviderFleetNameRef(obj: FleetStackAssociationSpecForProviderFleetNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FleetStackAssociationSpecForProviderFleetNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Fleet in appstream to populate fleetName.
 *
 * @schema FleetStackAssociationSpecForProviderFleetNameSelector
 */
export interface FleetStackAssociationSpecForProviderFleetNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FleetStackAssociationSpecForProviderFleetNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FleetStackAssociationSpecForProviderFleetNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FleetStackAssociationSpecForProviderFleetNameSelector#policy
   */
  readonly policy?: FleetStackAssociationSpecForProviderFleetNameSelectorPolicy;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecForProviderFleetNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecForProviderFleetNameSelector(obj: FleetStackAssociationSpecForProviderFleetNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FleetStackAssociationSpecForProviderFleetNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stack in appstream to populate stackName.
 *
 * @schema FleetStackAssociationSpecForProviderStackNameRef
 */
export interface FleetStackAssociationSpecForProviderStackNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema FleetStackAssociationSpecForProviderStackNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FleetStackAssociationSpecForProviderStackNameRef#policy
   */
  readonly policy?: FleetStackAssociationSpecForProviderStackNameRefPolicy;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecForProviderStackNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecForProviderStackNameRef(obj: FleetStackAssociationSpecForProviderStackNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FleetStackAssociationSpecForProviderStackNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stack in appstream to populate stackName.
 *
 * @schema FleetStackAssociationSpecForProviderStackNameSelector
 */
export interface FleetStackAssociationSpecForProviderStackNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FleetStackAssociationSpecForProviderStackNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FleetStackAssociationSpecForProviderStackNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FleetStackAssociationSpecForProviderStackNameSelector#policy
   */
  readonly policy?: FleetStackAssociationSpecForProviderStackNameSelectorPolicy;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecForProviderStackNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecForProviderStackNameSelector(obj: FleetStackAssociationSpecForProviderStackNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FleetStackAssociationSpecForProviderStackNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FleetStackAssociationSpecProviderConfigRefPolicy
 */
export interface FleetStackAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetStackAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FleetStackAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetStackAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FleetStackAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecProviderConfigRefPolicy(obj: FleetStackAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FleetStackAssociationSpecProviderRefPolicy
 */
export interface FleetStackAssociationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetStackAssociationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: FleetStackAssociationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetStackAssociationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: FleetStackAssociationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecProviderRefPolicy(obj: FleetStackAssociationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FleetStackAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface FleetStackAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FleetStackAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FleetStackAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FleetStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecPublishConnectionDetailsToConfigRef(obj: FleetStackAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FleetStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FleetStackAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface FleetStackAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FleetStackAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FleetStackAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FleetStackAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecPublishConnectionDetailsToMetadata(obj: FleetStackAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FleetStackAssociationSpecForProviderFleetNameRefPolicy
 */
export interface FleetStackAssociationSpecForProviderFleetNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetStackAssociationSpecForProviderFleetNameRefPolicy#resolution
   */
  readonly resolution?: FleetStackAssociationSpecForProviderFleetNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetStackAssociationSpecForProviderFleetNameRefPolicy#resolve
   */
  readonly resolve?: FleetStackAssociationSpecForProviderFleetNameRefPolicyResolve;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecForProviderFleetNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecForProviderFleetNameRefPolicy(obj: FleetStackAssociationSpecForProviderFleetNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FleetStackAssociationSpecForProviderFleetNameSelectorPolicy
 */
export interface FleetStackAssociationSpecForProviderFleetNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetStackAssociationSpecForProviderFleetNameSelectorPolicy#resolution
   */
  readonly resolution?: FleetStackAssociationSpecForProviderFleetNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetStackAssociationSpecForProviderFleetNameSelectorPolicy#resolve
   */
  readonly resolve?: FleetStackAssociationSpecForProviderFleetNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecForProviderFleetNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecForProviderFleetNameSelectorPolicy(obj: FleetStackAssociationSpecForProviderFleetNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FleetStackAssociationSpecForProviderStackNameRefPolicy
 */
export interface FleetStackAssociationSpecForProviderStackNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetStackAssociationSpecForProviderStackNameRefPolicy#resolution
   */
  readonly resolution?: FleetStackAssociationSpecForProviderStackNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetStackAssociationSpecForProviderStackNameRefPolicy#resolve
   */
  readonly resolve?: FleetStackAssociationSpecForProviderStackNameRefPolicyResolve;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecForProviderStackNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecForProviderStackNameRefPolicy(obj: FleetStackAssociationSpecForProviderStackNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FleetStackAssociationSpecForProviderStackNameSelectorPolicy
 */
export interface FleetStackAssociationSpecForProviderStackNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetStackAssociationSpecForProviderStackNameSelectorPolicy#resolution
   */
  readonly resolution?: FleetStackAssociationSpecForProviderStackNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetStackAssociationSpecForProviderStackNameSelectorPolicy#resolve
   */
  readonly resolve?: FleetStackAssociationSpecForProviderStackNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecForProviderStackNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecForProviderStackNameSelectorPolicy(obj: FleetStackAssociationSpecForProviderStackNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetStackAssociationSpecProviderConfigRefPolicyResolution
 */
export enum FleetStackAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetStackAssociationSpecProviderConfigRefPolicyResolve
 */
export enum FleetStackAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetStackAssociationSpecProviderRefPolicyResolution
 */
export enum FleetStackAssociationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetStackAssociationSpecProviderRefPolicyResolve
 */
export enum FleetStackAssociationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FleetStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FleetStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FleetStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FleetStackAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FleetStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FleetStackAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FleetStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FleetStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: FleetStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetStackAssociationSpecForProviderFleetNameRefPolicyResolution
 */
export enum FleetStackAssociationSpecForProviderFleetNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetStackAssociationSpecForProviderFleetNameRefPolicyResolve
 */
export enum FleetStackAssociationSpecForProviderFleetNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetStackAssociationSpecForProviderFleetNameSelectorPolicyResolution
 */
export enum FleetStackAssociationSpecForProviderFleetNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetStackAssociationSpecForProviderFleetNameSelectorPolicyResolve
 */
export enum FleetStackAssociationSpecForProviderFleetNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetStackAssociationSpecForProviderStackNameRefPolicyResolution
 */
export enum FleetStackAssociationSpecForProviderStackNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetStackAssociationSpecForProviderStackNameRefPolicyResolve
 */
export enum FleetStackAssociationSpecForProviderStackNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetStackAssociationSpecForProviderStackNameSelectorPolicyResolution
 */
export enum FleetStackAssociationSpecForProviderStackNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetStackAssociationSpecForProviderStackNameSelectorPolicyResolve
 */
export enum FleetStackAssociationSpecForProviderStackNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FleetStackAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FleetStackAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FleetStackAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FleetStackAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ImageBuilder is the Schema for the ImageBuilders API. Provides an AppStream image builder
 *
 * @schema ImageBuilder
 */
export class ImageBuilder extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ImageBuilder"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appstream.aws.upbound.io/v1beta1',
    kind: 'ImageBuilder',
  }

  /**
   * Renders a Kubernetes manifest for "ImageBuilder".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ImageBuilderProps): any {
    return {
      ...ImageBuilder.GVK,
      ...toJson_ImageBuilderProps(props),
    };
  }

  /**
   * Defines a "ImageBuilder" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ImageBuilderProps) {
    super(scope, id, {
      ...ImageBuilder.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ImageBuilder.GVK,
      ...toJson_ImageBuilderProps(resolved),
    };
  }
}

/**
 * ImageBuilder is the Schema for the ImageBuilders API. Provides an AppStream image builder
 *
 * @schema ImageBuilder
 */
export interface ImageBuilderProps {
  /**
   * @schema ImageBuilder#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ImageBuilderSpec defines the desired state of ImageBuilder
   *
   * @schema ImageBuilder#spec
   */
  readonly spec: ImageBuilderSpec;

}

/**
 * Converts an object of type 'ImageBuilderProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderProps(obj: ImageBuilderProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ImageBuilderSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageBuilderSpec defines the desired state of ImageBuilder
 *
 * @schema ImageBuilderSpec
 */
export interface ImageBuilderSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ImageBuilderSpec#deletionPolicy
   */
  readonly deletionPolicy?: ImageBuilderSpecDeletionPolicy;

  /**
   * @schema ImageBuilderSpec#forProvider
   */
  readonly forProvider: ImageBuilderSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ImageBuilderSpec#managementPolicy
   */
  readonly managementPolicy?: ImageBuilderSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ImageBuilderSpec#providerConfigRef
   */
  readonly providerConfigRef?: ImageBuilderSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ImageBuilderSpec#providerRef
   */
  readonly providerRef?: ImageBuilderSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ImageBuilderSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ImageBuilderSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ImageBuilderSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ImageBuilderSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ImageBuilderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpec(obj: ImageBuilderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ImageBuilderSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ImageBuilderSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ImageBuilderSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ImageBuilderSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ImageBuilderSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ImageBuilderSpecDeletionPolicy
 */
export enum ImageBuilderSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ImageBuilderSpecForProvider
 */
export interface ImageBuilderSpecForProvider {
  /**
   * Set of interface VPC endpoint (interface endpoint) objects. Maximum of 4. See below.
   *
   * @schema ImageBuilderSpecForProvider#accessEndpoint
   */
  readonly accessEndpoint?: ImageBuilderSpecForProviderAccessEndpoint[];

  /**
   * Version of the AppStream 2.0 agent to use for this image builder.
   *
   * @schema ImageBuilderSpecForProvider#appstreamAgentVersion
   */
  readonly appstreamAgentVersion?: string;

  /**
   * Description to display.
   *
   * @schema ImageBuilderSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Human-readable friendly name for the AppStream image builder.
   *
   * @schema ImageBuilderSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Configuration block for the name of the directory and organizational unit (OU) to use to join the image builder to a Microsoft Active Directory domain. See below.
   *
   * @schema ImageBuilderSpecForProvider#domainJoinInfo
   */
  readonly domainJoinInfo?: ImageBuilderSpecForProviderDomainJoinInfo[];

  /**
   * Enables or disables default internet access for the image builder.
   *
   * @schema ImageBuilderSpecForProvider#enableDefaultInternetAccess
   */
  readonly enableDefaultInternetAccess?: boolean;

  /**
   * ARN of the IAM role to apply to the image builder.
   *
   * @schema ImageBuilderSpecForProvider#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * Reference to a Role in iam to populate iamRoleArn.
   *
   * @schema ImageBuilderSpecForProvider#iamRoleArnRef
   */
  readonly iamRoleArnRef?: ImageBuilderSpecForProviderIamRoleArnRef;

  /**
   * Selector for a Role in iam to populate iamRoleArn.
   *
   * @schema ImageBuilderSpecForProvider#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: ImageBuilderSpecForProviderIamRoleArnSelector;

  /**
   * ARN of the public, private, or shared image to use.
   *
   * @schema ImageBuilderSpecForProvider#imageArn
   */
  readonly imageArn?: string;

  /**
   * Instance type to use when launching the image builder.
   *
   * @schema ImageBuilderSpecForProvider#instanceType
   */
  readonly instanceType?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ImageBuilderSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ImageBuilderSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Configuration block for the VPC configuration for the image builder. See below.
   *
   * @schema ImageBuilderSpecForProvider#vpcConfig
   */
  readonly vpcConfig?: ImageBuilderSpecForProviderVpcConfig[];

}

/**
 * Converts an object of type 'ImageBuilderSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecForProvider(obj: ImageBuilderSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessEndpoint': obj.accessEndpoint?.map(y => toJson_ImageBuilderSpecForProviderAccessEndpoint(y)),
    'appstreamAgentVersion': obj.appstreamAgentVersion,
    'description': obj.description,
    'displayName': obj.displayName,
    'domainJoinInfo': obj.domainJoinInfo?.map(y => toJson_ImageBuilderSpecForProviderDomainJoinInfo(y)),
    'enableDefaultInternetAccess': obj.enableDefaultInternetAccess,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_ImageBuilderSpecForProviderIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_ImageBuilderSpecForProviderIamRoleArnSelector(obj.iamRoleArnSelector),
    'imageArn': obj.imageArn,
    'instanceType': obj.instanceType,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcConfig': obj.vpcConfig?.map(y => toJson_ImageBuilderSpecForProviderVpcConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ImageBuilderSpecManagementPolicy
 */
export enum ImageBuilderSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ImageBuilderSpecProviderConfigRef
 */
export interface ImageBuilderSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageBuilderSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageBuilderSpecProviderConfigRef#policy
   */
  readonly policy?: ImageBuilderSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ImageBuilderSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecProviderConfigRef(obj: ImageBuilderSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageBuilderSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ImageBuilderSpecProviderRef
 */
export interface ImageBuilderSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageBuilderSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageBuilderSpecProviderRef#policy
   */
  readonly policy?: ImageBuilderSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ImageBuilderSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecProviderRef(obj: ImageBuilderSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageBuilderSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ImageBuilderSpecPublishConnectionDetailsTo
 */
export interface ImageBuilderSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ImageBuilderSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ImageBuilderSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ImageBuilderSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ImageBuilderSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ImageBuilderSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ImageBuilderSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecPublishConnectionDetailsTo(obj: ImageBuilderSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ImageBuilderSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ImageBuilderSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ImageBuilderSpecWriteConnectionSecretToRef
 */
export interface ImageBuilderSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ImageBuilderSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ImageBuilderSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ImageBuilderSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecWriteConnectionSecretToRef(obj: ImageBuilderSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImageBuilderSpecForProviderAccessEndpoint
 */
export interface ImageBuilderSpecForProviderAccessEndpoint {
  /**
   * Type of interface endpoint.
   *
   * @schema ImageBuilderSpecForProviderAccessEndpoint#endpointType
   */
  readonly endpointType: string;

  /**
   * Identifier (ID) of the VPC in which the interface endpoint is used.
   *
   * @schema ImageBuilderSpecForProviderAccessEndpoint#vpceId
   */
  readonly vpceId?: string;

}

/**
 * Converts an object of type 'ImageBuilderSpecForProviderAccessEndpoint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecForProviderAccessEndpoint(obj: ImageBuilderSpecForProviderAccessEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpointType': obj.endpointType,
    'vpceId': obj.vpceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImageBuilderSpecForProviderDomainJoinInfo
 */
export interface ImageBuilderSpecForProviderDomainJoinInfo {
  /**
   * Fully qualified name of the directory (for example, corp.example.com).
   *
   * @schema ImageBuilderSpecForProviderDomainJoinInfo#directoryName
   */
  readonly directoryName?: string;

  /**
   * Distinguished name of the organizational unit for computer accounts.
   *
   * @schema ImageBuilderSpecForProviderDomainJoinInfo#organizationalUnitDistinguishedName
   */
  readonly organizationalUnitDistinguishedName?: string;

}

/**
 * Converts an object of type 'ImageBuilderSpecForProviderDomainJoinInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecForProviderDomainJoinInfo(obj: ImageBuilderSpecForProviderDomainJoinInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directoryName': obj.directoryName,
    'organizationalUnitDistinguishedName': obj.organizationalUnitDistinguishedName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate iamRoleArn.
 *
 * @schema ImageBuilderSpecForProviderIamRoleArnRef
 */
export interface ImageBuilderSpecForProviderIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageBuilderSpecForProviderIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageBuilderSpecForProviderIamRoleArnRef#policy
   */
  readonly policy?: ImageBuilderSpecForProviderIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ImageBuilderSpecForProviderIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecForProviderIamRoleArnRef(obj: ImageBuilderSpecForProviderIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageBuilderSpecForProviderIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate iamRoleArn.
 *
 * @schema ImageBuilderSpecForProviderIamRoleArnSelector
 */
export interface ImageBuilderSpecForProviderIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ImageBuilderSpecForProviderIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ImageBuilderSpecForProviderIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ImageBuilderSpecForProviderIamRoleArnSelector#policy
   */
  readonly policy?: ImageBuilderSpecForProviderIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ImageBuilderSpecForProviderIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecForProviderIamRoleArnSelector(obj: ImageBuilderSpecForProviderIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ImageBuilderSpecForProviderIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ImageBuilderSpecForProviderVpcConfig
 */
export interface ImageBuilderSpecForProviderVpcConfig {
  /**
   * Identifiers of the security groups for the image builder or image builder.
   *
   * @schema ImageBuilderSpecForProviderVpcConfig#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema ImageBuilderSpecForProviderVpcConfig#subnetIdRefs
   */
  readonly subnetIdRefs?: ImageBuilderSpecForProviderVpcConfigSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema ImageBuilderSpecForProviderVpcConfig#subnetIdSelector
   */
  readonly subnetIdSelector?: ImageBuilderSpecForProviderVpcConfigSubnetIdSelector;

  /**
   * Identifiers of the subnets to which a network interface is attached from the image builder instance or image builder instance.
   *
   * @schema ImageBuilderSpecForProviderVpcConfig#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'ImageBuilderSpecForProviderVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecForProviderVpcConfig(obj: ImageBuilderSpecForProviderVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_ImageBuilderSpecForProviderVpcConfigSubnetIdRefs(y)),
    'subnetIdSelector': toJson_ImageBuilderSpecForProviderVpcConfigSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ImageBuilderSpecProviderConfigRefPolicy
 */
export interface ImageBuilderSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageBuilderSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ImageBuilderSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageBuilderSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ImageBuilderSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageBuilderSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecProviderConfigRefPolicy(obj: ImageBuilderSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ImageBuilderSpecProviderRefPolicy
 */
export interface ImageBuilderSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageBuilderSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ImageBuilderSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageBuilderSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ImageBuilderSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageBuilderSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecProviderRefPolicy(obj: ImageBuilderSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ImageBuilderSpecPublishConnectionDetailsToConfigRef
 */
export interface ImageBuilderSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ImageBuilderSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageBuilderSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ImageBuilderSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ImageBuilderSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecPublishConnectionDetailsToConfigRef(obj: ImageBuilderSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageBuilderSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ImageBuilderSpecPublishConnectionDetailsToMetadata
 */
export interface ImageBuilderSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ImageBuilderSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ImageBuilderSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ImageBuilderSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ImageBuilderSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecPublishConnectionDetailsToMetadata(obj: ImageBuilderSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ImageBuilderSpecForProviderIamRoleArnRefPolicy
 */
export interface ImageBuilderSpecForProviderIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageBuilderSpecForProviderIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: ImageBuilderSpecForProviderIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageBuilderSpecForProviderIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: ImageBuilderSpecForProviderIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageBuilderSpecForProviderIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecForProviderIamRoleArnRefPolicy(obj: ImageBuilderSpecForProviderIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ImageBuilderSpecForProviderIamRoleArnSelectorPolicy
 */
export interface ImageBuilderSpecForProviderIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageBuilderSpecForProviderIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ImageBuilderSpecForProviderIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageBuilderSpecForProviderIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ImageBuilderSpecForProviderIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ImageBuilderSpecForProviderIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecForProviderIamRoleArnSelectorPolicy(obj: ImageBuilderSpecForProviderIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ImageBuilderSpecForProviderVpcConfigSubnetIdRefs
 */
export interface ImageBuilderSpecForProviderVpcConfigSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ImageBuilderSpecForProviderVpcConfigSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ImageBuilderSpecForProviderVpcConfigSubnetIdRefs#policy
   */
  readonly policy?: ImageBuilderSpecForProviderVpcConfigSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'ImageBuilderSpecForProviderVpcConfigSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecForProviderVpcConfigSubnetIdRefs(obj: ImageBuilderSpecForProviderVpcConfigSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ImageBuilderSpecForProviderVpcConfigSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema ImageBuilderSpecForProviderVpcConfigSubnetIdSelector
 */
export interface ImageBuilderSpecForProviderVpcConfigSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ImageBuilderSpecForProviderVpcConfigSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ImageBuilderSpecForProviderVpcConfigSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ImageBuilderSpecForProviderVpcConfigSubnetIdSelector#policy
   */
  readonly policy?: ImageBuilderSpecForProviderVpcConfigSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'ImageBuilderSpecForProviderVpcConfigSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecForProviderVpcConfigSubnetIdSelector(obj: ImageBuilderSpecForProviderVpcConfigSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ImageBuilderSpecForProviderVpcConfigSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageBuilderSpecProviderConfigRefPolicyResolution
 */
export enum ImageBuilderSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageBuilderSpecProviderConfigRefPolicyResolve
 */
export enum ImageBuilderSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageBuilderSpecProviderRefPolicyResolution
 */
export enum ImageBuilderSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageBuilderSpecProviderRefPolicyResolve
 */
export enum ImageBuilderSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ImageBuilderSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ImageBuilderSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageBuilderSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ImageBuilderSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageBuilderSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ImageBuilderSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ImageBuilderSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecPublishConnectionDetailsToConfigRefPolicy(obj: ImageBuilderSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageBuilderSpecForProviderIamRoleArnRefPolicyResolution
 */
export enum ImageBuilderSpecForProviderIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageBuilderSpecForProviderIamRoleArnRefPolicyResolve
 */
export enum ImageBuilderSpecForProviderIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageBuilderSpecForProviderIamRoleArnSelectorPolicyResolution
 */
export enum ImageBuilderSpecForProviderIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageBuilderSpecForProviderIamRoleArnSelectorPolicyResolve
 */
export enum ImageBuilderSpecForProviderIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ImageBuilderSpecForProviderVpcConfigSubnetIdRefsPolicy
 */
export interface ImageBuilderSpecForProviderVpcConfigSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageBuilderSpecForProviderVpcConfigSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: ImageBuilderSpecForProviderVpcConfigSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageBuilderSpecForProviderVpcConfigSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: ImageBuilderSpecForProviderVpcConfigSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ImageBuilderSpecForProviderVpcConfigSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecForProviderVpcConfigSubnetIdRefsPolicy(obj: ImageBuilderSpecForProviderVpcConfigSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ImageBuilderSpecForProviderVpcConfigSubnetIdSelectorPolicy
 */
export interface ImageBuilderSpecForProviderVpcConfigSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ImageBuilderSpecForProviderVpcConfigSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: ImageBuilderSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ImageBuilderSpecForProviderVpcConfigSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: ImageBuilderSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ImageBuilderSpecForProviderVpcConfigSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageBuilderSpecForProviderVpcConfigSubnetIdSelectorPolicy(obj: ImageBuilderSpecForProviderVpcConfigSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageBuilderSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ImageBuilderSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageBuilderSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ImageBuilderSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageBuilderSpecForProviderVpcConfigSubnetIdRefsPolicyResolution
 */
export enum ImageBuilderSpecForProviderVpcConfigSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageBuilderSpecForProviderVpcConfigSubnetIdRefsPolicyResolve
 */
export enum ImageBuilderSpecForProviderVpcConfigSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ImageBuilderSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution
 */
export enum ImageBuilderSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ImageBuilderSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve
 */
export enum ImageBuilderSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Stack is the Schema for the Stacks API. Provides an AppStream stack
 *
 * @schema Stack
 */
export class Stack extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Stack"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appstream.aws.upbound.io/v1beta1',
    kind: 'Stack',
  }

  /**
   * Renders a Kubernetes manifest for "Stack".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StackProps): any {
    return {
      ...Stack.GVK,
      ...toJson_StackProps(props),
    };
  }

  /**
   * Defines a "Stack" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StackProps) {
    super(scope, id, {
      ...Stack.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Stack.GVK,
      ...toJson_StackProps(resolved),
    };
  }
}

/**
 * Stack is the Schema for the Stacks API. Provides an AppStream stack
 *
 * @schema Stack
 */
export interface StackProps {
  /**
   * @schema Stack#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StackSpec defines the desired state of Stack
   *
   * @schema Stack#spec
   */
  readonly spec: StackSpec;

}

/**
 * Converts an object of type 'StackProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackProps(obj: StackProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StackSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StackSpec defines the desired state of Stack
 *
 * @schema StackSpec
 */
export interface StackSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StackSpec#deletionPolicy
   */
  readonly deletionPolicy?: StackSpecDeletionPolicy;

  /**
   * @schema StackSpec#forProvider
   */
  readonly forProvider: StackSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StackSpec#managementPolicy
   */
  readonly managementPolicy?: StackSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StackSpec#providerConfigRef
   */
  readonly providerConfigRef?: StackSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema StackSpec#providerRef
   */
  readonly providerRef?: StackSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StackSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StackSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StackSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StackSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StackSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpec(obj: StackSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StackSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_StackSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_StackSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_StackSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StackSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StackSpecDeletionPolicy
 */
export enum StackSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StackSpecForProvider
 */
export interface StackSpecForProvider {
  /**
   * Set of configuration blocks defining the interface VPC endpoints. Users of the stack can connect to AppStream 2.0 only through the specified endpoints. See access_endpoints below.
   *
   * @schema StackSpecForProvider#accessEndpoints
   */
  readonly accessEndpoints?: StackSpecForProviderAccessEndpoints[];

  /**
   * Settings for application settings persistence. See application_settings below.
   *
   * @schema StackSpecForProvider#applicationSettings
   */
  readonly applicationSettings?: StackSpecForProviderApplicationSettings[];

  /**
   * Description for the AppStream stack.
   *
   * @schema StackSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Stack name to display.
   *
   * @schema StackSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Domains where AppStream 2.0 streaming sessions can be embedded in an iframe. You must approve the domains that you want to host embedded AppStream 2.0 streaming sessions.
   *
   * @schema StackSpecForProvider#embedHostDomains
   */
  readonly embedHostDomains?: string[];

  /**
   * URL that users are redirected to after they click the Send Feedback link. If no URL is specified, no Send Feedback link is displayed. .
   *
   * @schema StackSpecForProvider#feedbackUrl
   */
  readonly feedbackUrl?: string;

  /**
   * Unique name for the AppStream stack.
   *
   * @schema StackSpecForProvider#name
   */
  readonly name?: string;

  /**
   * URL that users are redirected to after their streaming session ends.
   *
   * @schema StackSpecForProvider#redirectUrl
   */
  readonly redirectUrl?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema StackSpecForProvider#region
   */
  readonly region: string;

  /**
   * Configuration block for the storage connectors to enable. See storage_connectors below.
   *
   * @schema StackSpecForProvider#storageConnectors
   */
  readonly storageConnectors?: StackSpecForProviderStorageConnectors[];

  /**
   * The streaming protocol you want your stack to prefer. This can be UDP or TCP. Currently, UDP is only supported in the Windows native client. See streaming_experience_settings below.
   *
   * @schema StackSpecForProvider#streamingExperienceSettings
   */
  readonly streamingExperienceSettings?: StackSpecForProviderStreamingExperienceSettings[];

  /**
   * Key-value map of resource tags.
   *
   * @schema StackSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Configuration block for the actions that are enabled or disabled for users during their streaming sessions. If not provided, these settings are configured automatically by AWS. See user_settings below.
   *
   * @schema StackSpecForProvider#userSettings
   */
  readonly userSettings?: StackSpecForProviderUserSettings[];

}

/**
 * Converts an object of type 'StackSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProvider(obj: StackSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessEndpoints': obj.accessEndpoints?.map(y => toJson_StackSpecForProviderAccessEndpoints(y)),
    'applicationSettings': obj.applicationSettings?.map(y => toJson_StackSpecForProviderApplicationSettings(y)),
    'description': obj.description,
    'displayName': obj.displayName,
    'embedHostDomains': obj.embedHostDomains?.map(y => y),
    'feedbackUrl': obj.feedbackUrl,
    'name': obj.name,
    'redirectUrl': obj.redirectUrl,
    'region': obj.region,
    'storageConnectors': obj.storageConnectors?.map(y => toJson_StackSpecForProviderStorageConnectors(y)),
    'streamingExperienceSettings': obj.streamingExperienceSettings?.map(y => toJson_StackSpecForProviderStreamingExperienceSettings(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'userSettings': obj.userSettings?.map(y => toJson_StackSpecForProviderUserSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StackSpecManagementPolicy
 */
export enum StackSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StackSpecProviderConfigRef
 */
export interface StackSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecProviderConfigRef#policy
   */
  readonly policy?: StackSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecProviderConfigRef(obj: StackSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema StackSpecProviderRef
 */
export interface StackSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecProviderRef#policy
   */
  readonly policy?: StackSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'StackSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecProviderRef(obj: StackSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StackSpecPublishConnectionDetailsTo
 */
export interface StackSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StackSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StackSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StackSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StackSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StackSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StackSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecPublishConnectionDetailsTo(obj: StackSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StackSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StackSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StackSpecWriteConnectionSecretToRef
 */
export interface StackSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StackSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StackSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StackSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecWriteConnectionSecretToRef(obj: StackSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSpecForProviderAccessEndpoints
 */
export interface StackSpecForProviderAccessEndpoints {
  /**
   * Type of the interface endpoint. See the AccessEndpoint AWS API documentation for valid values.
   *
   * @schema StackSpecForProviderAccessEndpoints#endpointType
   */
  readonly endpointType: string;

  /**
   * ID of the VPC in which the interface endpoint is used.
   *
   * @schema StackSpecForProviderAccessEndpoints#vpceId
   */
  readonly vpceId?: string;

}

/**
 * Converts an object of type 'StackSpecForProviderAccessEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderAccessEndpoints(obj: StackSpecForProviderAccessEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpointType': obj.endpointType,
    'vpceId': obj.vpceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSpecForProviderApplicationSettings
 */
export interface StackSpecForProviderApplicationSettings {
  /**
   * Whether application settings should be persisted.
   *
   * @schema StackSpecForProviderApplicationSettings#enabled
   */
  readonly enabled: boolean;

  /**
   * Name of the settings group. Required when enabled is true. Can be up to 100 characters.
   *
   * @schema StackSpecForProviderApplicationSettings#settingsGroup
   */
  readonly settingsGroup?: string;

}

/**
 * Converts an object of type 'StackSpecForProviderApplicationSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderApplicationSettings(obj: StackSpecForProviderApplicationSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'settingsGroup': obj.settingsGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSpecForProviderStorageConnectors
 */
export interface StackSpecForProviderStorageConnectors {
  /**
   * Type of storage connector. Valid values are HOMEFOLDERS, GOOGLE_DRIVE, or ONE_DRIVE.
   *
   * @schema StackSpecForProviderStorageConnectors#connectorType
   */
  readonly connectorType: string;

  /**
   * Names of the domains for the account.
   *
   * @schema StackSpecForProviderStorageConnectors#domains
   */
  readonly domains?: string[];

  /**
   * ARN of the storage connector.
   *
   * @schema StackSpecForProviderStorageConnectors#resourceIdentifier
   */
  readonly resourceIdentifier?: string;

}

/**
 * Converts an object of type 'StackSpecForProviderStorageConnectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderStorageConnectors(obj: StackSpecForProviderStorageConnectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectorType': obj.connectorType,
    'domains': obj.domains?.map(y => y),
    'resourceIdentifier': obj.resourceIdentifier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSpecForProviderStreamingExperienceSettings
 */
export interface StackSpecForProviderStreamingExperienceSettings {
  /**
   * The preferred protocol that you want to use while streaming your application. Valid values are TCP and UDP.
   *
   * @schema StackSpecForProviderStreamingExperienceSettings#preferredProtocol
   */
  readonly preferredProtocol?: string;

}

/**
 * Converts an object of type 'StackSpecForProviderStreamingExperienceSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderStreamingExperienceSettings(obj: StackSpecForProviderStreamingExperienceSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredProtocol': obj.preferredProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSpecForProviderUserSettings
 */
export interface StackSpecForProviderUserSettings {
  /**
   * Action that is enabled or disabled. Valid values are CLIPBOARD_COPY_FROM_LOCAL_DEVICE,  CLIPBOARD_COPY_TO_LOCAL_DEVICE, FILE_UPLOAD, FILE_DOWNLOAD, PRINTING_TO_LOCAL_DEVICE, DOMAIN_PASSWORD_SIGNIN, or DOMAIN_SMART_CARD_SIGNIN.
   *
   * @schema StackSpecForProviderUserSettings#action
   */
  readonly action: string;

  /**
   * Whether the action is enabled or disabled. Valid values are ENABLED or DISABLED.
   *
   * @schema StackSpecForProviderUserSettings#permission
   */
  readonly permission: string;

}

/**
 * Converts an object of type 'StackSpecForProviderUserSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderUserSettings(obj: StackSpecForProviderUserSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'permission': obj.permission,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSpecProviderConfigRefPolicy
 */
export interface StackSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StackSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StackSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecProviderConfigRefPolicy(obj: StackSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSpecProviderRefPolicy
 */
export interface StackSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecProviderRefPolicy#resolution
   */
  readonly resolution?: StackSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecProviderRefPolicy#resolve
   */
  readonly resolve?: StackSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecProviderRefPolicy(obj: StackSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StackSpecPublishConnectionDetailsToConfigRef
 */
export interface StackSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StackSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecPublishConnectionDetailsToConfigRef(obj: StackSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StackSpecPublishConnectionDetailsToMetadata
 */
export interface StackSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StackSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StackSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecPublishConnectionDetailsToMetadata(obj: StackSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecProviderConfigRefPolicyResolution
 */
export enum StackSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecProviderConfigRefPolicyResolve
 */
export enum StackSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecProviderRefPolicyResolution
 */
export enum StackSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecProviderRefPolicyResolve
 */
export enum StackSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StackSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StackSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StackSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StackSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StackSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StackSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecPublishConnectionDetailsToConfigRefPolicy(obj: StackSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StackSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StackSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StackSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StackSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * User is the Schema for the Users API. Provides an AppStream user
 *
 * @schema User
 */
export class User extends ApiObject {
  /**
   * Returns the apiVersion and kind for "User"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appstream.aws.upbound.io/v1beta1',
    kind: 'User',
  }

  /**
   * Renders a Kubernetes manifest for "User".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserProps): any {
    return {
      ...User.GVK,
      ...toJson_UserProps(props),
    };
  }

  /**
   * Defines a "User" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserProps) {
    super(scope, id, {
      ...User.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...User.GVK,
      ...toJson_UserProps(resolved),
    };
  }
}

/**
 * User is the Schema for the Users API. Provides an AppStream user
 *
 * @schema User
 */
export interface UserProps {
  /**
   * @schema User#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserSpec defines the desired state of User
   *
   * @schema User#spec
   */
  readonly spec: UserSpec;

}

/**
 * Converts an object of type 'UserProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProps(obj: UserProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserSpec defines the desired state of User
 *
 * @schema UserSpec
 */
export interface UserSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserSpecDeletionPolicy;

  /**
   * @schema UserSpec#forProvider
   */
  readonly forProvider: UserSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserSpec#managementPolicy
   */
  readonly managementPolicy?: UserSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema UserSpec#providerRef
   */
  readonly providerRef?: UserSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpec(obj: UserSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_UserSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_UserSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_UserSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserSpecDeletionPolicy
 */
export enum UserSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserSpecForProvider
 */
export interface UserSpecForProvider {
  /**
   * Authentication type for the user. You must specify USERPOOL. Valid values: API, SAML, USERPOOL
   *
   * @schema UserSpecForProvider#authenticationType
   */
  readonly authenticationType: string;

  /**
   * Whether the user in the user pool is enabled.
   *
   * @schema UserSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * First name, or given name, of the user.
   *
   * @schema UserSpecForProvider#firstName
   */
  readonly firstName?: string;

  /**
   * Last name, or surname, of the user.
   *
   * @schema UserSpecForProvider#lastName
   */
  readonly lastName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UserSpecForProvider#region
   */
  readonly region: string;

  /**
   * Send an email notification.
   *
   * @schema UserSpecForProvider#sendEmailNotification
   */
  readonly sendEmailNotification?: boolean;

}

/**
 * Converts an object of type 'UserSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProvider(obj: UserSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticationType': obj.authenticationType,
    'enabled': obj.enabled,
    'firstName': obj.firstName,
    'lastName': obj.lastName,
    'region': obj.region,
    'sendEmailNotification': obj.sendEmailNotification,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserSpecManagementPolicy
 */
export enum UserSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserSpecProviderConfigRef
 */
export interface UserSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecProviderConfigRef#policy
   */
  readonly policy?: UserSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderConfigRef(obj: UserSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema UserSpecProviderRef
 */
export interface UserSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecProviderRef#policy
   */
  readonly policy?: UserSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'UserSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderRef(obj: UserSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserSpecPublishConnectionDetailsTo
 */
export interface UserSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsTo(obj: UserSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserSpecWriteConnectionSecretToRef
 */
export interface UserSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecWriteConnectionSecretToRef(obj: UserSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecProviderConfigRefPolicy
 */
export interface UserSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderConfigRefPolicy(obj: UserSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecProviderRefPolicy
 */
export interface UserSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecProviderRefPolicy#resolution
   */
  readonly resolution?: UserSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecProviderRefPolicy#resolve
   */
  readonly resolve?: UserSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderRefPolicy(obj: UserSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRef
 */
export interface UserSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToConfigRef(obj: UserSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserSpecPublishConnectionDetailsToMetadata
 */
export interface UserSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToMetadata(obj: UserSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecProviderConfigRefPolicyResolution
 */
export enum UserSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecProviderConfigRefPolicyResolve
 */
export enum UserSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecProviderRefPolicyResolution
 */
export enum UserSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecProviderRefPolicyResolve
 */
export enum UserSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UserStackAssociation is the Schema for the UserStackAssociations API. Manages an AppStream User Stack association.
 *
 * @schema UserStackAssociation
 */
export class UserStackAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UserStackAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appstream.aws.upbound.io/v1beta1',
    kind: 'UserStackAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "UserStackAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserStackAssociationProps): any {
    return {
      ...UserStackAssociation.GVK,
      ...toJson_UserStackAssociationProps(props),
    };
  }

  /**
   * Defines a "UserStackAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserStackAssociationProps) {
    super(scope, id, {
      ...UserStackAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UserStackAssociation.GVK,
      ...toJson_UserStackAssociationProps(resolved),
    };
  }
}

/**
 * UserStackAssociation is the Schema for the UserStackAssociations API. Manages an AppStream User Stack association.
 *
 * @schema UserStackAssociation
 */
export interface UserStackAssociationProps {
  /**
   * @schema UserStackAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserStackAssociationSpec defines the desired state of UserStackAssociation
   *
   * @schema UserStackAssociation#spec
   */
  readonly spec: UserStackAssociationSpec;

}

/**
 * Converts an object of type 'UserStackAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationProps(obj: UserStackAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserStackAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserStackAssociationSpec defines the desired state of UserStackAssociation
 *
 * @schema UserStackAssociationSpec
 */
export interface UserStackAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserStackAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserStackAssociationSpecDeletionPolicy;

  /**
   * @schema UserStackAssociationSpec#forProvider
   */
  readonly forProvider: UserStackAssociationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserStackAssociationSpec#managementPolicy
   */
  readonly managementPolicy?: UserStackAssociationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserStackAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserStackAssociationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema UserStackAssociationSpec#providerRef
   */
  readonly providerRef?: UserStackAssociationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserStackAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserStackAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserStackAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserStackAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserStackAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpec(obj: UserStackAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserStackAssociationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_UserStackAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_UserStackAssociationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_UserStackAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserStackAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserStackAssociationSpecDeletionPolicy
 */
export enum UserStackAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserStackAssociationSpecForProvider
 */
export interface UserStackAssociationSpecForProvider {
  /**
   * Authentication type for the user.
   *
   * @schema UserStackAssociationSpecForProvider#authenticationType
   */
  readonly authenticationType?: string;

  /**
   * Reference to a User in appstream to populate authenticationType.
   *
   * @schema UserStackAssociationSpecForProvider#authenticationTypeRef
   */
  readonly authenticationTypeRef?: UserStackAssociationSpecForProviderAuthenticationTypeRef;

  /**
   * Selector for a User in appstream to populate authenticationType.
   *
   * @schema UserStackAssociationSpecForProvider#authenticationTypeSelector
   */
  readonly authenticationTypeSelector?: UserStackAssociationSpecForProviderAuthenticationTypeSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UserStackAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Whether a welcome email is sent to a user after the user is created in the user pool.
   *
   * @schema UserStackAssociationSpecForProvider#sendEmailNotification
   */
  readonly sendEmailNotification?: boolean;

  /**
   * Name of the stack that is associated with the user.
   *
   * @schema UserStackAssociationSpecForProvider#stackName
   */
  readonly stackName?: string;

  /**
   * Reference to a Stack in appstream to populate stackName.
   *
   * @schema UserStackAssociationSpecForProvider#stackNameRef
   */
  readonly stackNameRef?: UserStackAssociationSpecForProviderStackNameRef;

  /**
   * Selector for a Stack in appstream to populate stackName.
   *
   * @schema UserStackAssociationSpecForProvider#stackNameSelector
   */
  readonly stackNameSelector?: UserStackAssociationSpecForProviderStackNameSelector;

  /**
   * Email address of the user who is associated with the stack.
   *
   * @schema UserStackAssociationSpecForProvider#userName
   */
  readonly userName?: string;

  /**
   * Reference to a User in appstream to populate userName.
   *
   * @schema UserStackAssociationSpecForProvider#userNameRef
   */
  readonly userNameRef?: UserStackAssociationSpecForProviderUserNameRef;

  /**
   * Selector for a User in appstream to populate userName.
   *
   * @schema UserStackAssociationSpecForProvider#userNameSelector
   */
  readonly userNameSelector?: UserStackAssociationSpecForProviderUserNameSelector;

}

/**
 * Converts an object of type 'UserStackAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecForProvider(obj: UserStackAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticationType': obj.authenticationType,
    'authenticationTypeRef': toJson_UserStackAssociationSpecForProviderAuthenticationTypeRef(obj.authenticationTypeRef),
    'authenticationTypeSelector': toJson_UserStackAssociationSpecForProviderAuthenticationTypeSelector(obj.authenticationTypeSelector),
    'region': obj.region,
    'sendEmailNotification': obj.sendEmailNotification,
    'stackName': obj.stackName,
    'stackNameRef': toJson_UserStackAssociationSpecForProviderStackNameRef(obj.stackNameRef),
    'stackNameSelector': toJson_UserStackAssociationSpecForProviderStackNameSelector(obj.stackNameSelector),
    'userName': obj.userName,
    'userNameRef': toJson_UserStackAssociationSpecForProviderUserNameRef(obj.userNameRef),
    'userNameSelector': toJson_UserStackAssociationSpecForProviderUserNameSelector(obj.userNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserStackAssociationSpecManagementPolicy
 */
export enum UserStackAssociationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserStackAssociationSpecProviderConfigRef
 */
export interface UserStackAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserStackAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserStackAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: UserStackAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserStackAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecProviderConfigRef(obj: UserStackAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserStackAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema UserStackAssociationSpecProviderRef
 */
export interface UserStackAssociationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserStackAssociationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserStackAssociationSpecProviderRef#policy
   */
  readonly policy?: UserStackAssociationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'UserStackAssociationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecProviderRef(obj: UserStackAssociationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserStackAssociationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserStackAssociationSpecPublishConnectionDetailsTo
 */
export interface UserStackAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserStackAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserStackAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserStackAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserStackAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserStackAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserStackAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecPublishConnectionDetailsTo(obj: UserStackAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserStackAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserStackAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserStackAssociationSpecWriteConnectionSecretToRef
 */
export interface UserStackAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserStackAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserStackAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserStackAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecWriteConnectionSecretToRef(obj: UserStackAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a User in appstream to populate authenticationType.
 *
 * @schema UserStackAssociationSpecForProviderAuthenticationTypeRef
 */
export interface UserStackAssociationSpecForProviderAuthenticationTypeRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserStackAssociationSpecForProviderAuthenticationTypeRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserStackAssociationSpecForProviderAuthenticationTypeRef#policy
   */
  readonly policy?: UserStackAssociationSpecForProviderAuthenticationTypeRefPolicy;

}

/**
 * Converts an object of type 'UserStackAssociationSpecForProviderAuthenticationTypeRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecForProviderAuthenticationTypeRef(obj: UserStackAssociationSpecForProviderAuthenticationTypeRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserStackAssociationSpecForProviderAuthenticationTypeRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a User in appstream to populate authenticationType.
 *
 * @schema UserStackAssociationSpecForProviderAuthenticationTypeSelector
 */
export interface UserStackAssociationSpecForProviderAuthenticationTypeSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserStackAssociationSpecForProviderAuthenticationTypeSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserStackAssociationSpecForProviderAuthenticationTypeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserStackAssociationSpecForProviderAuthenticationTypeSelector#policy
   */
  readonly policy?: UserStackAssociationSpecForProviderAuthenticationTypeSelectorPolicy;

}

/**
 * Converts an object of type 'UserStackAssociationSpecForProviderAuthenticationTypeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecForProviderAuthenticationTypeSelector(obj: UserStackAssociationSpecForProviderAuthenticationTypeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserStackAssociationSpecForProviderAuthenticationTypeSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stack in appstream to populate stackName.
 *
 * @schema UserStackAssociationSpecForProviderStackNameRef
 */
export interface UserStackAssociationSpecForProviderStackNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserStackAssociationSpecForProviderStackNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserStackAssociationSpecForProviderStackNameRef#policy
   */
  readonly policy?: UserStackAssociationSpecForProviderStackNameRefPolicy;

}

/**
 * Converts an object of type 'UserStackAssociationSpecForProviderStackNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecForProviderStackNameRef(obj: UserStackAssociationSpecForProviderStackNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserStackAssociationSpecForProviderStackNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stack in appstream to populate stackName.
 *
 * @schema UserStackAssociationSpecForProviderStackNameSelector
 */
export interface UserStackAssociationSpecForProviderStackNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserStackAssociationSpecForProviderStackNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserStackAssociationSpecForProviderStackNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserStackAssociationSpecForProviderStackNameSelector#policy
   */
  readonly policy?: UserStackAssociationSpecForProviderStackNameSelectorPolicy;

}

/**
 * Converts an object of type 'UserStackAssociationSpecForProviderStackNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecForProviderStackNameSelector(obj: UserStackAssociationSpecForProviderStackNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserStackAssociationSpecForProviderStackNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a User in appstream to populate userName.
 *
 * @schema UserStackAssociationSpecForProviderUserNameRef
 */
export interface UserStackAssociationSpecForProviderUserNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserStackAssociationSpecForProviderUserNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserStackAssociationSpecForProviderUserNameRef#policy
   */
  readonly policy?: UserStackAssociationSpecForProviderUserNameRefPolicy;

}

/**
 * Converts an object of type 'UserStackAssociationSpecForProviderUserNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecForProviderUserNameRef(obj: UserStackAssociationSpecForProviderUserNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserStackAssociationSpecForProviderUserNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a User in appstream to populate userName.
 *
 * @schema UserStackAssociationSpecForProviderUserNameSelector
 */
export interface UserStackAssociationSpecForProviderUserNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserStackAssociationSpecForProviderUserNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserStackAssociationSpecForProviderUserNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserStackAssociationSpecForProviderUserNameSelector#policy
   */
  readonly policy?: UserStackAssociationSpecForProviderUserNameSelectorPolicy;

}

/**
 * Converts an object of type 'UserStackAssociationSpecForProviderUserNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecForProviderUserNameSelector(obj: UserStackAssociationSpecForProviderUserNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserStackAssociationSpecForProviderUserNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserStackAssociationSpecProviderConfigRefPolicy
 */
export interface UserStackAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserStackAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserStackAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserStackAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserStackAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserStackAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecProviderConfigRefPolicy(obj: UserStackAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserStackAssociationSpecProviderRefPolicy
 */
export interface UserStackAssociationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserStackAssociationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: UserStackAssociationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserStackAssociationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: UserStackAssociationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'UserStackAssociationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecProviderRefPolicy(obj: UserStackAssociationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserStackAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface UserStackAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserStackAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserStackAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserStackAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecPublishConnectionDetailsToConfigRef(obj: UserStackAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserStackAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface UserStackAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserStackAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserStackAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserStackAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserStackAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecPublishConnectionDetailsToMetadata(obj: UserStackAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserStackAssociationSpecForProviderAuthenticationTypeRefPolicy
 */
export interface UserStackAssociationSpecForProviderAuthenticationTypeRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserStackAssociationSpecForProviderAuthenticationTypeRefPolicy#resolution
   */
  readonly resolution?: UserStackAssociationSpecForProviderAuthenticationTypeRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserStackAssociationSpecForProviderAuthenticationTypeRefPolicy#resolve
   */
  readonly resolve?: UserStackAssociationSpecForProviderAuthenticationTypeRefPolicyResolve;

}

/**
 * Converts an object of type 'UserStackAssociationSpecForProviderAuthenticationTypeRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecForProviderAuthenticationTypeRefPolicy(obj: UserStackAssociationSpecForProviderAuthenticationTypeRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserStackAssociationSpecForProviderAuthenticationTypeSelectorPolicy
 */
export interface UserStackAssociationSpecForProviderAuthenticationTypeSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserStackAssociationSpecForProviderAuthenticationTypeSelectorPolicy#resolution
   */
  readonly resolution?: UserStackAssociationSpecForProviderAuthenticationTypeSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserStackAssociationSpecForProviderAuthenticationTypeSelectorPolicy#resolve
   */
  readonly resolve?: UserStackAssociationSpecForProviderAuthenticationTypeSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserStackAssociationSpecForProviderAuthenticationTypeSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecForProviderAuthenticationTypeSelectorPolicy(obj: UserStackAssociationSpecForProviderAuthenticationTypeSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserStackAssociationSpecForProviderStackNameRefPolicy
 */
export interface UserStackAssociationSpecForProviderStackNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserStackAssociationSpecForProviderStackNameRefPolicy#resolution
   */
  readonly resolution?: UserStackAssociationSpecForProviderStackNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserStackAssociationSpecForProviderStackNameRefPolicy#resolve
   */
  readonly resolve?: UserStackAssociationSpecForProviderStackNameRefPolicyResolve;

}

/**
 * Converts an object of type 'UserStackAssociationSpecForProviderStackNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecForProviderStackNameRefPolicy(obj: UserStackAssociationSpecForProviderStackNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserStackAssociationSpecForProviderStackNameSelectorPolicy
 */
export interface UserStackAssociationSpecForProviderStackNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserStackAssociationSpecForProviderStackNameSelectorPolicy#resolution
   */
  readonly resolution?: UserStackAssociationSpecForProviderStackNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserStackAssociationSpecForProviderStackNameSelectorPolicy#resolve
   */
  readonly resolve?: UserStackAssociationSpecForProviderStackNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserStackAssociationSpecForProviderStackNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecForProviderStackNameSelectorPolicy(obj: UserStackAssociationSpecForProviderStackNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserStackAssociationSpecForProviderUserNameRefPolicy
 */
export interface UserStackAssociationSpecForProviderUserNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserStackAssociationSpecForProviderUserNameRefPolicy#resolution
   */
  readonly resolution?: UserStackAssociationSpecForProviderUserNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserStackAssociationSpecForProviderUserNameRefPolicy#resolve
   */
  readonly resolve?: UserStackAssociationSpecForProviderUserNameRefPolicyResolve;

}

/**
 * Converts an object of type 'UserStackAssociationSpecForProviderUserNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecForProviderUserNameRefPolicy(obj: UserStackAssociationSpecForProviderUserNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserStackAssociationSpecForProviderUserNameSelectorPolicy
 */
export interface UserStackAssociationSpecForProviderUserNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserStackAssociationSpecForProviderUserNameSelectorPolicy#resolution
   */
  readonly resolution?: UserStackAssociationSpecForProviderUserNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserStackAssociationSpecForProviderUserNameSelectorPolicy#resolve
   */
  readonly resolve?: UserStackAssociationSpecForProviderUserNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserStackAssociationSpecForProviderUserNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecForProviderUserNameSelectorPolicy(obj: UserStackAssociationSpecForProviderUserNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserStackAssociationSpecProviderConfigRefPolicyResolution
 */
export enum UserStackAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserStackAssociationSpecProviderConfigRefPolicyResolve
 */
export enum UserStackAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserStackAssociationSpecProviderRefPolicyResolution
 */
export enum UserStackAssociationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserStackAssociationSpecProviderRefPolicyResolve
 */
export enum UserStackAssociationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserStackAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserStackAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserStackAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserStackAssociationSpecForProviderAuthenticationTypeRefPolicyResolution
 */
export enum UserStackAssociationSpecForProviderAuthenticationTypeRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserStackAssociationSpecForProviderAuthenticationTypeRefPolicyResolve
 */
export enum UserStackAssociationSpecForProviderAuthenticationTypeRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserStackAssociationSpecForProviderAuthenticationTypeSelectorPolicyResolution
 */
export enum UserStackAssociationSpecForProviderAuthenticationTypeSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserStackAssociationSpecForProviderAuthenticationTypeSelectorPolicyResolve
 */
export enum UserStackAssociationSpecForProviderAuthenticationTypeSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserStackAssociationSpecForProviderStackNameRefPolicyResolution
 */
export enum UserStackAssociationSpecForProviderStackNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserStackAssociationSpecForProviderStackNameRefPolicyResolve
 */
export enum UserStackAssociationSpecForProviderStackNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserStackAssociationSpecForProviderStackNameSelectorPolicyResolution
 */
export enum UserStackAssociationSpecForProviderStackNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserStackAssociationSpecForProviderStackNameSelectorPolicyResolve
 */
export enum UserStackAssociationSpecForProviderStackNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserStackAssociationSpecForProviderUserNameRefPolicyResolution
 */
export enum UserStackAssociationSpecForProviderUserNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserStackAssociationSpecForProviderUserNameRefPolicyResolve
 */
export enum UserStackAssociationSpecForProviderUserNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserStackAssociationSpecForProviderUserNameSelectorPolicyResolution
 */
export enum UserStackAssociationSpecForProviderUserNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserStackAssociationSpecForProviderUserNameSelectorPolicyResolve
 */
export enum UserStackAssociationSpecForProviderUserNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserStackAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserStackAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserStackAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserStackAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

