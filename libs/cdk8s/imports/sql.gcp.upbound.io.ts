// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Database is the Schema for the Databases API. Represents a SQL database inside the Cloud SQL instance, hosted in Google's cloud.
 *
 * @schema Database
 */
export class Database extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Database"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sql.gcp.upbound.io/v1beta1',
    kind: 'Database',
  }

  /**
   * Renders a Kubernetes manifest for "Database".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatabaseProps): any {
    return {
      ...Database.GVK,
      ...toJson_DatabaseProps(props),
    };
  }

  /**
   * Defines a "Database" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatabaseProps) {
    super(scope, id, {
      ...Database.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Database.GVK,
      ...toJson_DatabaseProps(resolved),
    };
  }
}

/**
 * Database is the Schema for the Databases API. Represents a SQL database inside the Cloud SQL instance, hosted in Google's cloud.
 *
 * @schema Database
 */
export interface DatabaseProps {
  /**
   * @schema Database#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatabaseSpec defines the desired state of Database
   *
   * @schema Database#spec
   */
  readonly spec: DatabaseSpec;

}

/**
 * Converts an object of type 'DatabaseProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseProps(obj: DatabaseProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatabaseSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatabaseSpec defines the desired state of Database
 *
 * @schema DatabaseSpec
 */
export interface DatabaseSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DatabaseSpec#deletionPolicy
   */
  readonly deletionPolicy?: DatabaseSpecDeletionPolicy;

  /**
   * @schema DatabaseSpec#forProvider
   */
  readonly forProvider: DatabaseSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DatabaseSpec#initProvider
   */
  readonly initProvider?: DatabaseSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DatabaseSpec#managementPolicies
   */
  readonly managementPolicies?: DatabaseSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DatabaseSpec#providerConfigRef
   */
  readonly providerConfigRef?: DatabaseSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DatabaseSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DatabaseSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DatabaseSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DatabaseSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DatabaseSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpec(obj: DatabaseSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DatabaseSpecForProvider(obj.forProvider),
    'initProvider': toJson_DatabaseSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DatabaseSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DatabaseSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DatabaseSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DatabaseSpecDeletionPolicy
 */
export enum DatabaseSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DatabaseSpecForProvider
 */
export interface DatabaseSpecForProvider {
  /**
   * The charset value. See MySQL's Supported Character Sets and Collations and Postgres' Character Set Support for more details and supported values. Postgres databases only support a value of UTF8 at creation time.
   *
   * @schema DatabaseSpecForProvider#charset
   */
  readonly charset?: string;

  /**
   * The collation value. See MySQL's Supported Character Sets and Collations and Postgres' Collation Support for more details and supported values. Postgres databases only support a value of en_US.UTF8 at creation time.
   *
   * @schema DatabaseSpecForProvider#collation
   */
  readonly collation?: string;

  /**
   * The deletion policy for the database. Setting ABANDON allows the resource to be abandoned rather than deleted. This is useful for Postgres, where databases cannot be deleted from the API if there are users other than cloudsqlsuperuser with access. Possible values are: "ABANDON", "DELETE". Defaults to "DELETE".
   *
   * @default DELETE".
   * @schema DatabaseSpecForProvider#deletionPolicy
   */
  readonly deletionPolicy?: string;

  /**
   * The name of the Cloud SQL instance. This does not include the project ID.
   *
   * @schema DatabaseSpecForProvider#instance
   */
  readonly instance?: string;

  /**
   * Reference to a DatabaseInstance to populate instance.
   *
   * @schema DatabaseSpecForProvider#instanceRef
   */
  readonly instanceRef?: DatabaseSpecForProviderInstanceRef;

  /**
   * Selector for a DatabaseInstance to populate instance.
   *
   * @schema DatabaseSpecForProvider#instanceSelector
   */
  readonly instanceSelector?: DatabaseSpecForProviderInstanceSelector;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema DatabaseSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'DatabaseSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProvider(obj: DatabaseSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charset': obj.charset,
    'collation': obj.collation,
    'deletionPolicy': obj.deletionPolicy,
    'instance': obj.instance,
    'instanceRef': toJson_DatabaseSpecForProviderInstanceRef(obj.instanceRef),
    'instanceSelector': toJson_DatabaseSpecForProviderInstanceSelector(obj.instanceSelector),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DatabaseSpecInitProvider
 */
export interface DatabaseSpecInitProvider {
  /**
   * The charset value. See MySQL's Supported Character Sets and Collations and Postgres' Character Set Support for more details and supported values. Postgres databases only support a value of UTF8 at creation time.
   *
   * @schema DatabaseSpecInitProvider#charset
   */
  readonly charset?: string;

  /**
   * The collation value. See MySQL's Supported Character Sets and Collations and Postgres' Collation Support for more details and supported values. Postgres databases only support a value of en_US.UTF8 at creation time.
   *
   * @schema DatabaseSpecInitProvider#collation
   */
  readonly collation?: string;

  /**
   * The deletion policy for the database. Setting ABANDON allows the resource to be abandoned rather than deleted. This is useful for Postgres, where databases cannot be deleted from the API if there are users other than cloudsqlsuperuser with access. Possible values are: "ABANDON", "DELETE". Defaults to "DELETE".
   *
   * @default DELETE".
   * @schema DatabaseSpecInitProvider#deletionPolicy
   */
  readonly deletionPolicy?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema DatabaseSpecInitProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'DatabaseSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecInitProvider(obj: DatabaseSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charset': obj.charset,
    'collation': obj.collation,
    'deletionPolicy': obj.deletionPolicy,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DatabaseSpecManagementPolicies
 */
export enum DatabaseSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DatabaseSpecProviderConfigRef
 */
export interface DatabaseSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatabaseSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatabaseSpecProviderConfigRef#policy
   */
  readonly policy?: DatabaseSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DatabaseSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecProviderConfigRef(obj: DatabaseSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatabaseSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DatabaseSpecPublishConnectionDetailsTo
 */
export interface DatabaseSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DatabaseSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DatabaseSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DatabaseSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DatabaseSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DatabaseSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatabaseSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecPublishConnectionDetailsTo(obj: DatabaseSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DatabaseSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DatabaseSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DatabaseSpecWriteConnectionSecretToRef
 */
export interface DatabaseSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DatabaseSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DatabaseSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DatabaseSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecWriteConnectionSecretToRef(obj: DatabaseSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DatabaseInstance to populate instance.
 *
 * @schema DatabaseSpecForProviderInstanceRef
 */
export interface DatabaseSpecForProviderInstanceRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatabaseSpecForProviderInstanceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatabaseSpecForProviderInstanceRef#policy
   */
  readonly policy?: DatabaseSpecForProviderInstanceRefPolicy;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderInstanceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderInstanceRef(obj: DatabaseSpecForProviderInstanceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatabaseSpecForProviderInstanceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DatabaseInstance to populate instance.
 *
 * @schema DatabaseSpecForProviderInstanceSelector
 */
export interface DatabaseSpecForProviderInstanceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatabaseSpecForProviderInstanceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatabaseSpecForProviderInstanceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatabaseSpecForProviderInstanceSelector#policy
   */
  readonly policy?: DatabaseSpecForProviderInstanceSelectorPolicy;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderInstanceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderInstanceSelector(obj: DatabaseSpecForProviderInstanceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatabaseSpecForProviderInstanceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatabaseSpecProviderConfigRefPolicy
 */
export interface DatabaseSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DatabaseSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DatabaseSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecProviderConfigRefPolicy(obj: DatabaseSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToConfigRef
 */
export interface DatabaseSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DatabaseSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DatabaseSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecPublishConnectionDetailsToConfigRef(obj: DatabaseSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatabaseSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToMetadata
 */
export interface DatabaseSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatabaseSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecPublishConnectionDetailsToMetadata(obj: DatabaseSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatabaseSpecForProviderInstanceRefPolicy
 */
export interface DatabaseSpecForProviderInstanceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseSpecForProviderInstanceRefPolicy#resolution
   */
  readonly resolution?: DatabaseSpecForProviderInstanceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseSpecForProviderInstanceRefPolicy#resolve
   */
  readonly resolve?: DatabaseSpecForProviderInstanceRefPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderInstanceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderInstanceRefPolicy(obj: DatabaseSpecForProviderInstanceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatabaseSpecForProviderInstanceSelectorPolicy
 */
export interface DatabaseSpecForProviderInstanceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseSpecForProviderInstanceSelectorPolicy#resolution
   */
  readonly resolution?: DatabaseSpecForProviderInstanceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseSpecForProviderInstanceSelectorPolicy#resolve
   */
  readonly resolve?: DatabaseSpecForProviderInstanceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderInstanceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderInstanceSelectorPolicy(obj: DatabaseSpecForProviderInstanceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseSpecProviderConfigRefPolicyResolution
 */
export enum DatabaseSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseSpecProviderConfigRefPolicyResolve
 */
export enum DatabaseSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DatabaseSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecPublishConnectionDetailsToConfigRefPolicy(obj: DatabaseSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseSpecForProviderInstanceRefPolicyResolution
 */
export enum DatabaseSpecForProviderInstanceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseSpecForProviderInstanceRefPolicyResolve
 */
export enum DatabaseSpecForProviderInstanceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseSpecForProviderInstanceSelectorPolicyResolution
 */
export enum DatabaseSpecForProviderInstanceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseSpecForProviderInstanceSelectorPolicyResolve
 */
export enum DatabaseSpecForProviderInstanceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DatabaseInstance is the Schema for the DatabaseInstances API. Creates a new SQL database instance in Google Cloud SQL.
 *
 * @schema DatabaseInstance
 */
export class DatabaseInstance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DatabaseInstance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sql.gcp.upbound.io/v1beta1',
    kind: 'DatabaseInstance',
  }

  /**
   * Renders a Kubernetes manifest for "DatabaseInstance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatabaseInstanceProps): any {
    return {
      ...DatabaseInstance.GVK,
      ...toJson_DatabaseInstanceProps(props),
    };
  }

  /**
   * Defines a "DatabaseInstance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatabaseInstanceProps) {
    super(scope, id, {
      ...DatabaseInstance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DatabaseInstance.GVK,
      ...toJson_DatabaseInstanceProps(resolved),
    };
  }
}

/**
 * DatabaseInstance is the Schema for the DatabaseInstances API. Creates a new SQL database instance in Google Cloud SQL.
 *
 * @schema DatabaseInstance
 */
export interface DatabaseInstanceProps {
  /**
   * @schema DatabaseInstance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatabaseInstanceSpec defines the desired state of DatabaseInstance
   *
   * @schema DatabaseInstance#spec
   */
  readonly spec: DatabaseInstanceSpec;

}

/**
 * Converts an object of type 'DatabaseInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceProps(obj: DatabaseInstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatabaseInstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatabaseInstanceSpec defines the desired state of DatabaseInstance
 *
 * @schema DatabaseInstanceSpec
 */
export interface DatabaseInstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DatabaseInstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: DatabaseInstanceSpecDeletionPolicy;

  /**
   * @schema DatabaseInstanceSpec#forProvider
   */
  readonly forProvider: DatabaseInstanceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DatabaseInstanceSpec#initProvider
   */
  readonly initProvider?: DatabaseInstanceSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DatabaseInstanceSpec#managementPolicies
   */
  readonly managementPolicies?: DatabaseInstanceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DatabaseInstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: DatabaseInstanceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DatabaseInstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DatabaseInstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DatabaseInstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DatabaseInstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DatabaseInstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpec(obj: DatabaseInstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DatabaseInstanceSpecForProvider(obj.forProvider),
    'initProvider': toJson_DatabaseInstanceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DatabaseInstanceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DatabaseInstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DatabaseInstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DatabaseInstanceSpecDeletionPolicy
 */
export enum DatabaseInstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DatabaseInstanceSpecForProvider
 */
export interface DatabaseInstanceSpecForProvider {
  /**
   * The context needed to create this instance as a clone of another instance. The configuration is detailed below.
   *
   * @schema DatabaseInstanceSpecForProvider#clone
   */
  readonly clone?: DatabaseInstanceSpecForProviderClone[];

  /**
   * The MySQL, PostgreSQL or SQL Server version to use. Supported values include MYSQL_5_6, MYSQL_5_7, MYSQL_8_0, POSTGRES_9_6,POSTGRES_10, POSTGRES_11, POSTGRES_12, POSTGRES_13, POSTGRES_14, POSTGRES_15, SQLSERVER_2017_STANDARD, SQLSERVER_2017_ENTERPRISE, SQLSERVER_2017_EXPRESS, SQLSERVER_2017_WEB. SQLSERVER_2019_STANDARD, SQLSERVER_2019_ENTERPRISE, SQLSERVER_2019_EXPRESS, SQLSERVER_2019_WEB. Database Version Policies includes an up-to-date reference of supported versions.
   *
   * @schema DatabaseInstanceSpecForProvider#databaseVersion
   */
  readonly databaseVersion?: string;

  /**
   * Defaults to true.
   *
   * @default true.
   * @schema DatabaseInstanceSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * The full path to the encryption key used for the CMEK disk encryption. The provided key must be in the same region as the SQL instance.  In order to use this feature, a special kind of service account must be created and granted permission on this key.  This step can currently only be done manually, please see this step. That service account needs the Cloud KMS > Cloud KMS CryptoKey Encrypter/Decrypter role on your key - please see this step.
   *
   * @schema DatabaseInstanceSpecForProvider#encryptionKeyName
   */
  readonly encryptionKeyName?: string;

  /**
   * The current software version on the instance. This attribute can not be set during creation. Refer to available_maintenance_versions attribute to see what maintenance_version are available for upgrade. When this attribute gets updated, it will cause an instance restart. Setting a maintenance_version value that is older than the current one on the instance will be ignored.
   *
   * @schema DatabaseInstanceSpecForProvider#maintenanceVersion
   */
  readonly maintenanceVersion?: string;

  /**
   * The name of the existing instance that will act as the master in the replication setup. Note, this requires the master to have binary_log_enabled set, as well as existing backups.
   *
   * @schema DatabaseInstanceSpecForProvider#masterInstanceName
   */
  readonly masterInstanceName?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema DatabaseInstanceSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The region the instance will sit in. If a region is not provided in the resource definition, the provider region will be used instead.
   *
   * @schema DatabaseInstanceSpecForProvider#region
   */
  readonly region?: string;

  /**
   * The configuration for replication. The configuration is detailed below. Valid only for MySQL instances.
   *
   * @schema DatabaseInstanceSpecForProvider#replicaConfiguration
   */
  readonly replicaConfiguration?: DatabaseInstanceSpecForProviderReplicaConfiguration[];

  /**
   * The context needed to restore the database to a backup run. The configuration is detailed below. Adding or modifying this block during resource creation/update will trigger the restore action after the resource is created/updated.
   *
   * @schema DatabaseInstanceSpecForProvider#restoreBackupContext
   */
  readonly restoreBackupContext?: DatabaseInstanceSpecForProviderRestoreBackupContext[];

  /**
   * Initial root password. Can be updated. Required for MS SQL Server.
   *
   * @schema DatabaseInstanceSpecForProvider#rootPasswordSecretRef
   */
  readonly rootPasswordSecretRef?: DatabaseInstanceSpecForProviderRootPasswordSecretRef;

  /**
   * The settings to use for the database. The configuration is detailed below. Required if clone is not set.
   *
   * @schema DatabaseInstanceSpecForProvider#settings
   */
  readonly settings?: DatabaseInstanceSpecForProviderSettings[];

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProvider(obj: DatabaseInstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clone': obj.clone?.map(y => toJson_DatabaseInstanceSpecForProviderClone(y)),
    'databaseVersion': obj.databaseVersion,
    'deletionProtection': obj.deletionProtection,
    'encryptionKeyName': obj.encryptionKeyName,
    'maintenanceVersion': obj.maintenanceVersion,
    'masterInstanceName': obj.masterInstanceName,
    'project': obj.project,
    'region': obj.region,
    'replicaConfiguration': obj.replicaConfiguration?.map(y => toJson_DatabaseInstanceSpecForProviderReplicaConfiguration(y)),
    'restoreBackupContext': obj.restoreBackupContext?.map(y => toJson_DatabaseInstanceSpecForProviderRestoreBackupContext(y)),
    'rootPasswordSecretRef': toJson_DatabaseInstanceSpecForProviderRootPasswordSecretRef(obj.rootPasswordSecretRef),
    'settings': obj.settings?.map(y => toJson_DatabaseInstanceSpecForProviderSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DatabaseInstanceSpecInitProvider
 */
export interface DatabaseInstanceSpecInitProvider {
  /**
   * The context needed to create this instance as a clone of another instance. The configuration is detailed below.
   *
   * @schema DatabaseInstanceSpecInitProvider#clone
   */
  readonly clone?: DatabaseInstanceSpecInitProviderClone[];

  /**
   * The MySQL, PostgreSQL or SQL Server version to use. Supported values include MYSQL_5_6, MYSQL_5_7, MYSQL_8_0, POSTGRES_9_6,POSTGRES_10, POSTGRES_11, POSTGRES_12, POSTGRES_13, POSTGRES_14, POSTGRES_15, SQLSERVER_2017_STANDARD, SQLSERVER_2017_ENTERPRISE, SQLSERVER_2017_EXPRESS, SQLSERVER_2017_WEB. SQLSERVER_2019_STANDARD, SQLSERVER_2019_ENTERPRISE, SQLSERVER_2019_EXPRESS, SQLSERVER_2019_WEB. Database Version Policies includes an up-to-date reference of supported versions.
   *
   * @schema DatabaseInstanceSpecInitProvider#databaseVersion
   */
  readonly databaseVersion?: string;

  /**
   * Defaults to true.
   *
   * @default true.
   * @schema DatabaseInstanceSpecInitProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * The full path to the encryption key used for the CMEK disk encryption. The provided key must be in the same region as the SQL instance.  In order to use this feature, a special kind of service account must be created and granted permission on this key.  This step can currently only be done manually, please see this step. That service account needs the Cloud KMS > Cloud KMS CryptoKey Encrypter/Decrypter role on your key - please see this step.
   *
   * @schema DatabaseInstanceSpecInitProvider#encryptionKeyName
   */
  readonly encryptionKeyName?: string;

  /**
   * The current software version on the instance. This attribute can not be set during creation. Refer to available_maintenance_versions attribute to see what maintenance_version are available for upgrade. When this attribute gets updated, it will cause an instance restart. Setting a maintenance_version value that is older than the current one on the instance will be ignored.
   *
   * @schema DatabaseInstanceSpecInitProvider#maintenanceVersion
   */
  readonly maintenanceVersion?: string;

  /**
   * The name of the existing instance that will act as the master in the replication setup. Note, this requires the master to have binary_log_enabled set, as well as existing backups.
   *
   * @schema DatabaseInstanceSpecInitProvider#masterInstanceName
   */
  readonly masterInstanceName?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema DatabaseInstanceSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The region the instance will sit in. If a region is not provided in the resource definition, the provider region will be used instead.
   *
   * @schema DatabaseInstanceSpecInitProvider#region
   */
  readonly region?: string;

  /**
   * The configuration for replication. The configuration is detailed below. Valid only for MySQL instances.
   *
   * @schema DatabaseInstanceSpecInitProvider#replicaConfiguration
   */
  readonly replicaConfiguration?: DatabaseInstanceSpecInitProviderReplicaConfiguration[];

  /**
   * The context needed to restore the database to a backup run. The configuration is detailed below. Adding or modifying this block during resource creation/update will trigger the restore action after the resource is created/updated.
   *
   * @schema DatabaseInstanceSpecInitProvider#restoreBackupContext
   */
  readonly restoreBackupContext?: DatabaseInstanceSpecInitProviderRestoreBackupContext[];

  /**
   * The settings to use for the database. The configuration is detailed below. Required if clone is not set.
   *
   * @schema DatabaseInstanceSpecInitProvider#settings
   */
  readonly settings?: DatabaseInstanceSpecInitProviderSettings[];

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProvider(obj: DatabaseInstanceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clone': obj.clone?.map(y => toJson_DatabaseInstanceSpecInitProviderClone(y)),
    'databaseVersion': obj.databaseVersion,
    'deletionProtection': obj.deletionProtection,
    'encryptionKeyName': obj.encryptionKeyName,
    'maintenanceVersion': obj.maintenanceVersion,
    'masterInstanceName': obj.masterInstanceName,
    'project': obj.project,
    'region': obj.region,
    'replicaConfiguration': obj.replicaConfiguration?.map(y => toJson_DatabaseInstanceSpecInitProviderReplicaConfiguration(y)),
    'restoreBackupContext': obj.restoreBackupContext?.map(y => toJson_DatabaseInstanceSpecInitProviderRestoreBackupContext(y)),
    'settings': obj.settings?.map(y => toJson_DatabaseInstanceSpecInitProviderSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DatabaseInstanceSpecManagementPolicies
 */
export enum DatabaseInstanceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DatabaseInstanceSpecProviderConfigRef
 */
export interface DatabaseInstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatabaseInstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatabaseInstanceSpecProviderConfigRef#policy
   */
  readonly policy?: DatabaseInstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecProviderConfigRef(obj: DatabaseInstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatabaseInstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DatabaseInstanceSpecPublishConnectionDetailsTo
 */
export interface DatabaseInstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DatabaseInstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DatabaseInstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DatabaseInstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DatabaseInstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DatabaseInstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecPublishConnectionDetailsTo(obj: DatabaseInstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DatabaseInstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DatabaseInstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DatabaseInstanceSpecWriteConnectionSecretToRef
 */
export interface DatabaseInstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DatabaseInstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DatabaseInstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecWriteConnectionSecretToRef(obj: DatabaseInstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderClone
 */
export interface DatabaseInstanceSpecForProviderClone {
  /**
   * The name of the allocated ip range for the private ip CloudSQL instance. For example: "google-managed-services-default". If set, the cloned instance ip will be created in the allocated range. The range name must comply with RFC 1035. Specifically, the name must be 1-63 characters long and match the regular expression a-z?.
   *
   * @schema DatabaseInstanceSpecForProviderClone#allocatedIpRange
   */
  readonly allocatedIpRange?: string;

  /**
   * (SQL Server only, use with point_in_time) Clone only the specified databases from the source instance. Clone all databases if empty.
   *
   * @schema DatabaseInstanceSpecForProviderClone#databaseNames
   */
  readonly databaseNames?: string[];

  /**
   * The timestamp of the point in time that should be restored.
   *
   * @schema DatabaseInstanceSpecForProviderClone#pointInTime
   */
  readonly pointInTime?: string;

  /**
   * Name of the source instance which will be cloned.
   *
   * @schema DatabaseInstanceSpecForProviderClone#sourceInstanceName
   */
  readonly sourceInstanceName?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderClone' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderClone(obj: DatabaseInstanceSpecForProviderClone | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocatedIpRange': obj.allocatedIpRange,
    'databaseNames': obj.databaseNames?.map(y => y),
    'pointInTime': obj.pointInTime,
    'sourceInstanceName': obj.sourceInstanceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderReplicaConfiguration
 */
export interface DatabaseInstanceSpecForProviderReplicaConfiguration {
  /**
   * PEM representation of the trusted CA's x509 certificate.
   *
   * @schema DatabaseInstanceSpecForProviderReplicaConfiguration#caCertificate
   */
  readonly caCertificate?: string;

  /**
   * PEM representation of the replica's x509 certificate.
   *
   * @schema DatabaseInstanceSpecForProviderReplicaConfiguration#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * PEM representation of the replica's private key. The corresponding public key in encoded in the client_certificate.
   *
   * @schema DatabaseInstanceSpecForProviderReplicaConfiguration#clientKey
   */
  readonly clientKey?: string;

  /**
   * The number of seconds between connect retries. MySQL's default is 60 seconds.
   *
   * @schema DatabaseInstanceSpecForProviderReplicaConfiguration#connectRetryInterval
   */
  readonly connectRetryInterval?: number;

  /**
   * Path to a SQL file in GCS from which replica instances are created. Format is gs://bucket/filename.
   *
   * @schema DatabaseInstanceSpecForProviderReplicaConfiguration#dumpFilePath
   */
  readonly dumpFilePath?: string;

  /**
   * Specifies if the replica is the failover target. If the field is set to true the replica will be designated as a failover replica. If the master instance fails, the replica instance will be promoted as the new master instance. ~> NOTE: Not supported for Postgres database.
   *
   * @schema DatabaseInstanceSpecForProviderReplicaConfiguration#failoverTarget
   */
  readonly failoverTarget?: boolean;

  /**
   * Time in ms between replication heartbeats.
   *
   * @schema DatabaseInstanceSpecForProviderReplicaConfiguration#masterHeartbeatPeriod
   */
  readonly masterHeartbeatPeriod?: number;

  /**
   * Password for the replication connection.
   *
   * @schema DatabaseInstanceSpecForProviderReplicaConfiguration#passwordSecretRef
   */
  readonly passwordSecretRef?: DatabaseInstanceSpecForProviderReplicaConfigurationPasswordSecretRef;

  /**
   * @schema DatabaseInstanceSpecForProviderReplicaConfiguration#sslCipher
   */
  readonly sslCipher?: string;

  /**
   * Username for replication connection.
   *
   * @schema DatabaseInstanceSpecForProviderReplicaConfiguration#username
   */
  readonly username?: string;

  /**
   * True if the master's common name value is checked during the SSL handshake.
   *
   * @schema DatabaseInstanceSpecForProviderReplicaConfiguration#verifyServerCertificate
   */
  readonly verifyServerCertificate?: boolean;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderReplicaConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderReplicaConfiguration(obj: DatabaseInstanceSpecForProviderReplicaConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificate': obj.caCertificate,
    'clientCertificate': obj.clientCertificate,
    'clientKey': obj.clientKey,
    'connectRetryInterval': obj.connectRetryInterval,
    'dumpFilePath': obj.dumpFilePath,
    'failoverTarget': obj.failoverTarget,
    'masterHeartbeatPeriod': obj.masterHeartbeatPeriod,
    'passwordSecretRef': toJson_DatabaseInstanceSpecForProviderReplicaConfigurationPasswordSecretRef(obj.passwordSecretRef),
    'sslCipher': obj.sslCipher,
    'username': obj.username,
    'verifyServerCertificate': obj.verifyServerCertificate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderRestoreBackupContext
 */
export interface DatabaseInstanceSpecForProviderRestoreBackupContext {
  /**
   * The ID of the backup run to restore from.
   *
   * @schema DatabaseInstanceSpecForProviderRestoreBackupContext#backupRunId
   */
  readonly backupRunId?: number;

  /**
   * The ID of the instance that the backup was taken from. If left empty, this instance's ID will be used.
   *
   * @schema DatabaseInstanceSpecForProviderRestoreBackupContext#instanceId
   */
  readonly instanceId?: string;

  /**
   * The full project ID of the source instance.`
   *
   * @schema DatabaseInstanceSpecForProviderRestoreBackupContext#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderRestoreBackupContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderRestoreBackupContext(obj: DatabaseInstanceSpecForProviderRestoreBackupContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupRunId': obj.backupRunId,
    'instanceId': obj.instanceId,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Initial root password. Can be updated. Required for MS SQL Server.
 *
 * @schema DatabaseInstanceSpecForProviderRootPasswordSecretRef
 */
export interface DatabaseInstanceSpecForProviderRootPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema DatabaseInstanceSpecForProviderRootPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DatabaseInstanceSpecForProviderRootPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DatabaseInstanceSpecForProviderRootPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderRootPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderRootPasswordSecretRef(obj: DatabaseInstanceSpecForProviderRootPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderSettings
 */
export interface DatabaseInstanceSpecForProviderSettings {
  /**
   * This specifies when the instance should be active. Can be either ALWAYS, NEVER or ON_DEMAND.
   *
   * @schema DatabaseInstanceSpecForProviderSettings#activationPolicy
   */
  readonly activationPolicy?: string;

  /**
   * @schema DatabaseInstanceSpecForProviderSettings#activeDirectoryConfig
   */
  readonly activeDirectoryConfig?: DatabaseInstanceSpecForProviderSettingsActiveDirectoryConfig[];

  /**
   * @schema DatabaseInstanceSpecForProviderSettings#advancedMachineFeatures
   */
  readonly advancedMachineFeatures?: DatabaseInstanceSpecForProviderSettingsAdvancedMachineFeatures[];

  /**
   * The availability type of the Cloud SQL instance, high availability (REGIONAL) or single zone (ZONAL).' For all instances, ensure that settings.backup_configuration.enabled is set to true. For MySQL instances, ensure that settings.backup_configuration.binary_log_enabled is set to true. For Postgres and SQL Server instances, ensure that settings.backup_configuration.point_in_time_recovery_enabled is set to true. Defaults to ZONAL.
   *
   * @default ZONAL.
   * @schema DatabaseInstanceSpecForProviderSettings#availabilityType
   */
  readonly availabilityType?: string;

  /**
   * @schema DatabaseInstanceSpecForProviderSettings#backupConfiguration
   */
  readonly backupConfiguration?: DatabaseInstanceSpecForProviderSettingsBackupConfiguration[];

  /**
   * The name of server instance collation.
   *
   * @schema DatabaseInstanceSpecForProviderSettings#collation
   */
  readonly collation?: string;

  /**
   * Specifies if connections must use Cloud SQL connectors.
   *
   * @schema DatabaseInstanceSpecForProviderSettings#connectorEnforcement
   */
  readonly connectorEnforcement?: string;

  /**
   * @schema DatabaseInstanceSpecForProviderSettings#dataCacheConfig
   */
  readonly dataCacheConfig?: DatabaseInstanceSpecForProviderSettingsDataCacheConfig[];

  /**
   * @schema DatabaseInstanceSpecForProviderSettings#databaseFlags
   */
  readonly databaseFlags?: DatabaseInstanceSpecForProviderSettingsDatabaseFlags[];

  /**
   * .
   *
   * @schema DatabaseInstanceSpecForProviderSettings#deletionProtectionEnabled
   */
  readonly deletionProtectionEnabled?: boolean;

  /**
   * @schema DatabaseInstanceSpecForProviderSettings#denyMaintenancePeriod
   */
  readonly denyMaintenancePeriod?: DatabaseInstanceSpecForProviderSettingsDenyMaintenancePeriod[];

  /**
   * Enables auto-resizing of the storage size. Defaults to true.
   *
   * @default true.
   * @schema DatabaseInstanceSpecForProviderSettings#diskAutoresize
   */
  readonly diskAutoresize?: boolean;

  /**
   * The maximum size to which storage capacity can be automatically increased. The default value is 0, which specifies that there is no limit.
   *
   * @schema DatabaseInstanceSpecForProviderSettings#diskAutoresizeLimit
   */
  readonly diskAutoresizeLimit?: number;

  /**
   * The size of data disk, in GB. Size of a running instance cannot be reduced but can be increased. The minimum value is 10GB.
   *
   * @schema DatabaseInstanceSpecForProviderSettings#diskSize
   */
  readonly diskSize?: number;

  /**
   * The type of data disk: PD_SSD or PD_HDD. Defaults to PD_SSD.
   *
   * @default PD_SSD.
   * @schema DatabaseInstanceSpecForProviderSettings#diskType
   */
  readonly diskType?: string;

  /**
   * The edition of the instance, can be ENTERPRISE or ENTERPRISE_PLUS.
   *
   * @schema DatabaseInstanceSpecForProviderSettings#edition
   */
  readonly edition?: string;

  /**
   * @schema DatabaseInstanceSpecForProviderSettings#insightsConfig
   */
  readonly insightsConfig?: DatabaseInstanceSpecForProviderSettingsInsightsConfig[];

  /**
   * @schema DatabaseInstanceSpecForProviderSettings#ipConfiguration
   */
  readonly ipConfiguration?: DatabaseInstanceSpecForProviderSettingsIpConfiguration[];

  /**
   * @schema DatabaseInstanceSpecForProviderSettings#locationPreference
   */
  readonly locationPreference?: DatabaseInstanceSpecForProviderSettingsLocationPreference[];

  /**
   * @schema DatabaseInstanceSpecForProviderSettings#maintenanceWindow
   */
  readonly maintenanceWindow?: DatabaseInstanceSpecForProviderSettingsMaintenanceWindow[];

  /**
   * @schema DatabaseInstanceSpecForProviderSettings#passwordValidationPolicy
   */
  readonly passwordValidationPolicy?: DatabaseInstanceSpecForProviderSettingsPasswordValidationPolicy[];

  /**
   * Pricing plan for this instance, can only be PER_USE.
   *
   * @schema DatabaseInstanceSpecForProviderSettings#pricingPlan
   */
  readonly pricingPlan?: string;

  /**
   * @schema DatabaseInstanceSpecForProviderSettings#sqlServerAuditConfig
   */
  readonly sqlServerAuditConfig?: DatabaseInstanceSpecForProviderSettingsSqlServerAuditConfig[];

  /**
   * The machine type to use. See tiers for more details and supported versions. Postgres supports only shared-core machine types, and custom machine types such as db-custom-2-13312. See the Custom Machine Type Documentation to learn about specifying custom machine types.
   *
   * @schema DatabaseInstanceSpecForProviderSettings#tier
   */
  readonly tier?: string;

  /**
   * The time_zone to be used by the database engine (supported only for SQL Server), in SQL Server timezone format.
   *
   * @schema DatabaseInstanceSpecForProviderSettings#timeZone
   */
  readonly timeZone?: string;

  /**
   * A set of key/value user label pairs to assign to the instance.
   *
   * @schema DatabaseInstanceSpecForProviderSettings#userLabels
   */
  readonly userLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettings(obj: DatabaseInstanceSpecForProviderSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activationPolicy': obj.activationPolicy,
    'activeDirectoryConfig': obj.activeDirectoryConfig?.map(y => toJson_DatabaseInstanceSpecForProviderSettingsActiveDirectoryConfig(y)),
    'advancedMachineFeatures': obj.advancedMachineFeatures?.map(y => toJson_DatabaseInstanceSpecForProviderSettingsAdvancedMachineFeatures(y)),
    'availabilityType': obj.availabilityType,
    'backupConfiguration': obj.backupConfiguration?.map(y => toJson_DatabaseInstanceSpecForProviderSettingsBackupConfiguration(y)),
    'collation': obj.collation,
    'connectorEnforcement': obj.connectorEnforcement,
    'dataCacheConfig': obj.dataCacheConfig?.map(y => toJson_DatabaseInstanceSpecForProviderSettingsDataCacheConfig(y)),
    'databaseFlags': obj.databaseFlags?.map(y => toJson_DatabaseInstanceSpecForProviderSettingsDatabaseFlags(y)),
    'deletionProtectionEnabled': obj.deletionProtectionEnabled,
    'denyMaintenancePeriod': obj.denyMaintenancePeriod?.map(y => toJson_DatabaseInstanceSpecForProviderSettingsDenyMaintenancePeriod(y)),
    'diskAutoresize': obj.diskAutoresize,
    'diskAutoresizeLimit': obj.diskAutoresizeLimit,
    'diskSize': obj.diskSize,
    'diskType': obj.diskType,
    'edition': obj.edition,
    'insightsConfig': obj.insightsConfig?.map(y => toJson_DatabaseInstanceSpecForProviderSettingsInsightsConfig(y)),
    'ipConfiguration': obj.ipConfiguration?.map(y => toJson_DatabaseInstanceSpecForProviderSettingsIpConfiguration(y)),
    'locationPreference': obj.locationPreference?.map(y => toJson_DatabaseInstanceSpecForProviderSettingsLocationPreference(y)),
    'maintenanceWindow': obj.maintenanceWindow?.map(y => toJson_DatabaseInstanceSpecForProviderSettingsMaintenanceWindow(y)),
    'passwordValidationPolicy': obj.passwordValidationPolicy?.map(y => toJson_DatabaseInstanceSpecForProviderSettingsPasswordValidationPolicy(y)),
    'pricingPlan': obj.pricingPlan,
    'sqlServerAuditConfig': obj.sqlServerAuditConfig?.map(y => toJson_DatabaseInstanceSpecForProviderSettingsSqlServerAuditConfig(y)),
    'tier': obj.tier,
    'timeZone': obj.timeZone,
    'userLabels': ((obj.userLabels) === undefined) ? undefined : (Object.entries(obj.userLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderClone
 */
export interface DatabaseInstanceSpecInitProviderClone {
  /**
   * The name of the allocated ip range for the private ip CloudSQL instance. For example: "google-managed-services-default". If set, the cloned instance ip will be created in the allocated range. The range name must comply with RFC 1035. Specifically, the name must be 1-63 characters long and match the regular expression a-z?.
   *
   * @schema DatabaseInstanceSpecInitProviderClone#allocatedIpRange
   */
  readonly allocatedIpRange?: string;

  /**
   * (SQL Server only, use with point_in_time) Clone only the specified databases from the source instance. Clone all databases if empty.
   *
   * @schema DatabaseInstanceSpecInitProviderClone#databaseNames
   */
  readonly databaseNames?: string[];

  /**
   * The timestamp of the point in time that should be restored.
   *
   * @schema DatabaseInstanceSpecInitProviderClone#pointInTime
   */
  readonly pointInTime?: string;

  /**
   * Name of the source instance which will be cloned.
   *
   * @schema DatabaseInstanceSpecInitProviderClone#sourceInstanceName
   */
  readonly sourceInstanceName?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderClone' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderClone(obj: DatabaseInstanceSpecInitProviderClone | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocatedIpRange': obj.allocatedIpRange,
    'databaseNames': obj.databaseNames?.map(y => y),
    'pointInTime': obj.pointInTime,
    'sourceInstanceName': obj.sourceInstanceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderReplicaConfiguration
 */
export interface DatabaseInstanceSpecInitProviderReplicaConfiguration {
  /**
   * PEM representation of the trusted CA's x509 certificate.
   *
   * @schema DatabaseInstanceSpecInitProviderReplicaConfiguration#caCertificate
   */
  readonly caCertificate?: string;

  /**
   * PEM representation of the replica's x509 certificate.
   *
   * @schema DatabaseInstanceSpecInitProviderReplicaConfiguration#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * PEM representation of the replica's private key. The corresponding public key in encoded in the client_certificate.
   *
   * @schema DatabaseInstanceSpecInitProviderReplicaConfiguration#clientKey
   */
  readonly clientKey?: string;

  /**
   * The number of seconds between connect retries. MySQL's default is 60 seconds.
   *
   * @schema DatabaseInstanceSpecInitProviderReplicaConfiguration#connectRetryInterval
   */
  readonly connectRetryInterval?: number;

  /**
   * Path to a SQL file in GCS from which replica instances are created. Format is gs://bucket/filename.
   *
   * @schema DatabaseInstanceSpecInitProviderReplicaConfiguration#dumpFilePath
   */
  readonly dumpFilePath?: string;

  /**
   * Specifies if the replica is the failover target. If the field is set to true the replica will be designated as a failover replica. If the master instance fails, the replica instance will be promoted as the new master instance. ~> NOTE: Not supported for Postgres database.
   *
   * @schema DatabaseInstanceSpecInitProviderReplicaConfiguration#failoverTarget
   */
  readonly failoverTarget?: boolean;

  /**
   * Time in ms between replication heartbeats.
   *
   * @schema DatabaseInstanceSpecInitProviderReplicaConfiguration#masterHeartbeatPeriod
   */
  readonly masterHeartbeatPeriod?: number;

  /**
   * @schema DatabaseInstanceSpecInitProviderReplicaConfiguration#sslCipher
   */
  readonly sslCipher?: string;

  /**
   * Username for replication connection.
   *
   * @schema DatabaseInstanceSpecInitProviderReplicaConfiguration#username
   */
  readonly username?: string;

  /**
   * True if the master's common name value is checked during the SSL handshake.
   *
   * @schema DatabaseInstanceSpecInitProviderReplicaConfiguration#verifyServerCertificate
   */
  readonly verifyServerCertificate?: boolean;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderReplicaConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderReplicaConfiguration(obj: DatabaseInstanceSpecInitProviderReplicaConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificate': obj.caCertificate,
    'clientCertificate': obj.clientCertificate,
    'clientKey': obj.clientKey,
    'connectRetryInterval': obj.connectRetryInterval,
    'dumpFilePath': obj.dumpFilePath,
    'failoverTarget': obj.failoverTarget,
    'masterHeartbeatPeriod': obj.masterHeartbeatPeriod,
    'sslCipher': obj.sslCipher,
    'username': obj.username,
    'verifyServerCertificate': obj.verifyServerCertificate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderRestoreBackupContext
 */
export interface DatabaseInstanceSpecInitProviderRestoreBackupContext {
  /**
   * The ID of the backup run to restore from.
   *
   * @schema DatabaseInstanceSpecInitProviderRestoreBackupContext#backupRunId
   */
  readonly backupRunId?: number;

  /**
   * The ID of the instance that the backup was taken from. If left empty, this instance's ID will be used.
   *
   * @schema DatabaseInstanceSpecInitProviderRestoreBackupContext#instanceId
   */
  readonly instanceId?: string;

  /**
   * The full project ID of the source instance.`
   *
   * @schema DatabaseInstanceSpecInitProviderRestoreBackupContext#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderRestoreBackupContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderRestoreBackupContext(obj: DatabaseInstanceSpecInitProviderRestoreBackupContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupRunId': obj.backupRunId,
    'instanceId': obj.instanceId,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderSettings
 */
export interface DatabaseInstanceSpecInitProviderSettings {
  /**
   * This specifies when the instance should be active. Can be either ALWAYS, NEVER or ON_DEMAND.
   *
   * @schema DatabaseInstanceSpecInitProviderSettings#activationPolicy
   */
  readonly activationPolicy?: string;

  /**
   * @schema DatabaseInstanceSpecInitProviderSettings#activeDirectoryConfig
   */
  readonly activeDirectoryConfig?: DatabaseInstanceSpecInitProviderSettingsActiveDirectoryConfig[];

  /**
   * @schema DatabaseInstanceSpecInitProviderSettings#advancedMachineFeatures
   */
  readonly advancedMachineFeatures?: DatabaseInstanceSpecInitProviderSettingsAdvancedMachineFeatures[];

  /**
   * The availability type of the Cloud SQL instance, high availability (REGIONAL) or single zone (ZONAL).' For all instances, ensure that settings.backup_configuration.enabled is set to true. For MySQL instances, ensure that settings.backup_configuration.binary_log_enabled is set to true. For Postgres and SQL Server instances, ensure that settings.backup_configuration.point_in_time_recovery_enabled is set to true. Defaults to ZONAL.
   *
   * @default ZONAL.
   * @schema DatabaseInstanceSpecInitProviderSettings#availabilityType
   */
  readonly availabilityType?: string;

  /**
   * @schema DatabaseInstanceSpecInitProviderSettings#backupConfiguration
   */
  readonly backupConfiguration?: DatabaseInstanceSpecInitProviderSettingsBackupConfiguration[];

  /**
   * The name of server instance collation.
   *
   * @schema DatabaseInstanceSpecInitProviderSettings#collation
   */
  readonly collation?: string;

  /**
   * Specifies if connections must use Cloud SQL connectors.
   *
   * @schema DatabaseInstanceSpecInitProviderSettings#connectorEnforcement
   */
  readonly connectorEnforcement?: string;

  /**
   * @schema DatabaseInstanceSpecInitProviderSettings#dataCacheConfig
   */
  readonly dataCacheConfig?: DatabaseInstanceSpecInitProviderSettingsDataCacheConfig[];

  /**
   * @schema DatabaseInstanceSpecInitProviderSettings#databaseFlags
   */
  readonly databaseFlags?: DatabaseInstanceSpecInitProviderSettingsDatabaseFlags[];

  /**
   * .
   *
   * @schema DatabaseInstanceSpecInitProviderSettings#deletionProtectionEnabled
   */
  readonly deletionProtectionEnabled?: boolean;

  /**
   * @schema DatabaseInstanceSpecInitProviderSettings#denyMaintenancePeriod
   */
  readonly denyMaintenancePeriod?: DatabaseInstanceSpecInitProviderSettingsDenyMaintenancePeriod[];

  /**
   * Enables auto-resizing of the storage size. Defaults to true.
   *
   * @default true.
   * @schema DatabaseInstanceSpecInitProviderSettings#diskAutoresize
   */
  readonly diskAutoresize?: boolean;

  /**
   * The maximum size to which storage capacity can be automatically increased. The default value is 0, which specifies that there is no limit.
   *
   * @schema DatabaseInstanceSpecInitProviderSettings#diskAutoresizeLimit
   */
  readonly diskAutoresizeLimit?: number;

  /**
   * The size of data disk, in GB. Size of a running instance cannot be reduced but can be increased. The minimum value is 10GB.
   *
   * @schema DatabaseInstanceSpecInitProviderSettings#diskSize
   */
  readonly diskSize?: number;

  /**
   * The type of data disk: PD_SSD or PD_HDD. Defaults to PD_SSD.
   *
   * @default PD_SSD.
   * @schema DatabaseInstanceSpecInitProviderSettings#diskType
   */
  readonly diskType?: string;

  /**
   * The edition of the instance, can be ENTERPRISE or ENTERPRISE_PLUS.
   *
   * @schema DatabaseInstanceSpecInitProviderSettings#edition
   */
  readonly edition?: string;

  /**
   * @schema DatabaseInstanceSpecInitProviderSettings#insightsConfig
   */
  readonly insightsConfig?: DatabaseInstanceSpecInitProviderSettingsInsightsConfig[];

  /**
   * @schema DatabaseInstanceSpecInitProviderSettings#ipConfiguration
   */
  readonly ipConfiguration?: DatabaseInstanceSpecInitProviderSettingsIpConfiguration[];

  /**
   * @schema DatabaseInstanceSpecInitProviderSettings#locationPreference
   */
  readonly locationPreference?: DatabaseInstanceSpecInitProviderSettingsLocationPreference[];

  /**
   * @schema DatabaseInstanceSpecInitProviderSettings#maintenanceWindow
   */
  readonly maintenanceWindow?: DatabaseInstanceSpecInitProviderSettingsMaintenanceWindow[];

  /**
   * @schema DatabaseInstanceSpecInitProviderSettings#passwordValidationPolicy
   */
  readonly passwordValidationPolicy?: DatabaseInstanceSpecInitProviderSettingsPasswordValidationPolicy[];

  /**
   * Pricing plan for this instance, can only be PER_USE.
   *
   * @schema DatabaseInstanceSpecInitProviderSettings#pricingPlan
   */
  readonly pricingPlan?: string;

  /**
   * @schema DatabaseInstanceSpecInitProviderSettings#sqlServerAuditConfig
   */
  readonly sqlServerAuditConfig?: DatabaseInstanceSpecInitProviderSettingsSqlServerAuditConfig[];

  /**
   * The machine type to use. See tiers for more details and supported versions. Postgres supports only shared-core machine types, and custom machine types such as db-custom-2-13312. See the Custom Machine Type Documentation to learn about specifying custom machine types.
   *
   * @schema DatabaseInstanceSpecInitProviderSettings#tier
   */
  readonly tier?: string;

  /**
   * The time_zone to be used by the database engine (supported only for SQL Server), in SQL Server timezone format.
   *
   * @schema DatabaseInstanceSpecInitProviderSettings#timeZone
   */
  readonly timeZone?: string;

  /**
   * A set of key/value user label pairs to assign to the instance.
   *
   * @schema DatabaseInstanceSpecInitProviderSettings#userLabels
   */
  readonly userLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderSettings(obj: DatabaseInstanceSpecInitProviderSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activationPolicy': obj.activationPolicy,
    'activeDirectoryConfig': obj.activeDirectoryConfig?.map(y => toJson_DatabaseInstanceSpecInitProviderSettingsActiveDirectoryConfig(y)),
    'advancedMachineFeatures': obj.advancedMachineFeatures?.map(y => toJson_DatabaseInstanceSpecInitProviderSettingsAdvancedMachineFeatures(y)),
    'availabilityType': obj.availabilityType,
    'backupConfiguration': obj.backupConfiguration?.map(y => toJson_DatabaseInstanceSpecInitProviderSettingsBackupConfiguration(y)),
    'collation': obj.collation,
    'connectorEnforcement': obj.connectorEnforcement,
    'dataCacheConfig': obj.dataCacheConfig?.map(y => toJson_DatabaseInstanceSpecInitProviderSettingsDataCacheConfig(y)),
    'databaseFlags': obj.databaseFlags?.map(y => toJson_DatabaseInstanceSpecInitProviderSettingsDatabaseFlags(y)),
    'deletionProtectionEnabled': obj.deletionProtectionEnabled,
    'denyMaintenancePeriod': obj.denyMaintenancePeriod?.map(y => toJson_DatabaseInstanceSpecInitProviderSettingsDenyMaintenancePeriod(y)),
    'diskAutoresize': obj.diskAutoresize,
    'diskAutoresizeLimit': obj.diskAutoresizeLimit,
    'diskSize': obj.diskSize,
    'diskType': obj.diskType,
    'edition': obj.edition,
    'insightsConfig': obj.insightsConfig?.map(y => toJson_DatabaseInstanceSpecInitProviderSettingsInsightsConfig(y)),
    'ipConfiguration': obj.ipConfiguration?.map(y => toJson_DatabaseInstanceSpecInitProviderSettingsIpConfiguration(y)),
    'locationPreference': obj.locationPreference?.map(y => toJson_DatabaseInstanceSpecInitProviderSettingsLocationPreference(y)),
    'maintenanceWindow': obj.maintenanceWindow?.map(y => toJson_DatabaseInstanceSpecInitProviderSettingsMaintenanceWindow(y)),
    'passwordValidationPolicy': obj.passwordValidationPolicy?.map(y => toJson_DatabaseInstanceSpecInitProviderSettingsPasswordValidationPolicy(y)),
    'pricingPlan': obj.pricingPlan,
    'sqlServerAuditConfig': obj.sqlServerAuditConfig?.map(y => toJson_DatabaseInstanceSpecInitProviderSettingsSqlServerAuditConfig(y)),
    'tier': obj.tier,
    'timeZone': obj.timeZone,
    'userLabels': ((obj.userLabels) === undefined) ? undefined : (Object.entries(obj.userLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatabaseInstanceSpecProviderConfigRefPolicy
 */
export interface DatabaseInstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseInstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DatabaseInstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseInstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DatabaseInstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecProviderConfigRefPolicy(obj: DatabaseInstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DatabaseInstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface DatabaseInstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatabaseInstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatabaseInstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DatabaseInstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecPublishConnectionDetailsToConfigRef(obj: DatabaseInstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatabaseInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DatabaseInstanceSpecPublishConnectionDetailsToMetadata
 */
export interface DatabaseInstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatabaseInstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatabaseInstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DatabaseInstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecPublishConnectionDetailsToMetadata(obj: DatabaseInstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Password for the replication connection.
 *
 * @schema DatabaseInstanceSpecForProviderReplicaConfigurationPasswordSecretRef
 */
export interface DatabaseInstanceSpecForProviderReplicaConfigurationPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema DatabaseInstanceSpecForProviderReplicaConfigurationPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DatabaseInstanceSpecForProviderReplicaConfigurationPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DatabaseInstanceSpecForProviderReplicaConfigurationPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderReplicaConfigurationPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderReplicaConfigurationPasswordSecretRef(obj: DatabaseInstanceSpecForProviderReplicaConfigurationPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderSettingsActiveDirectoryConfig
 */
export interface DatabaseInstanceSpecForProviderSettingsActiveDirectoryConfig {
  /**
   * The domain name for the active directory (e.g., mydomain.com). Can only be used with SQL Server.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsActiveDirectoryConfig#domain
   */
  readonly domain?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsActiveDirectoryConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsActiveDirectoryConfig(obj: DatabaseInstanceSpecForProviderSettingsActiveDirectoryConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domain': obj.domain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderSettingsAdvancedMachineFeatures
 */
export interface DatabaseInstanceSpecForProviderSettingsAdvancedMachineFeatures {
  /**
   * The number of threads per core. The value of this flag can be 1 or 2. To disable SMT, set this flag to 1. Only available in Cloud SQL for SQL Server instances. See smt for more details.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsAdvancedMachineFeatures#threadsPerCore
   */
  readonly threadsPerCore?: number;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsAdvancedMachineFeatures' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsAdvancedMachineFeatures(obj: DatabaseInstanceSpecForProviderSettingsAdvancedMachineFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'threadsPerCore': obj.threadsPerCore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderSettingsBackupConfiguration
 */
export interface DatabaseInstanceSpecForProviderSettingsBackupConfiguration {
  /**
   * Backup retention settings. The configuration is detailed below.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsBackupConfiguration#backupRetentionSettings
   */
  readonly backupRetentionSettings?: DatabaseInstanceSpecForProviderSettingsBackupConfigurationBackupRetentionSettings[];

  /**
   * True if binary logging is enabled. Can only be used with MySQL.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsBackupConfiguration#binaryLogEnabled
   */
  readonly binaryLogEnabled?: boolean;

  /**
   * True if backup configuration is enabled.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsBackupConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * The region where the backup will be stored
   *
   * @schema DatabaseInstanceSpecForProviderSettingsBackupConfiguration#location
   */
  readonly location?: string;

  /**
   * True if Point-in-time recovery is enabled. Will restart database if enabled after instance creation. Valid only for PostgreSQL and SQL Server instances.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsBackupConfiguration#pointInTimeRecoveryEnabled
   */
  readonly pointInTimeRecoveryEnabled?: boolean;

  /**
   * HH:MM format time indicating when backup configuration starts.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsBackupConfiguration#startTime
   */
  readonly startTime?: string;

  /**
   * The number of days of transaction logs we retain for point in time restore, from 1-7. For PostgreSQL Enterprise Plus instances, the number of days of retained transaction logs can be set from 1 to 35.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsBackupConfiguration#transactionLogRetentionDays
   */
  readonly transactionLogRetentionDays?: number;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsBackupConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsBackupConfiguration(obj: DatabaseInstanceSpecForProviderSettingsBackupConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupRetentionSettings': obj.backupRetentionSettings?.map(y => toJson_DatabaseInstanceSpecForProviderSettingsBackupConfigurationBackupRetentionSettings(y)),
    'binaryLogEnabled': obj.binaryLogEnabled,
    'enabled': obj.enabled,
    'location': obj.location,
    'pointInTimeRecoveryEnabled': obj.pointInTimeRecoveryEnabled,
    'startTime': obj.startTime,
    'transactionLogRetentionDays': obj.transactionLogRetentionDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderSettingsDataCacheConfig
 */
export interface DatabaseInstanceSpecForProviderSettingsDataCacheConfig {
  /**
   * Whether data cache is enabled for the instance. Defaults to false Can only be used with MYSQL.
   *
   * @default false Can only be used with MYSQL.
   * @schema DatabaseInstanceSpecForProviderSettingsDataCacheConfig#dataCacheEnabled
   */
  readonly dataCacheEnabled?: boolean;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsDataCacheConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsDataCacheConfig(obj: DatabaseInstanceSpecForProviderSettingsDataCacheConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataCacheEnabled': obj.dataCacheEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderSettingsDatabaseFlags
 */
export interface DatabaseInstanceSpecForProviderSettingsDatabaseFlags {
  /**
   * A name for this whitelist entry.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsDatabaseFlags#name
   */
  readonly name?: string;

  /**
   * A CIDR notation IPv4 or IPv6 address that is allowed to access this instance. Must be set even if other two attributes are not for the whitelist to become active.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsDatabaseFlags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsDatabaseFlags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsDatabaseFlags(obj: DatabaseInstanceSpecForProviderSettingsDatabaseFlags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderSettingsDenyMaintenancePeriod
 */
export interface DatabaseInstanceSpecForProviderSettingsDenyMaintenancePeriod {
  /**
   * "deny maintenance period" end date. If the year of the end date is empty, the year of the start date also must be empty. In this case, it means the no maintenance interval recurs every year. The date is in format yyyy-mm-dd i.e., 2020-11-01, or mm-dd, i.e., 11-01
   *
   * @schema DatabaseInstanceSpecForProviderSettingsDenyMaintenancePeriod#endDate
   */
  readonly endDate?: string;

  /**
   * "deny maintenance period" start date. If the year of the start date is empty, the year of the end date also must be empty. In this case, it means the deny maintenance period recurs every year. The date is in format yyyy-mm-dd i.e., 2020-11-01, or mm-dd, i.e., 11-01
   *
   * @schema DatabaseInstanceSpecForProviderSettingsDenyMaintenancePeriod#startDate
   */
  readonly startDate?: string;

  /**
   * Time in UTC when the "deny maintenance period" starts on startDate and ends on endDate. The time is in format: HH:mm:SS, i.e., 00:00:00
   *
   * @schema DatabaseInstanceSpecForProviderSettingsDenyMaintenancePeriod#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsDenyMaintenancePeriod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsDenyMaintenancePeriod(obj: DatabaseInstanceSpecForProviderSettingsDenyMaintenancePeriod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endDate': obj.endDate,
    'startDate': obj.startDate,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderSettingsInsightsConfig
 */
export interface DatabaseInstanceSpecForProviderSettingsInsightsConfig {
  /**
   * True if Query Insights feature is enabled.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsInsightsConfig#queryInsightsEnabled
   */
  readonly queryInsightsEnabled?: boolean;

  /**
   * Number of query execution plans captured by Insights per minute for all queries combined. Between 0 and 20. Default to 5.
   *
   * @default 5.
   * @schema DatabaseInstanceSpecForProviderSettingsInsightsConfig#queryPlansPerMinute
   */
  readonly queryPlansPerMinute?: number;

  /**
   * Maximum query length stored in bytes. Between 256 and 4500. Default to 1024. Higher query lengths are more useful for analytical queries, but they also require more memory. Changing the query length requires you to restart the instance. You can still add tags to queries that exceed the length limit.
   *
   * @default 1024. Higher query lengths are more useful for analytical queries, but they also require more memory. Changing the query length requires you to restart the instance. You can still add tags to queries that exceed the length limit.
   * @schema DatabaseInstanceSpecForProviderSettingsInsightsConfig#queryStringLength
   */
  readonly queryStringLength?: number;

  /**
   * True if Query Insights will record application tags from query when enabled.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsInsightsConfig#recordApplicationTags
   */
  readonly recordApplicationTags?: boolean;

  /**
   * True if Query Insights will record client address when enabled.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsInsightsConfig#recordClientAddress
   */
  readonly recordClientAddress?: boolean;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsInsightsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsInsightsConfig(obj: DatabaseInstanceSpecForProviderSettingsInsightsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'queryInsightsEnabled': obj.queryInsightsEnabled,
    'queryPlansPerMinute': obj.queryPlansPerMinute,
    'queryStringLength': obj.queryStringLength,
    'recordApplicationTags': obj.recordApplicationTags,
    'recordClientAddress': obj.recordClientAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderSettingsIpConfiguration
 */
export interface DatabaseInstanceSpecForProviderSettingsIpConfiguration {
  /**
   * The name of the allocated ip range for the private ip CloudSQL instance. For example: "google-managed-services-default". If set, the instance ip will be created in the allocated range. The range name must comply with RFC 1035. Specifically, the name must be 1-63 characters long and match the regular expression a-z?.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfiguration#allocatedIpRange
   */
  readonly allocatedIpRange?: string;

  /**
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfiguration#authorizedNetworks
   */
  readonly authorizedNetworks?: DatabaseInstanceSpecForProviderSettingsIpConfigurationAuthorizedNetworks[];

  /**
   * Whether Google Cloud services such as BigQuery are allowed to access data in this Cloud SQL instance over a private IP connection. SQLSERVER database type is not supported.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfiguration#enablePrivatePathForGoogleCloudServices
   */
  readonly enablePrivatePathForGoogleCloudServices?: boolean;

  /**
   * Whether this Cloud SQL instance should be assigned a public IPV4 address. At least ipv4_enabled must be enabled or a private_network must be configured.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfiguration#ipv4Enabled
   */
  readonly ipv4Enabled?: boolean;

  /**
   * The VPC network from which the Cloud SQL instance is accessible for private IP. For example, projects/myProject/global/networks/default. Specifying a network enables private IP. At least ipv4_enabled must be enabled or a private_network must be configured. This setting can be updated, but it cannot be removed after it is set.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfiguration#privateNetwork
   */
  readonly privateNetwork?: string;

  /**
   * Reference to a Network in compute to populate privateNetwork.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfiguration#privateNetworkRef
   */
  readonly privateNetworkRef?: DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRef;

  /**
   * Selector for a Network in compute to populate privateNetwork.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfiguration#privateNetworkSelector
   */
  readonly privateNetworkSelector?: DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelector;

  /**
   * Whether SSL connections over IP are enforced or not.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfiguration#requireSsl
   */
  readonly requireSsl?: boolean;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsIpConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsIpConfiguration(obj: DatabaseInstanceSpecForProviderSettingsIpConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocatedIpRange': obj.allocatedIpRange,
    'authorizedNetworks': obj.authorizedNetworks?.map(y => toJson_DatabaseInstanceSpecForProviderSettingsIpConfigurationAuthorizedNetworks(y)),
    'enablePrivatePathForGoogleCloudServices': obj.enablePrivatePathForGoogleCloudServices,
    'ipv4Enabled': obj.ipv4Enabled,
    'privateNetwork': obj.privateNetwork,
    'privateNetworkRef': toJson_DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRef(obj.privateNetworkRef),
    'privateNetworkSelector': toJson_DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelector(obj.privateNetworkSelector),
    'requireSsl': obj.requireSsl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderSettingsLocationPreference
 */
export interface DatabaseInstanceSpecForProviderSettingsLocationPreference {
  /**
   * A GAE application whose zone to remain in. Must be in the same region as this instance.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsLocationPreference#followGaeApplication
   */
  readonly followGaeApplication?: string;

  /**
   * The preferred Compute Engine zone for the secondary/failover.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsLocationPreference#secondaryZone
   */
  readonly secondaryZone?: string;

  /**
   * The preferred compute engine zone.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsLocationPreference#zone
   */
  readonly zone?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsLocationPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsLocationPreference(obj: DatabaseInstanceSpecForProviderSettingsLocationPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'followGaeApplication': obj.followGaeApplication,
    'secondaryZone': obj.secondaryZone,
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderSettingsMaintenanceWindow
 */
export interface DatabaseInstanceSpecForProviderSettingsMaintenanceWindow {
  /**
   * Day of week (1-7), starting on Monday
   *
   * @schema DatabaseInstanceSpecForProviderSettingsMaintenanceWindow#day
   */
  readonly day?: number;

  /**
   * Hour of day (0-23), ignored if day not set
   *
   * @schema DatabaseInstanceSpecForProviderSettingsMaintenanceWindow#hour
   */
  readonly hour?: number;

  /**
   * Receive updates earlier (canary) or later (stable)
   *
   * @schema DatabaseInstanceSpecForProviderSettingsMaintenanceWindow#updateTrack
   */
  readonly updateTrack?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsMaintenanceWindow' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsMaintenanceWindow(obj: DatabaseInstanceSpecForProviderSettingsMaintenanceWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'hour': obj.hour,
    'updateTrack': obj.updateTrack,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderSettingsPasswordValidationPolicy
 */
export interface DatabaseInstanceSpecForProviderSettingsPasswordValidationPolicy {
  /**
   * Checks if the password is a combination of lowercase, uppercase, numeric, and non-alphanumeric characters.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsPasswordValidationPolicy#complexity
   */
  readonly complexity?: string;

  /**
   * Prevents the use of the username in the password.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsPasswordValidationPolicy#disallowUsernameSubstring
   */
  readonly disallowUsernameSubstring?: boolean;

  /**
   * Enables or disable the password validation policy.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsPasswordValidationPolicy#enablePasswordPolicy
   */
  readonly enablePasswordPolicy?: boolean;

  /**
   * Specifies the minimum number of characters that the password must have.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsPasswordValidationPolicy#minLength
   */
  readonly minLength?: number;

  /**
   * Specifies the minimum duration after which you can change the password.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsPasswordValidationPolicy#passwordChangeInterval
   */
  readonly passwordChangeInterval?: string;

  /**
   * Specifies the number of previous passwords that you can't reuse.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsPasswordValidationPolicy#reuseInterval
   */
  readonly reuseInterval?: number;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsPasswordValidationPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsPasswordValidationPolicy(obj: DatabaseInstanceSpecForProviderSettingsPasswordValidationPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'complexity': obj.complexity,
    'disallowUsernameSubstring': obj.disallowUsernameSubstring,
    'enablePasswordPolicy': obj.enablePasswordPolicy,
    'minLength': obj.minLength,
    'passwordChangeInterval': obj.passwordChangeInterval,
    'reuseInterval': obj.reuseInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderSettingsSqlServerAuditConfig
 */
export interface DatabaseInstanceSpecForProviderSettingsSqlServerAuditConfig {
  /**
   * The name of the destination bucket (e.g., gs://mybucket).
   *
   * @schema DatabaseInstanceSpecForProviderSettingsSqlServerAuditConfig#bucket
   */
  readonly bucket?: string;

  /**
   * How long to keep generated audit files. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema DatabaseInstanceSpecForProviderSettingsSqlServerAuditConfig#retentionInterval
   */
  readonly retentionInterval?: string;

  /**
   * How often to upload generated audit files. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema DatabaseInstanceSpecForProviderSettingsSqlServerAuditConfig#uploadInterval
   */
  readonly uploadInterval?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsSqlServerAuditConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsSqlServerAuditConfig(obj: DatabaseInstanceSpecForProviderSettingsSqlServerAuditConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'retentionInterval': obj.retentionInterval,
    'uploadInterval': obj.uploadInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderSettingsActiveDirectoryConfig
 */
export interface DatabaseInstanceSpecInitProviderSettingsActiveDirectoryConfig {
  /**
   * The domain name for the active directory (e.g., mydomain.com). Can only be used with SQL Server.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsActiveDirectoryConfig#domain
   */
  readonly domain?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderSettingsActiveDirectoryConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderSettingsActiveDirectoryConfig(obj: DatabaseInstanceSpecInitProviderSettingsActiveDirectoryConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domain': obj.domain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderSettingsAdvancedMachineFeatures
 */
export interface DatabaseInstanceSpecInitProviderSettingsAdvancedMachineFeatures {
  /**
   * The number of threads per core. The value of this flag can be 1 or 2. To disable SMT, set this flag to 1. Only available in Cloud SQL for SQL Server instances. See smt for more details.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsAdvancedMachineFeatures#threadsPerCore
   */
  readonly threadsPerCore?: number;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderSettingsAdvancedMachineFeatures' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderSettingsAdvancedMachineFeatures(obj: DatabaseInstanceSpecInitProviderSettingsAdvancedMachineFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'threadsPerCore': obj.threadsPerCore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderSettingsBackupConfiguration
 */
export interface DatabaseInstanceSpecInitProviderSettingsBackupConfiguration {
  /**
   * Backup retention settings. The configuration is detailed below.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsBackupConfiguration#backupRetentionSettings
   */
  readonly backupRetentionSettings?: DatabaseInstanceSpecInitProviderSettingsBackupConfigurationBackupRetentionSettings[];

  /**
   * True if binary logging is enabled. Can only be used with MySQL.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsBackupConfiguration#binaryLogEnabled
   */
  readonly binaryLogEnabled?: boolean;

  /**
   * True if backup configuration is enabled.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsBackupConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * The region where the backup will be stored
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsBackupConfiguration#location
   */
  readonly location?: string;

  /**
   * True if Point-in-time recovery is enabled. Will restart database if enabled after instance creation. Valid only for PostgreSQL and SQL Server instances.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsBackupConfiguration#pointInTimeRecoveryEnabled
   */
  readonly pointInTimeRecoveryEnabled?: boolean;

  /**
   * HH:MM format time indicating when backup configuration starts.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsBackupConfiguration#startTime
   */
  readonly startTime?: string;

  /**
   * The number of days of transaction logs we retain for point in time restore, from 1-7. For PostgreSQL Enterprise Plus instances, the number of days of retained transaction logs can be set from 1 to 35.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsBackupConfiguration#transactionLogRetentionDays
   */
  readonly transactionLogRetentionDays?: number;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderSettingsBackupConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderSettingsBackupConfiguration(obj: DatabaseInstanceSpecInitProviderSettingsBackupConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupRetentionSettings': obj.backupRetentionSettings?.map(y => toJson_DatabaseInstanceSpecInitProviderSettingsBackupConfigurationBackupRetentionSettings(y)),
    'binaryLogEnabled': obj.binaryLogEnabled,
    'enabled': obj.enabled,
    'location': obj.location,
    'pointInTimeRecoveryEnabled': obj.pointInTimeRecoveryEnabled,
    'startTime': obj.startTime,
    'transactionLogRetentionDays': obj.transactionLogRetentionDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderSettingsDataCacheConfig
 */
export interface DatabaseInstanceSpecInitProviderSettingsDataCacheConfig {
  /**
   * Whether data cache is enabled for the instance. Defaults to false Can only be used with MYSQL.
   *
   * @default false Can only be used with MYSQL.
   * @schema DatabaseInstanceSpecInitProviderSettingsDataCacheConfig#dataCacheEnabled
   */
  readonly dataCacheEnabled?: boolean;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderSettingsDataCacheConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderSettingsDataCacheConfig(obj: DatabaseInstanceSpecInitProviderSettingsDataCacheConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataCacheEnabled': obj.dataCacheEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderSettingsDatabaseFlags
 */
export interface DatabaseInstanceSpecInitProviderSettingsDatabaseFlags {
  /**
   * A name for this whitelist entry.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsDatabaseFlags#name
   */
  readonly name?: string;

  /**
   * A CIDR notation IPv4 or IPv6 address that is allowed to access this instance. Must be set even if other two attributes are not for the whitelist to become active.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsDatabaseFlags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderSettingsDatabaseFlags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderSettingsDatabaseFlags(obj: DatabaseInstanceSpecInitProviderSettingsDatabaseFlags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderSettingsDenyMaintenancePeriod
 */
export interface DatabaseInstanceSpecInitProviderSettingsDenyMaintenancePeriod {
  /**
   * "deny maintenance period" end date. If the year of the end date is empty, the year of the start date also must be empty. In this case, it means the no maintenance interval recurs every year. The date is in format yyyy-mm-dd i.e., 2020-11-01, or mm-dd, i.e., 11-01
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsDenyMaintenancePeriod#endDate
   */
  readonly endDate?: string;

  /**
   * "deny maintenance period" start date. If the year of the start date is empty, the year of the end date also must be empty. In this case, it means the deny maintenance period recurs every year. The date is in format yyyy-mm-dd i.e., 2020-11-01, or mm-dd, i.e., 11-01
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsDenyMaintenancePeriod#startDate
   */
  readonly startDate?: string;

  /**
   * Time in UTC when the "deny maintenance period" starts on startDate and ends on endDate. The time is in format: HH:mm:SS, i.e., 00:00:00
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsDenyMaintenancePeriod#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderSettingsDenyMaintenancePeriod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderSettingsDenyMaintenancePeriod(obj: DatabaseInstanceSpecInitProviderSettingsDenyMaintenancePeriod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endDate': obj.endDate,
    'startDate': obj.startDate,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderSettingsInsightsConfig
 */
export interface DatabaseInstanceSpecInitProviderSettingsInsightsConfig {
  /**
   * True if Query Insights feature is enabled.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsInsightsConfig#queryInsightsEnabled
   */
  readonly queryInsightsEnabled?: boolean;

  /**
   * Number of query execution plans captured by Insights per minute for all queries combined. Between 0 and 20. Default to 5.
   *
   * @default 5.
   * @schema DatabaseInstanceSpecInitProviderSettingsInsightsConfig#queryPlansPerMinute
   */
  readonly queryPlansPerMinute?: number;

  /**
   * Maximum query length stored in bytes. Between 256 and 4500. Default to 1024. Higher query lengths are more useful for analytical queries, but they also require more memory. Changing the query length requires you to restart the instance. You can still add tags to queries that exceed the length limit.
   *
   * @default 1024. Higher query lengths are more useful for analytical queries, but they also require more memory. Changing the query length requires you to restart the instance. You can still add tags to queries that exceed the length limit.
   * @schema DatabaseInstanceSpecInitProviderSettingsInsightsConfig#queryStringLength
   */
  readonly queryStringLength?: number;

  /**
   * True if Query Insights will record application tags from query when enabled.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsInsightsConfig#recordApplicationTags
   */
  readonly recordApplicationTags?: boolean;

  /**
   * True if Query Insights will record client address when enabled.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsInsightsConfig#recordClientAddress
   */
  readonly recordClientAddress?: boolean;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderSettingsInsightsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderSettingsInsightsConfig(obj: DatabaseInstanceSpecInitProviderSettingsInsightsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'queryInsightsEnabled': obj.queryInsightsEnabled,
    'queryPlansPerMinute': obj.queryPlansPerMinute,
    'queryStringLength': obj.queryStringLength,
    'recordApplicationTags': obj.recordApplicationTags,
    'recordClientAddress': obj.recordClientAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderSettingsIpConfiguration
 */
export interface DatabaseInstanceSpecInitProviderSettingsIpConfiguration {
  /**
   * The name of the allocated ip range for the private ip CloudSQL instance. For example: "google-managed-services-default". If set, the instance ip will be created in the allocated range. The range name must comply with RFC 1035. Specifically, the name must be 1-63 characters long and match the regular expression a-z?.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsIpConfiguration#allocatedIpRange
   */
  readonly allocatedIpRange?: string;

  /**
   * @schema DatabaseInstanceSpecInitProviderSettingsIpConfiguration#authorizedNetworks
   */
  readonly authorizedNetworks?: DatabaseInstanceSpecInitProviderSettingsIpConfigurationAuthorizedNetworks[];

  /**
   * Whether Google Cloud services such as BigQuery are allowed to access data in this Cloud SQL instance over a private IP connection. SQLSERVER database type is not supported.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsIpConfiguration#enablePrivatePathForGoogleCloudServices
   */
  readonly enablePrivatePathForGoogleCloudServices?: boolean;

  /**
   * Whether this Cloud SQL instance should be assigned a public IPV4 address. At least ipv4_enabled must be enabled or a private_network must be configured.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsIpConfiguration#ipv4Enabled
   */
  readonly ipv4Enabled?: boolean;

  /**
   * Whether SSL connections over IP are enforced or not.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsIpConfiguration#requireSsl
   */
  readonly requireSsl?: boolean;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderSettingsIpConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderSettingsIpConfiguration(obj: DatabaseInstanceSpecInitProviderSettingsIpConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocatedIpRange': obj.allocatedIpRange,
    'authorizedNetworks': obj.authorizedNetworks?.map(y => toJson_DatabaseInstanceSpecInitProviderSettingsIpConfigurationAuthorizedNetworks(y)),
    'enablePrivatePathForGoogleCloudServices': obj.enablePrivatePathForGoogleCloudServices,
    'ipv4Enabled': obj.ipv4Enabled,
    'requireSsl': obj.requireSsl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderSettingsLocationPreference
 */
export interface DatabaseInstanceSpecInitProviderSettingsLocationPreference {
  /**
   * A GAE application whose zone to remain in. Must be in the same region as this instance.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsLocationPreference#followGaeApplication
   */
  readonly followGaeApplication?: string;

  /**
   * The preferred Compute Engine zone for the secondary/failover.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsLocationPreference#secondaryZone
   */
  readonly secondaryZone?: string;

  /**
   * The preferred compute engine zone.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsLocationPreference#zone
   */
  readonly zone?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderSettingsLocationPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderSettingsLocationPreference(obj: DatabaseInstanceSpecInitProviderSettingsLocationPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'followGaeApplication': obj.followGaeApplication,
    'secondaryZone': obj.secondaryZone,
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderSettingsMaintenanceWindow
 */
export interface DatabaseInstanceSpecInitProviderSettingsMaintenanceWindow {
  /**
   * Day of week (1-7), starting on Monday
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsMaintenanceWindow#day
   */
  readonly day?: number;

  /**
   * Hour of day (0-23), ignored if day not set
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsMaintenanceWindow#hour
   */
  readonly hour?: number;

  /**
   * Receive updates earlier (canary) or later (stable)
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsMaintenanceWindow#updateTrack
   */
  readonly updateTrack?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderSettingsMaintenanceWindow' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderSettingsMaintenanceWindow(obj: DatabaseInstanceSpecInitProviderSettingsMaintenanceWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'hour': obj.hour,
    'updateTrack': obj.updateTrack,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderSettingsPasswordValidationPolicy
 */
export interface DatabaseInstanceSpecInitProviderSettingsPasswordValidationPolicy {
  /**
   * Checks if the password is a combination of lowercase, uppercase, numeric, and non-alphanumeric characters.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsPasswordValidationPolicy#complexity
   */
  readonly complexity?: string;

  /**
   * Prevents the use of the username in the password.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsPasswordValidationPolicy#disallowUsernameSubstring
   */
  readonly disallowUsernameSubstring?: boolean;

  /**
   * Enables or disable the password validation policy.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsPasswordValidationPolicy#enablePasswordPolicy
   */
  readonly enablePasswordPolicy?: boolean;

  /**
   * Specifies the minimum number of characters that the password must have.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsPasswordValidationPolicy#minLength
   */
  readonly minLength?: number;

  /**
   * Specifies the minimum duration after which you can change the password.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsPasswordValidationPolicy#passwordChangeInterval
   */
  readonly passwordChangeInterval?: string;

  /**
   * Specifies the number of previous passwords that you can't reuse.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsPasswordValidationPolicy#reuseInterval
   */
  readonly reuseInterval?: number;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderSettingsPasswordValidationPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderSettingsPasswordValidationPolicy(obj: DatabaseInstanceSpecInitProviderSettingsPasswordValidationPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'complexity': obj.complexity,
    'disallowUsernameSubstring': obj.disallowUsernameSubstring,
    'enablePasswordPolicy': obj.enablePasswordPolicy,
    'minLength': obj.minLength,
    'passwordChangeInterval': obj.passwordChangeInterval,
    'reuseInterval': obj.reuseInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderSettingsSqlServerAuditConfig
 */
export interface DatabaseInstanceSpecInitProviderSettingsSqlServerAuditConfig {
  /**
   * The name of the destination bucket (e.g., gs://mybucket).
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsSqlServerAuditConfig#bucket
   */
  readonly bucket?: string;

  /**
   * How long to keep generated audit files. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsSqlServerAuditConfig#retentionInterval
   */
  readonly retentionInterval?: string;

  /**
   * How often to upload generated audit files. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsSqlServerAuditConfig#uploadInterval
   */
  readonly uploadInterval?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderSettingsSqlServerAuditConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderSettingsSqlServerAuditConfig(obj: DatabaseInstanceSpecInitProviderSettingsSqlServerAuditConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'retentionInterval': obj.retentionInterval,
    'uploadInterval': obj.uploadInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseInstanceSpecProviderConfigRefPolicyResolution
 */
export enum DatabaseInstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseInstanceSpecProviderConfigRefPolicyResolve
 */
export enum DatabaseInstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatabaseInstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DatabaseInstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DatabaseInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DatabaseInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: DatabaseInstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderSettingsBackupConfigurationBackupRetentionSettings
 */
export interface DatabaseInstanceSpecForProviderSettingsBackupConfigurationBackupRetentionSettings {
  /**
   * Depending on the value of retention_unit, this is used to determine if a backup needs to be deleted. If retention_unit is 'COUNT', we will retain this many backups.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsBackupConfigurationBackupRetentionSettings#retainedBackups
   */
  readonly retainedBackups?: number;

  /**
   * The unit that 'retained_backups' represents. Defaults to COUNT.
   *
   * @default COUNT.
   * @schema DatabaseInstanceSpecForProviderSettingsBackupConfigurationBackupRetentionSettings#retentionUnit
   */
  readonly retentionUnit?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsBackupConfigurationBackupRetentionSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsBackupConfigurationBackupRetentionSettings(obj: DatabaseInstanceSpecForProviderSettingsBackupConfigurationBackupRetentionSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'retainedBackups': obj.retainedBackups,
    'retentionUnit': obj.retentionUnit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationAuthorizedNetworks
 */
export interface DatabaseInstanceSpecForProviderSettingsIpConfigurationAuthorizedNetworks {
  /**
   * The RFC 3339 formatted date time string indicating when this whitelist expires.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationAuthorizedNetworks#expirationTime
   */
  readonly expirationTime?: string;

  /**
   * A name for this whitelist entry.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationAuthorizedNetworks#name
   */
  readonly name?: string;

  /**
   * A CIDR notation IPv4 or IPv6 address that is allowed to access this instance. Must be set even if other two attributes are not for the whitelist to become active.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationAuthorizedNetworks#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsIpConfigurationAuthorizedNetworks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsIpConfigurationAuthorizedNetworks(obj: DatabaseInstanceSpecForProviderSettingsIpConfigurationAuthorizedNetworks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expirationTime': obj.expirationTime,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Network in compute to populate privateNetwork.
 *
 * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRef
 */
export interface DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRef#policy
   */
  readonly policy?: DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRefPolicy;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRef(obj: DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Network in compute to populate privateNetwork.
 *
 * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelector
 */
export interface DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelector#policy
   */
  readonly policy?: DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelectorPolicy;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelector(obj: DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderSettingsBackupConfigurationBackupRetentionSettings
 */
export interface DatabaseInstanceSpecInitProviderSettingsBackupConfigurationBackupRetentionSettings {
  /**
   * Depending on the value of retention_unit, this is used to determine if a backup needs to be deleted. If retention_unit is 'COUNT', we will retain this many backups.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsBackupConfigurationBackupRetentionSettings#retainedBackups
   */
  readonly retainedBackups?: number;

  /**
   * The unit that 'retained_backups' represents. Defaults to COUNT.
   *
   * @default COUNT.
   * @schema DatabaseInstanceSpecInitProviderSettingsBackupConfigurationBackupRetentionSettings#retentionUnit
   */
  readonly retentionUnit?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderSettingsBackupConfigurationBackupRetentionSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderSettingsBackupConfigurationBackupRetentionSettings(obj: DatabaseInstanceSpecInitProviderSettingsBackupConfigurationBackupRetentionSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'retainedBackups': obj.retainedBackups,
    'retentionUnit': obj.retentionUnit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseInstanceSpecInitProviderSettingsIpConfigurationAuthorizedNetworks
 */
export interface DatabaseInstanceSpecInitProviderSettingsIpConfigurationAuthorizedNetworks {
  /**
   * The RFC 3339 formatted date time string indicating when this whitelist expires.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsIpConfigurationAuthorizedNetworks#expirationTime
   */
  readonly expirationTime?: string;

  /**
   * A name for this whitelist entry.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsIpConfigurationAuthorizedNetworks#name
   */
  readonly name?: string;

  /**
   * A CIDR notation IPv4 or IPv6 address that is allowed to access this instance. Must be set even if other two attributes are not for the whitelist to become active.
   *
   * @schema DatabaseInstanceSpecInitProviderSettingsIpConfigurationAuthorizedNetworks#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecInitProviderSettingsIpConfigurationAuthorizedNetworks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecInitProviderSettingsIpConfigurationAuthorizedNetworks(obj: DatabaseInstanceSpecInitProviderSettingsIpConfigurationAuthorizedNetworks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expirationTime': obj.expirationTime,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DatabaseInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DatabaseInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRefPolicy
 */
export interface DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRefPolicy#resolution
   */
  readonly resolution?: DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRefPolicy#resolve
   */
  readonly resolve?: DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRefPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRefPolicy(obj: DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelectorPolicy
 */
export interface DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelectorPolicy#resolution
   */
  readonly resolution?: DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelectorPolicy#resolve
   */
  readonly resolve?: DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelectorPolicy(obj: DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRefPolicyResolution
 */
export enum DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRefPolicyResolve
 */
export enum DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelectorPolicyResolution
 */
export enum DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelectorPolicyResolve
 */
export enum DatabaseInstanceSpecForProviderSettingsIpConfigurationPrivateNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SourceRepresentationInstance is the Schema for the SourceRepresentationInstances API. A source representation instance is a Cloud SQL instance that represents the source database server to the Cloud SQL replica.
 *
 * @schema SourceRepresentationInstance
 */
export class SourceRepresentationInstance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SourceRepresentationInstance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sql.gcp.upbound.io/v1beta1',
    kind: 'SourceRepresentationInstance',
  }

  /**
   * Renders a Kubernetes manifest for "SourceRepresentationInstance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SourceRepresentationInstanceProps): any {
    return {
      ...SourceRepresentationInstance.GVK,
      ...toJson_SourceRepresentationInstanceProps(props),
    };
  }

  /**
   * Defines a "SourceRepresentationInstance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SourceRepresentationInstanceProps) {
    super(scope, id, {
      ...SourceRepresentationInstance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SourceRepresentationInstance.GVK,
      ...toJson_SourceRepresentationInstanceProps(resolved),
    };
  }
}

/**
 * SourceRepresentationInstance is the Schema for the SourceRepresentationInstances API. A source representation instance is a Cloud SQL instance that represents the source database server to the Cloud SQL replica.
 *
 * @schema SourceRepresentationInstance
 */
export interface SourceRepresentationInstanceProps {
  /**
   * @schema SourceRepresentationInstance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SourceRepresentationInstanceSpec defines the desired state of SourceRepresentationInstance
   *
   * @schema SourceRepresentationInstance#spec
   */
  readonly spec: SourceRepresentationInstanceSpec;

}

/**
 * Converts an object of type 'SourceRepresentationInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SourceRepresentationInstanceProps(obj: SourceRepresentationInstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SourceRepresentationInstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SourceRepresentationInstanceSpec defines the desired state of SourceRepresentationInstance
 *
 * @schema SourceRepresentationInstanceSpec
 */
export interface SourceRepresentationInstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SourceRepresentationInstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: SourceRepresentationInstanceSpecDeletionPolicy;

  /**
   * @schema SourceRepresentationInstanceSpec#forProvider
   */
  readonly forProvider: SourceRepresentationInstanceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SourceRepresentationInstanceSpec#initProvider
   */
  readonly initProvider?: SourceRepresentationInstanceSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SourceRepresentationInstanceSpec#managementPolicies
   */
  readonly managementPolicies?: SourceRepresentationInstanceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SourceRepresentationInstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: SourceRepresentationInstanceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SourceRepresentationInstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SourceRepresentationInstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SourceRepresentationInstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SourceRepresentationInstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SourceRepresentationInstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SourceRepresentationInstanceSpec(obj: SourceRepresentationInstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SourceRepresentationInstanceSpecForProvider(obj.forProvider),
    'initProvider': toJson_SourceRepresentationInstanceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SourceRepresentationInstanceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SourceRepresentationInstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SourceRepresentationInstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SourceRepresentationInstanceSpecDeletionPolicy
 */
export enum SourceRepresentationInstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SourceRepresentationInstanceSpecForProvider
 */
export interface SourceRepresentationInstanceSpecForProvider {
  /**
   * The CA certificate on the external server. Include only if SSL/TLS is used on the external server.
   *
   * @schema SourceRepresentationInstanceSpecForProvider#caCertificate
   */
  readonly caCertificate?: string;

  /**
   * The client certificate on the external server. Required only for server-client authentication. Include only if SSL/TLS is used on the external server.
   *
   * @schema SourceRepresentationInstanceSpecForProvider#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The private key file for the client certificate on the external server. Required only for server-client authentication. Include only if SSL/TLS is used on the external server.
   *
   * @schema SourceRepresentationInstanceSpecForProvider#clientKey
   */
  readonly clientKey?: string;

  /**
   * The MySQL version running on your source database server. Possible values are: MYSQL_5_6, MYSQL_5_7, MYSQL_8_0, POSTGRES_9_6, POSTGRES_10, POSTGRES_11, POSTGRES_12, POSTGRES_13, POSTGRES_14.
   *
   * @schema SourceRepresentationInstanceSpecForProvider#databaseVersion
   */
  readonly databaseVersion?: string;

  /**
   * A file in the bucket that contains the data from the external server.
   *
   * @schema SourceRepresentationInstanceSpecForProvider#dumpFilePath
   */
  readonly dumpFilePath?: string;

  /**
   * The externally accessible IPv4 address for the source database server.
   *
   * @schema SourceRepresentationInstanceSpecForProvider#host
   */
  readonly host?: string;

  /**
   * The password for the replication user account. Note: This property is sensitive and will not be displayed in the plan.
   *
   * @schema SourceRepresentationInstanceSpecForProvider#passwordSecretRef
   */
  readonly passwordSecretRef?: SourceRepresentationInstanceSpecForProviderPasswordSecretRef;

  /**
   * The externally accessible port for the source database server. Defaults to 3306.
   *
   * @default 3306.
   * @schema SourceRepresentationInstanceSpecForProvider#port
   */
  readonly port?: number;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema SourceRepresentationInstanceSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The Region in which the created instance should reside. If it is not provided, the provider region is used.
   *
   * @schema SourceRepresentationInstanceSpecForProvider#region
   */
  readonly region?: string;

  /**
   * The replication user account on the external server.
   *
   * @schema SourceRepresentationInstanceSpecForProvider#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'SourceRepresentationInstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SourceRepresentationInstanceSpecForProvider(obj: SourceRepresentationInstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificate': obj.caCertificate,
    'clientCertificate': obj.clientCertificate,
    'clientKey': obj.clientKey,
    'databaseVersion': obj.databaseVersion,
    'dumpFilePath': obj.dumpFilePath,
    'host': obj.host,
    'passwordSecretRef': toJson_SourceRepresentationInstanceSpecForProviderPasswordSecretRef(obj.passwordSecretRef),
    'port': obj.port,
    'project': obj.project,
    'region': obj.region,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SourceRepresentationInstanceSpecInitProvider
 */
export interface SourceRepresentationInstanceSpecInitProvider {
  /**
   * The CA certificate on the external server. Include only if SSL/TLS is used on the external server.
   *
   * @schema SourceRepresentationInstanceSpecInitProvider#caCertificate
   */
  readonly caCertificate?: string;

  /**
   * The client certificate on the external server. Required only for server-client authentication. Include only if SSL/TLS is used on the external server.
   *
   * @schema SourceRepresentationInstanceSpecInitProvider#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The private key file for the client certificate on the external server. Required only for server-client authentication. Include only if SSL/TLS is used on the external server.
   *
   * @schema SourceRepresentationInstanceSpecInitProvider#clientKey
   */
  readonly clientKey?: string;

  /**
   * The MySQL version running on your source database server. Possible values are: MYSQL_5_6, MYSQL_5_7, MYSQL_8_0, POSTGRES_9_6, POSTGRES_10, POSTGRES_11, POSTGRES_12, POSTGRES_13, POSTGRES_14.
   *
   * @schema SourceRepresentationInstanceSpecInitProvider#databaseVersion
   */
  readonly databaseVersion?: string;

  /**
   * A file in the bucket that contains the data from the external server.
   *
   * @schema SourceRepresentationInstanceSpecInitProvider#dumpFilePath
   */
  readonly dumpFilePath?: string;

  /**
   * The externally accessible IPv4 address for the source database server.
   *
   * @schema SourceRepresentationInstanceSpecInitProvider#host
   */
  readonly host?: string;

  /**
   * The externally accessible port for the source database server. Defaults to 3306.
   *
   * @default 3306.
   * @schema SourceRepresentationInstanceSpecInitProvider#port
   */
  readonly port?: number;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema SourceRepresentationInstanceSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The Region in which the created instance should reside. If it is not provided, the provider region is used.
   *
   * @schema SourceRepresentationInstanceSpecInitProvider#region
   */
  readonly region?: string;

  /**
   * The replication user account on the external server.
   *
   * @schema SourceRepresentationInstanceSpecInitProvider#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'SourceRepresentationInstanceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SourceRepresentationInstanceSpecInitProvider(obj: SourceRepresentationInstanceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificate': obj.caCertificate,
    'clientCertificate': obj.clientCertificate,
    'clientKey': obj.clientKey,
    'databaseVersion': obj.databaseVersion,
    'dumpFilePath': obj.dumpFilePath,
    'host': obj.host,
    'port': obj.port,
    'project': obj.project,
    'region': obj.region,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SourceRepresentationInstanceSpecManagementPolicies
 */
export enum SourceRepresentationInstanceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SourceRepresentationInstanceSpecProviderConfigRef
 */
export interface SourceRepresentationInstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SourceRepresentationInstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SourceRepresentationInstanceSpecProviderConfigRef#policy
   */
  readonly policy?: SourceRepresentationInstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SourceRepresentationInstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SourceRepresentationInstanceSpecProviderConfigRef(obj: SourceRepresentationInstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SourceRepresentationInstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SourceRepresentationInstanceSpecPublishConnectionDetailsTo
 */
export interface SourceRepresentationInstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SourceRepresentationInstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SourceRepresentationInstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SourceRepresentationInstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SourceRepresentationInstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SourceRepresentationInstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SourceRepresentationInstanceSpecPublishConnectionDetailsTo(obj: SourceRepresentationInstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SourceRepresentationInstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SourceRepresentationInstanceSpecWriteConnectionSecretToRef
 */
export interface SourceRepresentationInstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SourceRepresentationInstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SourceRepresentationInstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SourceRepresentationInstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SourceRepresentationInstanceSpecWriteConnectionSecretToRef(obj: SourceRepresentationInstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The password for the replication user account. Note: This property is sensitive and will not be displayed in the plan.
 *
 * @schema SourceRepresentationInstanceSpecForProviderPasswordSecretRef
 */
export interface SourceRepresentationInstanceSpecForProviderPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema SourceRepresentationInstanceSpecForProviderPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema SourceRepresentationInstanceSpecForProviderPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SourceRepresentationInstanceSpecForProviderPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SourceRepresentationInstanceSpecForProviderPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SourceRepresentationInstanceSpecForProviderPasswordSecretRef(obj: SourceRepresentationInstanceSpecForProviderPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SourceRepresentationInstanceSpecProviderConfigRefPolicy
 */
export interface SourceRepresentationInstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SourceRepresentationInstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SourceRepresentationInstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SourceRepresentationInstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SourceRepresentationInstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SourceRepresentationInstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SourceRepresentationInstanceSpecProviderConfigRefPolicy(obj: SourceRepresentationInstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRef(obj: SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SourceRepresentationInstanceSpecPublishConnectionDetailsToMetadata
 */
export interface SourceRepresentationInstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SourceRepresentationInstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SourceRepresentationInstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SourceRepresentationInstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SourceRepresentationInstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SourceRepresentationInstanceSpecPublishConnectionDetailsToMetadata(obj: SourceRepresentationInstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SourceRepresentationInstanceSpecProviderConfigRefPolicyResolution
 */
export enum SourceRepresentationInstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SourceRepresentationInstanceSpecProviderConfigRefPolicyResolve
 */
export enum SourceRepresentationInstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SourceRepresentationInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SSLCert is the Schema for the SSLCerts API. Creates a new SQL Ssl Cert in Google Cloud SQL.
 *
 * @schema SSLCert
 */
export class SslCert extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SSLCert"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sql.gcp.upbound.io/v1beta1',
    kind: 'SSLCert',
  }

  /**
   * Renders a Kubernetes manifest for "SSLCert".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SslCertProps): any {
    return {
      ...SslCert.GVK,
      ...toJson_SslCertProps(props),
    };
  }

  /**
   * Defines a "SSLCert" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SslCertProps) {
    super(scope, id, {
      ...SslCert.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SslCert.GVK,
      ...toJson_SslCertProps(resolved),
    };
  }
}

/**
 * SSLCert is the Schema for the SSLCerts API. Creates a new SQL Ssl Cert in Google Cloud SQL.
 *
 * @schema SSLCert
 */
export interface SslCertProps {
  /**
   * @schema SSLCert#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SSLCertSpec defines the desired state of SSLCert
   *
   * @schema SSLCert#spec
   */
  readonly spec: SslCertSpec;

}

/**
 * Converts an object of type 'SslCertProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SslCertProps(obj: SslCertProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SslCertSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SSLCertSpec defines the desired state of SSLCert
 *
 * @schema SslCertSpec
 */
export interface SslCertSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SslCertSpec#deletionPolicy
   */
  readonly deletionPolicy?: SslCertSpecDeletionPolicy;

  /**
   * @schema SslCertSpec#forProvider
   */
  readonly forProvider: SslCertSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SslCertSpec#initProvider
   */
  readonly initProvider?: SslCertSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SslCertSpec#managementPolicies
   */
  readonly managementPolicies?: SslCertSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SslCertSpec#providerConfigRef
   */
  readonly providerConfigRef?: SslCertSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SslCertSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SslCertSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SslCertSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SslCertSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SslCertSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SslCertSpec(obj: SslCertSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SslCertSpecForProvider(obj.forProvider),
    'initProvider': toJson_SslCertSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SslCertSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SslCertSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SslCertSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SslCertSpecDeletionPolicy
 */
export enum SslCertSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SslCertSpecForProvider
 */
export interface SslCertSpecForProvider {
  /**
   * The common name to be used in the certificate to identify the client. Constrained to [a-zA-Z.-_ ]+. Changing this forces a new resource to be created.
   *
   * @schema SslCertSpecForProvider#commonName
   */
  readonly commonName?: string;

  /**
   * The name of the Cloud SQL instance. Changing this forces a new resource to be created.
   *
   * @schema SslCertSpecForProvider#instance
   */
  readonly instance?: string;

  /**
   * Reference to a DatabaseInstance to populate instance.
   *
   * @schema SslCertSpecForProvider#instanceRef
   */
  readonly instanceRef?: SslCertSpecForProviderInstanceRef;

  /**
   * Selector for a DatabaseInstance to populate instance.
   *
   * @schema SslCertSpecForProvider#instanceSelector
   */
  readonly instanceSelector?: SslCertSpecForProviderInstanceSelector;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema SslCertSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'SslCertSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SslCertSpecForProvider(obj: SslCertSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonName': obj.commonName,
    'instance': obj.instance,
    'instanceRef': toJson_SslCertSpecForProviderInstanceRef(obj.instanceRef),
    'instanceSelector': toJson_SslCertSpecForProviderInstanceSelector(obj.instanceSelector),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SslCertSpecInitProvider
 */
export interface SslCertSpecInitProvider {
  /**
   * The common name to be used in the certificate to identify the client. Constrained to [a-zA-Z.-_ ]+. Changing this forces a new resource to be created.
   *
   * @schema SslCertSpecInitProvider#commonName
   */
  readonly commonName?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema SslCertSpecInitProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'SslCertSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SslCertSpecInitProvider(obj: SslCertSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonName': obj.commonName,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SslCertSpecManagementPolicies
 */
export enum SslCertSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SslCertSpecProviderConfigRef
 */
export interface SslCertSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SslCertSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SslCertSpecProviderConfigRef#policy
   */
  readonly policy?: SslCertSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SslCertSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SslCertSpecProviderConfigRef(obj: SslCertSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SslCertSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SslCertSpecPublishConnectionDetailsTo
 */
export interface SslCertSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SslCertSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SslCertSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SslCertSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SslCertSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SslCertSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SslCertSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SslCertSpecPublishConnectionDetailsTo(obj: SslCertSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SslCertSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SslCertSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SslCertSpecWriteConnectionSecretToRef
 */
export interface SslCertSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SslCertSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SslCertSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SslCertSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SslCertSpecWriteConnectionSecretToRef(obj: SslCertSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DatabaseInstance to populate instance.
 *
 * @schema SslCertSpecForProviderInstanceRef
 */
export interface SslCertSpecForProviderInstanceRef {
  /**
   * Name of the referenced object.
   *
   * @schema SslCertSpecForProviderInstanceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SslCertSpecForProviderInstanceRef#policy
   */
  readonly policy?: SslCertSpecForProviderInstanceRefPolicy;

}

/**
 * Converts an object of type 'SslCertSpecForProviderInstanceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SslCertSpecForProviderInstanceRef(obj: SslCertSpecForProviderInstanceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SslCertSpecForProviderInstanceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DatabaseInstance to populate instance.
 *
 * @schema SslCertSpecForProviderInstanceSelector
 */
export interface SslCertSpecForProviderInstanceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SslCertSpecForProviderInstanceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SslCertSpecForProviderInstanceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SslCertSpecForProviderInstanceSelector#policy
   */
  readonly policy?: SslCertSpecForProviderInstanceSelectorPolicy;

}

/**
 * Converts an object of type 'SslCertSpecForProviderInstanceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SslCertSpecForProviderInstanceSelector(obj: SslCertSpecForProviderInstanceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SslCertSpecForProviderInstanceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SslCertSpecProviderConfigRefPolicy
 */
export interface SslCertSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SslCertSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SslCertSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SslCertSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SslCertSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SslCertSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SslCertSpecProviderConfigRefPolicy(obj: SslCertSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SslCertSpecPublishConnectionDetailsToConfigRef
 */
export interface SslCertSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SslCertSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SslCertSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SslCertSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SslCertSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SslCertSpecPublishConnectionDetailsToConfigRef(obj: SslCertSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SslCertSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SslCertSpecPublishConnectionDetailsToMetadata
 */
export interface SslCertSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SslCertSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SslCertSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SslCertSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SslCertSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SslCertSpecPublishConnectionDetailsToMetadata(obj: SslCertSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SslCertSpecForProviderInstanceRefPolicy
 */
export interface SslCertSpecForProviderInstanceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SslCertSpecForProviderInstanceRefPolicy#resolution
   */
  readonly resolution?: SslCertSpecForProviderInstanceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SslCertSpecForProviderInstanceRefPolicy#resolve
   */
  readonly resolve?: SslCertSpecForProviderInstanceRefPolicyResolve;

}

/**
 * Converts an object of type 'SslCertSpecForProviderInstanceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SslCertSpecForProviderInstanceRefPolicy(obj: SslCertSpecForProviderInstanceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SslCertSpecForProviderInstanceSelectorPolicy
 */
export interface SslCertSpecForProviderInstanceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SslCertSpecForProviderInstanceSelectorPolicy#resolution
   */
  readonly resolution?: SslCertSpecForProviderInstanceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SslCertSpecForProviderInstanceSelectorPolicy#resolve
   */
  readonly resolve?: SslCertSpecForProviderInstanceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SslCertSpecForProviderInstanceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SslCertSpecForProviderInstanceSelectorPolicy(obj: SslCertSpecForProviderInstanceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SslCertSpecProviderConfigRefPolicyResolution
 */
export enum SslCertSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SslCertSpecProviderConfigRefPolicyResolve
 */
export enum SslCertSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SslCertSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SslCertSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SslCertSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SslCertSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SslCertSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SslCertSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SslCertSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SslCertSpecPublishConnectionDetailsToConfigRefPolicy(obj: SslCertSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SslCertSpecForProviderInstanceRefPolicyResolution
 */
export enum SslCertSpecForProviderInstanceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SslCertSpecForProviderInstanceRefPolicyResolve
 */
export enum SslCertSpecForProviderInstanceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SslCertSpecForProviderInstanceSelectorPolicyResolution
 */
export enum SslCertSpecForProviderInstanceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SslCertSpecForProviderInstanceSelectorPolicyResolve
 */
export enum SslCertSpecForProviderInstanceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SslCertSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SslCertSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SslCertSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SslCertSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * User is the Schema for the Users API. Creates a new SQL user in Google Cloud SQL.
 *
 * @schema User
 */
export class User extends ApiObject {
  /**
   * Returns the apiVersion and kind for "User"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sql.gcp.upbound.io/v1beta1',
    kind: 'User',
  }

  /**
   * Renders a Kubernetes manifest for "User".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserProps): any {
    return {
      ...User.GVK,
      ...toJson_UserProps(props),
    };
  }

  /**
   * Defines a "User" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserProps) {
    super(scope, id, {
      ...User.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...User.GVK,
      ...toJson_UserProps(resolved),
    };
  }
}

/**
 * User is the Schema for the Users API. Creates a new SQL user in Google Cloud SQL.
 *
 * @schema User
 */
export interface UserProps {
  /**
   * @schema User#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserSpec defines the desired state of User
   *
   * @schema User#spec
   */
  readonly spec: UserSpec;

}

/**
 * Converts an object of type 'UserProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProps(obj: UserProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserSpec defines the desired state of User
 *
 * @schema UserSpec
 */
export interface UserSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserSpecDeletionPolicy;

  /**
   * @schema UserSpec#forProvider
   */
  readonly forProvider: UserSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema UserSpec#initProvider
   */
  readonly initProvider?: UserSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema UserSpec#managementPolicies
   */
  readonly managementPolicies?: UserSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpec(obj: UserSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserSpecForProvider(obj.forProvider),
    'initProvider': toJson_UserSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_UserSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_UserSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserSpecDeletionPolicy
 */
export enum UserSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserSpecForProvider
 */
export interface UserSpecForProvider {
  /**
   * The deletion policy for the user. Setting ABANDON allows the resource to be abandoned rather than deleted. This is useful for Postgres, where users cannot be deleted from the API if they have been granted SQL roles.
   *
   * @schema UserSpecForProvider#deletionPolicy
   */
  readonly deletionPolicy?: string;

  /**
   * The host the user can connect from. This is only supported for BUILT_IN users in MySQL instances. Don't set this field for PostgreSQL and SQL Server instances. Can be an IP address. Changing this forces a new resource to be created.
   *
   * @schema UserSpecForProvider#host
   */
  readonly host?: string;

  /**
   * The name of the Cloud SQL instance. Changing this forces a new resource to be created.
   *
   * @schema UserSpecForProvider#instance
   */
  readonly instance?: string;

  /**
   * Reference to a DatabaseInstance to populate instance.
   *
   * @schema UserSpecForProvider#instanceRef
   */
  readonly instanceRef?: UserSpecForProviderInstanceRef;

  /**
   * Selector for a DatabaseInstance to populate instance.
   *
   * @schema UserSpecForProvider#instanceSelector
   */
  readonly instanceSelector?: UserSpecForProviderInstanceSelector;

  /**
   * @schema UserSpecForProvider#passwordPolicy
   */
  readonly passwordPolicy?: UserSpecForProviderPasswordPolicy[];

  /**
   * The password for the user. Can be updated. For Postgres instances this is a Required field, unless type is set to either CLOUD_IAM_USER or CLOUD_IAM_SERVICE_ACCOUNT. Don't set this field for CLOUD_IAM_USER and CLOUD_IAM_SERVICE_ACCOUNT user types for any Cloud SQL instance.
   *
   * @schema UserSpecForProvider#passwordSecretRef
   */
  readonly passwordSecretRef?: UserSpecForProviderPasswordSecretRef;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema UserSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The user type. It determines the method to authenticate the user during login. The default is the database's built-in user type. Flags include "BUILT_IN", "CLOUD_IAM_USER", or "CLOUD_IAM_SERVICE_ACCOUNT".
   *
   * @schema UserSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProvider(obj: UserSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'host': obj.host,
    'instance': obj.instance,
    'instanceRef': toJson_UserSpecForProviderInstanceRef(obj.instanceRef),
    'instanceSelector': toJson_UserSpecForProviderInstanceSelector(obj.instanceSelector),
    'passwordPolicy': obj.passwordPolicy?.map(y => toJson_UserSpecForProviderPasswordPolicy(y)),
    'passwordSecretRef': toJson_UserSpecForProviderPasswordSecretRef(obj.passwordSecretRef),
    'project': obj.project,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema UserSpecInitProvider
 */
export interface UserSpecInitProvider {
  /**
   * The deletion policy for the user. Setting ABANDON allows the resource to be abandoned rather than deleted. This is useful for Postgres, where users cannot be deleted from the API if they have been granted SQL roles.
   *
   * @schema UserSpecInitProvider#deletionPolicy
   */
  readonly deletionPolicy?: string;

  /**
   * The host the user can connect from. This is only supported for BUILT_IN users in MySQL instances. Don't set this field for PostgreSQL and SQL Server instances. Can be an IP address. Changing this forces a new resource to be created.
   *
   * @schema UserSpecInitProvider#host
   */
  readonly host?: string;

  /**
   * @schema UserSpecInitProvider#passwordPolicy
   */
  readonly passwordPolicy?: UserSpecInitProviderPasswordPolicy[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema UserSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The user type. It determines the method to authenticate the user during login. The default is the database's built-in user type. Flags include "BUILT_IN", "CLOUD_IAM_USER", or "CLOUD_IAM_SERVICE_ACCOUNT".
   *
   * @schema UserSpecInitProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecInitProvider(obj: UserSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'host': obj.host,
    'passwordPolicy': obj.passwordPolicy?.map(y => toJson_UserSpecInitProviderPasswordPolicy(y)),
    'project': obj.project,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema UserSpecManagementPolicies
 */
export enum UserSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserSpecProviderConfigRef
 */
export interface UserSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecProviderConfigRef#policy
   */
  readonly policy?: UserSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderConfigRef(obj: UserSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserSpecPublishConnectionDetailsTo
 */
export interface UserSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsTo(obj: UserSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserSpecWriteConnectionSecretToRef
 */
export interface UserSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecWriteConnectionSecretToRef(obj: UserSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DatabaseInstance to populate instance.
 *
 * @schema UserSpecForProviderInstanceRef
 */
export interface UserSpecForProviderInstanceRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecForProviderInstanceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecForProviderInstanceRef#policy
   */
  readonly policy?: UserSpecForProviderInstanceRefPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderInstanceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderInstanceRef(obj: UserSpecForProviderInstanceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecForProviderInstanceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DatabaseInstance to populate instance.
 *
 * @schema UserSpecForProviderInstanceSelector
 */
export interface UserSpecForProviderInstanceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserSpecForProviderInstanceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserSpecForProviderInstanceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserSpecForProviderInstanceSelector#policy
   */
  readonly policy?: UserSpecForProviderInstanceSelectorPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderInstanceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderInstanceSelector(obj: UserSpecForProviderInstanceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserSpecForProviderInstanceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecForProviderPasswordPolicy
 */
export interface UserSpecForProviderPasswordPolicy {
  /**
   * Number of failed attempts allowed before the user get locked.
   *
   * @schema UserSpecForProviderPasswordPolicy#allowedFailedAttempts
   */
  readonly allowedFailedAttempts?: number;

  /**
   * If true, the check that will lock user after too many failed login attempts will be enabled.
   *
   * @schema UserSpecForProviderPasswordPolicy#enableFailedAttemptsCheck
   */
  readonly enableFailedAttemptsCheck?: boolean;

  /**
   * If true, the user must specify the current password before changing the password. This flag is supported only for MySQL.
   *
   * @schema UserSpecForProviderPasswordPolicy#enablePasswordVerification
   */
  readonly enablePasswordVerification?: boolean;

  /**
   * Password expiration duration with one week grace period.
   *
   * @schema UserSpecForProviderPasswordPolicy#passwordExpirationDuration
   */
  readonly passwordExpirationDuration?: string;

}

/**
 * Converts an object of type 'UserSpecForProviderPasswordPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderPasswordPolicy(obj: UserSpecForProviderPasswordPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedFailedAttempts': obj.allowedFailedAttempts,
    'enableFailedAttemptsCheck': obj.enableFailedAttemptsCheck,
    'enablePasswordVerification': obj.enablePasswordVerification,
    'passwordExpirationDuration': obj.passwordExpirationDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The password for the user. Can be updated. For Postgres instances this is a Required field, unless type is set to either CLOUD_IAM_USER or CLOUD_IAM_SERVICE_ACCOUNT. Don't set this field for CLOUD_IAM_USER and CLOUD_IAM_SERVICE_ACCOUNT user types for any Cloud SQL instance.
 *
 * @schema UserSpecForProviderPasswordSecretRef
 */
export interface UserSpecForProviderPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema UserSpecForProviderPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema UserSpecForProviderPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserSpecForProviderPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserSpecForProviderPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderPasswordSecretRef(obj: UserSpecForProviderPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecInitProviderPasswordPolicy
 */
export interface UserSpecInitProviderPasswordPolicy {
  /**
   * Number of failed attempts allowed before the user get locked.
   *
   * @schema UserSpecInitProviderPasswordPolicy#allowedFailedAttempts
   */
  readonly allowedFailedAttempts?: number;

  /**
   * If true, the check that will lock user after too many failed login attempts will be enabled.
   *
   * @schema UserSpecInitProviderPasswordPolicy#enableFailedAttemptsCheck
   */
  readonly enableFailedAttemptsCheck?: boolean;

  /**
   * If true, the user must specify the current password before changing the password. This flag is supported only for MySQL.
   *
   * @schema UserSpecInitProviderPasswordPolicy#enablePasswordVerification
   */
  readonly enablePasswordVerification?: boolean;

  /**
   * Password expiration duration with one week grace period.
   *
   * @schema UserSpecInitProviderPasswordPolicy#passwordExpirationDuration
   */
  readonly passwordExpirationDuration?: string;

}

/**
 * Converts an object of type 'UserSpecInitProviderPasswordPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecInitProviderPasswordPolicy(obj: UserSpecInitProviderPasswordPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedFailedAttempts': obj.allowedFailedAttempts,
    'enableFailedAttemptsCheck': obj.enableFailedAttemptsCheck,
    'enablePasswordVerification': obj.enablePasswordVerification,
    'passwordExpirationDuration': obj.passwordExpirationDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecProviderConfigRefPolicy
 */
export interface UserSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderConfigRefPolicy(obj: UserSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRef
 */
export interface UserSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToConfigRef(obj: UserSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserSpecPublishConnectionDetailsToMetadata
 */
export interface UserSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToMetadata(obj: UserSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecForProviderInstanceRefPolicy
 */
export interface UserSpecForProviderInstanceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderInstanceRefPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderInstanceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderInstanceRefPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderInstanceRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderInstanceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderInstanceRefPolicy(obj: UserSpecForProviderInstanceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserSpecForProviderInstanceSelectorPolicy
 */
export interface UserSpecForProviderInstanceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderInstanceSelectorPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderInstanceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderInstanceSelectorPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderInstanceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderInstanceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderInstanceSelectorPolicy(obj: UserSpecForProviderInstanceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecProviderConfigRefPolicyResolution
 */
export enum UserSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecProviderConfigRefPolicyResolve
 */
export enum UserSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderInstanceRefPolicyResolution
 */
export enum UserSpecForProviderInstanceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderInstanceRefPolicyResolve
 */
export enum UserSpecForProviderInstanceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderInstanceSelectorPolicyResolution
 */
export enum UserSpecForProviderInstanceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderInstanceSelectorPolicyResolve
 */
export enum UserSpecForProviderInstanceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

