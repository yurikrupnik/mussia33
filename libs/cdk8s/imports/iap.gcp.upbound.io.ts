// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AppEngineServiceIAMMember is the Schema for the AppEngineServiceIAMMembers API. <no value>
 *
 * @schema AppEngineServiceIAMMember
 */
export class AppEngineServiceIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AppEngineServiceIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iap.gcp.upbound.io/v1beta1',
    kind: 'AppEngineServiceIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "AppEngineServiceIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AppEngineServiceIamMemberProps): any {
    return {
      ...AppEngineServiceIamMember.GVK,
      ...toJson_AppEngineServiceIamMemberProps(props),
    };
  }

  /**
   * Defines a "AppEngineServiceIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AppEngineServiceIamMemberProps) {
    super(scope, id, {
      ...AppEngineServiceIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AppEngineServiceIamMember.GVK,
      ...toJson_AppEngineServiceIamMemberProps(resolved),
    };
  }
}

/**
 * AppEngineServiceIAMMember is the Schema for the AppEngineServiceIAMMembers API. <no value>
 *
 * @schema AppEngineServiceIAMMember
 */
export interface AppEngineServiceIamMemberProps {
  /**
   * @schema AppEngineServiceIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AppEngineServiceIAMMemberSpec defines the desired state of AppEngineServiceIAMMember
   *
   * @schema AppEngineServiceIAMMember#spec
   */
  readonly spec: AppEngineServiceIamMemberSpec;

}

/**
 * Converts an object of type 'AppEngineServiceIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineServiceIamMemberProps(obj: AppEngineServiceIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AppEngineServiceIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppEngineServiceIAMMemberSpec defines the desired state of AppEngineServiceIAMMember
 *
 * @schema AppEngineServiceIamMemberSpec
 */
export interface AppEngineServiceIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema AppEngineServiceIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: AppEngineServiceIamMemberSpecDeletionPolicy;

  /**
   * @schema AppEngineServiceIamMemberSpec#forProvider
   */
  readonly forProvider: AppEngineServiceIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AppEngineServiceIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: AppEngineServiceIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AppEngineServiceIamMemberSpec#providerRef
   */
  readonly providerRef?: AppEngineServiceIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AppEngineServiceIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AppEngineServiceIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AppEngineServiceIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AppEngineServiceIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AppEngineServiceIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineServiceIamMemberSpec(obj: AppEngineServiceIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AppEngineServiceIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_AppEngineServiceIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AppEngineServiceIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AppEngineServiceIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AppEngineServiceIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema AppEngineServiceIamMemberSpecDeletionPolicy
 */
export enum AppEngineServiceIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AppEngineServiceIamMemberSpecForProvider
 */
export interface AppEngineServiceIamMemberSpecForProvider {
  /**
   * @schema AppEngineServiceIamMemberSpecForProvider#appId
   */
  readonly appId: string;

  /**
   * @schema AppEngineServiceIamMemberSpecForProvider#condition
   */
  readonly condition?: AppEngineServiceIamMemberSpecForProviderCondition[];

  /**
   * @schema AppEngineServiceIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema AppEngineServiceIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema AppEngineServiceIamMemberSpecForProvider#role
   */
  readonly role: string;

  /**
   * @schema AppEngineServiceIamMemberSpecForProvider#service
   */
  readonly service: string;

}

/**
 * Converts an object of type 'AppEngineServiceIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineServiceIamMemberSpecForProvider(obj: AppEngineServiceIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appId': obj.appId,
    'condition': obj.condition?.map(y => toJson_AppEngineServiceIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AppEngineServiceIamMemberSpecProviderConfigRef
 */
export interface AppEngineServiceIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppEngineServiceIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppEngineServiceIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: AppEngineServiceIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AppEngineServiceIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineServiceIamMemberSpecProviderConfigRef(obj: AppEngineServiceIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppEngineServiceIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AppEngineServiceIamMemberSpecProviderRef
 */
export interface AppEngineServiceIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppEngineServiceIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppEngineServiceIamMemberSpecProviderRef#policy
   */
  readonly policy?: AppEngineServiceIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AppEngineServiceIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineServiceIamMemberSpecProviderRef(obj: AppEngineServiceIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppEngineServiceIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AppEngineServiceIamMemberSpecPublishConnectionDetailsTo
 */
export interface AppEngineServiceIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AppEngineServiceIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AppEngineServiceIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AppEngineServiceIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AppEngineServiceIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AppEngineServiceIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineServiceIamMemberSpecPublishConnectionDetailsTo(obj: AppEngineServiceIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AppEngineServiceIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AppEngineServiceIamMemberSpecWriteConnectionSecretToRef
 */
export interface AppEngineServiceIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AppEngineServiceIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AppEngineServiceIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AppEngineServiceIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineServiceIamMemberSpecWriteConnectionSecretToRef(obj: AppEngineServiceIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppEngineServiceIamMemberSpecForProviderCondition
 */
export interface AppEngineServiceIamMemberSpecForProviderCondition {
  /**
   * @schema AppEngineServiceIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema AppEngineServiceIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema AppEngineServiceIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'AppEngineServiceIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineServiceIamMemberSpecForProviderCondition(obj: AppEngineServiceIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppEngineServiceIamMemberSpecProviderConfigRefPolicy
 */
export interface AppEngineServiceIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppEngineServiceIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AppEngineServiceIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppEngineServiceIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AppEngineServiceIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppEngineServiceIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineServiceIamMemberSpecProviderConfigRefPolicy(obj: AppEngineServiceIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppEngineServiceIamMemberSpecProviderRefPolicy
 */
export interface AppEngineServiceIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppEngineServiceIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AppEngineServiceIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppEngineServiceIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AppEngineServiceIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AppEngineServiceIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineServiceIamMemberSpecProviderRefPolicy(obj: AppEngineServiceIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRef(obj: AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AppEngineServiceIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface AppEngineServiceIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppEngineServiceIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppEngineServiceIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AppEngineServiceIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppEngineServiceIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineServiceIamMemberSpecPublishConnectionDetailsToMetadata(obj: AppEngineServiceIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppEngineServiceIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum AppEngineServiceIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppEngineServiceIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum AppEngineServiceIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppEngineServiceIamMemberSpecProviderRefPolicyResolution
 */
export enum AppEngineServiceIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppEngineServiceIamMemberSpecProviderRefPolicyResolve
 */
export enum AppEngineServiceIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AppEngineServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * AppEngineVersionIAMMember is the Schema for the AppEngineVersionIAMMembers API. <no value>
 *
 * @schema AppEngineVersionIAMMember
 */
export class AppEngineVersionIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AppEngineVersionIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iap.gcp.upbound.io/v1beta1',
    kind: 'AppEngineVersionIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "AppEngineVersionIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AppEngineVersionIamMemberProps): any {
    return {
      ...AppEngineVersionIamMember.GVK,
      ...toJson_AppEngineVersionIamMemberProps(props),
    };
  }

  /**
   * Defines a "AppEngineVersionIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AppEngineVersionIamMemberProps) {
    super(scope, id, {
      ...AppEngineVersionIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AppEngineVersionIamMember.GVK,
      ...toJson_AppEngineVersionIamMemberProps(resolved),
    };
  }
}

/**
 * AppEngineVersionIAMMember is the Schema for the AppEngineVersionIAMMembers API. <no value>
 *
 * @schema AppEngineVersionIAMMember
 */
export interface AppEngineVersionIamMemberProps {
  /**
   * @schema AppEngineVersionIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AppEngineVersionIAMMemberSpec defines the desired state of AppEngineVersionIAMMember
   *
   * @schema AppEngineVersionIAMMember#spec
   */
  readonly spec: AppEngineVersionIamMemberSpec;

}

/**
 * Converts an object of type 'AppEngineVersionIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineVersionIamMemberProps(obj: AppEngineVersionIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AppEngineVersionIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppEngineVersionIAMMemberSpec defines the desired state of AppEngineVersionIAMMember
 *
 * @schema AppEngineVersionIamMemberSpec
 */
export interface AppEngineVersionIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema AppEngineVersionIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: AppEngineVersionIamMemberSpecDeletionPolicy;

  /**
   * @schema AppEngineVersionIamMemberSpec#forProvider
   */
  readonly forProvider: AppEngineVersionIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AppEngineVersionIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: AppEngineVersionIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AppEngineVersionIamMemberSpec#providerRef
   */
  readonly providerRef?: AppEngineVersionIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AppEngineVersionIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AppEngineVersionIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AppEngineVersionIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AppEngineVersionIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AppEngineVersionIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineVersionIamMemberSpec(obj: AppEngineVersionIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AppEngineVersionIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_AppEngineVersionIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AppEngineVersionIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AppEngineVersionIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AppEngineVersionIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema AppEngineVersionIamMemberSpecDeletionPolicy
 */
export enum AppEngineVersionIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AppEngineVersionIamMemberSpecForProvider
 */
export interface AppEngineVersionIamMemberSpecForProvider {
  /**
   * @schema AppEngineVersionIamMemberSpecForProvider#appId
   */
  readonly appId: string;

  /**
   * @schema AppEngineVersionIamMemberSpecForProvider#condition
   */
  readonly condition?: AppEngineVersionIamMemberSpecForProviderCondition[];

  /**
   * @schema AppEngineVersionIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema AppEngineVersionIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema AppEngineVersionIamMemberSpecForProvider#role
   */
  readonly role: string;

  /**
   * @schema AppEngineVersionIamMemberSpecForProvider#service
   */
  readonly service: string;

  /**
   * @schema AppEngineVersionIamMemberSpecForProvider#versionId
   */
  readonly versionId: string;

}

/**
 * Converts an object of type 'AppEngineVersionIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineVersionIamMemberSpecForProvider(obj: AppEngineVersionIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appId': obj.appId,
    'condition': obj.condition?.map(y => toJson_AppEngineVersionIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
    'service': obj.service,
    'versionId': obj.versionId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AppEngineVersionIamMemberSpecProviderConfigRef
 */
export interface AppEngineVersionIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppEngineVersionIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppEngineVersionIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: AppEngineVersionIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AppEngineVersionIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineVersionIamMemberSpecProviderConfigRef(obj: AppEngineVersionIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppEngineVersionIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AppEngineVersionIamMemberSpecProviderRef
 */
export interface AppEngineVersionIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppEngineVersionIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppEngineVersionIamMemberSpecProviderRef#policy
   */
  readonly policy?: AppEngineVersionIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AppEngineVersionIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineVersionIamMemberSpecProviderRef(obj: AppEngineVersionIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppEngineVersionIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AppEngineVersionIamMemberSpecPublishConnectionDetailsTo
 */
export interface AppEngineVersionIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AppEngineVersionIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AppEngineVersionIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AppEngineVersionIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AppEngineVersionIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AppEngineVersionIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineVersionIamMemberSpecPublishConnectionDetailsTo(obj: AppEngineVersionIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AppEngineVersionIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AppEngineVersionIamMemberSpecWriteConnectionSecretToRef
 */
export interface AppEngineVersionIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AppEngineVersionIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AppEngineVersionIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AppEngineVersionIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineVersionIamMemberSpecWriteConnectionSecretToRef(obj: AppEngineVersionIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppEngineVersionIamMemberSpecForProviderCondition
 */
export interface AppEngineVersionIamMemberSpecForProviderCondition {
  /**
   * @schema AppEngineVersionIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema AppEngineVersionIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema AppEngineVersionIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'AppEngineVersionIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineVersionIamMemberSpecForProviderCondition(obj: AppEngineVersionIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppEngineVersionIamMemberSpecProviderConfigRefPolicy
 */
export interface AppEngineVersionIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppEngineVersionIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AppEngineVersionIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppEngineVersionIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AppEngineVersionIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppEngineVersionIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineVersionIamMemberSpecProviderConfigRefPolicy(obj: AppEngineVersionIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppEngineVersionIamMemberSpecProviderRefPolicy
 */
export interface AppEngineVersionIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppEngineVersionIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AppEngineVersionIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppEngineVersionIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AppEngineVersionIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AppEngineVersionIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineVersionIamMemberSpecProviderRefPolicy(obj: AppEngineVersionIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRef(obj: AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AppEngineVersionIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface AppEngineVersionIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppEngineVersionIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppEngineVersionIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AppEngineVersionIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppEngineVersionIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineVersionIamMemberSpecPublishConnectionDetailsToMetadata(obj: AppEngineVersionIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppEngineVersionIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum AppEngineVersionIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppEngineVersionIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum AppEngineVersionIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppEngineVersionIamMemberSpecProviderRefPolicyResolution
 */
export enum AppEngineVersionIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppEngineVersionIamMemberSpecProviderRefPolicyResolve
 */
export enum AppEngineVersionIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AppEngineVersionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TunnelIAMMember is the Schema for the TunnelIAMMembers API. <no value>
 *
 * @schema TunnelIAMMember
 */
export class TunnelIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TunnelIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iap.gcp.upbound.io/v1beta1',
    kind: 'TunnelIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "TunnelIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TunnelIamMemberProps): any {
    return {
      ...TunnelIamMember.GVK,
      ...toJson_TunnelIamMemberProps(props),
    };
  }

  /**
   * Defines a "TunnelIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TunnelIamMemberProps) {
    super(scope, id, {
      ...TunnelIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TunnelIamMember.GVK,
      ...toJson_TunnelIamMemberProps(resolved),
    };
  }
}

/**
 * TunnelIAMMember is the Schema for the TunnelIAMMembers API. <no value>
 *
 * @schema TunnelIAMMember
 */
export interface TunnelIamMemberProps {
  /**
   * @schema TunnelIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TunnelIAMMemberSpec defines the desired state of TunnelIAMMember
   *
   * @schema TunnelIAMMember#spec
   */
  readonly spec: TunnelIamMemberSpec;

}

/**
 * Converts an object of type 'TunnelIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelIamMemberProps(obj: TunnelIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TunnelIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TunnelIAMMemberSpec defines the desired state of TunnelIAMMember
 *
 * @schema TunnelIamMemberSpec
 */
export interface TunnelIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema TunnelIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: TunnelIamMemberSpecDeletionPolicy;

  /**
   * @schema TunnelIamMemberSpec#forProvider
   */
  readonly forProvider: TunnelIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TunnelIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: TunnelIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TunnelIamMemberSpec#providerRef
   */
  readonly providerRef?: TunnelIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TunnelIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TunnelIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TunnelIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TunnelIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TunnelIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelIamMemberSpec(obj: TunnelIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TunnelIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_TunnelIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TunnelIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TunnelIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TunnelIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema TunnelIamMemberSpecDeletionPolicy
 */
export enum TunnelIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TunnelIamMemberSpecForProvider
 */
export interface TunnelIamMemberSpecForProvider {
  /**
   * @schema TunnelIamMemberSpecForProvider#condition
   */
  readonly condition?: TunnelIamMemberSpecForProviderCondition[];

  /**
   * @schema TunnelIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema TunnelIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema TunnelIamMemberSpecForProvider#role
   */
  readonly role: string;

}

/**
 * Converts an object of type 'TunnelIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelIamMemberSpecForProvider(obj: TunnelIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_TunnelIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TunnelIamMemberSpecProviderConfigRef
 */
export interface TunnelIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TunnelIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TunnelIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: TunnelIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TunnelIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelIamMemberSpecProviderConfigRef(obj: TunnelIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TunnelIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TunnelIamMemberSpecProviderRef
 */
export interface TunnelIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TunnelIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TunnelIamMemberSpecProviderRef#policy
   */
  readonly policy?: TunnelIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TunnelIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelIamMemberSpecProviderRef(obj: TunnelIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TunnelIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TunnelIamMemberSpecPublishConnectionDetailsTo
 */
export interface TunnelIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TunnelIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TunnelIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TunnelIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TunnelIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TunnelIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TunnelIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelIamMemberSpecPublishConnectionDetailsTo(obj: TunnelIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TunnelIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TunnelIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TunnelIamMemberSpecWriteConnectionSecretToRef
 */
export interface TunnelIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TunnelIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TunnelIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TunnelIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelIamMemberSpecWriteConnectionSecretToRef(obj: TunnelIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TunnelIamMemberSpecForProviderCondition
 */
export interface TunnelIamMemberSpecForProviderCondition {
  /**
   * @schema TunnelIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema TunnelIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema TunnelIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'TunnelIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelIamMemberSpecForProviderCondition(obj: TunnelIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TunnelIamMemberSpecProviderConfigRefPolicy
 */
export interface TunnelIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TunnelIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TunnelIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TunnelIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TunnelIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TunnelIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelIamMemberSpecProviderConfigRefPolicy(obj: TunnelIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TunnelIamMemberSpecProviderRefPolicy
 */
export interface TunnelIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TunnelIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TunnelIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TunnelIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TunnelIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TunnelIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelIamMemberSpecProviderRefPolicy(obj: TunnelIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TunnelIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface TunnelIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TunnelIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TunnelIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TunnelIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TunnelIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelIamMemberSpecPublishConnectionDetailsToConfigRef(obj: TunnelIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TunnelIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TunnelIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface TunnelIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TunnelIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TunnelIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TunnelIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TunnelIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelIamMemberSpecPublishConnectionDetailsToMetadata(obj: TunnelIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TunnelIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum TunnelIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TunnelIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum TunnelIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TunnelIamMemberSpecProviderRefPolicyResolution
 */
export enum TunnelIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TunnelIamMemberSpecProviderRefPolicyResolve
 */
export enum TunnelIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TunnelIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TunnelIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TunnelIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TunnelIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TunnelIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TunnelIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TunnelIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: TunnelIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TunnelIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TunnelIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TunnelIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TunnelIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * WebBackendServiceIAMMember is the Schema for the WebBackendServiceIAMMembers API. <no value>
 *
 * @schema WebBackendServiceIAMMember
 */
export class WebBackendServiceIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WebBackendServiceIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iap.gcp.upbound.io/v1beta1',
    kind: 'WebBackendServiceIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "WebBackendServiceIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WebBackendServiceIamMemberProps): any {
    return {
      ...WebBackendServiceIamMember.GVK,
      ...toJson_WebBackendServiceIamMemberProps(props),
    };
  }

  /**
   * Defines a "WebBackendServiceIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WebBackendServiceIamMemberProps) {
    super(scope, id, {
      ...WebBackendServiceIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...WebBackendServiceIamMember.GVK,
      ...toJson_WebBackendServiceIamMemberProps(resolved),
    };
  }
}

/**
 * WebBackendServiceIAMMember is the Schema for the WebBackendServiceIAMMembers API. <no value>
 *
 * @schema WebBackendServiceIAMMember
 */
export interface WebBackendServiceIamMemberProps {
  /**
   * @schema WebBackendServiceIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WebBackendServiceIAMMemberSpec defines the desired state of WebBackendServiceIAMMember
   *
   * @schema WebBackendServiceIAMMember#spec
   */
  readonly spec: WebBackendServiceIamMemberSpec;

}

/**
 * Converts an object of type 'WebBackendServiceIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebBackendServiceIamMemberProps(obj: WebBackendServiceIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WebBackendServiceIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WebBackendServiceIAMMemberSpec defines the desired state of WebBackendServiceIAMMember
 *
 * @schema WebBackendServiceIamMemberSpec
 */
export interface WebBackendServiceIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema WebBackendServiceIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: WebBackendServiceIamMemberSpecDeletionPolicy;

  /**
   * @schema WebBackendServiceIamMemberSpec#forProvider
   */
  readonly forProvider: WebBackendServiceIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WebBackendServiceIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: WebBackendServiceIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema WebBackendServiceIamMemberSpec#providerRef
   */
  readonly providerRef?: WebBackendServiceIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WebBackendServiceIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WebBackendServiceIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WebBackendServiceIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WebBackendServiceIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WebBackendServiceIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebBackendServiceIamMemberSpec(obj: WebBackendServiceIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WebBackendServiceIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_WebBackendServiceIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_WebBackendServiceIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_WebBackendServiceIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WebBackendServiceIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema WebBackendServiceIamMemberSpecDeletionPolicy
 */
export enum WebBackendServiceIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WebBackendServiceIamMemberSpecForProvider
 */
export interface WebBackendServiceIamMemberSpecForProvider {
  /**
   * @schema WebBackendServiceIamMemberSpecForProvider#condition
   */
  readonly condition?: WebBackendServiceIamMemberSpecForProviderCondition[];

  /**
   * @schema WebBackendServiceIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema WebBackendServiceIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema WebBackendServiceIamMemberSpecForProvider#role
   */
  readonly role: string;

  /**
   * @schema WebBackendServiceIamMemberSpecForProvider#webBackendService
   */
  readonly webBackendService?: string;

  /**
   * Reference to a BackendService in compute to populate webBackendService.
   *
   * @schema WebBackendServiceIamMemberSpecForProvider#webBackendServiceRef
   */
  readonly webBackendServiceRef?: WebBackendServiceIamMemberSpecForProviderWebBackendServiceRef;

  /**
   * Selector for a BackendService in compute to populate webBackendService.
   *
   * @schema WebBackendServiceIamMemberSpecForProvider#webBackendServiceSelector
   */
  readonly webBackendServiceSelector?: WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelector;

}

/**
 * Converts an object of type 'WebBackendServiceIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebBackendServiceIamMemberSpecForProvider(obj: WebBackendServiceIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_WebBackendServiceIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
    'webBackendService': obj.webBackendService,
    'webBackendServiceRef': toJson_WebBackendServiceIamMemberSpecForProviderWebBackendServiceRef(obj.webBackendServiceRef),
    'webBackendServiceSelector': toJson_WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelector(obj.webBackendServiceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WebBackendServiceIamMemberSpecProviderConfigRef
 */
export interface WebBackendServiceIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebBackendServiceIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebBackendServiceIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: WebBackendServiceIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WebBackendServiceIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebBackendServiceIamMemberSpecProviderConfigRef(obj: WebBackendServiceIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebBackendServiceIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema WebBackendServiceIamMemberSpecProviderRef
 */
export interface WebBackendServiceIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebBackendServiceIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebBackendServiceIamMemberSpecProviderRef#policy
   */
  readonly policy?: WebBackendServiceIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'WebBackendServiceIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebBackendServiceIamMemberSpecProviderRef(obj: WebBackendServiceIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebBackendServiceIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WebBackendServiceIamMemberSpecPublishConnectionDetailsTo
 */
export interface WebBackendServiceIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WebBackendServiceIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WebBackendServiceIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WebBackendServiceIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WebBackendServiceIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WebBackendServiceIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebBackendServiceIamMemberSpecPublishConnectionDetailsTo(obj: WebBackendServiceIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WebBackendServiceIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WebBackendServiceIamMemberSpecWriteConnectionSecretToRef
 */
export interface WebBackendServiceIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WebBackendServiceIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WebBackendServiceIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WebBackendServiceIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebBackendServiceIamMemberSpecWriteConnectionSecretToRef(obj: WebBackendServiceIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebBackendServiceIamMemberSpecForProviderCondition
 */
export interface WebBackendServiceIamMemberSpecForProviderCondition {
  /**
   * @schema WebBackendServiceIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema WebBackendServiceIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema WebBackendServiceIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'WebBackendServiceIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebBackendServiceIamMemberSpecForProviderCondition(obj: WebBackendServiceIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a BackendService in compute to populate webBackendService.
 *
 * @schema WebBackendServiceIamMemberSpecForProviderWebBackendServiceRef
 */
export interface WebBackendServiceIamMemberSpecForProviderWebBackendServiceRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebBackendServiceIamMemberSpecForProviderWebBackendServiceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebBackendServiceIamMemberSpecForProviderWebBackendServiceRef#policy
   */
  readonly policy?: WebBackendServiceIamMemberSpecForProviderWebBackendServiceRefPolicy;

}

/**
 * Converts an object of type 'WebBackendServiceIamMemberSpecForProviderWebBackendServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebBackendServiceIamMemberSpecForProviderWebBackendServiceRef(obj: WebBackendServiceIamMemberSpecForProviderWebBackendServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebBackendServiceIamMemberSpecForProviderWebBackendServiceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a BackendService in compute to populate webBackendService.
 *
 * @schema WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelector
 */
export interface WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelector#policy
   */
  readonly policy?: WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelectorPolicy;

}

/**
 * Converts an object of type 'WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelector(obj: WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebBackendServiceIamMemberSpecProviderConfigRefPolicy
 */
export interface WebBackendServiceIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebBackendServiceIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WebBackendServiceIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebBackendServiceIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WebBackendServiceIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebBackendServiceIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebBackendServiceIamMemberSpecProviderConfigRefPolicy(obj: WebBackendServiceIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebBackendServiceIamMemberSpecProviderRefPolicy
 */
export interface WebBackendServiceIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebBackendServiceIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: WebBackendServiceIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebBackendServiceIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: WebBackendServiceIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'WebBackendServiceIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebBackendServiceIamMemberSpecProviderRefPolicy(obj: WebBackendServiceIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRef(obj: WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WebBackendServiceIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface WebBackendServiceIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebBackendServiceIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebBackendServiceIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WebBackendServiceIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WebBackendServiceIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebBackendServiceIamMemberSpecPublishConnectionDetailsToMetadata(obj: WebBackendServiceIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebBackendServiceIamMemberSpecForProviderWebBackendServiceRefPolicy
 */
export interface WebBackendServiceIamMemberSpecForProviderWebBackendServiceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebBackendServiceIamMemberSpecForProviderWebBackendServiceRefPolicy#resolution
   */
  readonly resolution?: WebBackendServiceIamMemberSpecForProviderWebBackendServiceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebBackendServiceIamMemberSpecForProviderWebBackendServiceRefPolicy#resolve
   */
  readonly resolve?: WebBackendServiceIamMemberSpecForProviderWebBackendServiceRefPolicyResolve;

}

/**
 * Converts an object of type 'WebBackendServiceIamMemberSpecForProviderWebBackendServiceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebBackendServiceIamMemberSpecForProviderWebBackendServiceRefPolicy(obj: WebBackendServiceIamMemberSpecForProviderWebBackendServiceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelectorPolicy
 */
export interface WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelectorPolicy#resolution
   */
  readonly resolution?: WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelectorPolicy#resolve
   */
  readonly resolve?: WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelectorPolicy(obj: WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebBackendServiceIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum WebBackendServiceIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebBackendServiceIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum WebBackendServiceIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebBackendServiceIamMemberSpecProviderRefPolicyResolution
 */
export enum WebBackendServiceIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebBackendServiceIamMemberSpecProviderRefPolicyResolve
 */
export enum WebBackendServiceIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebBackendServiceIamMemberSpecForProviderWebBackendServiceRefPolicyResolution
 */
export enum WebBackendServiceIamMemberSpecForProviderWebBackendServiceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebBackendServiceIamMemberSpecForProviderWebBackendServiceRefPolicyResolve
 */
export enum WebBackendServiceIamMemberSpecForProviderWebBackendServiceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelectorPolicyResolution
 */
export enum WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelectorPolicyResolve
 */
export enum WebBackendServiceIamMemberSpecForProviderWebBackendServiceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WebBackendServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * WebIAMMember is the Schema for the WebIAMMembers API. <no value>
 *
 * @schema WebIAMMember
 */
export class WebIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WebIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iap.gcp.upbound.io/v1beta1',
    kind: 'WebIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "WebIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WebIamMemberProps): any {
    return {
      ...WebIamMember.GVK,
      ...toJson_WebIamMemberProps(props),
    };
  }

  /**
   * Defines a "WebIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WebIamMemberProps) {
    super(scope, id, {
      ...WebIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...WebIamMember.GVK,
      ...toJson_WebIamMemberProps(resolved),
    };
  }
}

/**
 * WebIAMMember is the Schema for the WebIAMMembers API. <no value>
 *
 * @schema WebIAMMember
 */
export interface WebIamMemberProps {
  /**
   * @schema WebIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WebIAMMemberSpec defines the desired state of WebIAMMember
   *
   * @schema WebIAMMember#spec
   */
  readonly spec: WebIamMemberSpec;

}

/**
 * Converts an object of type 'WebIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebIamMemberProps(obj: WebIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WebIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WebIAMMemberSpec defines the desired state of WebIAMMember
 *
 * @schema WebIamMemberSpec
 */
export interface WebIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema WebIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: WebIamMemberSpecDeletionPolicy;

  /**
   * @schema WebIamMemberSpec#forProvider
   */
  readonly forProvider: WebIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WebIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: WebIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema WebIamMemberSpec#providerRef
   */
  readonly providerRef?: WebIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WebIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WebIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WebIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WebIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WebIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebIamMemberSpec(obj: WebIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WebIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_WebIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_WebIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_WebIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WebIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema WebIamMemberSpecDeletionPolicy
 */
export enum WebIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WebIamMemberSpecForProvider
 */
export interface WebIamMemberSpecForProvider {
  /**
   * @schema WebIamMemberSpecForProvider#condition
   */
  readonly condition?: WebIamMemberSpecForProviderCondition[];

  /**
   * @schema WebIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema WebIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema WebIamMemberSpecForProvider#role
   */
  readonly role: string;

}

/**
 * Converts an object of type 'WebIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebIamMemberSpecForProvider(obj: WebIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_WebIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WebIamMemberSpecProviderConfigRef
 */
export interface WebIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: WebIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WebIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebIamMemberSpecProviderConfigRef(obj: WebIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema WebIamMemberSpecProviderRef
 */
export interface WebIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebIamMemberSpecProviderRef#policy
   */
  readonly policy?: WebIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'WebIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebIamMemberSpecProviderRef(obj: WebIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WebIamMemberSpecPublishConnectionDetailsTo
 */
export interface WebIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WebIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WebIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WebIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WebIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WebIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WebIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebIamMemberSpecPublishConnectionDetailsTo(obj: WebIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WebIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WebIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WebIamMemberSpecWriteConnectionSecretToRef
 */
export interface WebIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WebIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WebIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WebIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebIamMemberSpecWriteConnectionSecretToRef(obj: WebIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebIamMemberSpecForProviderCondition
 */
export interface WebIamMemberSpecForProviderCondition {
  /**
   * @schema WebIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema WebIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema WebIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'WebIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebIamMemberSpecForProviderCondition(obj: WebIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebIamMemberSpecProviderConfigRefPolicy
 */
export interface WebIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WebIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WebIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebIamMemberSpecProviderConfigRefPolicy(obj: WebIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebIamMemberSpecProviderRefPolicy
 */
export interface WebIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: WebIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: WebIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'WebIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebIamMemberSpecProviderRefPolicy(obj: WebIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WebIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface WebIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WebIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WebIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebIamMemberSpecPublishConnectionDetailsToConfigRef(obj: WebIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WebIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface WebIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WebIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WebIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebIamMemberSpecPublishConnectionDetailsToMetadata(obj: WebIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum WebIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum WebIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebIamMemberSpecProviderRefPolicyResolution
 */
export enum WebIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebIamMemberSpecProviderRefPolicyResolve
 */
export enum WebIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WebIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WebIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WebIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WebIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: WebIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WebIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WebIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * WebTypeAppEngineIAMMember is the Schema for the WebTypeAppEngineIAMMembers API. <no value>
 *
 * @schema WebTypeAppEngineIAMMember
 */
export class WebTypeAppEngineIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WebTypeAppEngineIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iap.gcp.upbound.io/v1beta1',
    kind: 'WebTypeAppEngineIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "WebTypeAppEngineIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WebTypeAppEngineIamMemberProps): any {
    return {
      ...WebTypeAppEngineIamMember.GVK,
      ...toJson_WebTypeAppEngineIamMemberProps(props),
    };
  }

  /**
   * Defines a "WebTypeAppEngineIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WebTypeAppEngineIamMemberProps) {
    super(scope, id, {
      ...WebTypeAppEngineIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...WebTypeAppEngineIamMember.GVK,
      ...toJson_WebTypeAppEngineIamMemberProps(resolved),
    };
  }
}

/**
 * WebTypeAppEngineIAMMember is the Schema for the WebTypeAppEngineIAMMembers API. <no value>
 *
 * @schema WebTypeAppEngineIAMMember
 */
export interface WebTypeAppEngineIamMemberProps {
  /**
   * @schema WebTypeAppEngineIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WebTypeAppEngineIAMMemberSpec defines the desired state of WebTypeAppEngineIAMMember
   *
   * @schema WebTypeAppEngineIAMMember#spec
   */
  readonly spec: WebTypeAppEngineIamMemberSpec;

}

/**
 * Converts an object of type 'WebTypeAppEngineIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeAppEngineIamMemberProps(obj: WebTypeAppEngineIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WebTypeAppEngineIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WebTypeAppEngineIAMMemberSpec defines the desired state of WebTypeAppEngineIAMMember
 *
 * @schema WebTypeAppEngineIamMemberSpec
 */
export interface WebTypeAppEngineIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema WebTypeAppEngineIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: WebTypeAppEngineIamMemberSpecDeletionPolicy;

  /**
   * @schema WebTypeAppEngineIamMemberSpec#forProvider
   */
  readonly forProvider: WebTypeAppEngineIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WebTypeAppEngineIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: WebTypeAppEngineIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema WebTypeAppEngineIamMemberSpec#providerRef
   */
  readonly providerRef?: WebTypeAppEngineIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WebTypeAppEngineIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WebTypeAppEngineIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WebTypeAppEngineIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WebTypeAppEngineIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WebTypeAppEngineIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeAppEngineIamMemberSpec(obj: WebTypeAppEngineIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WebTypeAppEngineIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_WebTypeAppEngineIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_WebTypeAppEngineIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_WebTypeAppEngineIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WebTypeAppEngineIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema WebTypeAppEngineIamMemberSpecDeletionPolicy
 */
export enum WebTypeAppEngineIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WebTypeAppEngineIamMemberSpecForProvider
 */
export interface WebTypeAppEngineIamMemberSpecForProvider {
  /**
   * @schema WebTypeAppEngineIamMemberSpecForProvider#appId
   */
  readonly appId?: string;

  /**
   * Reference to a Application in appengine to populate appId.
   *
   * @schema WebTypeAppEngineIamMemberSpecForProvider#appIdRef
   */
  readonly appIdRef?: WebTypeAppEngineIamMemberSpecForProviderAppIdRef;

  /**
   * Selector for a Application in appengine to populate appId.
   *
   * @schema WebTypeAppEngineIamMemberSpecForProvider#appIdSelector
   */
  readonly appIdSelector?: WebTypeAppEngineIamMemberSpecForProviderAppIdSelector;

  /**
   * @schema WebTypeAppEngineIamMemberSpecForProvider#condition
   */
  readonly condition?: WebTypeAppEngineIamMemberSpecForProviderCondition[];

  /**
   * @schema WebTypeAppEngineIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema WebTypeAppEngineIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema WebTypeAppEngineIamMemberSpecForProvider#role
   */
  readonly role: string;

}

/**
 * Converts an object of type 'WebTypeAppEngineIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeAppEngineIamMemberSpecForProvider(obj: WebTypeAppEngineIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appId': obj.appId,
    'appIdRef': toJson_WebTypeAppEngineIamMemberSpecForProviderAppIdRef(obj.appIdRef),
    'appIdSelector': toJson_WebTypeAppEngineIamMemberSpecForProviderAppIdSelector(obj.appIdSelector),
    'condition': obj.condition?.map(y => toJson_WebTypeAppEngineIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WebTypeAppEngineIamMemberSpecProviderConfigRef
 */
export interface WebTypeAppEngineIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebTypeAppEngineIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebTypeAppEngineIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: WebTypeAppEngineIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WebTypeAppEngineIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeAppEngineIamMemberSpecProviderConfigRef(obj: WebTypeAppEngineIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebTypeAppEngineIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema WebTypeAppEngineIamMemberSpecProviderRef
 */
export interface WebTypeAppEngineIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebTypeAppEngineIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebTypeAppEngineIamMemberSpecProviderRef#policy
   */
  readonly policy?: WebTypeAppEngineIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'WebTypeAppEngineIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeAppEngineIamMemberSpecProviderRef(obj: WebTypeAppEngineIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebTypeAppEngineIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WebTypeAppEngineIamMemberSpecPublishConnectionDetailsTo
 */
export interface WebTypeAppEngineIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WebTypeAppEngineIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WebTypeAppEngineIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WebTypeAppEngineIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WebTypeAppEngineIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeAppEngineIamMemberSpecPublishConnectionDetailsTo(obj: WebTypeAppEngineIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WebTypeAppEngineIamMemberSpecWriteConnectionSecretToRef
 */
export interface WebTypeAppEngineIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WebTypeAppEngineIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WebTypeAppEngineIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WebTypeAppEngineIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeAppEngineIamMemberSpecWriteConnectionSecretToRef(obj: WebTypeAppEngineIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Application in appengine to populate appId.
 *
 * @schema WebTypeAppEngineIamMemberSpecForProviderAppIdRef
 */
export interface WebTypeAppEngineIamMemberSpecForProviderAppIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebTypeAppEngineIamMemberSpecForProviderAppIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebTypeAppEngineIamMemberSpecForProviderAppIdRef#policy
   */
  readonly policy?: WebTypeAppEngineIamMemberSpecForProviderAppIdRefPolicy;

}

/**
 * Converts an object of type 'WebTypeAppEngineIamMemberSpecForProviderAppIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeAppEngineIamMemberSpecForProviderAppIdRef(obj: WebTypeAppEngineIamMemberSpecForProviderAppIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebTypeAppEngineIamMemberSpecForProviderAppIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Application in appengine to populate appId.
 *
 * @schema WebTypeAppEngineIamMemberSpecForProviderAppIdSelector
 */
export interface WebTypeAppEngineIamMemberSpecForProviderAppIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WebTypeAppEngineIamMemberSpecForProviderAppIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WebTypeAppEngineIamMemberSpecForProviderAppIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WebTypeAppEngineIamMemberSpecForProviderAppIdSelector#policy
   */
  readonly policy?: WebTypeAppEngineIamMemberSpecForProviderAppIdSelectorPolicy;

}

/**
 * Converts an object of type 'WebTypeAppEngineIamMemberSpecForProviderAppIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeAppEngineIamMemberSpecForProviderAppIdSelector(obj: WebTypeAppEngineIamMemberSpecForProviderAppIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WebTypeAppEngineIamMemberSpecForProviderAppIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebTypeAppEngineIamMemberSpecForProviderCondition
 */
export interface WebTypeAppEngineIamMemberSpecForProviderCondition {
  /**
   * @schema WebTypeAppEngineIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema WebTypeAppEngineIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema WebTypeAppEngineIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'WebTypeAppEngineIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeAppEngineIamMemberSpecForProviderCondition(obj: WebTypeAppEngineIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebTypeAppEngineIamMemberSpecProviderConfigRefPolicy
 */
export interface WebTypeAppEngineIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebTypeAppEngineIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WebTypeAppEngineIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebTypeAppEngineIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WebTypeAppEngineIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebTypeAppEngineIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeAppEngineIamMemberSpecProviderConfigRefPolicy(obj: WebTypeAppEngineIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebTypeAppEngineIamMemberSpecProviderRefPolicy
 */
export interface WebTypeAppEngineIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebTypeAppEngineIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: WebTypeAppEngineIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebTypeAppEngineIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: WebTypeAppEngineIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'WebTypeAppEngineIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeAppEngineIamMemberSpecProviderRefPolicy(obj: WebTypeAppEngineIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRef(obj: WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToMetadata(obj: WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebTypeAppEngineIamMemberSpecForProviderAppIdRefPolicy
 */
export interface WebTypeAppEngineIamMemberSpecForProviderAppIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebTypeAppEngineIamMemberSpecForProviderAppIdRefPolicy#resolution
   */
  readonly resolution?: WebTypeAppEngineIamMemberSpecForProviderAppIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebTypeAppEngineIamMemberSpecForProviderAppIdRefPolicy#resolve
   */
  readonly resolve?: WebTypeAppEngineIamMemberSpecForProviderAppIdRefPolicyResolve;

}

/**
 * Converts an object of type 'WebTypeAppEngineIamMemberSpecForProviderAppIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeAppEngineIamMemberSpecForProviderAppIdRefPolicy(obj: WebTypeAppEngineIamMemberSpecForProviderAppIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WebTypeAppEngineIamMemberSpecForProviderAppIdSelectorPolicy
 */
export interface WebTypeAppEngineIamMemberSpecForProviderAppIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebTypeAppEngineIamMemberSpecForProviderAppIdSelectorPolicy#resolution
   */
  readonly resolution?: WebTypeAppEngineIamMemberSpecForProviderAppIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebTypeAppEngineIamMemberSpecForProviderAppIdSelectorPolicy#resolve
   */
  readonly resolve?: WebTypeAppEngineIamMemberSpecForProviderAppIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WebTypeAppEngineIamMemberSpecForProviderAppIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeAppEngineIamMemberSpecForProviderAppIdSelectorPolicy(obj: WebTypeAppEngineIamMemberSpecForProviderAppIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebTypeAppEngineIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum WebTypeAppEngineIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebTypeAppEngineIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum WebTypeAppEngineIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebTypeAppEngineIamMemberSpecProviderRefPolicyResolution
 */
export enum WebTypeAppEngineIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebTypeAppEngineIamMemberSpecProviderRefPolicyResolve
 */
export enum WebTypeAppEngineIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebTypeAppEngineIamMemberSpecForProviderAppIdRefPolicyResolution
 */
export enum WebTypeAppEngineIamMemberSpecForProviderAppIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebTypeAppEngineIamMemberSpecForProviderAppIdRefPolicyResolve
 */
export enum WebTypeAppEngineIamMemberSpecForProviderAppIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebTypeAppEngineIamMemberSpecForProviderAppIdSelectorPolicyResolution
 */
export enum WebTypeAppEngineIamMemberSpecForProviderAppIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebTypeAppEngineIamMemberSpecForProviderAppIdSelectorPolicyResolve
 */
export enum WebTypeAppEngineIamMemberSpecForProviderAppIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WebTypeAppEngineIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * WebTypeComputeIAMMember is the Schema for the WebTypeComputeIAMMembers API. <no value>
 *
 * @schema WebTypeComputeIAMMember
 */
export class WebTypeComputeIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WebTypeComputeIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iap.gcp.upbound.io/v1beta1',
    kind: 'WebTypeComputeIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "WebTypeComputeIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WebTypeComputeIamMemberProps): any {
    return {
      ...WebTypeComputeIamMember.GVK,
      ...toJson_WebTypeComputeIamMemberProps(props),
    };
  }

  /**
   * Defines a "WebTypeComputeIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WebTypeComputeIamMemberProps) {
    super(scope, id, {
      ...WebTypeComputeIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...WebTypeComputeIamMember.GVK,
      ...toJson_WebTypeComputeIamMemberProps(resolved),
    };
  }
}

/**
 * WebTypeComputeIAMMember is the Schema for the WebTypeComputeIAMMembers API. <no value>
 *
 * @schema WebTypeComputeIAMMember
 */
export interface WebTypeComputeIamMemberProps {
  /**
   * @schema WebTypeComputeIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WebTypeComputeIAMMemberSpec defines the desired state of WebTypeComputeIAMMember
   *
   * @schema WebTypeComputeIAMMember#spec
   */
  readonly spec: WebTypeComputeIamMemberSpec;

}

/**
 * Converts an object of type 'WebTypeComputeIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeComputeIamMemberProps(obj: WebTypeComputeIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WebTypeComputeIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WebTypeComputeIAMMemberSpec defines the desired state of WebTypeComputeIAMMember
 *
 * @schema WebTypeComputeIamMemberSpec
 */
export interface WebTypeComputeIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema WebTypeComputeIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: WebTypeComputeIamMemberSpecDeletionPolicy;

  /**
   * @schema WebTypeComputeIamMemberSpec#forProvider
   */
  readonly forProvider: WebTypeComputeIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WebTypeComputeIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: WebTypeComputeIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema WebTypeComputeIamMemberSpec#providerRef
   */
  readonly providerRef?: WebTypeComputeIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WebTypeComputeIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WebTypeComputeIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WebTypeComputeIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WebTypeComputeIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WebTypeComputeIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeComputeIamMemberSpec(obj: WebTypeComputeIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WebTypeComputeIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_WebTypeComputeIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_WebTypeComputeIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_WebTypeComputeIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WebTypeComputeIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema WebTypeComputeIamMemberSpecDeletionPolicy
 */
export enum WebTypeComputeIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WebTypeComputeIamMemberSpecForProvider
 */
export interface WebTypeComputeIamMemberSpecForProvider {
  /**
   * @schema WebTypeComputeIamMemberSpecForProvider#condition
   */
  readonly condition?: WebTypeComputeIamMemberSpecForProviderCondition[];

  /**
   * @schema WebTypeComputeIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema WebTypeComputeIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema WebTypeComputeIamMemberSpecForProvider#role
   */
  readonly role: string;

}

/**
 * Converts an object of type 'WebTypeComputeIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeComputeIamMemberSpecForProvider(obj: WebTypeComputeIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_WebTypeComputeIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WebTypeComputeIamMemberSpecProviderConfigRef
 */
export interface WebTypeComputeIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebTypeComputeIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebTypeComputeIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: WebTypeComputeIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WebTypeComputeIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeComputeIamMemberSpecProviderConfigRef(obj: WebTypeComputeIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebTypeComputeIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema WebTypeComputeIamMemberSpecProviderRef
 */
export interface WebTypeComputeIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebTypeComputeIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebTypeComputeIamMemberSpecProviderRef#policy
   */
  readonly policy?: WebTypeComputeIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'WebTypeComputeIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeComputeIamMemberSpecProviderRef(obj: WebTypeComputeIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebTypeComputeIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WebTypeComputeIamMemberSpecPublishConnectionDetailsTo
 */
export interface WebTypeComputeIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WebTypeComputeIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WebTypeComputeIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WebTypeComputeIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WebTypeComputeIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WebTypeComputeIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeComputeIamMemberSpecPublishConnectionDetailsTo(obj: WebTypeComputeIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WebTypeComputeIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WebTypeComputeIamMemberSpecWriteConnectionSecretToRef
 */
export interface WebTypeComputeIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WebTypeComputeIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WebTypeComputeIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WebTypeComputeIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeComputeIamMemberSpecWriteConnectionSecretToRef(obj: WebTypeComputeIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebTypeComputeIamMemberSpecForProviderCondition
 */
export interface WebTypeComputeIamMemberSpecForProviderCondition {
  /**
   * @schema WebTypeComputeIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema WebTypeComputeIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema WebTypeComputeIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'WebTypeComputeIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeComputeIamMemberSpecForProviderCondition(obj: WebTypeComputeIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebTypeComputeIamMemberSpecProviderConfigRefPolicy
 */
export interface WebTypeComputeIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebTypeComputeIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WebTypeComputeIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebTypeComputeIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WebTypeComputeIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebTypeComputeIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeComputeIamMemberSpecProviderConfigRefPolicy(obj: WebTypeComputeIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebTypeComputeIamMemberSpecProviderRefPolicy
 */
export interface WebTypeComputeIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebTypeComputeIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: WebTypeComputeIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebTypeComputeIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: WebTypeComputeIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'WebTypeComputeIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeComputeIamMemberSpecProviderRefPolicy(obj: WebTypeComputeIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRef(obj: WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WebTypeComputeIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface WebTypeComputeIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebTypeComputeIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebTypeComputeIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WebTypeComputeIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WebTypeComputeIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeComputeIamMemberSpecPublishConnectionDetailsToMetadata(obj: WebTypeComputeIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebTypeComputeIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum WebTypeComputeIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebTypeComputeIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum WebTypeComputeIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebTypeComputeIamMemberSpecProviderRefPolicyResolution
 */
export enum WebTypeComputeIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebTypeComputeIamMemberSpecProviderRefPolicyResolve
 */
export enum WebTypeComputeIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WebTypeComputeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

