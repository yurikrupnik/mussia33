// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Container is the Schema for the Containers API. Provides a MediaStore Container.
 *
 * @schema Container
 */
export class Container extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Container"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'mediastore.aws.upbound.io/v1beta1',
    kind: 'Container',
  }

  /**
   * Renders a Kubernetes manifest for "Container".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ContainerProps): any {
    return {
      ...Container.GVK,
      ...toJson_ContainerProps(props),
    };
  }

  /**
   * Defines a "Container" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ContainerProps) {
    super(scope, id, {
      ...Container.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Container.GVK,
      ...toJson_ContainerProps(resolved),
    };
  }
}

/**
 * Container is the Schema for the Containers API. Provides a MediaStore Container.
 *
 * @schema Container
 */
export interface ContainerProps {
  /**
   * @schema Container#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ContainerSpec defines the desired state of Container
   *
   * @schema Container#spec
   */
  readonly spec: ContainerSpec;

}

/**
 * Converts an object of type 'ContainerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerProps(obj: ContainerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ContainerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerSpec defines the desired state of Container
 *
 * @schema ContainerSpec
 */
export interface ContainerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ContainerSpec#deletionPolicy
   */
  readonly deletionPolicy?: ContainerSpecDeletionPolicy;

  /**
   * @schema ContainerSpec#forProvider
   */
  readonly forProvider: ContainerSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ContainerSpec#providerConfigRef
   */
  readonly providerConfigRef?: ContainerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ContainerSpec#providerRef
   */
  readonly providerRef?: ContainerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ContainerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ContainerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ContainerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ContainerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ContainerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerSpec(obj: ContainerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ContainerSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ContainerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ContainerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ContainerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ContainerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ContainerSpecDeletionPolicy
 */
export enum ContainerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ContainerSpecForProvider
 */
export interface ContainerSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ContainerSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ContainerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ContainerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerSpecForProvider(obj: ContainerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ContainerSpecProviderConfigRef
 */
export interface ContainerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContainerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContainerSpecProviderConfigRef#policy
   */
  readonly policy?: ContainerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ContainerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerSpecProviderConfigRef(obj: ContainerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContainerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ContainerSpecProviderRef
 */
export interface ContainerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContainerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContainerSpecProviderRef#policy
   */
  readonly policy?: ContainerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ContainerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerSpecProviderRef(obj: ContainerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContainerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ContainerSpecPublishConnectionDetailsTo
 */
export interface ContainerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ContainerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ContainerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ContainerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ContainerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ContainerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ContainerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerSpecPublishConnectionDetailsTo(obj: ContainerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ContainerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ContainerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ContainerSpecWriteConnectionSecretToRef
 */
export interface ContainerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ContainerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ContainerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContainerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerSpecWriteConnectionSecretToRef(obj: ContainerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ContainerSpecProviderConfigRefPolicy
 */
export interface ContainerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContainerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ContainerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContainerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ContainerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ContainerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerSpecProviderConfigRefPolicy(obj: ContainerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ContainerSpecProviderRefPolicy
 */
export interface ContainerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContainerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ContainerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContainerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ContainerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ContainerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerSpecProviderRefPolicy(obj: ContainerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ContainerSpecPublishConnectionDetailsToConfigRef
 */
export interface ContainerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContainerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContainerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ContainerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ContainerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerSpecPublishConnectionDetailsToConfigRef(obj: ContainerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContainerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ContainerSpecPublishConnectionDetailsToMetadata
 */
export interface ContainerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ContainerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ContainerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ContainerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ContainerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerSpecPublishConnectionDetailsToMetadata(obj: ContainerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContainerSpecProviderConfigRefPolicyResolution
 */
export enum ContainerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContainerSpecProviderConfigRefPolicyResolve
 */
export enum ContainerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContainerSpecProviderRefPolicyResolution
 */
export enum ContainerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContainerSpecProviderRefPolicyResolve
 */
export enum ContainerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ContainerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ContainerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContainerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ContainerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContainerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ContainerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ContainerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerSpecPublishConnectionDetailsToConfigRefPolicy(obj: ContainerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContainerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ContainerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContainerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ContainerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ContainerPolicy is the Schema for the ContainerPolicys API. Provides a MediaStore Container Policy.
 *
 * @schema ContainerPolicy
 */
export class ContainerPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ContainerPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'mediastore.aws.upbound.io/v1beta1',
    kind: 'ContainerPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ContainerPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ContainerPolicyProps): any {
    return {
      ...ContainerPolicy.GVK,
      ...toJson_ContainerPolicyProps(props),
    };
  }

  /**
   * Defines a "ContainerPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ContainerPolicyProps) {
    super(scope, id, {
      ...ContainerPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ContainerPolicy.GVK,
      ...toJson_ContainerPolicyProps(resolved),
    };
  }
}

/**
 * ContainerPolicy is the Schema for the ContainerPolicys API. Provides a MediaStore Container Policy.
 *
 * @schema ContainerPolicy
 */
export interface ContainerPolicyProps {
  /**
   * @schema ContainerPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ContainerPolicySpec defines the desired state of ContainerPolicy
   *
   * @schema ContainerPolicy#spec
   */
  readonly spec: ContainerPolicySpec;

}

/**
 * Converts an object of type 'ContainerPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerPolicyProps(obj: ContainerPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ContainerPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPolicySpec defines the desired state of ContainerPolicy
 *
 * @schema ContainerPolicySpec
 */
export interface ContainerPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ContainerPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: ContainerPolicySpecDeletionPolicy;

  /**
   * @schema ContainerPolicySpec#forProvider
   */
  readonly forProvider: ContainerPolicySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ContainerPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: ContainerPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ContainerPolicySpec#providerRef
   */
  readonly providerRef?: ContainerPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ContainerPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ContainerPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ContainerPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ContainerPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ContainerPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerPolicySpec(obj: ContainerPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ContainerPolicySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ContainerPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ContainerPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ContainerPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ContainerPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ContainerPolicySpecDeletionPolicy
 */
export enum ContainerPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ContainerPolicySpecForProvider
 */
export interface ContainerPolicySpecForProvider {
  /**
   * The name of the container.
   *
   * @schema ContainerPolicySpecForProvider#containerName
   */
  readonly containerName?: string;

  /**
   * Reference to a Container in mediastore to populate containerName.
   *
   * @schema ContainerPolicySpecForProvider#containerNameRef
   */
  readonly containerNameRef?: ContainerPolicySpecForProviderContainerNameRef;

  /**
   * Selector for a Container in mediastore to populate containerName.
   *
   * @schema ContainerPolicySpecForProvider#containerNameSelector
   */
  readonly containerNameSelector?: ContainerPolicySpecForProviderContainerNameSelector;

  /**
   * The contents of the policy.
   *
   * @schema ContainerPolicySpecForProvider#policy
   */
  readonly policy: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ContainerPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ContainerPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerPolicySpecForProvider(obj: ContainerPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'containerNameRef': toJson_ContainerPolicySpecForProviderContainerNameRef(obj.containerNameRef),
    'containerNameSelector': toJson_ContainerPolicySpecForProviderContainerNameSelector(obj.containerNameSelector),
    'policy': obj.policy,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ContainerPolicySpecProviderConfigRef
 */
export interface ContainerPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContainerPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContainerPolicySpecProviderConfigRef#policy
   */
  readonly policy?: ContainerPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ContainerPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerPolicySpecProviderConfigRef(obj: ContainerPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContainerPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ContainerPolicySpecProviderRef
 */
export interface ContainerPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContainerPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContainerPolicySpecProviderRef#policy
   */
  readonly policy?: ContainerPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ContainerPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerPolicySpecProviderRef(obj: ContainerPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContainerPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ContainerPolicySpecPublishConnectionDetailsTo
 */
export interface ContainerPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ContainerPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ContainerPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ContainerPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ContainerPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ContainerPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ContainerPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerPolicySpecPublishConnectionDetailsTo(obj: ContainerPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ContainerPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ContainerPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ContainerPolicySpecWriteConnectionSecretToRef
 */
export interface ContainerPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ContainerPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ContainerPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContainerPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerPolicySpecWriteConnectionSecretToRef(obj: ContainerPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Container in mediastore to populate containerName.
 *
 * @schema ContainerPolicySpecForProviderContainerNameRef
 */
export interface ContainerPolicySpecForProviderContainerNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContainerPolicySpecForProviderContainerNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContainerPolicySpecForProviderContainerNameRef#policy
   */
  readonly policy?: ContainerPolicySpecForProviderContainerNameRefPolicy;

}

/**
 * Converts an object of type 'ContainerPolicySpecForProviderContainerNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerPolicySpecForProviderContainerNameRef(obj: ContainerPolicySpecForProviderContainerNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContainerPolicySpecForProviderContainerNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Container in mediastore to populate containerName.
 *
 * @schema ContainerPolicySpecForProviderContainerNameSelector
 */
export interface ContainerPolicySpecForProviderContainerNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ContainerPolicySpecForProviderContainerNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ContainerPolicySpecForProviderContainerNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ContainerPolicySpecForProviderContainerNameSelector#policy
   */
  readonly policy?: ContainerPolicySpecForProviderContainerNameSelectorPolicy;

}

/**
 * Converts an object of type 'ContainerPolicySpecForProviderContainerNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerPolicySpecForProviderContainerNameSelector(obj: ContainerPolicySpecForProviderContainerNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ContainerPolicySpecForProviderContainerNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ContainerPolicySpecProviderConfigRefPolicy
 */
export interface ContainerPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContainerPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ContainerPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContainerPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ContainerPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ContainerPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerPolicySpecProviderConfigRefPolicy(obj: ContainerPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ContainerPolicySpecProviderRefPolicy
 */
export interface ContainerPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContainerPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: ContainerPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContainerPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: ContainerPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ContainerPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerPolicySpecProviderRefPolicy(obj: ContainerPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ContainerPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface ContainerPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContainerPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContainerPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ContainerPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ContainerPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerPolicySpecPublishConnectionDetailsToConfigRef(obj: ContainerPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContainerPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ContainerPolicySpecPublishConnectionDetailsToMetadata
 */
export interface ContainerPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ContainerPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ContainerPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ContainerPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ContainerPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerPolicySpecPublishConnectionDetailsToMetadata(obj: ContainerPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ContainerPolicySpecForProviderContainerNameRefPolicy
 */
export interface ContainerPolicySpecForProviderContainerNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContainerPolicySpecForProviderContainerNameRefPolicy#resolution
   */
  readonly resolution?: ContainerPolicySpecForProviderContainerNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContainerPolicySpecForProviderContainerNameRefPolicy#resolve
   */
  readonly resolve?: ContainerPolicySpecForProviderContainerNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ContainerPolicySpecForProviderContainerNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerPolicySpecForProviderContainerNameRefPolicy(obj: ContainerPolicySpecForProviderContainerNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ContainerPolicySpecForProviderContainerNameSelectorPolicy
 */
export interface ContainerPolicySpecForProviderContainerNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContainerPolicySpecForProviderContainerNameSelectorPolicy#resolution
   */
  readonly resolution?: ContainerPolicySpecForProviderContainerNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContainerPolicySpecForProviderContainerNameSelectorPolicy#resolve
   */
  readonly resolve?: ContainerPolicySpecForProviderContainerNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ContainerPolicySpecForProviderContainerNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerPolicySpecForProviderContainerNameSelectorPolicy(obj: ContainerPolicySpecForProviderContainerNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContainerPolicySpecProviderConfigRefPolicyResolution
 */
export enum ContainerPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContainerPolicySpecProviderConfigRefPolicyResolve
 */
export enum ContainerPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContainerPolicySpecProviderRefPolicyResolution
 */
export enum ContainerPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContainerPolicySpecProviderRefPolicyResolve
 */
export enum ContainerPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ContainerPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ContainerPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContainerPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ContainerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContainerPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ContainerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ContainerPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContainerPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: ContainerPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContainerPolicySpecForProviderContainerNameRefPolicyResolution
 */
export enum ContainerPolicySpecForProviderContainerNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContainerPolicySpecForProviderContainerNameRefPolicyResolve
 */
export enum ContainerPolicySpecForProviderContainerNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContainerPolicySpecForProviderContainerNameSelectorPolicyResolution
 */
export enum ContainerPolicySpecForProviderContainerNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContainerPolicySpecForProviderContainerNameSelectorPolicyResolve
 */
export enum ContainerPolicySpecForProviderContainerNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContainerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ContainerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContainerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ContainerPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

