// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Queue is the Schema for the Queues API. Provides a SQS resource.
 *
 * @schema Queue
 */
export class Queue extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Queue"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sqs.aws.upbound.io/v1beta1',
    kind: 'Queue',
  }

  /**
   * Renders a Kubernetes manifest for "Queue".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: QueueProps): any {
    return {
      ...Queue.GVK,
      ...toJson_QueueProps(props),
    };
  }

  /**
   * Defines a "Queue" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: QueueProps) {
    super(scope, id, {
      ...Queue.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Queue.GVK,
      ...toJson_QueueProps(resolved),
    };
  }
}

/**
 * Queue is the Schema for the Queues API. Provides a SQS resource.
 *
 * @schema Queue
 */
export interface QueueProps {
  /**
   * @schema Queue#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * QueueSpec defines the desired state of Queue
   *
   * @schema Queue#spec
   */
  readonly spec: QueueSpec;

}

/**
 * Converts an object of type 'QueueProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueProps(obj: QueueProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_QueueSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueueSpec defines the desired state of Queue
 *
 * @schema QueueSpec
 */
export interface QueueSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema QueueSpec#deletionPolicy
   */
  readonly deletionPolicy?: QueueSpecDeletionPolicy;

  /**
   * @schema QueueSpec#forProvider
   */
  readonly forProvider: QueueSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema QueueSpec#providerConfigRef
   */
  readonly providerConfigRef?: QueueSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema QueueSpec#providerRef
   */
  readonly providerRef?: QueueSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema QueueSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: QueueSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema QueueSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: QueueSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'QueueSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpec(obj: QueueSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_QueueSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_QueueSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_QueueSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_QueueSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_QueueSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema QueueSpecDeletionPolicy
 */
export enum QueueSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema QueueSpecForProvider
 */
export interface QueueSpecForProvider {
  /**
   * Enables content-based deduplication for FIFO queues. For more information, see the related documentation
   *
   * @schema QueueSpecForProvider#contentBasedDeduplication
   */
  readonly contentBasedDeduplication?: boolean;

  /**
   * Specifies whether message deduplication occurs at the message group or queue level. Valid values are messageGroup and queue (default).
   *
   * @schema QueueSpecForProvider#deduplicationScope
   */
  readonly deduplicationScope?: string;

  /**
   * The time in seconds that the delivery of all messages in the queue will be delayed. An integer from 0 to 900 (15 minutes). The default for this attribute is 0 seconds.
   *
   * @schema QueueSpecForProvider#delaySeconds
   */
  readonly delaySeconds?: number;

  /**
   * Boolean designating a FIFO queue. If not set, it defaults to false making it standard.
   *
   * @schema QueueSpecForProvider#fifoQueue
   */
  readonly fifoQueue?: boolean;

  /**
   * Specifies whether the FIFO queue throughput quota applies to the entire queue or per message group. Valid values are perQueue (default) and perMessageGroupId.
   *
   * @schema QueueSpecForProvider#fifoThroughputLimit
   */
  readonly fifoThroughputLimit?: string;

  /**
   * The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again. An integer representing seconds, between 60 seconds (1 minute) and 86,400 seconds (24 hours). The default is 300 (5 minutes).
   *
   * @schema QueueSpecForProvider#kmsDataKeyReusePeriodSeconds
   */
  readonly kmsDataKeyReusePeriodSeconds?: number;

  /**
   * The ID of an AWS-managed customer master key (CMK) for Amazon SQS or a custom CMK. For more information, see Key Terms.
   *
   * @schema QueueSpecForProvider#kmsMasterKeyId
   */
  readonly kmsMasterKeyId?: string;

  /**
   * The limit of how many bytes a message can contain before Amazon SQS rejects it. An integer from 1024 bytes (1 KiB) up to 262144 bytes (256 KiB). The default for this attribute is 262144 (256 KiB).
   *
   * @schema QueueSpecForProvider#maxMessageSize
   */
  readonly maxMessageSize?: number;

  /**
   * The number of seconds Amazon SQS retains a message. Integer representing seconds, from 60 (1 minute) to 1209600 (14 days). The default for this attribute is 345600 (4 days).
   *
   * @schema QueueSpecForProvider#messageRetentionSeconds
   */
  readonly messageRetentionSeconds?: number;

  /**
   * The name of the queue. Queue names must be made up of only uppercase and lowercase ASCII letters, numbers, underscores, and hyphens, and must be between 1 and 80 characters long. For a FIFO (first-in-first-out) queue, the name must end with the .fifo suffix. Conflicts with name_prefix
   *
   * @schema QueueSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The JSON policy for the SQS queue.
   *
   * @schema QueueSpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * The time for which a ReceiveMessage call will wait for a message to arrive (long polling) before returning. An integer from 0 to 20 (seconds). The default for this attribute is 0, meaning that the call will return immediately.
   *
   * @schema QueueSpecForProvider#receiveWaitTimeSeconds
   */
  readonly receiveWaitTimeSeconds?: number;

  /**
   * The JSON policy to set up the Dead Letter Queue redrive permission, see AWS docs.
   *
   * @schema QueueSpecForProvider#redriveAllowPolicy
   */
  readonly redriveAllowPolicy?: string;

  /**
   * The JSON policy to set up the Dead Letter Queue, see AWS docs. Note: when specifying maxReceiveCount, you must specify it as an integer (5), and not a string ("5").
   *
   * @schema QueueSpecForProvider#redrivePolicy
   */
  readonly redrivePolicy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema QueueSpecForProvider#region
   */
  readonly region: string;

  /**
   * Boolean to enable server-side encryption (SSE) of message content with SQS-owned encryption keys. See Encryption at rest.
   *
   * @schema QueueSpecForProvider#sqsManagedSseEnabled
   */
  readonly sqsManagedSseEnabled?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema QueueSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The visibility timeout for the queue. An integer from 0 to 43200 (12 hours). The default for this attribute is 30. For more information about visibility timeout, see AWS docs.
   *
   * @schema QueueSpecForProvider#visibilityTimeoutSeconds
   */
  readonly visibilityTimeoutSeconds?: number;

}

/**
 * Converts an object of type 'QueueSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProvider(obj: QueueSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentBasedDeduplication': obj.contentBasedDeduplication,
    'deduplicationScope': obj.deduplicationScope,
    'delaySeconds': obj.delaySeconds,
    'fifoQueue': obj.fifoQueue,
    'fifoThroughputLimit': obj.fifoThroughputLimit,
    'kmsDataKeyReusePeriodSeconds': obj.kmsDataKeyReusePeriodSeconds,
    'kmsMasterKeyId': obj.kmsMasterKeyId,
    'maxMessageSize': obj.maxMessageSize,
    'messageRetentionSeconds': obj.messageRetentionSeconds,
    'name': obj.name,
    'policy': obj.policy,
    'receiveWaitTimeSeconds': obj.receiveWaitTimeSeconds,
    'redriveAllowPolicy': obj.redriveAllowPolicy,
    'redrivePolicy': obj.redrivePolicy,
    'region': obj.region,
    'sqsManagedSseEnabled': obj.sqsManagedSseEnabled,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'visibilityTimeoutSeconds': obj.visibilityTimeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema QueueSpecProviderConfigRef
 */
export interface QueueSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueSpecProviderConfigRef#policy
   */
  readonly policy?: QueueSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'QueueSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecProviderConfigRef(obj: QueueSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema QueueSpecProviderRef
 */
export interface QueueSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueSpecProviderRef#policy
   */
  readonly policy?: QueueSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'QueueSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecProviderRef(obj: QueueSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema QueueSpecPublishConnectionDetailsTo
 */
export interface QueueSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema QueueSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: QueueSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema QueueSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: QueueSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema QueueSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'QueueSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecPublishConnectionDetailsTo(obj: QueueSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_QueueSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_QueueSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema QueueSpecWriteConnectionSecretToRef
 */
export interface QueueSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema QueueSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema QueueSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'QueueSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecWriteConnectionSecretToRef(obj: QueueSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QueueSpecProviderConfigRefPolicy
 */
export interface QueueSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: QueueSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: QueueSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecProviderConfigRefPolicy(obj: QueueSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QueueSpecProviderRefPolicy
 */
export interface QueueSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueSpecProviderRefPolicy#resolution
   */
  readonly resolution?: QueueSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueSpecProviderRefPolicy#resolve
   */
  readonly resolve?: QueueSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecProviderRefPolicy(obj: QueueSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema QueueSpecPublishConnectionDetailsToConfigRef
 */
export interface QueueSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: QueueSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'QueueSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecPublishConnectionDetailsToConfigRef(obj: QueueSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema QueueSpecPublishConnectionDetailsToMetadata
 */
export interface QueueSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema QueueSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema QueueSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema QueueSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'QueueSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecPublishConnectionDetailsToMetadata(obj: QueueSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueSpecProviderConfigRefPolicyResolution
 */
export enum QueueSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueSpecProviderConfigRefPolicyResolve
 */
export enum QueueSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueSpecProviderRefPolicyResolution
 */
export enum QueueSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueSpecProviderRefPolicyResolve
 */
export enum QueueSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema QueueSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface QueueSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: QueueSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: QueueSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecPublishConnectionDetailsToConfigRefPolicy(obj: QueueSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum QueueSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum QueueSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * QueuePolicy is the Schema for the QueuePolicys API. Provides a SQS Queue Policy resource.
 *
 * @schema QueuePolicy
 */
export class QueuePolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "QueuePolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sqs.aws.upbound.io/v1beta1',
    kind: 'QueuePolicy',
  }

  /**
   * Renders a Kubernetes manifest for "QueuePolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: QueuePolicyProps): any {
    return {
      ...QueuePolicy.GVK,
      ...toJson_QueuePolicyProps(props),
    };
  }

  /**
   * Defines a "QueuePolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: QueuePolicyProps) {
    super(scope, id, {
      ...QueuePolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...QueuePolicy.GVK,
      ...toJson_QueuePolicyProps(resolved),
    };
  }
}

/**
 * QueuePolicy is the Schema for the QueuePolicys API. Provides a SQS Queue Policy resource.
 *
 * @schema QueuePolicy
 */
export interface QueuePolicyProps {
  /**
   * @schema QueuePolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * QueuePolicySpec defines the desired state of QueuePolicy
   *
   * @schema QueuePolicy#spec
   */
  readonly spec: QueuePolicySpec;

}

/**
 * Converts an object of type 'QueuePolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueuePolicyProps(obj: QueuePolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_QueuePolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueuePolicySpec defines the desired state of QueuePolicy
 *
 * @schema QueuePolicySpec
 */
export interface QueuePolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema QueuePolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: QueuePolicySpecDeletionPolicy;

  /**
   * @schema QueuePolicySpec#forProvider
   */
  readonly forProvider: QueuePolicySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema QueuePolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: QueuePolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema QueuePolicySpec#providerRef
   */
  readonly providerRef?: QueuePolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema QueuePolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: QueuePolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema QueuePolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: QueuePolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'QueuePolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueuePolicySpec(obj: QueuePolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_QueuePolicySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_QueuePolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_QueuePolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_QueuePolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_QueuePolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema QueuePolicySpecDeletionPolicy
 */
export enum QueuePolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema QueuePolicySpecForProvider
 */
export interface QueuePolicySpecForProvider {
  /**
   * The JSON policy for the SQS queue.
   *
   * @schema QueuePolicySpecForProvider#policy
   */
  readonly policy: string;

  /**
   * The URL of the SQS Queue to which to attach the policy
   *
   * @schema QueuePolicySpecForProvider#queueUrl
   */
  readonly queueUrl?: string;

  /**
   * Reference to a Queue in sqs to populate queueUrl.
   *
   * @schema QueuePolicySpecForProvider#queueUrlRef
   */
  readonly queueUrlRef?: QueuePolicySpecForProviderQueueUrlRef;

  /**
   * Selector for a Queue in sqs to populate queueUrl.
   *
   * @schema QueuePolicySpecForProvider#queueUrlSelector
   */
  readonly queueUrlSelector?: QueuePolicySpecForProviderQueueUrlSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema QueuePolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'QueuePolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueuePolicySpecForProvider(obj: QueuePolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policy': obj.policy,
    'queueUrl': obj.queueUrl,
    'queueUrlRef': toJson_QueuePolicySpecForProviderQueueUrlRef(obj.queueUrlRef),
    'queueUrlSelector': toJson_QueuePolicySpecForProviderQueueUrlSelector(obj.queueUrlSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema QueuePolicySpecProviderConfigRef
 */
export interface QueuePolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueuePolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueuePolicySpecProviderConfigRef#policy
   */
  readonly policy?: QueuePolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'QueuePolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueuePolicySpecProviderConfigRef(obj: QueuePolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueuePolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema QueuePolicySpecProviderRef
 */
export interface QueuePolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueuePolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueuePolicySpecProviderRef#policy
   */
  readonly policy?: QueuePolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'QueuePolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueuePolicySpecProviderRef(obj: QueuePolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueuePolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema QueuePolicySpecPublishConnectionDetailsTo
 */
export interface QueuePolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema QueuePolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: QueuePolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema QueuePolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: QueuePolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema QueuePolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'QueuePolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueuePolicySpecPublishConnectionDetailsTo(obj: QueuePolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_QueuePolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_QueuePolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema QueuePolicySpecWriteConnectionSecretToRef
 */
export interface QueuePolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema QueuePolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema QueuePolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'QueuePolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueuePolicySpecWriteConnectionSecretToRef(obj: QueuePolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Queue in sqs to populate queueUrl.
 *
 * @schema QueuePolicySpecForProviderQueueUrlRef
 */
export interface QueuePolicySpecForProviderQueueUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueuePolicySpecForProviderQueueUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueuePolicySpecForProviderQueueUrlRef#policy
   */
  readonly policy?: QueuePolicySpecForProviderQueueUrlRefPolicy;

}

/**
 * Converts an object of type 'QueuePolicySpecForProviderQueueUrlRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueuePolicySpecForProviderQueueUrlRef(obj: QueuePolicySpecForProviderQueueUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueuePolicySpecForProviderQueueUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Queue in sqs to populate queueUrl.
 *
 * @schema QueuePolicySpecForProviderQueueUrlSelector
 */
export interface QueuePolicySpecForProviderQueueUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema QueuePolicySpecForProviderQueueUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema QueuePolicySpecForProviderQueueUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema QueuePolicySpecForProviderQueueUrlSelector#policy
   */
  readonly policy?: QueuePolicySpecForProviderQueueUrlSelectorPolicy;

}

/**
 * Converts an object of type 'QueuePolicySpecForProviderQueueUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueuePolicySpecForProviderQueueUrlSelector(obj: QueuePolicySpecForProviderQueueUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_QueuePolicySpecForProviderQueueUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QueuePolicySpecProviderConfigRefPolicy
 */
export interface QueuePolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueuePolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: QueuePolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueuePolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: QueuePolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'QueuePolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueuePolicySpecProviderConfigRefPolicy(obj: QueuePolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QueuePolicySpecProviderRefPolicy
 */
export interface QueuePolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueuePolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: QueuePolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueuePolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: QueuePolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'QueuePolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueuePolicySpecProviderRefPolicy(obj: QueuePolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema QueuePolicySpecPublishConnectionDetailsToConfigRef
 */
export interface QueuePolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueuePolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueuePolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: QueuePolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'QueuePolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueuePolicySpecPublishConnectionDetailsToConfigRef(obj: QueuePolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueuePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema QueuePolicySpecPublishConnectionDetailsToMetadata
 */
export interface QueuePolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema QueuePolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema QueuePolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema QueuePolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'QueuePolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueuePolicySpecPublishConnectionDetailsToMetadata(obj: QueuePolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QueuePolicySpecForProviderQueueUrlRefPolicy
 */
export interface QueuePolicySpecForProviderQueueUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueuePolicySpecForProviderQueueUrlRefPolicy#resolution
   */
  readonly resolution?: QueuePolicySpecForProviderQueueUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueuePolicySpecForProviderQueueUrlRefPolicy#resolve
   */
  readonly resolve?: QueuePolicySpecForProviderQueueUrlRefPolicyResolve;

}

/**
 * Converts an object of type 'QueuePolicySpecForProviderQueueUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueuePolicySpecForProviderQueueUrlRefPolicy(obj: QueuePolicySpecForProviderQueueUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema QueuePolicySpecForProviderQueueUrlSelectorPolicy
 */
export interface QueuePolicySpecForProviderQueueUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueuePolicySpecForProviderQueueUrlSelectorPolicy#resolution
   */
  readonly resolution?: QueuePolicySpecForProviderQueueUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueuePolicySpecForProviderQueueUrlSelectorPolicy#resolve
   */
  readonly resolve?: QueuePolicySpecForProviderQueueUrlSelectorPolicyResolve;

}

/**
 * Converts an object of type 'QueuePolicySpecForProviderQueueUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueuePolicySpecForProviderQueueUrlSelectorPolicy(obj: QueuePolicySpecForProviderQueueUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueuePolicySpecProviderConfigRefPolicyResolution
 */
export enum QueuePolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueuePolicySpecProviderConfigRefPolicyResolve
 */
export enum QueuePolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueuePolicySpecProviderRefPolicyResolution
 */
export enum QueuePolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueuePolicySpecProviderRefPolicyResolve
 */
export enum QueuePolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema QueuePolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface QueuePolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueuePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: QueuePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueuePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: QueuePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'QueuePolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueuePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: QueuePolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueuePolicySpecForProviderQueueUrlRefPolicyResolution
 */
export enum QueuePolicySpecForProviderQueueUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueuePolicySpecForProviderQueueUrlRefPolicyResolve
 */
export enum QueuePolicySpecForProviderQueueUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueuePolicySpecForProviderQueueUrlSelectorPolicyResolution
 */
export enum QueuePolicySpecForProviderQueueUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueuePolicySpecForProviderQueueUrlSelectorPolicyResolve
 */
export enum QueuePolicySpecForProviderQueueUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueuePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum QueuePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueuePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum QueuePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * QueueRedriveAllowPolicy is the Schema for the QueueRedriveAllowPolicys API. Provides a SQS Queue Redrive Allow Policy resource.
 *
 * @schema QueueRedriveAllowPolicy
 */
export class QueueRedriveAllowPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "QueueRedriveAllowPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sqs.aws.upbound.io/v1beta1',
    kind: 'QueueRedriveAllowPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "QueueRedriveAllowPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: QueueRedriveAllowPolicyProps): any {
    return {
      ...QueueRedriveAllowPolicy.GVK,
      ...toJson_QueueRedriveAllowPolicyProps(props),
    };
  }

  /**
   * Defines a "QueueRedriveAllowPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: QueueRedriveAllowPolicyProps) {
    super(scope, id, {
      ...QueueRedriveAllowPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...QueueRedriveAllowPolicy.GVK,
      ...toJson_QueueRedriveAllowPolicyProps(resolved),
    };
  }
}

/**
 * QueueRedriveAllowPolicy is the Schema for the QueueRedriveAllowPolicys API. Provides a SQS Queue Redrive Allow Policy resource.
 *
 * @schema QueueRedriveAllowPolicy
 */
export interface QueueRedriveAllowPolicyProps {
  /**
   * @schema QueueRedriveAllowPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * QueueRedriveAllowPolicySpec defines the desired state of QueueRedriveAllowPolicy
   *
   * @schema QueueRedriveAllowPolicy#spec
   */
  readonly spec: QueueRedriveAllowPolicySpec;

}

/**
 * Converts an object of type 'QueueRedriveAllowPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedriveAllowPolicyProps(obj: QueueRedriveAllowPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_QueueRedriveAllowPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueueRedriveAllowPolicySpec defines the desired state of QueueRedriveAllowPolicy
 *
 * @schema QueueRedriveAllowPolicySpec
 */
export interface QueueRedriveAllowPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema QueueRedriveAllowPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: QueueRedriveAllowPolicySpecDeletionPolicy;

  /**
   * @schema QueueRedriveAllowPolicySpec#forProvider
   */
  readonly forProvider: QueueRedriveAllowPolicySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema QueueRedriveAllowPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: QueueRedriveAllowPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema QueueRedriveAllowPolicySpec#providerRef
   */
  readonly providerRef?: QueueRedriveAllowPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema QueueRedriveAllowPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: QueueRedriveAllowPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema QueueRedriveAllowPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: QueueRedriveAllowPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'QueueRedriveAllowPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedriveAllowPolicySpec(obj: QueueRedriveAllowPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_QueueRedriveAllowPolicySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_QueueRedriveAllowPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_QueueRedriveAllowPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_QueueRedriveAllowPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_QueueRedriveAllowPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema QueueRedriveAllowPolicySpecDeletionPolicy
 */
export enum QueueRedriveAllowPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema QueueRedriveAllowPolicySpecForProvider
 */
export interface QueueRedriveAllowPolicySpecForProvider {
  /**
   * The URL of the SQS Queue to which to attach the policy
   *
   * @schema QueueRedriveAllowPolicySpecForProvider#queueUrl
   */
  readonly queueUrl?: string;

  /**
   * Reference to a Queue in sqs to populate queueUrl.
   *
   * @schema QueueRedriveAllowPolicySpecForProvider#queueUrlRef
   */
  readonly queueUrlRef?: QueueRedriveAllowPolicySpecForProviderQueueUrlRef;

  /**
   * Selector for a Queue in sqs to populate queueUrl.
   *
   * @schema QueueRedriveAllowPolicySpecForProvider#queueUrlSelector
   */
  readonly queueUrlSelector?: QueueRedriveAllowPolicySpecForProviderQueueUrlSelector;

  /**
   * The JSON redrive allow policy for the SQS queue. Learn more in the Amazon SQS dead-letter queues documentation.
   *
   * @schema QueueRedriveAllowPolicySpecForProvider#redriveAllowPolicy
   */
  readonly redriveAllowPolicy: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema QueueRedriveAllowPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'QueueRedriveAllowPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedriveAllowPolicySpecForProvider(obj: QueueRedriveAllowPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'queueUrl': obj.queueUrl,
    'queueUrlRef': toJson_QueueRedriveAllowPolicySpecForProviderQueueUrlRef(obj.queueUrlRef),
    'queueUrlSelector': toJson_QueueRedriveAllowPolicySpecForProviderQueueUrlSelector(obj.queueUrlSelector),
    'redriveAllowPolicy': obj.redriveAllowPolicy,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema QueueRedriveAllowPolicySpecProviderConfigRef
 */
export interface QueueRedriveAllowPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueRedriveAllowPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueRedriveAllowPolicySpecProviderConfigRef#policy
   */
  readonly policy?: QueueRedriveAllowPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'QueueRedriveAllowPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedriveAllowPolicySpecProviderConfigRef(obj: QueueRedriveAllowPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueRedriveAllowPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema QueueRedriveAllowPolicySpecProviderRef
 */
export interface QueueRedriveAllowPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueRedriveAllowPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueRedriveAllowPolicySpecProviderRef#policy
   */
  readonly policy?: QueueRedriveAllowPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'QueueRedriveAllowPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedriveAllowPolicySpecProviderRef(obj: QueueRedriveAllowPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueRedriveAllowPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema QueueRedriveAllowPolicySpecPublishConnectionDetailsTo
 */
export interface QueueRedriveAllowPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema QueueRedriveAllowPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema QueueRedriveAllowPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: QueueRedriveAllowPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema QueueRedriveAllowPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'QueueRedriveAllowPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedriveAllowPolicySpecPublishConnectionDetailsTo(obj: QueueRedriveAllowPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_QueueRedriveAllowPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema QueueRedriveAllowPolicySpecWriteConnectionSecretToRef
 */
export interface QueueRedriveAllowPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema QueueRedriveAllowPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema QueueRedriveAllowPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'QueueRedriveAllowPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedriveAllowPolicySpecWriteConnectionSecretToRef(obj: QueueRedriveAllowPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Queue in sqs to populate queueUrl.
 *
 * @schema QueueRedriveAllowPolicySpecForProviderQueueUrlRef
 */
export interface QueueRedriveAllowPolicySpecForProviderQueueUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueRedriveAllowPolicySpecForProviderQueueUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueRedriveAllowPolicySpecForProviderQueueUrlRef#policy
   */
  readonly policy?: QueueRedriveAllowPolicySpecForProviderQueueUrlRefPolicy;

}

/**
 * Converts an object of type 'QueueRedriveAllowPolicySpecForProviderQueueUrlRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedriveAllowPolicySpecForProviderQueueUrlRef(obj: QueueRedriveAllowPolicySpecForProviderQueueUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueRedriveAllowPolicySpecForProviderQueueUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Queue in sqs to populate queueUrl.
 *
 * @schema QueueRedriveAllowPolicySpecForProviderQueueUrlSelector
 */
export interface QueueRedriveAllowPolicySpecForProviderQueueUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema QueueRedriveAllowPolicySpecForProviderQueueUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema QueueRedriveAllowPolicySpecForProviderQueueUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema QueueRedriveAllowPolicySpecForProviderQueueUrlSelector#policy
   */
  readonly policy?: QueueRedriveAllowPolicySpecForProviderQueueUrlSelectorPolicy;

}

/**
 * Converts an object of type 'QueueRedriveAllowPolicySpecForProviderQueueUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedriveAllowPolicySpecForProviderQueueUrlSelector(obj: QueueRedriveAllowPolicySpecForProviderQueueUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_QueueRedriveAllowPolicySpecForProviderQueueUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QueueRedriveAllowPolicySpecProviderConfigRefPolicy
 */
export interface QueueRedriveAllowPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueRedriveAllowPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: QueueRedriveAllowPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueRedriveAllowPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: QueueRedriveAllowPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueRedriveAllowPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedriveAllowPolicySpecProviderConfigRefPolicy(obj: QueueRedriveAllowPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QueueRedriveAllowPolicySpecProviderRefPolicy
 */
export interface QueueRedriveAllowPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueRedriveAllowPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: QueueRedriveAllowPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueRedriveAllowPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: QueueRedriveAllowPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueRedriveAllowPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedriveAllowPolicySpecProviderRefPolicy(obj: QueueRedriveAllowPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRef(obj: QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema QueueRedriveAllowPolicySpecPublishConnectionDetailsToMetadata
 */
export interface QueueRedriveAllowPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema QueueRedriveAllowPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema QueueRedriveAllowPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema QueueRedriveAllowPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'QueueRedriveAllowPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedriveAllowPolicySpecPublishConnectionDetailsToMetadata(obj: QueueRedriveAllowPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QueueRedriveAllowPolicySpecForProviderQueueUrlRefPolicy
 */
export interface QueueRedriveAllowPolicySpecForProviderQueueUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueRedriveAllowPolicySpecForProviderQueueUrlRefPolicy#resolution
   */
  readonly resolution?: QueueRedriveAllowPolicySpecForProviderQueueUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueRedriveAllowPolicySpecForProviderQueueUrlRefPolicy#resolve
   */
  readonly resolve?: QueueRedriveAllowPolicySpecForProviderQueueUrlRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueRedriveAllowPolicySpecForProviderQueueUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedriveAllowPolicySpecForProviderQueueUrlRefPolicy(obj: QueueRedriveAllowPolicySpecForProviderQueueUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema QueueRedriveAllowPolicySpecForProviderQueueUrlSelectorPolicy
 */
export interface QueueRedriveAllowPolicySpecForProviderQueueUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueRedriveAllowPolicySpecForProviderQueueUrlSelectorPolicy#resolution
   */
  readonly resolution?: QueueRedriveAllowPolicySpecForProviderQueueUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueRedriveAllowPolicySpecForProviderQueueUrlSelectorPolicy#resolve
   */
  readonly resolve?: QueueRedriveAllowPolicySpecForProviderQueueUrlSelectorPolicyResolve;

}

/**
 * Converts an object of type 'QueueRedriveAllowPolicySpecForProviderQueueUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedriveAllowPolicySpecForProviderQueueUrlSelectorPolicy(obj: QueueRedriveAllowPolicySpecForProviderQueueUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueRedriveAllowPolicySpecProviderConfigRefPolicyResolution
 */
export enum QueueRedriveAllowPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueRedriveAllowPolicySpecProviderConfigRefPolicyResolve
 */
export enum QueueRedriveAllowPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueRedriveAllowPolicySpecProviderRefPolicyResolution
 */
export enum QueueRedriveAllowPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueRedriveAllowPolicySpecProviderRefPolicyResolve
 */
export enum QueueRedriveAllowPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueRedriveAllowPolicySpecForProviderQueueUrlRefPolicyResolution
 */
export enum QueueRedriveAllowPolicySpecForProviderQueueUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueRedriveAllowPolicySpecForProviderQueueUrlRefPolicyResolve
 */
export enum QueueRedriveAllowPolicySpecForProviderQueueUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueRedriveAllowPolicySpecForProviderQueueUrlSelectorPolicyResolution
 */
export enum QueueRedriveAllowPolicySpecForProviderQueueUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueRedriveAllowPolicySpecForProviderQueueUrlSelectorPolicyResolve
 */
export enum QueueRedriveAllowPolicySpecForProviderQueueUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum QueueRedriveAllowPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * QueueRedrivePolicy is the Schema for the QueueRedrivePolicys API. Provides a SQS Queue Redrive Policy resource.
 *
 * @schema QueueRedrivePolicy
 */
export class QueueRedrivePolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "QueueRedrivePolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sqs.aws.upbound.io/v1beta1',
    kind: 'QueueRedrivePolicy',
  }

  /**
   * Renders a Kubernetes manifest for "QueueRedrivePolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: QueueRedrivePolicyProps): any {
    return {
      ...QueueRedrivePolicy.GVK,
      ...toJson_QueueRedrivePolicyProps(props),
    };
  }

  /**
   * Defines a "QueueRedrivePolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: QueueRedrivePolicyProps) {
    super(scope, id, {
      ...QueueRedrivePolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...QueueRedrivePolicy.GVK,
      ...toJson_QueueRedrivePolicyProps(resolved),
    };
  }
}

/**
 * QueueRedrivePolicy is the Schema for the QueueRedrivePolicys API. Provides a SQS Queue Redrive Policy resource.
 *
 * @schema QueueRedrivePolicy
 */
export interface QueueRedrivePolicyProps {
  /**
   * @schema QueueRedrivePolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * QueueRedrivePolicySpec defines the desired state of QueueRedrivePolicy
   *
   * @schema QueueRedrivePolicy#spec
   */
  readonly spec: QueueRedrivePolicySpec;

}

/**
 * Converts an object of type 'QueueRedrivePolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedrivePolicyProps(obj: QueueRedrivePolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_QueueRedrivePolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueueRedrivePolicySpec defines the desired state of QueueRedrivePolicy
 *
 * @schema QueueRedrivePolicySpec
 */
export interface QueueRedrivePolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema QueueRedrivePolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: QueueRedrivePolicySpecDeletionPolicy;

  /**
   * @schema QueueRedrivePolicySpec#forProvider
   */
  readonly forProvider: QueueRedrivePolicySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema QueueRedrivePolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: QueueRedrivePolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema QueueRedrivePolicySpec#providerRef
   */
  readonly providerRef?: QueueRedrivePolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema QueueRedrivePolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: QueueRedrivePolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema QueueRedrivePolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: QueueRedrivePolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'QueueRedrivePolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedrivePolicySpec(obj: QueueRedrivePolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_QueueRedrivePolicySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_QueueRedrivePolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_QueueRedrivePolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_QueueRedrivePolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_QueueRedrivePolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema QueueRedrivePolicySpecDeletionPolicy
 */
export enum QueueRedrivePolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema QueueRedrivePolicySpecForProvider
 */
export interface QueueRedrivePolicySpecForProvider {
  /**
   * The URL of the SQS Queue to which to attach the policy
   *
   * @schema QueueRedrivePolicySpecForProvider#queueUrl
   */
  readonly queueUrl?: string;

  /**
   * Reference to a Queue in sqs to populate queueUrl.
   *
   * @schema QueueRedrivePolicySpecForProvider#queueUrlRef
   */
  readonly queueUrlRef?: QueueRedrivePolicySpecForProviderQueueUrlRef;

  /**
   * Selector for a Queue in sqs to populate queueUrl.
   *
   * @schema QueueRedrivePolicySpecForProvider#queueUrlSelector
   */
  readonly queueUrlSelector?: QueueRedrivePolicySpecForProviderQueueUrlSelector;

  /**
   * The JSON redrive policy for the SQS queue. Accepts two key/val pairs: deadLetterTargetArn and maxReceiveCount. Learn more in the Amazon SQS dead-letter queues documentation.
   *
   * @schema QueueRedrivePolicySpecForProvider#redrivePolicy
   */
  readonly redrivePolicy: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema QueueRedrivePolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'QueueRedrivePolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedrivePolicySpecForProvider(obj: QueueRedrivePolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'queueUrl': obj.queueUrl,
    'queueUrlRef': toJson_QueueRedrivePolicySpecForProviderQueueUrlRef(obj.queueUrlRef),
    'queueUrlSelector': toJson_QueueRedrivePolicySpecForProviderQueueUrlSelector(obj.queueUrlSelector),
    'redrivePolicy': obj.redrivePolicy,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema QueueRedrivePolicySpecProviderConfigRef
 */
export interface QueueRedrivePolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueRedrivePolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueRedrivePolicySpecProviderConfigRef#policy
   */
  readonly policy?: QueueRedrivePolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'QueueRedrivePolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedrivePolicySpecProviderConfigRef(obj: QueueRedrivePolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueRedrivePolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema QueueRedrivePolicySpecProviderRef
 */
export interface QueueRedrivePolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueRedrivePolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueRedrivePolicySpecProviderRef#policy
   */
  readonly policy?: QueueRedrivePolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'QueueRedrivePolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedrivePolicySpecProviderRef(obj: QueueRedrivePolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueRedrivePolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema QueueRedrivePolicySpecPublishConnectionDetailsTo
 */
export interface QueueRedrivePolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema QueueRedrivePolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: QueueRedrivePolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema QueueRedrivePolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: QueueRedrivePolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema QueueRedrivePolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'QueueRedrivePolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedrivePolicySpecPublishConnectionDetailsTo(obj: QueueRedrivePolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_QueueRedrivePolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_QueueRedrivePolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema QueueRedrivePolicySpecWriteConnectionSecretToRef
 */
export interface QueueRedrivePolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema QueueRedrivePolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema QueueRedrivePolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'QueueRedrivePolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedrivePolicySpecWriteConnectionSecretToRef(obj: QueueRedrivePolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Queue in sqs to populate queueUrl.
 *
 * @schema QueueRedrivePolicySpecForProviderQueueUrlRef
 */
export interface QueueRedrivePolicySpecForProviderQueueUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueRedrivePolicySpecForProviderQueueUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueRedrivePolicySpecForProviderQueueUrlRef#policy
   */
  readonly policy?: QueueRedrivePolicySpecForProviderQueueUrlRefPolicy;

}

/**
 * Converts an object of type 'QueueRedrivePolicySpecForProviderQueueUrlRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedrivePolicySpecForProviderQueueUrlRef(obj: QueueRedrivePolicySpecForProviderQueueUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueRedrivePolicySpecForProviderQueueUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Queue in sqs to populate queueUrl.
 *
 * @schema QueueRedrivePolicySpecForProviderQueueUrlSelector
 */
export interface QueueRedrivePolicySpecForProviderQueueUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema QueueRedrivePolicySpecForProviderQueueUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema QueueRedrivePolicySpecForProviderQueueUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema QueueRedrivePolicySpecForProviderQueueUrlSelector#policy
   */
  readonly policy?: QueueRedrivePolicySpecForProviderQueueUrlSelectorPolicy;

}

/**
 * Converts an object of type 'QueueRedrivePolicySpecForProviderQueueUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedrivePolicySpecForProviderQueueUrlSelector(obj: QueueRedrivePolicySpecForProviderQueueUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_QueueRedrivePolicySpecForProviderQueueUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QueueRedrivePolicySpecProviderConfigRefPolicy
 */
export interface QueueRedrivePolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueRedrivePolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: QueueRedrivePolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueRedrivePolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: QueueRedrivePolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueRedrivePolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedrivePolicySpecProviderConfigRefPolicy(obj: QueueRedrivePolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QueueRedrivePolicySpecProviderRefPolicy
 */
export interface QueueRedrivePolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueRedrivePolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: QueueRedrivePolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueRedrivePolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: QueueRedrivePolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueRedrivePolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedrivePolicySpecProviderRefPolicy(obj: QueueRedrivePolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema QueueRedrivePolicySpecPublishConnectionDetailsToConfigRef
 */
export interface QueueRedrivePolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueRedrivePolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueRedrivePolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: QueueRedrivePolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'QueueRedrivePolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedrivePolicySpecPublishConnectionDetailsToConfigRef(obj: QueueRedrivePolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueRedrivePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema QueueRedrivePolicySpecPublishConnectionDetailsToMetadata
 */
export interface QueueRedrivePolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema QueueRedrivePolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema QueueRedrivePolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema QueueRedrivePolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'QueueRedrivePolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedrivePolicySpecPublishConnectionDetailsToMetadata(obj: QueueRedrivePolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QueueRedrivePolicySpecForProviderQueueUrlRefPolicy
 */
export interface QueueRedrivePolicySpecForProviderQueueUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueRedrivePolicySpecForProviderQueueUrlRefPolicy#resolution
   */
  readonly resolution?: QueueRedrivePolicySpecForProviderQueueUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueRedrivePolicySpecForProviderQueueUrlRefPolicy#resolve
   */
  readonly resolve?: QueueRedrivePolicySpecForProviderQueueUrlRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueRedrivePolicySpecForProviderQueueUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedrivePolicySpecForProviderQueueUrlRefPolicy(obj: QueueRedrivePolicySpecForProviderQueueUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema QueueRedrivePolicySpecForProviderQueueUrlSelectorPolicy
 */
export interface QueueRedrivePolicySpecForProviderQueueUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueRedrivePolicySpecForProviderQueueUrlSelectorPolicy#resolution
   */
  readonly resolution?: QueueRedrivePolicySpecForProviderQueueUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueRedrivePolicySpecForProviderQueueUrlSelectorPolicy#resolve
   */
  readonly resolve?: QueueRedrivePolicySpecForProviderQueueUrlSelectorPolicyResolve;

}

/**
 * Converts an object of type 'QueueRedrivePolicySpecForProviderQueueUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedrivePolicySpecForProviderQueueUrlSelectorPolicy(obj: QueueRedrivePolicySpecForProviderQueueUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueRedrivePolicySpecProviderConfigRefPolicyResolution
 */
export enum QueueRedrivePolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueRedrivePolicySpecProviderConfigRefPolicyResolve
 */
export enum QueueRedrivePolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueRedrivePolicySpecProviderRefPolicyResolution
 */
export enum QueueRedrivePolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueRedrivePolicySpecProviderRefPolicyResolve
 */
export enum QueueRedrivePolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema QueueRedrivePolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface QueueRedrivePolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueRedrivePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: QueueRedrivePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueRedrivePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: QueueRedrivePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueRedrivePolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueRedrivePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: QueueRedrivePolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueRedrivePolicySpecForProviderQueueUrlRefPolicyResolution
 */
export enum QueueRedrivePolicySpecForProviderQueueUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueRedrivePolicySpecForProviderQueueUrlRefPolicyResolve
 */
export enum QueueRedrivePolicySpecForProviderQueueUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueRedrivePolicySpecForProviderQueueUrlSelectorPolicyResolution
 */
export enum QueueRedrivePolicySpecForProviderQueueUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueRedrivePolicySpecForProviderQueueUrlSelectorPolicyResolve
 */
export enum QueueRedrivePolicySpecForProviderQueueUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueRedrivePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum QueueRedrivePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueRedrivePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum QueueRedrivePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

