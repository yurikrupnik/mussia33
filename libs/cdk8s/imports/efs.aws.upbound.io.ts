// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AccessPoint is the Schema for the AccessPoints API. Provides an Elastic File System (EFS) access point.
 *
 * @schema AccessPoint
 */
export class AccessPoint extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AccessPoint"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'efs.aws.upbound.io/v1beta1',
    kind: 'AccessPoint',
  }

  /**
   * Renders a Kubernetes manifest for "AccessPoint".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccessPointProps): any {
    return {
      ...AccessPoint.GVK,
      ...toJson_AccessPointProps(props),
    };
  }

  /**
   * Defines a "AccessPoint" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccessPointProps) {
    super(scope, id, {
      ...AccessPoint.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AccessPoint.GVK,
      ...toJson_AccessPointProps(resolved),
    };
  }
}

/**
 * AccessPoint is the Schema for the AccessPoints API. Provides an Elastic File System (EFS) access point.
 *
 * @schema AccessPoint
 */
export interface AccessPointProps {
  /**
   * @schema AccessPoint#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccessPointSpec defines the desired state of AccessPoint
   *
   * @schema AccessPoint#spec
   */
  readonly spec: AccessPointSpec;

}

/**
 * Converts an object of type 'AccessPointProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointProps(obj: AccessPointProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccessPointSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessPointSpec defines the desired state of AccessPoint
 *
 * @schema AccessPointSpec
 */
export interface AccessPointSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccessPointSpec#deletionPolicy
   */
  readonly deletionPolicy?: AccessPointSpecDeletionPolicy;

  /**
   * @schema AccessPointSpec#forProvider
   */
  readonly forProvider: AccessPointSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AccessPointSpec#initProvider
   */
  readonly initProvider?: AccessPointSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AccessPointSpec#managementPolicies
   */
  readonly managementPolicies?: AccessPointSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AccessPointSpec#providerConfigRef
   */
  readonly providerConfigRef?: AccessPointSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AccessPointSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccessPointSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AccessPointSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccessPointSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccessPointSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpec(obj: AccessPointSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccessPointSpecForProvider(obj.forProvider),
    'initProvider': toJson_AccessPointSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AccessPointSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AccessPointSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccessPointSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccessPointSpecDeletionPolicy
 */
export enum AccessPointSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AccessPointSpecForProvider
 */
export interface AccessPointSpecForProvider {
  /**
   * ID of the file system for which the access point is intended.
   *
   * @schema AccessPointSpecForProvider#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * Reference to a FileSystem to populate fileSystemId.
   *
   * @schema AccessPointSpecForProvider#fileSystemIdRef
   */
  readonly fileSystemIdRef?: AccessPointSpecForProviderFileSystemIdRef;

  /**
   * Selector for a FileSystem to populate fileSystemId.
   *
   * @schema AccessPointSpecForProvider#fileSystemIdSelector
   */
  readonly fileSystemIdSelector?: AccessPointSpecForProviderFileSystemIdSelector;

  /**
   * Operating system user and group applied to all file system requests made using the access point. Detailed below.
   *
   * @schema AccessPointSpecForProvider#posixUser
   */
  readonly posixUser?: AccessPointSpecForProviderPosixUser[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AccessPointSpecForProvider#region
   */
  readonly region: string;

  /**
   * Directory on the Amazon EFS file system that the access point provides access to. Detailed below.
   *
   * @schema AccessPointSpecForProvider#rootDirectory
   */
  readonly rootDirectory?: AccessPointSpecForProviderRootDirectory[];

  /**
   * Key-value map of resource tags.
   *
   * @schema AccessPointSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AccessPointSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProvider(obj: AccessPointSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileSystemId': obj.fileSystemId,
    'fileSystemIdRef': toJson_AccessPointSpecForProviderFileSystemIdRef(obj.fileSystemIdRef),
    'fileSystemIdSelector': toJson_AccessPointSpecForProviderFileSystemIdSelector(obj.fileSystemIdSelector),
    'posixUser': obj.posixUser?.map(y => toJson_AccessPointSpecForProviderPosixUser(y)),
    'region': obj.region,
    'rootDirectory': obj.rootDirectory?.map(y => toJson_AccessPointSpecForProviderRootDirectory(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AccessPointSpecInitProvider
 */
export interface AccessPointSpecInitProvider {
  /**
   * Operating system user and group applied to all file system requests made using the access point. Detailed below.
   *
   * @schema AccessPointSpecInitProvider#posixUser
   */
  readonly posixUser?: AccessPointSpecInitProviderPosixUser[];

  /**
   * Directory on the Amazon EFS file system that the access point provides access to. Detailed below.
   *
   * @schema AccessPointSpecInitProvider#rootDirectory
   */
  readonly rootDirectory?: AccessPointSpecInitProviderRootDirectory[];

  /**
   * Key-value map of resource tags.
   *
   * @schema AccessPointSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AccessPointSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecInitProvider(obj: AccessPointSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'posixUser': obj.posixUser?.map(y => toJson_AccessPointSpecInitProviderPosixUser(y)),
    'rootDirectory': obj.rootDirectory?.map(y => toJson_AccessPointSpecInitProviderRootDirectory(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AccessPointSpecManagementPolicies
 */
export enum AccessPointSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AccessPointSpecProviderConfigRef
 */
export interface AccessPointSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecProviderConfigRef#policy
   */
  readonly policy?: AccessPointSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecProviderConfigRef(obj: AccessPointSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AccessPointSpecPublishConnectionDetailsTo
 */
export interface AccessPointSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AccessPointSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccessPointSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccessPointSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccessPointSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccessPointSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccessPointSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecPublishConnectionDetailsTo(obj: AccessPointSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccessPointSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccessPointSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AccessPointSpecWriteConnectionSecretToRef
 */
export interface AccessPointSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccessPointSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccessPointSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccessPointSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecWriteConnectionSecretToRef(obj: AccessPointSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a FileSystem to populate fileSystemId.
 *
 * @schema AccessPointSpecForProviderFileSystemIdRef
 */
export interface AccessPointSpecForProviderFileSystemIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecForProviderFileSystemIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecForProviderFileSystemIdRef#policy
   */
  readonly policy?: AccessPointSpecForProviderFileSystemIdRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderFileSystemIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderFileSystemIdRef(obj: AccessPointSpecForProviderFileSystemIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecForProviderFileSystemIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a FileSystem to populate fileSystemId.
 *
 * @schema AccessPointSpecForProviderFileSystemIdSelector
 */
export interface AccessPointSpecForProviderFileSystemIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AccessPointSpecForProviderFileSystemIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AccessPointSpecForProviderFileSystemIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AccessPointSpecForProviderFileSystemIdSelector#policy
   */
  readonly policy?: AccessPointSpecForProviderFileSystemIdSelectorPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderFileSystemIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderFileSystemIdSelector(obj: AccessPointSpecForProviderFileSystemIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AccessPointSpecForProviderFileSystemIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessPointSpecForProviderPosixUser
 */
export interface AccessPointSpecForProviderPosixUser {
  /**
   * POSIX group ID used for all file system operations using this access point.
   *
   * @schema AccessPointSpecForProviderPosixUser#gid
   */
  readonly gid?: number;

  /**
   * Secondary POSIX group IDs used for all file system operations using this access point.
   *
   * @schema AccessPointSpecForProviderPosixUser#secondaryGids
   */
  readonly secondaryGids?: number[];

  /**
   * POSIX user ID used for all file system operations using this access point.
   *
   * @schema AccessPointSpecForProviderPosixUser#uid
   */
  readonly uid?: number;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPosixUser' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPosixUser(obj: AccessPointSpecForProviderPosixUser | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gid': obj.gid,
    'secondaryGids': obj.secondaryGids?.map(y => y),
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessPointSpecForProviderRootDirectory
 */
export interface AccessPointSpecForProviderRootDirectory {
  /**
   * POSIX IDs and permissions to apply to the access point's Root Directory. See Creation Info below.
   *
   * @schema AccessPointSpecForProviderRootDirectory#creationInfo
   */
  readonly creationInfo?: AccessPointSpecForProviderRootDirectoryCreationInfo[];

  /**
   * Path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified path does not exist, you are required to provide creation_info.
   *
   * @schema AccessPointSpecForProviderRootDirectory#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderRootDirectory' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderRootDirectory(obj: AccessPointSpecForProviderRootDirectory | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'creationInfo': obj.creationInfo?.map(y => toJson_AccessPointSpecForProviderRootDirectoryCreationInfo(y)),
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessPointSpecInitProviderPosixUser
 */
export interface AccessPointSpecInitProviderPosixUser {
  /**
   * POSIX group ID used for all file system operations using this access point.
   *
   * @schema AccessPointSpecInitProviderPosixUser#gid
   */
  readonly gid?: number;

  /**
   * Secondary POSIX group IDs used for all file system operations using this access point.
   *
   * @schema AccessPointSpecInitProviderPosixUser#secondaryGids
   */
  readonly secondaryGids?: number[];

  /**
   * POSIX user ID used for all file system operations using this access point.
   *
   * @schema AccessPointSpecInitProviderPosixUser#uid
   */
  readonly uid?: number;

}

/**
 * Converts an object of type 'AccessPointSpecInitProviderPosixUser' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecInitProviderPosixUser(obj: AccessPointSpecInitProviderPosixUser | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gid': obj.gid,
    'secondaryGids': obj.secondaryGids?.map(y => y),
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessPointSpecInitProviderRootDirectory
 */
export interface AccessPointSpecInitProviderRootDirectory {
  /**
   * POSIX IDs and permissions to apply to the access point's Root Directory. See Creation Info below.
   *
   * @schema AccessPointSpecInitProviderRootDirectory#creationInfo
   */
  readonly creationInfo?: AccessPointSpecInitProviderRootDirectoryCreationInfo[];

  /**
   * Path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified path does not exist, you are required to provide creation_info.
   *
   * @schema AccessPointSpecInitProviderRootDirectory#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'AccessPointSpecInitProviderRootDirectory' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecInitProviderRootDirectory(obj: AccessPointSpecInitProviderRootDirectory | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'creationInfo': obj.creationInfo?.map(y => toJson_AccessPointSpecInitProviderRootDirectoryCreationInfo(y)),
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecProviderConfigRefPolicy
 */
export interface AccessPointSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecProviderConfigRefPolicy(obj: AccessPointSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToConfigRef
 */
export interface AccessPointSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccessPointSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecPublishConnectionDetailsToConfigRef(obj: AccessPointSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToMetadata
 */
export interface AccessPointSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccessPointSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecPublishConnectionDetailsToMetadata(obj: AccessPointSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecForProviderFileSystemIdRefPolicy
 */
export interface AccessPointSpecForProviderFileSystemIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderFileSystemIdRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderFileSystemIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderFileSystemIdRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderFileSystemIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderFileSystemIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderFileSystemIdRefPolicy(obj: AccessPointSpecForProviderFileSystemIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AccessPointSpecForProviderFileSystemIdSelectorPolicy
 */
export interface AccessPointSpecForProviderFileSystemIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderFileSystemIdSelectorPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderFileSystemIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderFileSystemIdSelectorPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderFileSystemIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderFileSystemIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderFileSystemIdSelectorPolicy(obj: AccessPointSpecForProviderFileSystemIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessPointSpecForProviderRootDirectoryCreationInfo
 */
export interface AccessPointSpecForProviderRootDirectoryCreationInfo {
  /**
   * POSIX group ID to apply to the root_directory.
   *
   * @schema AccessPointSpecForProviderRootDirectoryCreationInfo#ownerGid
   */
  readonly ownerGid?: number;

  /**
   * POSIX user ID to apply to the root_directory.
   *
   * @schema AccessPointSpecForProviderRootDirectoryCreationInfo#ownerUid
   */
  readonly ownerUid?: number;

  /**
   * POSIX permissions to apply to the RootDirectory, in the format of an octal number representing the file's mode bits.
   *
   * @schema AccessPointSpecForProviderRootDirectoryCreationInfo#permissions
   */
  readonly permissions?: string;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderRootDirectoryCreationInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderRootDirectoryCreationInfo(obj: AccessPointSpecForProviderRootDirectoryCreationInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ownerGid': obj.ownerGid,
    'ownerUid': obj.ownerUid,
    'permissions': obj.permissions,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessPointSpecInitProviderRootDirectoryCreationInfo
 */
export interface AccessPointSpecInitProviderRootDirectoryCreationInfo {
  /**
   * POSIX group ID to apply to the root_directory.
   *
   * @schema AccessPointSpecInitProviderRootDirectoryCreationInfo#ownerGid
   */
  readonly ownerGid?: number;

  /**
   * POSIX user ID to apply to the root_directory.
   *
   * @schema AccessPointSpecInitProviderRootDirectoryCreationInfo#ownerUid
   */
  readonly ownerUid?: number;

  /**
   * POSIX permissions to apply to the RootDirectory, in the format of an octal number representing the file's mode bits.
   *
   * @schema AccessPointSpecInitProviderRootDirectoryCreationInfo#permissions
   */
  readonly permissions?: string;

}

/**
 * Converts an object of type 'AccessPointSpecInitProviderRootDirectoryCreationInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecInitProviderRootDirectoryCreationInfo(obj: AccessPointSpecInitProviderRootDirectoryCreationInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ownerGid': obj.ownerGid,
    'ownerUid': obj.ownerUid,
    'permissions': obj.permissions,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecProviderConfigRefPolicyResolution
 */
export enum AccessPointSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecProviderConfigRefPolicyResolve
 */
export enum AccessPointSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccessPointSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecPublishConnectionDetailsToConfigRefPolicy(obj: AccessPointSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderFileSystemIdRefPolicyResolution
 */
export enum AccessPointSpecForProviderFileSystemIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderFileSystemIdRefPolicyResolve
 */
export enum AccessPointSpecForProviderFileSystemIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderFileSystemIdSelectorPolicyResolution
 */
export enum AccessPointSpecForProviderFileSystemIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderFileSystemIdSelectorPolicyResolve
 */
export enum AccessPointSpecForProviderFileSystemIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BackupPolicy is the Schema for the BackupPolicys API. Provides an Elastic File System (EFS) Backup Policy resource.
 *
 * @schema BackupPolicy
 */
export class BackupPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackupPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'efs.aws.upbound.io/v1beta1',
    kind: 'BackupPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "BackupPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupPolicyProps): any {
    return {
      ...BackupPolicy.GVK,
      ...toJson_BackupPolicyProps(props),
    };
  }

  /**
   * Defines a "BackupPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupPolicyProps) {
    super(scope, id, {
      ...BackupPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackupPolicy.GVK,
      ...toJson_BackupPolicyProps(resolved),
    };
  }
}

/**
 * BackupPolicy is the Schema for the BackupPolicys API. Provides an Elastic File System (EFS) Backup Policy resource.
 *
 * @schema BackupPolicy
 */
export interface BackupPolicyProps {
  /**
   * @schema BackupPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackupPolicySpec defines the desired state of BackupPolicy
   *
   * @schema BackupPolicy#spec
   */
  readonly spec: BackupPolicySpec;

}

/**
 * Converts an object of type 'BackupPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupPolicyProps(obj: BackupPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackupPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BackupPolicySpec defines the desired state of BackupPolicy
 *
 * @schema BackupPolicySpec
 */
export interface BackupPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BackupPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: BackupPolicySpecDeletionPolicy;

  /**
   * @schema BackupPolicySpec#forProvider
   */
  readonly forProvider: BackupPolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema BackupPolicySpec#initProvider
   */
  readonly initProvider?: BackupPolicySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BackupPolicySpec#managementPolicies
   */
  readonly managementPolicies?: BackupPolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BackupPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: BackupPolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BackupPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BackupPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BackupPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BackupPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BackupPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupPolicySpec(obj: BackupPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BackupPolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_BackupPolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BackupPolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_BackupPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BackupPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BackupPolicySpecDeletionPolicy
 */
export enum BackupPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BackupPolicySpecForProvider
 */
export interface BackupPolicySpecForProvider {
  /**
   * A backup_policy object (documented below).
   *
   * @schema BackupPolicySpecForProvider#backupPolicy
   */
  readonly backupPolicy?: BackupPolicySpecForProviderBackupPolicy[];

  /**
   * The ID of the EFS file system.
   *
   * @schema BackupPolicySpecForProvider#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * Reference to a FileSystem to populate fileSystemId.
   *
   * @schema BackupPolicySpecForProvider#fileSystemIdRef
   */
  readonly fileSystemIdRef?: BackupPolicySpecForProviderFileSystemIdRef;

  /**
   * Selector for a FileSystem to populate fileSystemId.
   *
   * @schema BackupPolicySpecForProvider#fileSystemIdSelector
   */
  readonly fileSystemIdSelector?: BackupPolicySpecForProviderFileSystemIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BackupPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'BackupPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupPolicySpecForProvider(obj: BackupPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupPolicy': obj.backupPolicy?.map(y => toJson_BackupPolicySpecForProviderBackupPolicy(y)),
    'fileSystemId': obj.fileSystemId,
    'fileSystemIdRef': toJson_BackupPolicySpecForProviderFileSystemIdRef(obj.fileSystemIdRef),
    'fileSystemIdSelector': toJson_BackupPolicySpecForProviderFileSystemIdSelector(obj.fileSystemIdSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema BackupPolicySpecInitProvider
 */
export interface BackupPolicySpecInitProvider {
  /**
   * A backup_policy object (documented below).
   *
   * @schema BackupPolicySpecInitProvider#backupPolicy
   */
  readonly backupPolicy?: BackupPolicySpecInitProviderBackupPolicy[];

}

/**
 * Converts an object of type 'BackupPolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupPolicySpecInitProvider(obj: BackupPolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupPolicy': obj.backupPolicy?.map(y => toJson_BackupPolicySpecInitProviderBackupPolicy(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema BackupPolicySpecManagementPolicies
 */
export enum BackupPolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BackupPolicySpecProviderConfigRef
 */
export interface BackupPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupPolicySpecProviderConfigRef#policy
   */
  readonly policy?: BackupPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BackupPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupPolicySpecProviderConfigRef(obj: BackupPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BackupPolicySpecPublishConnectionDetailsTo
 */
export interface BackupPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BackupPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BackupPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BackupPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BackupPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BackupPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BackupPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupPolicySpecPublishConnectionDetailsTo(obj: BackupPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BackupPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BackupPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BackupPolicySpecWriteConnectionSecretToRef
 */
export interface BackupPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BackupPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BackupPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BackupPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupPolicySpecWriteConnectionSecretToRef(obj: BackupPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackupPolicySpecForProviderBackupPolicy
 */
export interface BackupPolicySpecForProviderBackupPolicy {
  /**
   * A status of the backup policy. Valid values: ENABLED, DISABLED.
   *
   * @schema BackupPolicySpecForProviderBackupPolicy#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'BackupPolicySpecForProviderBackupPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupPolicySpecForProviderBackupPolicy(obj: BackupPolicySpecForProviderBackupPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a FileSystem to populate fileSystemId.
 *
 * @schema BackupPolicySpecForProviderFileSystemIdRef
 */
export interface BackupPolicySpecForProviderFileSystemIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupPolicySpecForProviderFileSystemIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupPolicySpecForProviderFileSystemIdRef#policy
   */
  readonly policy?: BackupPolicySpecForProviderFileSystemIdRefPolicy;

}

/**
 * Converts an object of type 'BackupPolicySpecForProviderFileSystemIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupPolicySpecForProviderFileSystemIdRef(obj: BackupPolicySpecForProviderFileSystemIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupPolicySpecForProviderFileSystemIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a FileSystem to populate fileSystemId.
 *
 * @schema BackupPolicySpecForProviderFileSystemIdSelector
 */
export interface BackupPolicySpecForProviderFileSystemIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BackupPolicySpecForProviderFileSystemIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BackupPolicySpecForProviderFileSystemIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BackupPolicySpecForProviderFileSystemIdSelector#policy
   */
  readonly policy?: BackupPolicySpecForProviderFileSystemIdSelectorPolicy;

}

/**
 * Converts an object of type 'BackupPolicySpecForProviderFileSystemIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupPolicySpecForProviderFileSystemIdSelector(obj: BackupPolicySpecForProviderFileSystemIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BackupPolicySpecForProviderFileSystemIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackupPolicySpecInitProviderBackupPolicy
 */
export interface BackupPolicySpecInitProviderBackupPolicy {
  /**
   * A status of the backup policy. Valid values: ENABLED, DISABLED.
   *
   * @schema BackupPolicySpecInitProviderBackupPolicy#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'BackupPolicySpecInitProviderBackupPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupPolicySpecInitProviderBackupPolicy(obj: BackupPolicySpecInitProviderBackupPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackupPolicySpecProviderConfigRefPolicy
 */
export interface BackupPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BackupPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BackupPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupPolicySpecProviderConfigRefPolicy(obj: BackupPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BackupPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface BackupPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BackupPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BackupPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupPolicySpecPublishConnectionDetailsToConfigRef(obj: BackupPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BackupPolicySpecPublishConnectionDetailsToMetadata
 */
export interface BackupPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BackupPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BackupPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BackupPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BackupPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupPolicySpecPublishConnectionDetailsToMetadata(obj: BackupPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackupPolicySpecForProviderFileSystemIdRefPolicy
 */
export interface BackupPolicySpecForProviderFileSystemIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupPolicySpecForProviderFileSystemIdRefPolicy#resolution
   */
  readonly resolution?: BackupPolicySpecForProviderFileSystemIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupPolicySpecForProviderFileSystemIdRefPolicy#resolve
   */
  readonly resolve?: BackupPolicySpecForProviderFileSystemIdRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupPolicySpecForProviderFileSystemIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupPolicySpecForProviderFileSystemIdRefPolicy(obj: BackupPolicySpecForProviderFileSystemIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BackupPolicySpecForProviderFileSystemIdSelectorPolicy
 */
export interface BackupPolicySpecForProviderFileSystemIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupPolicySpecForProviderFileSystemIdSelectorPolicy#resolution
   */
  readonly resolution?: BackupPolicySpecForProviderFileSystemIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupPolicySpecForProviderFileSystemIdSelectorPolicy#resolve
   */
  readonly resolve?: BackupPolicySpecForProviderFileSystemIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BackupPolicySpecForProviderFileSystemIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupPolicySpecForProviderFileSystemIdSelectorPolicy(obj: BackupPolicySpecForProviderFileSystemIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupPolicySpecProviderConfigRefPolicyResolution
 */
export enum BackupPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupPolicySpecProviderConfigRefPolicyResolve
 */
export enum BackupPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BackupPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BackupPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BackupPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BackupPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: BackupPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupPolicySpecForProviderFileSystemIdRefPolicyResolution
 */
export enum BackupPolicySpecForProviderFileSystemIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupPolicySpecForProviderFileSystemIdRefPolicyResolve
 */
export enum BackupPolicySpecForProviderFileSystemIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupPolicySpecForProviderFileSystemIdSelectorPolicyResolution
 */
export enum BackupPolicySpecForProviderFileSystemIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupPolicySpecForProviderFileSystemIdSelectorPolicyResolve
 */
export enum BackupPolicySpecForProviderFileSystemIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BackupPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BackupPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FileSystem is the Schema for the FileSystems API. Provides an Elastic File System (EFS) File System resource.
 *
 * @schema FileSystem
 */
export class FileSystem extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FileSystem"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'efs.aws.upbound.io/v1beta1',
    kind: 'FileSystem',
  }

  /**
   * Renders a Kubernetes manifest for "FileSystem".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FileSystemProps): any {
    return {
      ...FileSystem.GVK,
      ...toJson_FileSystemProps(props),
    };
  }

  /**
   * Defines a "FileSystem" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FileSystemProps) {
    super(scope, id, {
      ...FileSystem.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FileSystem.GVK,
      ...toJson_FileSystemProps(resolved),
    };
  }
}

/**
 * FileSystem is the Schema for the FileSystems API. Provides an Elastic File System (EFS) File System resource.
 *
 * @schema FileSystem
 */
export interface FileSystemProps {
  /**
   * @schema FileSystem#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FileSystemSpec defines the desired state of FileSystem
   *
   * @schema FileSystem#spec
   */
  readonly spec: FileSystemSpec;

}

/**
 * Converts an object of type 'FileSystemProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemProps(obj: FileSystemProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FileSystemSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FileSystemSpec defines the desired state of FileSystem
 *
 * @schema FileSystemSpec
 */
export interface FileSystemSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FileSystemSpec#deletionPolicy
   */
  readonly deletionPolicy?: FileSystemSpecDeletionPolicy;

  /**
   * @schema FileSystemSpec#forProvider
   */
  readonly forProvider: FileSystemSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema FileSystemSpec#initProvider
   */
  readonly initProvider?: FileSystemSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FileSystemSpec#managementPolicies
   */
  readonly managementPolicies?: FileSystemSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FileSystemSpec#providerConfigRef
   */
  readonly providerConfigRef?: FileSystemSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FileSystemSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FileSystemSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FileSystemSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FileSystemSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FileSystemSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpec(obj: FileSystemSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FileSystemSpecForProvider(obj.forProvider),
    'initProvider': toJson_FileSystemSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FileSystemSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FileSystemSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FileSystemSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FileSystemSpecDeletionPolicy
 */
export enum FileSystemSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FileSystemSpecForProvider
 */
export interface FileSystemSpecForProvider {
  /**
   * the AWS Availability Zone in which to create the file system. Used to create a file system that uses One Zone storage classes. See user guide for more information.
   *
   * @schema FileSystemSpecForProvider#availabilityZoneName
   */
  readonly availabilityZoneName?: string;

  /**
   * A unique name (a maximum of 64 characters are allowed) used as reference when creating the Elastic File System to ensure idempotent file system creation. See Elastic File System user guide for more information.
   *
   * @schema FileSystemSpecForProvider#creationToken
   */
  readonly creationToken?: string;

  /**
   * If true, the disk will be encrypted.
   *
   * @schema FileSystemSpecForProvider#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * The ARN for the KMS encryption key. When specifying kms_key_id, encrypted needs to be set to true.
   *
   * @schema FileSystemSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema FileSystemSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: FileSystemSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema FileSystemSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: FileSystemSpecForProviderKmsKeyIdSelector;

  /**
   * A file system lifecycle policy object (documented below).
   *
   * @schema FileSystemSpecForProvider#lifecyclePolicy
   */
  readonly lifecyclePolicy?: FileSystemSpecForProviderLifecyclePolicy[];

  /**
   * The file system performance mode. Can be either "generalPurpose" or "maxIO" (Default: "generalPurpose").
   *
   * @schema FileSystemSpecForProvider#performanceMode
   */
  readonly performanceMode?: string;

  /**
   * The throughput, measured in MiB/s, that you want to provision for the file system. Only applicable with throughput_mode set to provisioned.
   *
   * @schema FileSystemSpecForProvider#provisionedThroughputInMibps
   */
  readonly provisionedThroughputInMibps?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FileSystemSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema FileSystemSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Throughput mode for the file system. Defaults to bursting. Valid values: bursting, provisioned, or elastic. When using provisioned, also set provisioned_throughput_in_mibps.
   *
   * @default bursting. Valid values: bursting, provisioned, or elastic. When using provisioned, also set provisioned_throughput_in_mibps.
   * @schema FileSystemSpecForProvider#throughputMode
   */
  readonly throughputMode?: string;

}

/**
 * Converts an object of type 'FileSystemSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecForProvider(obj: FileSystemSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityZoneName': obj.availabilityZoneName,
    'creationToken': obj.creationToken,
    'encrypted': obj.encrypted,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_FileSystemSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_FileSystemSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'lifecyclePolicy': obj.lifecyclePolicy?.map(y => toJson_FileSystemSpecForProviderLifecyclePolicy(y)),
    'performanceMode': obj.performanceMode,
    'provisionedThroughputInMibps': obj.provisionedThroughputInMibps,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'throughputMode': obj.throughputMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema FileSystemSpecInitProvider
 */
export interface FileSystemSpecInitProvider {
  /**
   * the AWS Availability Zone in which to create the file system. Used to create a file system that uses One Zone storage classes. See user guide for more information.
   *
   * @schema FileSystemSpecInitProvider#availabilityZoneName
   */
  readonly availabilityZoneName?: string;

  /**
   * A unique name (a maximum of 64 characters are allowed) used as reference when creating the Elastic File System to ensure idempotent file system creation. See Elastic File System user guide for more information.
   *
   * @schema FileSystemSpecInitProvider#creationToken
   */
  readonly creationToken?: string;

  /**
   * If true, the disk will be encrypted.
   *
   * @schema FileSystemSpecInitProvider#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * A file system lifecycle policy object (documented below).
   *
   * @schema FileSystemSpecInitProvider#lifecyclePolicy
   */
  readonly lifecyclePolicy?: FileSystemSpecInitProviderLifecyclePolicy[];

  /**
   * The file system performance mode. Can be either "generalPurpose" or "maxIO" (Default: "generalPurpose").
   *
   * @schema FileSystemSpecInitProvider#performanceMode
   */
  readonly performanceMode?: string;

  /**
   * The throughput, measured in MiB/s, that you want to provision for the file system. Only applicable with throughput_mode set to provisioned.
   *
   * @schema FileSystemSpecInitProvider#provisionedThroughputInMibps
   */
  readonly provisionedThroughputInMibps?: number;

  /**
   * Key-value map of resource tags.
   *
   * @schema FileSystemSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Throughput mode for the file system. Defaults to bursting. Valid values: bursting, provisioned, or elastic. When using provisioned, also set provisioned_throughput_in_mibps.
   *
   * @default bursting. Valid values: bursting, provisioned, or elastic. When using provisioned, also set provisioned_throughput_in_mibps.
   * @schema FileSystemSpecInitProvider#throughputMode
   */
  readonly throughputMode?: string;

}

/**
 * Converts an object of type 'FileSystemSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecInitProvider(obj: FileSystemSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityZoneName': obj.availabilityZoneName,
    'creationToken': obj.creationToken,
    'encrypted': obj.encrypted,
    'lifecyclePolicy': obj.lifecyclePolicy?.map(y => toJson_FileSystemSpecInitProviderLifecyclePolicy(y)),
    'performanceMode': obj.performanceMode,
    'provisionedThroughputInMibps': obj.provisionedThroughputInMibps,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'throughputMode': obj.throughputMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FileSystemSpecManagementPolicies
 */
export enum FileSystemSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FileSystemSpecProviderConfigRef
 */
export interface FileSystemSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FileSystemSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FileSystemSpecProviderConfigRef#policy
   */
  readonly policy?: FileSystemSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FileSystemSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecProviderConfigRef(obj: FileSystemSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FileSystemSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FileSystemSpecPublishConnectionDetailsTo
 */
export interface FileSystemSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FileSystemSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FileSystemSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FileSystemSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FileSystemSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FileSystemSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FileSystemSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecPublishConnectionDetailsTo(obj: FileSystemSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FileSystemSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FileSystemSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FileSystemSpecWriteConnectionSecretToRef
 */
export interface FileSystemSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FileSystemSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FileSystemSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FileSystemSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecWriteConnectionSecretToRef(obj: FileSystemSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema FileSystemSpecForProviderKmsKeyIdRef
 */
export interface FileSystemSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: FileSystemSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'FileSystemSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecForProviderKmsKeyIdRef(obj: FileSystemSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FileSystemSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema FileSystemSpecForProviderKmsKeyIdSelector
 */
export interface FileSystemSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: FileSystemSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'FileSystemSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecForProviderKmsKeyIdSelector(obj: FileSystemSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FileSystemSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FileSystemSpecForProviderLifecyclePolicy
 */
export interface FileSystemSpecForProviderLifecyclePolicy {
  /**
   * Indicates how long it takes to transition files to the IA storage class. Valid values: AFTER_1_DAY, AFTER_7_DAYS, AFTER_14_DAYS, AFTER_30_DAYS, AFTER_60_DAYS, or AFTER_90_DAYS.
   *
   * @schema FileSystemSpecForProviderLifecyclePolicy#transitionToIa
   */
  readonly transitionToIa?: string;

  /**
   * Describes the policy used to transition a file from infequent access storage to primary storage. Valid values: AFTER_1_ACCESS.
   *
   * @schema FileSystemSpecForProviderLifecyclePolicy#transitionToPrimaryStorageClass
   */
  readonly transitionToPrimaryStorageClass?: string;

}

/**
 * Converts an object of type 'FileSystemSpecForProviderLifecyclePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecForProviderLifecyclePolicy(obj: FileSystemSpecForProviderLifecyclePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'transitionToIa': obj.transitionToIa,
    'transitionToPrimaryStorageClass': obj.transitionToPrimaryStorageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FileSystemSpecInitProviderLifecyclePolicy
 */
export interface FileSystemSpecInitProviderLifecyclePolicy {
  /**
   * Indicates how long it takes to transition files to the IA storage class. Valid values: AFTER_1_DAY, AFTER_7_DAYS, AFTER_14_DAYS, AFTER_30_DAYS, AFTER_60_DAYS, or AFTER_90_DAYS.
   *
   * @schema FileSystemSpecInitProviderLifecyclePolicy#transitionToIa
   */
  readonly transitionToIa?: string;

  /**
   * Describes the policy used to transition a file from infequent access storage to primary storage. Valid values: AFTER_1_ACCESS.
   *
   * @schema FileSystemSpecInitProviderLifecyclePolicy#transitionToPrimaryStorageClass
   */
  readonly transitionToPrimaryStorageClass?: string;

}

/**
 * Converts an object of type 'FileSystemSpecInitProviderLifecyclePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecInitProviderLifecyclePolicy(obj: FileSystemSpecInitProviderLifecyclePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'transitionToIa': obj.transitionToIa,
    'transitionToPrimaryStorageClass': obj.transitionToPrimaryStorageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FileSystemSpecProviderConfigRefPolicy
 */
export interface FileSystemSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FileSystemSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FileSystemSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FileSystemSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FileSystemSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FileSystemSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecProviderConfigRefPolicy(obj: FileSystemSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FileSystemSpecPublishConnectionDetailsToConfigRef
 */
export interface FileSystemSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FileSystemSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FileSystemSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FileSystemSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FileSystemSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecPublishConnectionDetailsToConfigRef(obj: FileSystemSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FileSystemSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FileSystemSpecPublishConnectionDetailsToMetadata
 */
export interface FileSystemSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FileSystemSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FileSystemSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FileSystemSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FileSystemSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecPublishConnectionDetailsToMetadata(obj: FileSystemSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FileSystemSpecForProviderKmsKeyIdRefPolicy
 */
export interface FileSystemSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: FileSystemSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: FileSystemSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'FileSystemSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecForProviderKmsKeyIdRefPolicy(obj: FileSystemSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FileSystemSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface FileSystemSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: FileSystemSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: FileSystemSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FileSystemSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecForProviderKmsKeyIdSelectorPolicy(obj: FileSystemSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FileSystemSpecProviderConfigRefPolicyResolution
 */
export enum FileSystemSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FileSystemSpecProviderConfigRefPolicyResolve
 */
export enum FileSystemSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FileSystemSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FileSystemSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FileSystemSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FileSystemSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FileSystemSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecPublishConnectionDetailsToConfigRefPolicy(obj: FileSystemSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FileSystemSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum FileSystemSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FileSystemSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum FileSystemSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FileSystemSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum FileSystemSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FileSystemSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum FileSystemSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FileSystemPolicy is the Schema for the FileSystemPolicys API. Provides an Elastic File System (EFS) File System Policy resource.
 *
 * @schema FileSystemPolicy
 */
export class FileSystemPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FileSystemPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'efs.aws.upbound.io/v1beta1',
    kind: 'FileSystemPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "FileSystemPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FileSystemPolicyProps): any {
    return {
      ...FileSystemPolicy.GVK,
      ...toJson_FileSystemPolicyProps(props),
    };
  }

  /**
   * Defines a "FileSystemPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FileSystemPolicyProps) {
    super(scope, id, {
      ...FileSystemPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FileSystemPolicy.GVK,
      ...toJson_FileSystemPolicyProps(resolved),
    };
  }
}

/**
 * FileSystemPolicy is the Schema for the FileSystemPolicys API. Provides an Elastic File System (EFS) File System Policy resource.
 *
 * @schema FileSystemPolicy
 */
export interface FileSystemPolicyProps {
  /**
   * @schema FileSystemPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FileSystemPolicySpec defines the desired state of FileSystemPolicy
   *
   * @schema FileSystemPolicy#spec
   */
  readonly spec: FileSystemPolicySpec;

}

/**
 * Converts an object of type 'FileSystemPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemPolicyProps(obj: FileSystemPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FileSystemPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FileSystemPolicySpec defines the desired state of FileSystemPolicy
 *
 * @schema FileSystemPolicySpec
 */
export interface FileSystemPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FileSystemPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: FileSystemPolicySpecDeletionPolicy;

  /**
   * @schema FileSystemPolicySpec#forProvider
   */
  readonly forProvider: FileSystemPolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema FileSystemPolicySpec#initProvider
   */
  readonly initProvider?: FileSystemPolicySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FileSystemPolicySpec#managementPolicies
   */
  readonly managementPolicies?: FileSystemPolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FileSystemPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: FileSystemPolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FileSystemPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FileSystemPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FileSystemPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FileSystemPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FileSystemPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemPolicySpec(obj: FileSystemPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FileSystemPolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_FileSystemPolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FileSystemPolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FileSystemPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FileSystemPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FileSystemPolicySpecDeletionPolicy
 */
export enum FileSystemPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FileSystemPolicySpecForProvider
 */
export interface FileSystemPolicySpecForProvider {
  /**
   * A flag to indicate whether to bypass the aws_efs_file_system_policy lockout safety check. The policy lockout safety check determines whether the policy in the request will prevent the principal making the request will be locked out from making future PutFileSystemPolicy requests on the file system. Set bypass_policy_lockout_safety_check to true only when you intend to prevent the principal that is making the request from making a subsequent PutFileSystemPolicy request on the file system. The default value is false.
   *
   * @schema FileSystemPolicySpecForProvider#bypassPolicyLockoutSafetyCheck
   */
  readonly bypassPolicyLockoutSafetyCheck?: boolean;

  /**
   * The ID of the EFS file system.
   *
   * @schema FileSystemPolicySpecForProvider#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * Reference to a FileSystem to populate fileSystemId.
   *
   * @schema FileSystemPolicySpecForProvider#fileSystemIdRef
   */
  readonly fileSystemIdRef?: FileSystemPolicySpecForProviderFileSystemIdRef;

  /**
   * Selector for a FileSystem to populate fileSystemId.
   *
   * @schema FileSystemPolicySpecForProvider#fileSystemIdSelector
   */
  readonly fileSystemIdSelector?: FileSystemPolicySpecForProviderFileSystemIdSelector;

  /**
   * The JSON formatted file system policy for the EFS file system. see Docs for more info.
   *
   * @schema FileSystemPolicySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FileSystemPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'FileSystemPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemPolicySpecForProvider(obj: FileSystemPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bypassPolicyLockoutSafetyCheck': obj.bypassPolicyLockoutSafetyCheck,
    'fileSystemId': obj.fileSystemId,
    'fileSystemIdRef': toJson_FileSystemPolicySpecForProviderFileSystemIdRef(obj.fileSystemIdRef),
    'fileSystemIdSelector': toJson_FileSystemPolicySpecForProviderFileSystemIdSelector(obj.fileSystemIdSelector),
    'policy': obj.policy,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema FileSystemPolicySpecInitProvider
 */
export interface FileSystemPolicySpecInitProvider {
  /**
   * A flag to indicate whether to bypass the aws_efs_file_system_policy lockout safety check. The policy lockout safety check determines whether the policy in the request will prevent the principal making the request will be locked out from making future PutFileSystemPolicy requests on the file system. Set bypass_policy_lockout_safety_check to true only when you intend to prevent the principal that is making the request from making a subsequent PutFileSystemPolicy request on the file system. The default value is false.
   *
   * @schema FileSystemPolicySpecInitProvider#bypassPolicyLockoutSafetyCheck
   */
  readonly bypassPolicyLockoutSafetyCheck?: boolean;

  /**
   * The JSON formatted file system policy for the EFS file system. see Docs for more info.
   *
   * @schema FileSystemPolicySpecInitProvider#policy
   */
  readonly policy?: string;

}

/**
 * Converts an object of type 'FileSystemPolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemPolicySpecInitProvider(obj: FileSystemPolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bypassPolicyLockoutSafetyCheck': obj.bypassPolicyLockoutSafetyCheck,
    'policy': obj.policy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FileSystemPolicySpecManagementPolicies
 */
export enum FileSystemPolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FileSystemPolicySpecProviderConfigRef
 */
export interface FileSystemPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FileSystemPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FileSystemPolicySpecProviderConfigRef#policy
   */
  readonly policy?: FileSystemPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FileSystemPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemPolicySpecProviderConfigRef(obj: FileSystemPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FileSystemPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FileSystemPolicySpecPublishConnectionDetailsTo
 */
export interface FileSystemPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FileSystemPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FileSystemPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FileSystemPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FileSystemPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FileSystemPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FileSystemPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemPolicySpecPublishConnectionDetailsTo(obj: FileSystemPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FileSystemPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FileSystemPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FileSystemPolicySpecWriteConnectionSecretToRef
 */
export interface FileSystemPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FileSystemPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FileSystemPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FileSystemPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemPolicySpecWriteConnectionSecretToRef(obj: FileSystemPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a FileSystem to populate fileSystemId.
 *
 * @schema FileSystemPolicySpecForProviderFileSystemIdRef
 */
export interface FileSystemPolicySpecForProviderFileSystemIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema FileSystemPolicySpecForProviderFileSystemIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FileSystemPolicySpecForProviderFileSystemIdRef#policy
   */
  readonly policy?: FileSystemPolicySpecForProviderFileSystemIdRefPolicy;

}

/**
 * Converts an object of type 'FileSystemPolicySpecForProviderFileSystemIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemPolicySpecForProviderFileSystemIdRef(obj: FileSystemPolicySpecForProviderFileSystemIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FileSystemPolicySpecForProviderFileSystemIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a FileSystem to populate fileSystemId.
 *
 * @schema FileSystemPolicySpecForProviderFileSystemIdSelector
 */
export interface FileSystemPolicySpecForProviderFileSystemIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FileSystemPolicySpecForProviderFileSystemIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FileSystemPolicySpecForProviderFileSystemIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FileSystemPolicySpecForProviderFileSystemIdSelector#policy
   */
  readonly policy?: FileSystemPolicySpecForProviderFileSystemIdSelectorPolicy;

}

/**
 * Converts an object of type 'FileSystemPolicySpecForProviderFileSystemIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemPolicySpecForProviderFileSystemIdSelector(obj: FileSystemPolicySpecForProviderFileSystemIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FileSystemPolicySpecForProviderFileSystemIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FileSystemPolicySpecProviderConfigRefPolicy
 */
export interface FileSystemPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FileSystemPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FileSystemPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FileSystemPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FileSystemPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FileSystemPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemPolicySpecProviderConfigRefPolicy(obj: FileSystemPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FileSystemPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface FileSystemPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FileSystemPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FileSystemPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FileSystemPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FileSystemPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemPolicySpecPublishConnectionDetailsToConfigRef(obj: FileSystemPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FileSystemPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FileSystemPolicySpecPublishConnectionDetailsToMetadata
 */
export interface FileSystemPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FileSystemPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FileSystemPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FileSystemPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FileSystemPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemPolicySpecPublishConnectionDetailsToMetadata(obj: FileSystemPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FileSystemPolicySpecForProviderFileSystemIdRefPolicy
 */
export interface FileSystemPolicySpecForProviderFileSystemIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FileSystemPolicySpecForProviderFileSystemIdRefPolicy#resolution
   */
  readonly resolution?: FileSystemPolicySpecForProviderFileSystemIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FileSystemPolicySpecForProviderFileSystemIdRefPolicy#resolve
   */
  readonly resolve?: FileSystemPolicySpecForProviderFileSystemIdRefPolicyResolve;

}

/**
 * Converts an object of type 'FileSystemPolicySpecForProviderFileSystemIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemPolicySpecForProviderFileSystemIdRefPolicy(obj: FileSystemPolicySpecForProviderFileSystemIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FileSystemPolicySpecForProviderFileSystemIdSelectorPolicy
 */
export interface FileSystemPolicySpecForProviderFileSystemIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FileSystemPolicySpecForProviderFileSystemIdSelectorPolicy#resolution
   */
  readonly resolution?: FileSystemPolicySpecForProviderFileSystemIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FileSystemPolicySpecForProviderFileSystemIdSelectorPolicy#resolve
   */
  readonly resolve?: FileSystemPolicySpecForProviderFileSystemIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FileSystemPolicySpecForProviderFileSystemIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemPolicySpecForProviderFileSystemIdSelectorPolicy(obj: FileSystemPolicySpecForProviderFileSystemIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FileSystemPolicySpecProviderConfigRefPolicyResolution
 */
export enum FileSystemPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FileSystemPolicySpecProviderConfigRefPolicyResolve
 */
export enum FileSystemPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FileSystemPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FileSystemPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FileSystemPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FileSystemPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FileSystemPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FileSystemPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FileSystemPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: FileSystemPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FileSystemPolicySpecForProviderFileSystemIdRefPolicyResolution
 */
export enum FileSystemPolicySpecForProviderFileSystemIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FileSystemPolicySpecForProviderFileSystemIdRefPolicyResolve
 */
export enum FileSystemPolicySpecForProviderFileSystemIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FileSystemPolicySpecForProviderFileSystemIdSelectorPolicyResolution
 */
export enum FileSystemPolicySpecForProviderFileSystemIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FileSystemPolicySpecForProviderFileSystemIdSelectorPolicyResolve
 */
export enum FileSystemPolicySpecForProviderFileSystemIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FileSystemPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FileSystemPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FileSystemPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FileSystemPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MountTarget is the Schema for the MountTargets API. Provides an Elastic File System (EFS) mount target.
 *
 * @schema MountTarget
 */
export class MountTarget extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MountTarget"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'efs.aws.upbound.io/v1beta1',
    kind: 'MountTarget',
  }

  /**
   * Renders a Kubernetes manifest for "MountTarget".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MountTargetProps): any {
    return {
      ...MountTarget.GVK,
      ...toJson_MountTargetProps(props),
    };
  }

  /**
   * Defines a "MountTarget" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MountTargetProps) {
    super(scope, id, {
      ...MountTarget.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MountTarget.GVK,
      ...toJson_MountTargetProps(resolved),
    };
  }
}

/**
 * MountTarget is the Schema for the MountTargets API. Provides an Elastic File System (EFS) mount target.
 *
 * @schema MountTarget
 */
export interface MountTargetProps {
  /**
   * @schema MountTarget#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MountTargetSpec defines the desired state of MountTarget
   *
   * @schema MountTarget#spec
   */
  readonly spec: MountTargetSpec;

}

/**
 * Converts an object of type 'MountTargetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetProps(obj: MountTargetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MountTargetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MountTargetSpec defines the desired state of MountTarget
 *
 * @schema MountTargetSpec
 */
export interface MountTargetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MountTargetSpec#deletionPolicy
   */
  readonly deletionPolicy?: MountTargetSpecDeletionPolicy;

  /**
   * @schema MountTargetSpec#forProvider
   */
  readonly forProvider: MountTargetSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema MountTargetSpec#initProvider
   */
  readonly initProvider?: MountTargetSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema MountTargetSpec#managementPolicies
   */
  readonly managementPolicies?: MountTargetSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MountTargetSpec#providerConfigRef
   */
  readonly providerConfigRef?: MountTargetSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MountTargetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MountTargetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MountTargetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MountTargetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MountTargetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpec(obj: MountTargetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MountTargetSpecForProvider(obj.forProvider),
    'initProvider': toJson_MountTargetSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_MountTargetSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_MountTargetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MountTargetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MountTargetSpecDeletionPolicy
 */
export enum MountTargetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MountTargetSpecForProvider
 */
export interface MountTargetSpecForProvider {
  /**
   * The ID of the file system for which the mount target is intended.
   *
   * @schema MountTargetSpecForProvider#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * Reference to a FileSystem to populate fileSystemId.
   *
   * @schema MountTargetSpecForProvider#fileSystemIdRef
   */
  readonly fileSystemIdRef?: MountTargetSpecForProviderFileSystemIdRef;

  /**
   * Selector for a FileSystem to populate fileSystemId.
   *
   * @schema MountTargetSpecForProvider#fileSystemIdSelector
   */
  readonly fileSystemIdSelector?: MountTargetSpecForProviderFileSystemIdSelector;

  /**
   * The address (within the address range of the specified subnet) at which the file system may be mounted via the mount target.
   *
   * @schema MountTargetSpecForProvider#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MountTargetSpecForProvider#region
   */
  readonly region: string;

  /**
   * A list of up to 5 VPC security group IDs (that must be for the same VPC as subnet specified) in effect for the mount target.
   *
   * @schema MountTargetSpecForProvider#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * References to SecurityGroup in ec2 to populate securityGroups.
   *
   * @schema MountTargetSpecForProvider#securityGroupsRefs
   */
  readonly securityGroupsRefs?: MountTargetSpecForProviderSecurityGroupsRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate securityGroups.
   *
   * @schema MountTargetSpecForProvider#securityGroupsSelector
   */
  readonly securityGroupsSelector?: MountTargetSpecForProviderSecurityGroupsSelector;

  /**
   * The ID of the subnet to add the mount target in.
   *
   * @schema MountTargetSpecForProvider#subnetId
   */
  readonly subnetId?: string;

  /**
   * Reference to a Subnet in ec2 to populate subnetId.
   *
   * @schema MountTargetSpecForProvider#subnetIdRef
   */
  readonly subnetIdRef?: MountTargetSpecForProviderSubnetIdRef;

  /**
   * Selector for a Subnet in ec2 to populate subnetId.
   *
   * @schema MountTargetSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: MountTargetSpecForProviderSubnetIdSelector;

}

/**
 * Converts an object of type 'MountTargetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProvider(obj: MountTargetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileSystemId': obj.fileSystemId,
    'fileSystemIdRef': toJson_MountTargetSpecForProviderFileSystemIdRef(obj.fileSystemIdRef),
    'fileSystemIdSelector': toJson_MountTargetSpecForProviderFileSystemIdSelector(obj.fileSystemIdSelector),
    'ipAddress': obj.ipAddress,
    'region': obj.region,
    'securityGroups': obj.securityGroups?.map(y => y),
    'securityGroupsRefs': obj.securityGroupsRefs?.map(y => toJson_MountTargetSpecForProviderSecurityGroupsRefs(y)),
    'securityGroupsSelector': toJson_MountTargetSpecForProviderSecurityGroupsSelector(obj.securityGroupsSelector),
    'subnetId': obj.subnetId,
    'subnetIdRef': toJson_MountTargetSpecForProviderSubnetIdRef(obj.subnetIdRef),
    'subnetIdSelector': toJson_MountTargetSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema MountTargetSpecInitProvider
 */
export interface MountTargetSpecInitProvider {
  /**
   * The address (within the address range of the specified subnet) at which the file system may be mounted via the mount target.
   *
   * @schema MountTargetSpecInitProvider#ipAddress
   */
  readonly ipAddress?: string;

}

/**
 * Converts an object of type 'MountTargetSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecInitProvider(obj: MountTargetSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema MountTargetSpecManagementPolicies
 */
export enum MountTargetSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MountTargetSpecProviderConfigRef
 */
export interface MountTargetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MountTargetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MountTargetSpecProviderConfigRef#policy
   */
  readonly policy?: MountTargetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MountTargetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecProviderConfigRef(obj: MountTargetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MountTargetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MountTargetSpecPublishConnectionDetailsTo
 */
export interface MountTargetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MountTargetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MountTargetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MountTargetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MountTargetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MountTargetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MountTargetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecPublishConnectionDetailsTo(obj: MountTargetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MountTargetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MountTargetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MountTargetSpecWriteConnectionSecretToRef
 */
export interface MountTargetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MountTargetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MountTargetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MountTargetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecWriteConnectionSecretToRef(obj: MountTargetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a FileSystem to populate fileSystemId.
 *
 * @schema MountTargetSpecForProviderFileSystemIdRef
 */
export interface MountTargetSpecForProviderFileSystemIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MountTargetSpecForProviderFileSystemIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MountTargetSpecForProviderFileSystemIdRef#policy
   */
  readonly policy?: MountTargetSpecForProviderFileSystemIdRefPolicy;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderFileSystemIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderFileSystemIdRef(obj: MountTargetSpecForProviderFileSystemIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MountTargetSpecForProviderFileSystemIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a FileSystem to populate fileSystemId.
 *
 * @schema MountTargetSpecForProviderFileSystemIdSelector
 */
export interface MountTargetSpecForProviderFileSystemIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MountTargetSpecForProviderFileSystemIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MountTargetSpecForProviderFileSystemIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MountTargetSpecForProviderFileSystemIdSelector#policy
   */
  readonly policy?: MountTargetSpecForProviderFileSystemIdSelectorPolicy;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderFileSystemIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderFileSystemIdSelector(obj: MountTargetSpecForProviderFileSystemIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MountTargetSpecForProviderFileSystemIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema MountTargetSpecForProviderSecurityGroupsRefs
 */
export interface MountTargetSpecForProviderSecurityGroupsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsRefs#policy
   */
  readonly policy?: MountTargetSpecForProviderSecurityGroupsRefsPolicy;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderSecurityGroupsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderSecurityGroupsRefs(obj: MountTargetSpecForProviderSecurityGroupsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MountTargetSpecForProviderSecurityGroupsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate securityGroups.
 *
 * @schema MountTargetSpecForProviderSecurityGroupsSelector
 */
export interface MountTargetSpecForProviderSecurityGroupsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsSelector#policy
   */
  readonly policy?: MountTargetSpecForProviderSecurityGroupsSelectorPolicy;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderSecurityGroupsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderSecurityGroupsSelector(obj: MountTargetSpecForProviderSecurityGroupsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MountTargetSpecForProviderSecurityGroupsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Subnet in ec2 to populate subnetId.
 *
 * @schema MountTargetSpecForProviderSubnetIdRef
 */
export interface MountTargetSpecForProviderSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MountTargetSpecForProviderSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MountTargetSpecForProviderSubnetIdRef#policy
   */
  readonly policy?: MountTargetSpecForProviderSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderSubnetIdRef(obj: MountTargetSpecForProviderSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MountTargetSpecForProviderSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Subnet in ec2 to populate subnetId.
 *
 * @schema MountTargetSpecForProviderSubnetIdSelector
 */
export interface MountTargetSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MountTargetSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MountTargetSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MountTargetSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: MountTargetSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderSubnetIdSelector(obj: MountTargetSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MountTargetSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MountTargetSpecProviderConfigRefPolicy
 */
export interface MountTargetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MountTargetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MountTargetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MountTargetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MountTargetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MountTargetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecProviderConfigRefPolicy(obj: MountTargetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MountTargetSpecPublishConnectionDetailsToConfigRef
 */
export interface MountTargetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MountTargetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MountTargetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MountTargetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MountTargetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecPublishConnectionDetailsToConfigRef(obj: MountTargetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MountTargetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MountTargetSpecPublishConnectionDetailsToMetadata
 */
export interface MountTargetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MountTargetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MountTargetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MountTargetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MountTargetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecPublishConnectionDetailsToMetadata(obj: MountTargetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MountTargetSpecForProviderFileSystemIdRefPolicy
 */
export interface MountTargetSpecForProviderFileSystemIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MountTargetSpecForProviderFileSystemIdRefPolicy#resolution
   */
  readonly resolution?: MountTargetSpecForProviderFileSystemIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MountTargetSpecForProviderFileSystemIdRefPolicy#resolve
   */
  readonly resolve?: MountTargetSpecForProviderFileSystemIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderFileSystemIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderFileSystemIdRefPolicy(obj: MountTargetSpecForProviderFileSystemIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MountTargetSpecForProviderFileSystemIdSelectorPolicy
 */
export interface MountTargetSpecForProviderFileSystemIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MountTargetSpecForProviderFileSystemIdSelectorPolicy#resolution
   */
  readonly resolution?: MountTargetSpecForProviderFileSystemIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MountTargetSpecForProviderFileSystemIdSelectorPolicy#resolve
   */
  readonly resolve?: MountTargetSpecForProviderFileSystemIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderFileSystemIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderFileSystemIdSelectorPolicy(obj: MountTargetSpecForProviderFileSystemIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MountTargetSpecForProviderSecurityGroupsRefsPolicy
 */
export interface MountTargetSpecForProviderSecurityGroupsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsRefsPolicy#resolution
   */
  readonly resolution?: MountTargetSpecForProviderSecurityGroupsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsRefsPolicy#resolve
   */
  readonly resolve?: MountTargetSpecForProviderSecurityGroupsRefsPolicyResolve;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderSecurityGroupsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderSecurityGroupsRefsPolicy(obj: MountTargetSpecForProviderSecurityGroupsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MountTargetSpecForProviderSecurityGroupsSelectorPolicy
 */
export interface MountTargetSpecForProviderSecurityGroupsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsSelectorPolicy#resolution
   */
  readonly resolution?: MountTargetSpecForProviderSecurityGroupsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsSelectorPolicy#resolve
   */
  readonly resolve?: MountTargetSpecForProviderSecurityGroupsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderSecurityGroupsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderSecurityGroupsSelectorPolicy(obj: MountTargetSpecForProviderSecurityGroupsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MountTargetSpecForProviderSubnetIdRefPolicy
 */
export interface MountTargetSpecForProviderSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MountTargetSpecForProviderSubnetIdRefPolicy#resolution
   */
  readonly resolution?: MountTargetSpecForProviderSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MountTargetSpecForProviderSubnetIdRefPolicy#resolve
   */
  readonly resolve?: MountTargetSpecForProviderSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderSubnetIdRefPolicy(obj: MountTargetSpecForProviderSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MountTargetSpecForProviderSubnetIdSelectorPolicy
 */
export interface MountTargetSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MountTargetSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: MountTargetSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MountTargetSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: MountTargetSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderSubnetIdSelectorPolicy(obj: MountTargetSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MountTargetSpecProviderConfigRefPolicyResolution
 */
export enum MountTargetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MountTargetSpecProviderConfigRefPolicyResolve
 */
export enum MountTargetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MountTargetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MountTargetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MountTargetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MountTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MountTargetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MountTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MountTargetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecPublishConnectionDetailsToConfigRefPolicy(obj: MountTargetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MountTargetSpecForProviderFileSystemIdRefPolicyResolution
 */
export enum MountTargetSpecForProviderFileSystemIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MountTargetSpecForProviderFileSystemIdRefPolicyResolve
 */
export enum MountTargetSpecForProviderFileSystemIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MountTargetSpecForProviderFileSystemIdSelectorPolicyResolution
 */
export enum MountTargetSpecForProviderFileSystemIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MountTargetSpecForProviderFileSystemIdSelectorPolicyResolve
 */
export enum MountTargetSpecForProviderFileSystemIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MountTargetSpecForProviderSecurityGroupsRefsPolicyResolution
 */
export enum MountTargetSpecForProviderSecurityGroupsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MountTargetSpecForProviderSecurityGroupsRefsPolicyResolve
 */
export enum MountTargetSpecForProviderSecurityGroupsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MountTargetSpecForProviderSecurityGroupsSelectorPolicyResolution
 */
export enum MountTargetSpecForProviderSecurityGroupsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MountTargetSpecForProviderSecurityGroupsSelectorPolicyResolve
 */
export enum MountTargetSpecForProviderSecurityGroupsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MountTargetSpecForProviderSubnetIdRefPolicyResolution
 */
export enum MountTargetSpecForProviderSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MountTargetSpecForProviderSubnetIdRefPolicyResolve
 */
export enum MountTargetSpecForProviderSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MountTargetSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum MountTargetSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MountTargetSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum MountTargetSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MountTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MountTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MountTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MountTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ReplicationConfiguration is the Schema for the ReplicationConfigurations API. Provides an Elastic File System (EFS) Replication Configuration.
 *
 * @schema ReplicationConfiguration
 */
export class ReplicationConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReplicationConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'efs.aws.upbound.io/v1beta1',
    kind: 'ReplicationConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "ReplicationConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReplicationConfigurationProps): any {
    return {
      ...ReplicationConfiguration.GVK,
      ...toJson_ReplicationConfigurationProps(props),
    };
  }

  /**
   * Defines a "ReplicationConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReplicationConfigurationProps) {
    super(scope, id, {
      ...ReplicationConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReplicationConfiguration.GVK,
      ...toJson_ReplicationConfigurationProps(resolved),
    };
  }
}

/**
 * ReplicationConfiguration is the Schema for the ReplicationConfigurations API. Provides an Elastic File System (EFS) Replication Configuration.
 *
 * @schema ReplicationConfiguration
 */
export interface ReplicationConfigurationProps {
  /**
   * @schema ReplicationConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReplicationConfigurationSpec defines the desired state of ReplicationConfiguration
   *
   * @schema ReplicationConfiguration#spec
   */
  readonly spec: ReplicationConfigurationSpec;

}

/**
 * Converts an object of type 'ReplicationConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationProps(obj: ReplicationConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReplicationConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReplicationConfigurationSpec defines the desired state of ReplicationConfiguration
 *
 * @schema ReplicationConfigurationSpec
 */
export interface ReplicationConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReplicationConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ReplicationConfigurationSpecDeletionPolicy;

  /**
   * @schema ReplicationConfigurationSpec#forProvider
   */
  readonly forProvider: ReplicationConfigurationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ReplicationConfigurationSpec#initProvider
   */
  readonly initProvider?: ReplicationConfigurationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ReplicationConfigurationSpec#managementPolicies
   */
  readonly managementPolicies?: ReplicationConfigurationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ReplicationConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ReplicationConfigurationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ReplicationConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ReplicationConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ReplicationConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ReplicationConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpec(obj: ReplicationConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ReplicationConfigurationSpecForProvider(obj.forProvider),
    'initProvider': toJson_ReplicationConfigurationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ReplicationConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ReplicationConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ReplicationConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReplicationConfigurationSpecDeletionPolicy
 */
export enum ReplicationConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ReplicationConfigurationSpecForProvider
 */
export interface ReplicationConfigurationSpecForProvider {
  /**
   * A destination configuration block (documented below).
   *
   * @schema ReplicationConfigurationSpecForProvider#destination
   */
  readonly destination?: ReplicationConfigurationSpecForProviderDestination[];

  /**
   * The region in which the replica should be created. Region is the region you'd like your resource to be created in.
   *
   * @schema ReplicationConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ID of the file system that is to be replicated.
   *
   * @schema ReplicationConfigurationSpecForProvider#sourceFileSystemId
   */
  readonly sourceFileSystemId?: string;

  /**
   * Reference to a FileSystem in efs to populate sourceFileSystemId.
   *
   * @schema ReplicationConfigurationSpecForProvider#sourceFileSystemIdRef
   */
  readonly sourceFileSystemIdRef?: ReplicationConfigurationSpecForProviderSourceFileSystemIdRef;

  /**
   * Selector for a FileSystem in efs to populate sourceFileSystemId.
   *
   * @schema ReplicationConfigurationSpecForProvider#sourceFileSystemIdSelector
   */
  readonly sourceFileSystemIdSelector?: ReplicationConfigurationSpecForProviderSourceFileSystemIdSelector;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecForProvider(obj: ReplicationConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination?.map(y => toJson_ReplicationConfigurationSpecForProviderDestination(y)),
    'region': obj.region,
    'sourceFileSystemId': obj.sourceFileSystemId,
    'sourceFileSystemIdRef': toJson_ReplicationConfigurationSpecForProviderSourceFileSystemIdRef(obj.sourceFileSystemIdRef),
    'sourceFileSystemIdSelector': toJson_ReplicationConfigurationSpecForProviderSourceFileSystemIdSelector(obj.sourceFileSystemIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ReplicationConfigurationSpecInitProvider
 */
export interface ReplicationConfigurationSpecInitProvider {
  /**
   * A destination configuration block (documented below).
   *
   * @schema ReplicationConfigurationSpecInitProvider#destination
   */
  readonly destination?: ReplicationConfigurationSpecInitProviderDestination[];

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecInitProvider(obj: ReplicationConfigurationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination?.map(y => toJson_ReplicationConfigurationSpecInitProviderDestination(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ReplicationConfigurationSpecManagementPolicies
 */
export enum ReplicationConfigurationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ReplicationConfigurationSpecProviderConfigRef
 */
export interface ReplicationConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: ReplicationConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecProviderConfigRef(obj: ReplicationConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ReplicationConfigurationSpecPublishConnectionDetailsTo
 */
export interface ReplicationConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ReplicationConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecPublishConnectionDetailsTo(obj: ReplicationConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ReplicationConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ReplicationConfigurationSpecWriteConnectionSecretToRef
 */
export interface ReplicationConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ReplicationConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReplicationConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecWriteConnectionSecretToRef(obj: ReplicationConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReplicationConfigurationSpecForProviderDestination
 */
export interface ReplicationConfigurationSpecForProviderDestination {
  /**
   * The availability zone in which the replica should be created. If specified, the replica will be created with One Zone storage. If omitted, regional storage will be used.
   *
   * @schema ReplicationConfigurationSpecForProviderDestination#availabilityZoneName
   */
  readonly availabilityZoneName?: string;

  /**
   * The Key ID, ARN, alias, or alias ARN of the KMS key that should be used to encrypt the replica file system. If omitted, the default KMS key for EFS /aws/elasticfilesystem will be used.
   *
   * @schema ReplicationConfigurationSpecForProviderDestination#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * The region in which the replica should be created.
   *
   * @schema ReplicationConfigurationSpecForProviderDestination#region
   */
  readonly region?: string;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecForProviderDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecForProviderDestination(obj: ReplicationConfigurationSpecForProviderDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityZoneName': obj.availabilityZoneName,
    'kmsKeyId': obj.kmsKeyId,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a FileSystem in efs to populate sourceFileSystemId.
 *
 * @schema ReplicationConfigurationSpecForProviderSourceFileSystemIdRef
 */
export interface ReplicationConfigurationSpecForProviderSourceFileSystemIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationConfigurationSpecForProviderSourceFileSystemIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationConfigurationSpecForProviderSourceFileSystemIdRef#policy
   */
  readonly policy?: ReplicationConfigurationSpecForProviderSourceFileSystemIdRefPolicy;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecForProviderSourceFileSystemIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecForProviderSourceFileSystemIdRef(obj: ReplicationConfigurationSpecForProviderSourceFileSystemIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationConfigurationSpecForProviderSourceFileSystemIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a FileSystem in efs to populate sourceFileSystemId.
 *
 * @schema ReplicationConfigurationSpecForProviderSourceFileSystemIdSelector
 */
export interface ReplicationConfigurationSpecForProviderSourceFileSystemIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ReplicationConfigurationSpecForProviderSourceFileSystemIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ReplicationConfigurationSpecForProviderSourceFileSystemIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ReplicationConfigurationSpecForProviderSourceFileSystemIdSelector#policy
   */
  readonly policy?: ReplicationConfigurationSpecForProviderSourceFileSystemIdSelectorPolicy;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecForProviderSourceFileSystemIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecForProviderSourceFileSystemIdSelector(obj: ReplicationConfigurationSpecForProviderSourceFileSystemIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ReplicationConfigurationSpecForProviderSourceFileSystemIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReplicationConfigurationSpecInitProviderDestination
 */
export interface ReplicationConfigurationSpecInitProviderDestination {
  /**
   * The availability zone in which the replica should be created. If specified, the replica will be created with One Zone storage. If omitted, regional storage will be used.
   *
   * @schema ReplicationConfigurationSpecInitProviderDestination#availabilityZoneName
   */
  readonly availabilityZoneName?: string;

  /**
   * The Key ID, ARN, alias, or alias ARN of the KMS key that should be used to encrypt the replica file system. If omitted, the default KMS key for EFS /aws/elasticfilesystem will be used.
   *
   * @schema ReplicationConfigurationSpecInitProviderDestination#kmsKeyId
   */
  readonly kmsKeyId?: string;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecInitProviderDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecInitProviderDestination(obj: ReplicationConfigurationSpecInitProviderDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityZoneName': obj.availabilityZoneName,
    'kmsKeyId': obj.kmsKeyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicationConfigurationSpecProviderConfigRefPolicy
 */
export interface ReplicationConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ReplicationConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ReplicationConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecProviderConfigRefPolicy(obj: ReplicationConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef(obj: ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ReplicationConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface ReplicationConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecPublishConnectionDetailsToMetadata(obj: ReplicationConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicationConfigurationSpecForProviderSourceFileSystemIdRefPolicy
 */
export interface ReplicationConfigurationSpecForProviderSourceFileSystemIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationConfigurationSpecForProviderSourceFileSystemIdRefPolicy#resolution
   */
  readonly resolution?: ReplicationConfigurationSpecForProviderSourceFileSystemIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationConfigurationSpecForProviderSourceFileSystemIdRefPolicy#resolve
   */
  readonly resolve?: ReplicationConfigurationSpecForProviderSourceFileSystemIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecForProviderSourceFileSystemIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecForProviderSourceFileSystemIdRefPolicy(obj: ReplicationConfigurationSpecForProviderSourceFileSystemIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ReplicationConfigurationSpecForProviderSourceFileSystemIdSelectorPolicy
 */
export interface ReplicationConfigurationSpecForProviderSourceFileSystemIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationConfigurationSpecForProviderSourceFileSystemIdSelectorPolicy#resolution
   */
  readonly resolution?: ReplicationConfigurationSpecForProviderSourceFileSystemIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationConfigurationSpecForProviderSourceFileSystemIdSelectorPolicy#resolve
   */
  readonly resolve?: ReplicationConfigurationSpecForProviderSourceFileSystemIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecForProviderSourceFileSystemIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecForProviderSourceFileSystemIdSelectorPolicy(obj: ReplicationConfigurationSpecForProviderSourceFileSystemIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum ReplicationConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum ReplicationConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationConfigurationSpecForProviderSourceFileSystemIdRefPolicyResolution
 */
export enum ReplicationConfigurationSpecForProviderSourceFileSystemIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationConfigurationSpecForProviderSourceFileSystemIdRefPolicyResolve
 */
export enum ReplicationConfigurationSpecForProviderSourceFileSystemIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationConfigurationSpecForProviderSourceFileSystemIdSelectorPolicyResolution
 */
export enum ReplicationConfigurationSpecForProviderSourceFileSystemIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationConfigurationSpecForProviderSourceFileSystemIdSelectorPolicyResolve
 */
export enum ReplicationConfigurationSpecForProviderSourceFileSystemIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

