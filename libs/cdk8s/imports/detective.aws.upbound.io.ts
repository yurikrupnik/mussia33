// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Graph is the Schema for the Graphs API. Provides a resource to manage an Amazon Detective graph.
 *
 * @schema Graph
 */
export class Graph extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Graph"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'detective.aws.upbound.io/v1beta1',
    kind: 'Graph',
  }

  /**
   * Renders a Kubernetes manifest for "Graph".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GraphProps): any {
    return {
      ...Graph.GVK,
      ...toJson_GraphProps(props),
    };
  }

  /**
   * Defines a "Graph" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GraphProps) {
    super(scope, id, {
      ...Graph.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Graph.GVK,
      ...toJson_GraphProps(resolved),
    };
  }
}

/**
 * Graph is the Schema for the Graphs API. Provides a resource to manage an Amazon Detective graph.
 *
 * @schema Graph
 */
export interface GraphProps {
  /**
   * @schema Graph#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GraphSpec defines the desired state of Graph
   *
   * @schema Graph#spec
   */
  readonly spec: GraphSpec;

}

/**
 * Converts an object of type 'GraphProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphProps(obj: GraphProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GraphSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GraphSpec defines the desired state of Graph
 *
 * @schema GraphSpec
 */
export interface GraphSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema GraphSpec#deletionPolicy
   */
  readonly deletionPolicy?: GraphSpecDeletionPolicy;

  /**
   * @schema GraphSpec#forProvider
   */
  readonly forProvider: GraphSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GraphSpec#providerConfigRef
   */
  readonly providerConfigRef?: GraphSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema GraphSpec#providerRef
   */
  readonly providerRef?: GraphSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GraphSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GraphSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GraphSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GraphSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GraphSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphSpec(obj: GraphSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GraphSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_GraphSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_GraphSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_GraphSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GraphSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema GraphSpecDeletionPolicy
 */
export enum GraphSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GraphSpecForProvider
 */
export interface GraphSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GraphSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema GraphSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'GraphSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphSpecForProvider(obj: GraphSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GraphSpecProviderConfigRef
 */
export interface GraphSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GraphSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GraphSpecProviderConfigRef#policy
   */
  readonly policy?: GraphSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GraphSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphSpecProviderConfigRef(obj: GraphSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GraphSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema GraphSpecProviderRef
 */
export interface GraphSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema GraphSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GraphSpecProviderRef#policy
   */
  readonly policy?: GraphSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'GraphSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphSpecProviderRef(obj: GraphSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GraphSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GraphSpecPublishConnectionDetailsTo
 */
export interface GraphSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GraphSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GraphSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GraphSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GraphSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GraphSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GraphSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphSpecPublishConnectionDetailsTo(obj: GraphSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GraphSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GraphSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GraphSpecWriteConnectionSecretToRef
 */
export interface GraphSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GraphSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GraphSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GraphSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphSpecWriteConnectionSecretToRef(obj: GraphSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GraphSpecProviderConfigRefPolicy
 */
export interface GraphSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GraphSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GraphSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GraphSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GraphSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GraphSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphSpecProviderConfigRefPolicy(obj: GraphSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GraphSpecProviderRefPolicy
 */
export interface GraphSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GraphSpecProviderRefPolicy#resolution
   */
  readonly resolution?: GraphSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GraphSpecProviderRefPolicy#resolve
   */
  readonly resolve?: GraphSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'GraphSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphSpecProviderRefPolicy(obj: GraphSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GraphSpecPublishConnectionDetailsToConfigRef
 */
export interface GraphSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GraphSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GraphSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GraphSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GraphSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphSpecPublishConnectionDetailsToConfigRef(obj: GraphSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GraphSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GraphSpecPublishConnectionDetailsToMetadata
 */
export interface GraphSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GraphSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GraphSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GraphSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GraphSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphSpecPublishConnectionDetailsToMetadata(obj: GraphSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GraphSpecProviderConfigRefPolicyResolution
 */
export enum GraphSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GraphSpecProviderConfigRefPolicyResolve
 */
export enum GraphSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GraphSpecProviderRefPolicyResolution
 */
export enum GraphSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GraphSpecProviderRefPolicyResolve
 */
export enum GraphSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GraphSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GraphSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GraphSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GraphSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GraphSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GraphSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GraphSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphSpecPublishConnectionDetailsToConfigRefPolicy(obj: GraphSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GraphSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GraphSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GraphSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GraphSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * InvitationAccepter is the Schema for the InvitationAccepters API. Provides a resource to manage an Amazon Detective member invitation accepter.
 *
 * @schema InvitationAccepter
 */
export class InvitationAccepter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InvitationAccepter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'detective.aws.upbound.io/v1beta1',
    kind: 'InvitationAccepter',
  }

  /**
   * Renders a Kubernetes manifest for "InvitationAccepter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InvitationAccepterProps): any {
    return {
      ...InvitationAccepter.GVK,
      ...toJson_InvitationAccepterProps(props),
    };
  }

  /**
   * Defines a "InvitationAccepter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InvitationAccepterProps) {
    super(scope, id, {
      ...InvitationAccepter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InvitationAccepter.GVK,
      ...toJson_InvitationAccepterProps(resolved),
    };
  }
}

/**
 * InvitationAccepter is the Schema for the InvitationAccepters API. Provides a resource to manage an Amazon Detective member invitation accepter.
 *
 * @schema InvitationAccepter
 */
export interface InvitationAccepterProps {
  /**
   * @schema InvitationAccepter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InvitationAccepterSpec defines the desired state of InvitationAccepter
   *
   * @schema InvitationAccepter#spec
   */
  readonly spec: InvitationAccepterSpec;

}

/**
 * Converts an object of type 'InvitationAccepterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterProps(obj: InvitationAccepterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InvitationAccepterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InvitationAccepterSpec defines the desired state of InvitationAccepter
 *
 * @schema InvitationAccepterSpec
 */
export interface InvitationAccepterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema InvitationAccepterSpec#deletionPolicy
   */
  readonly deletionPolicy?: InvitationAccepterSpecDeletionPolicy;

  /**
   * @schema InvitationAccepterSpec#forProvider
   */
  readonly forProvider: InvitationAccepterSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InvitationAccepterSpec#providerConfigRef
   */
  readonly providerConfigRef?: InvitationAccepterSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema InvitationAccepterSpec#providerRef
   */
  readonly providerRef?: InvitationAccepterSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InvitationAccepterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InvitationAccepterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InvitationAccepterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InvitationAccepterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InvitationAccepterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpec(obj: InvitationAccepterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InvitationAccepterSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_InvitationAccepterSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_InvitationAccepterSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_InvitationAccepterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InvitationAccepterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema InvitationAccepterSpecDeletionPolicy
 */
export enum InvitationAccepterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InvitationAccepterSpecForProvider
 */
export interface InvitationAccepterSpecForProvider {
  /**
   * ARN of the behavior graph that the member account is accepting the invitation for.
   *
   * @schema InvitationAccepterSpecForProvider#graphArn
   */
  readonly graphArn?: string;

  /**
   * Reference to a Graph in detective to populate graphArn.
   *
   * @schema InvitationAccepterSpecForProvider#graphArnRef
   */
  readonly graphArnRef?: InvitationAccepterSpecForProviderGraphArnRef;

  /**
   * Selector for a Graph in detective to populate graphArn.
   *
   * @schema InvitationAccepterSpecForProvider#graphArnSelector
   */
  readonly graphArnSelector?: InvitationAccepterSpecForProviderGraphArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema InvitationAccepterSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'InvitationAccepterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecForProvider(obj: InvitationAccepterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'graphArn': obj.graphArn,
    'graphArnRef': toJson_InvitationAccepterSpecForProviderGraphArnRef(obj.graphArnRef),
    'graphArnSelector': toJson_InvitationAccepterSpecForProviderGraphArnSelector(obj.graphArnSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InvitationAccepterSpecProviderConfigRef
 */
export interface InvitationAccepterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InvitationAccepterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InvitationAccepterSpecProviderConfigRef#policy
   */
  readonly policy?: InvitationAccepterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InvitationAccepterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecProviderConfigRef(obj: InvitationAccepterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InvitationAccepterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema InvitationAccepterSpecProviderRef
 */
export interface InvitationAccepterSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema InvitationAccepterSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InvitationAccepterSpecProviderRef#policy
   */
  readonly policy?: InvitationAccepterSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'InvitationAccepterSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecProviderRef(obj: InvitationAccepterSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InvitationAccepterSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InvitationAccepterSpecPublishConnectionDetailsTo
 */
export interface InvitationAccepterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InvitationAccepterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InvitationAccepterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InvitationAccepterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecPublishConnectionDetailsTo(obj: InvitationAccepterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InvitationAccepterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InvitationAccepterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InvitationAccepterSpecWriteConnectionSecretToRef
 */
export interface InvitationAccepterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InvitationAccepterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InvitationAccepterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InvitationAccepterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecWriteConnectionSecretToRef(obj: InvitationAccepterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Graph in detective to populate graphArn.
 *
 * @schema InvitationAccepterSpecForProviderGraphArnRef
 */
export interface InvitationAccepterSpecForProviderGraphArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema InvitationAccepterSpecForProviderGraphArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InvitationAccepterSpecForProviderGraphArnRef#policy
   */
  readonly policy?: InvitationAccepterSpecForProviderGraphArnRefPolicy;

}

/**
 * Converts an object of type 'InvitationAccepterSpecForProviderGraphArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecForProviderGraphArnRef(obj: InvitationAccepterSpecForProviderGraphArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InvitationAccepterSpecForProviderGraphArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Graph in detective to populate graphArn.
 *
 * @schema InvitationAccepterSpecForProviderGraphArnSelector
 */
export interface InvitationAccepterSpecForProviderGraphArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InvitationAccepterSpecForProviderGraphArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InvitationAccepterSpecForProviderGraphArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InvitationAccepterSpecForProviderGraphArnSelector#policy
   */
  readonly policy?: InvitationAccepterSpecForProviderGraphArnSelectorPolicy;

}

/**
 * Converts an object of type 'InvitationAccepterSpecForProviderGraphArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecForProviderGraphArnSelector(obj: InvitationAccepterSpecForProviderGraphArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InvitationAccepterSpecForProviderGraphArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InvitationAccepterSpecProviderConfigRefPolicy
 */
export interface InvitationAccepterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InvitationAccepterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InvitationAccepterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InvitationAccepterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InvitationAccepterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InvitationAccepterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecProviderConfigRefPolicy(obj: InvitationAccepterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InvitationAccepterSpecProviderRefPolicy
 */
export interface InvitationAccepterSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InvitationAccepterSpecProviderRefPolicy#resolution
   */
  readonly resolution?: InvitationAccepterSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InvitationAccepterSpecProviderRefPolicy#resolve
   */
  readonly resolve?: InvitationAccepterSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'InvitationAccepterSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecProviderRefPolicy(obj: InvitationAccepterSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InvitationAccepterSpecPublishConnectionDetailsToConfigRef
 */
export interface InvitationAccepterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InvitationAccepterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecPublishConnectionDetailsToConfigRef(obj: InvitationAccepterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InvitationAccepterSpecPublishConnectionDetailsToMetadata
 */
export interface InvitationAccepterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InvitationAccepterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecPublishConnectionDetailsToMetadata(obj: InvitationAccepterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InvitationAccepterSpecForProviderGraphArnRefPolicy
 */
export interface InvitationAccepterSpecForProviderGraphArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InvitationAccepterSpecForProviderGraphArnRefPolicy#resolution
   */
  readonly resolution?: InvitationAccepterSpecForProviderGraphArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InvitationAccepterSpecForProviderGraphArnRefPolicy#resolve
   */
  readonly resolve?: InvitationAccepterSpecForProviderGraphArnRefPolicyResolve;

}

/**
 * Converts an object of type 'InvitationAccepterSpecForProviderGraphArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecForProviderGraphArnRefPolicy(obj: InvitationAccepterSpecForProviderGraphArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InvitationAccepterSpecForProviderGraphArnSelectorPolicy
 */
export interface InvitationAccepterSpecForProviderGraphArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InvitationAccepterSpecForProviderGraphArnSelectorPolicy#resolution
   */
  readonly resolution?: InvitationAccepterSpecForProviderGraphArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InvitationAccepterSpecForProviderGraphArnSelectorPolicy#resolve
   */
  readonly resolve?: InvitationAccepterSpecForProviderGraphArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InvitationAccepterSpecForProviderGraphArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecForProviderGraphArnSelectorPolicy(obj: InvitationAccepterSpecForProviderGraphArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InvitationAccepterSpecProviderConfigRefPolicyResolution
 */
export enum InvitationAccepterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InvitationAccepterSpecProviderConfigRefPolicyResolve
 */
export enum InvitationAccepterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InvitationAccepterSpecProviderRefPolicyResolution
 */
export enum InvitationAccepterSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InvitationAccepterSpecProviderRefPolicyResolve
 */
export enum InvitationAccepterSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy(obj: InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InvitationAccepterSpecForProviderGraphArnRefPolicyResolution
 */
export enum InvitationAccepterSpecForProviderGraphArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InvitationAccepterSpecForProviderGraphArnRefPolicyResolve
 */
export enum InvitationAccepterSpecForProviderGraphArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InvitationAccepterSpecForProviderGraphArnSelectorPolicyResolution
 */
export enum InvitationAccepterSpecForProviderGraphArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InvitationAccepterSpecForProviderGraphArnSelectorPolicyResolve
 */
export enum InvitationAccepterSpecForProviderGraphArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InvitationAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Member is the Schema for the Members API. Provides a resource to manage an Amazon Detective member.
 *
 * @schema Member
 */
export class Member extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Member"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'detective.aws.upbound.io/v1beta1',
    kind: 'Member',
  }

  /**
   * Renders a Kubernetes manifest for "Member".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MemberProps): any {
    return {
      ...Member.GVK,
      ...toJson_MemberProps(props),
    };
  }

  /**
   * Defines a "Member" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MemberProps) {
    super(scope, id, {
      ...Member.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Member.GVK,
      ...toJson_MemberProps(resolved),
    };
  }
}

/**
 * Member is the Schema for the Members API. Provides a resource to manage an Amazon Detective member.
 *
 * @schema Member
 */
export interface MemberProps {
  /**
   * @schema Member#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MemberSpec defines the desired state of Member
   *
   * @schema Member#spec
   */
  readonly spec: MemberSpec;

}

/**
 * Converts an object of type 'MemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberProps(obj: MemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MemberSpec defines the desired state of Member
 *
 * @schema MemberSpec
 */
export interface MemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema MemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: MemberSpecDeletionPolicy;

  /**
   * @schema MemberSpec#forProvider
   */
  readonly forProvider: MemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: MemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MemberSpec#providerRef
   */
  readonly providerRef?: MemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpec(obj: MemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_MemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema MemberSpecDeletionPolicy
 */
export enum MemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MemberSpecForProvider
 */
export interface MemberSpecForProvider {
  /**
   * AWS account ID for the account.
   *
   * @schema MemberSpecForProvider#accountId
   */
  readonly accountId: string;

  /**
   * If set to true, then the root user of the invited account will not receive an email notification. This notification is in addition to an alert that the root user receives in AWS Personal Health Dashboard. By default, this is set to false.
   *
   * @schema MemberSpecForProvider#disableEmailNotification
   */
  readonly disableEmailNotification?: boolean;

  /**
   * Email address for the account.
   *
   * @schema MemberSpecForProvider#emailAddress
   */
  readonly emailAddress: string;

  /**
   * ARN of the behavior graph to invite the member accounts to contribute their data to.
   *
   * @schema MemberSpecForProvider#graphArn
   */
  readonly graphArn?: string;

  /**
   * Reference to a Graph in detective to populate graphArn.
   *
   * @schema MemberSpecForProvider#graphArnRef
   */
  readonly graphArnRef?: MemberSpecForProviderGraphArnRef;

  /**
   * Selector for a Graph in detective to populate graphArn.
   *
   * @schema MemberSpecForProvider#graphArnSelector
   */
  readonly graphArnSelector?: MemberSpecForProviderGraphArnSelector;

  /**
   * A custom message to include in the invitation. Amazon Detective adds this message to the standard content that it sends for an invitation.
   *
   * @schema MemberSpecForProvider#message
   */
  readonly message?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MemberSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'MemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecForProvider(obj: MemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'disableEmailNotification': obj.disableEmailNotification,
    'emailAddress': obj.emailAddress,
    'graphArn': obj.graphArn,
    'graphArnRef': toJson_MemberSpecForProviderGraphArnRef(obj.graphArnRef),
    'graphArnSelector': toJson_MemberSpecForProviderGraphArnSelector(obj.graphArnSelector),
    'message': obj.message,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MemberSpecProviderConfigRef
 */
export interface MemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemberSpecProviderConfigRef#policy
   */
  readonly policy?: MemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderConfigRef(obj: MemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MemberSpecProviderRef
 */
export interface MemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemberSpecProviderRef#policy
   */
  readonly policy?: MemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderRef(obj: MemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MemberSpecPublishConnectionDetailsTo
 */
export interface MemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsTo(obj: MemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MemberSpecWriteConnectionSecretToRef
 */
export interface MemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecWriteConnectionSecretToRef(obj: MemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Graph in detective to populate graphArn.
 *
 * @schema MemberSpecForProviderGraphArnRef
 */
export interface MemberSpecForProviderGraphArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemberSpecForProviderGraphArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemberSpecForProviderGraphArnRef#policy
   */
  readonly policy?: MemberSpecForProviderGraphArnRefPolicy;

}

/**
 * Converts an object of type 'MemberSpecForProviderGraphArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecForProviderGraphArnRef(obj: MemberSpecForProviderGraphArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemberSpecForProviderGraphArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Graph in detective to populate graphArn.
 *
 * @schema MemberSpecForProviderGraphArnSelector
 */
export interface MemberSpecForProviderGraphArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MemberSpecForProviderGraphArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MemberSpecForProviderGraphArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MemberSpecForProviderGraphArnSelector#policy
   */
  readonly policy?: MemberSpecForProviderGraphArnSelectorPolicy;

}

/**
 * Converts an object of type 'MemberSpecForProviderGraphArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecForProviderGraphArnSelector(obj: MemberSpecForProviderGraphArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MemberSpecForProviderGraphArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MemberSpecProviderConfigRefPolicy
 */
export interface MemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderConfigRefPolicy(obj: MemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MemberSpecProviderRefPolicy
 */
export interface MemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderRefPolicy(obj: MemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRef
 */
export interface MemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsToConfigRef(obj: MemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MemberSpecPublishConnectionDetailsToMetadata
 */
export interface MemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsToMetadata(obj: MemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MemberSpecForProviderGraphArnRefPolicy
 */
export interface MemberSpecForProviderGraphArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecForProviderGraphArnRefPolicy#resolution
   */
  readonly resolution?: MemberSpecForProviderGraphArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecForProviderGraphArnRefPolicy#resolve
   */
  readonly resolve?: MemberSpecForProviderGraphArnRefPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecForProviderGraphArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecForProviderGraphArnRefPolicy(obj: MemberSpecForProviderGraphArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MemberSpecForProviderGraphArnSelectorPolicy
 */
export interface MemberSpecForProviderGraphArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecForProviderGraphArnSelectorPolicy#resolution
   */
  readonly resolution?: MemberSpecForProviderGraphArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecForProviderGraphArnSelectorPolicy#resolve
   */
  readonly resolve?: MemberSpecForProviderGraphArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecForProviderGraphArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecForProviderGraphArnSelectorPolicy(obj: MemberSpecForProviderGraphArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecProviderConfigRefPolicyResolution
 */
export enum MemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecProviderConfigRefPolicyResolve
 */
export enum MemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecProviderRefPolicyResolution
 */
export enum MemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecProviderRefPolicyResolve
 */
export enum MemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: MemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecForProviderGraphArnRefPolicyResolution
 */
export enum MemberSpecForProviderGraphArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecForProviderGraphArnRefPolicyResolve
 */
export enum MemberSpecForProviderGraphArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecForProviderGraphArnSelectorPolicyResolution
 */
export enum MemberSpecForProviderGraphArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecForProviderGraphArnSelectorPolicyResolve
 */
export enum MemberSpecForProviderGraphArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

