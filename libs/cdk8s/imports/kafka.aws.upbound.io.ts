// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Cluster is the Schema for the Clusters API.
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.aws.upbound.io/v1beta1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * Cluster is the Schema for the Clusters API.
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSpec defines the desired state of Cluster
   *
   * @schema Cluster#spec
   */
  readonly spec: ClusterSpec;

}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSpec defines the desired state of Cluster
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSpecDeletionPolicy;

  /**
   * @schema ClusterSpec#forProvider
   */
  readonly forProvider: ClusterSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ClusterSpec#providerRef
   */
  readonly providerRef?: ClusterSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ClusterSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ClusterSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ClusterSpecDeletionPolicy
 */
export enum ClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterSpecForProvider
 */
export interface ClusterSpecForProvider {
  /**
   * Configuration block for the broker nodes of the Kafka cluster.
   *
   * @schema ClusterSpecForProvider#brokerNodeGroupInfo
   */
  readonly brokerNodeGroupInfo: ClusterSpecForProviderBrokerNodeGroupInfo[];

  /**
   * Configuration block for specifying a client authentication. See below.
   *
   * @schema ClusterSpecForProvider#clientAuthentication
   */
  readonly clientAuthentication?: ClusterSpecForProviderClientAuthentication[];

  /**
   * Name of the MSK cluster.
   *
   * @schema ClusterSpecForProvider#clusterName
   */
  readonly clusterName: string;

  /**
   * Configuration block for specifying a MSK Configuration to attach to Kafka brokers. See below.
   *
   * @schema ClusterSpecForProvider#configurationInfo
   */
  readonly configurationInfo?: ClusterSpecForProviderConfigurationInfo[];

  /**
   * Configuration block for specifying encryption. See below.
   *
   * @schema ClusterSpecForProvider#encryptionInfo
   */
  readonly encryptionInfo?: ClusterSpecForProviderEncryptionInfo[];

  /**
   * Specify the desired enhanced MSK CloudWatch monitoring level. See Monitoring Amazon MSK with Amazon CloudWatch
   *
   * @schema ClusterSpecForProvider#enhancedMonitoring
   */
  readonly enhancedMonitoring?: string;

  /**
   * Specify the desired Kafka software version.
   *
   * @schema ClusterSpecForProvider#kafkaVersion
   */
  readonly kafkaVersion: string;

  /**
   * Configuration block for streaming broker logs to Cloudwatch/S3/Kinesis Firehose. See below.
   *
   * @schema ClusterSpecForProvider#loggingInfo
   */
  readonly loggingInfo?: ClusterSpecForProviderLoggingInfo[];

  /**
   * The desired total number of broker nodes in the kafka cluster.  It must be a multiple of the number of specified client subnets.
   *
   * @schema ClusterSpecForProvider#numberOfBrokerNodes
   */
  readonly numberOfBrokerNodes: number;

  /**
   * Configuration block for JMX and Node monitoring for the MSK cluster. See below.
   *
   * @schema ClusterSpecForProvider#openMonitoring
   */
  readonly openMonitoring?: ClusterSpecForProviderOpenMonitoring[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterSpecForProvider#region
   */
  readonly region: string;

  /**
   * Controls storage mode for supported storage tiers. Valid values are: LOCAL or TIERED.
   *
   * @schema ClusterSpecForProvider#storageMode
   */
  readonly storageMode?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProvider(obj: ClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'brokerNodeGroupInfo': obj.brokerNodeGroupInfo?.map(y => toJson_ClusterSpecForProviderBrokerNodeGroupInfo(y)),
    'clientAuthentication': obj.clientAuthentication?.map(y => toJson_ClusterSpecForProviderClientAuthentication(y)),
    'clusterName': obj.clusterName,
    'configurationInfo': obj.configurationInfo?.map(y => toJson_ClusterSpecForProviderConfigurationInfo(y)),
    'encryptionInfo': obj.encryptionInfo?.map(y => toJson_ClusterSpecForProviderEncryptionInfo(y)),
    'enhancedMonitoring': obj.enhancedMonitoring,
    'kafkaVersion': obj.kafkaVersion,
    'loggingInfo': obj.loggingInfo?.map(y => toJson_ClusterSpecForProviderLoggingInfo(y)),
    'numberOfBrokerNodes': obj.numberOfBrokerNodes,
    'openMonitoring': obj.openMonitoring?.map(y => toJson_ClusterSpecForProviderOpenMonitoring(y)),
    'region': obj.region,
    'storageMode': obj.storageMode,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterSpecProviderConfigRef
 */
export interface ClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRef(obj: ClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ClusterSpecProviderRef
 */
export interface ClusterSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderRef#policy
   */
  readonly policy?: ClusterSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderRef(obj: ClusterSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterSpecPublishConnectionDetailsTo
 */
export interface ClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsTo(obj: ClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterSpecWriteConnectionSecretToRef
 */
export interface ClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWriteConnectionSecretToRef(obj: ClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderBrokerNodeGroupInfo
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfo {
  /**
   * The distribution of broker nodes across availability zones (documentation). Currently the only valid value is DEFAULT.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#azDistribution
   */
  readonly azDistribution?: string;

  /**
   * A list of subnets to connect to in client VPC (documentation).
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#clientSubnets
   */
  readonly clientSubnets?: string[];

  /**
   * References to Subnet in ec2 to populate clientSubnets.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#clientSubnetsRefs
   */
  readonly clientSubnetsRefs?: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate clientSubnets.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#clientSubnetsSelector
   */
  readonly clientSubnetsSelector?: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelector;

  /**
   * Information about the cluster access configuration. See below. For security reasons, you can't turn on public access while creating an MSK cluster. However, you can update an existing cluster to make it publicly accessible. You can also create a new cluster and then update it to make it publicly accessible (documentation).
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#connectivityInfo
   */
  readonly connectivityInfo?: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfo[];

  /**
   * The size in GiB of the EBS volume for the data drive on each broker node.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#ebsVolumeSize
   */
  readonly ebsVolumeSize?: number;

  /**
   * Specify the instance type to use for the kafka brokersE.g., kafka.m5.large. (Pricing info)
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#instanceType
   */
  readonly instanceType: string;

  /**
   * A list of the security groups to associate with the elastic network interfaces to control who can communicate with the cluster.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * References to SecurityGroup in ec2 to populate securityGroups.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#securityGroupsRefs
   */
  readonly securityGroupsRefs?: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate securityGroups.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#securityGroupsSelector
   */
  readonly securityGroupsSelector?: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelector;

  /**
   * A block that contains information about storage volumes attached to MSK broker nodes. See below.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfo#storageInfo
   */
  readonly storageInfo?: ClusterSpecForProviderBrokerNodeGroupInfoStorageInfo[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfo(obj: ClusterSpecForProviderBrokerNodeGroupInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azDistribution': obj.azDistribution,
    'clientSubnets': obj.clientSubnets?.map(y => y),
    'clientSubnetsRefs': obj.clientSubnetsRefs?.map(y => toJson_ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefs(y)),
    'clientSubnetsSelector': toJson_ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelector(obj.clientSubnetsSelector),
    'connectivityInfo': obj.connectivityInfo?.map(y => toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfo(y)),
    'ebsVolumeSize': obj.ebsVolumeSize,
    'instanceType': obj.instanceType,
    'securityGroups': obj.securityGroups?.map(y => y),
    'securityGroupsRefs': obj.securityGroupsRefs?.map(y => toJson_ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefs(y)),
    'securityGroupsSelector': toJson_ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelector(obj.securityGroupsSelector),
    'storageInfo': obj.storageInfo?.map(y => toJson_ClusterSpecForProviderBrokerNodeGroupInfoStorageInfo(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderClientAuthentication
 */
export interface ClusterSpecForProviderClientAuthentication {
  /**
   * Configuration block for specifying SASL client authentication. See below.
   *
   * @schema ClusterSpecForProviderClientAuthentication#sasl
   */
  readonly sasl?: ClusterSpecForProviderClientAuthenticationSasl[];

  /**
   * Configuration block for specifying TLS client authentication. See below.
   *
   * @schema ClusterSpecForProviderClientAuthentication#tls
   */
  readonly tls?: ClusterSpecForProviderClientAuthenticationTls[];

  /**
   * Enables unauthenticated access.
   *
   * @schema ClusterSpecForProviderClientAuthentication#unauthenticated
   */
  readonly unauthenticated?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClientAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClientAuthentication(obj: ClusterSpecForProviderClientAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sasl': obj.sasl?.map(y => toJson_ClusterSpecForProviderClientAuthenticationSasl(y)),
    'tls': obj.tls?.map(y => toJson_ClusterSpecForProviderClientAuthenticationTls(y)),
    'unauthenticated': obj.unauthenticated,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderConfigurationInfo
 */
export interface ClusterSpecForProviderConfigurationInfo {
  /**
   * Amazon Resource Name (ARN) of the MSK Configuration to use in the cluster.
   *
   * @schema ClusterSpecForProviderConfigurationInfo#arn
   */
  readonly arn: string;

  /**
   * Revision of the MSK Configuration to use in the cluster.
   *
   * @schema ClusterSpecForProviderConfigurationInfo#revision
   */
  readonly revision: number;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigurationInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigurationInfo(obj: ClusterSpecForProviderConfigurationInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderEncryptionInfo
 */
export interface ClusterSpecForProviderEncryptionInfo {
  /**
   * The ARN of the KMS key used for encryption at rest of the broker data volumes.
   *
   * @schema ClusterSpecForProviderEncryptionInfo#encryptionAtRestKmsKeyArn
   */
  readonly encryptionAtRestKmsKeyArn?: string;

  /**
   * Reference to a Key in kms to populate encryptionAtRestKmsKeyArn.
   *
   * @schema ClusterSpecForProviderEncryptionInfo#encryptionAtRestKmsKeyArnRef
   */
  readonly encryptionAtRestKmsKeyArnRef?: ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRef;

  /**
   * Selector for a Key in kms to populate encryptionAtRestKmsKeyArn.
   *
   * @schema ClusterSpecForProviderEncryptionInfo#encryptionAtRestKmsKeyArnSelector
   */
  readonly encryptionAtRestKmsKeyArnSelector?: ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelector;

  /**
   * Configuration block to specify encryption in transit. See below.
   *
   * @schema ClusterSpecForProviderEncryptionInfo#encryptionInTransit
   */
  readonly encryptionInTransit?: ClusterSpecForProviderEncryptionInfoEncryptionInTransit[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderEncryptionInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderEncryptionInfo(obj: ClusterSpecForProviderEncryptionInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionAtRestKmsKeyArn': obj.encryptionAtRestKmsKeyArn,
    'encryptionAtRestKmsKeyArnRef': toJson_ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRef(obj.encryptionAtRestKmsKeyArnRef),
    'encryptionAtRestKmsKeyArnSelector': toJson_ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelector(obj.encryptionAtRestKmsKeyArnSelector),
    'encryptionInTransit': obj.encryptionInTransit?.map(y => toJson_ClusterSpecForProviderEncryptionInfoEncryptionInTransit(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderLoggingInfo
 */
export interface ClusterSpecForProviderLoggingInfo {
  /**
   * Configuration block for Broker Logs settings for logging info. See below.
   *
   * @schema ClusterSpecForProviderLoggingInfo#brokerLogs
   */
  readonly brokerLogs: ClusterSpecForProviderLoggingInfoBrokerLogs[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfo(obj: ClusterSpecForProviderLoggingInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'brokerLogs': obj.brokerLogs?.map(y => toJson_ClusterSpecForProviderLoggingInfoBrokerLogs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderOpenMonitoring
 */
export interface ClusterSpecForProviderOpenMonitoring {
  /**
   * Configuration block for Prometheus settings for open monitoring. See below.
   *
   * @schema ClusterSpecForProviderOpenMonitoring#prometheus
   */
  readonly prometheus: ClusterSpecForProviderOpenMonitoringPrometheus[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderOpenMonitoring' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderOpenMonitoring(obj: ClusterSpecForProviderOpenMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prometheus': obj.prometheus?.map(y => toJson_ClusterSpecForProviderOpenMonitoringPrometheus(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderConfigRefPolicy
 */
export interface ClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRefPolicy(obj: ClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderRefPolicy
 */
export interface ClusterSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderRefPolicy(obj: ClusterSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj: ClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj: ClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefs
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefs#policy
   */
  readonly policy?: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefs(obj: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate clientSubnets.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelector
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelector#policy
   */
  readonly policy?: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelector(obj: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfo
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfo {
  /**
   * Access control settings for brokers. See below.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfo#publicAccess
   */
  readonly publicAccess?: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfo(obj: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publicAccess': obj.publicAccess?.map(y => toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefs
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefs#policy
   */
  readonly policy?: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefs(obj: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate securityGroups.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelector
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelector#policy
   */
  readonly policy?: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelector(obj: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoStorageInfo
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoStorageInfo {
  /**
   * A block that contains EBS volume information. See below.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoStorageInfo#ebsStorageInfo
   */
  readonly ebsStorageInfo?: ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoStorageInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoStorageInfo(obj: ClusterSpecForProviderBrokerNodeGroupInfoStorageInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ebsStorageInfo': obj.ebsStorageInfo?.map(y => toJson_ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderClientAuthenticationSasl
 */
export interface ClusterSpecForProviderClientAuthenticationSasl {
  /**
   * Enables IAM client authentication. Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecForProviderClientAuthenticationSasl#iam
   */
  readonly iam?: boolean;

  /**
   * Enables SCRAM client authentication via AWS Secrets Manager. Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecForProviderClientAuthenticationSasl#scram
   */
  readonly scram?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderClientAuthenticationSasl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClientAuthenticationSasl(obj: ClusterSpecForProviderClientAuthenticationSasl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iam': obj.iam,
    'scram': obj.scram,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderClientAuthenticationTls
 */
export interface ClusterSpecForProviderClientAuthenticationTls {
  /**
   * List of ACM Certificate Authority Amazon Resource Names (ARNs).
   *
   * @schema ClusterSpecForProviderClientAuthenticationTls#certificateAuthorityArns
   */
  readonly certificateAuthorityArns?: string[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderClientAuthenticationTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderClientAuthenticationTls(obj: ClusterSpecForProviderClientAuthenticationTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityArns': obj.certificateAuthorityArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate encryptionAtRestKmsKeyArn.
 *
 * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRef
 */
export interface ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRef#policy
   */
  readonly policy?: ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRef(obj: ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate encryptionAtRestKmsKeyArn.
 *
 * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelector
 */
export interface ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelector#policy
   */
  readonly policy?: ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelector(obj: ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderEncryptionInfoEncryptionInTransit
 */
export interface ClusterSpecForProviderEncryptionInfoEncryptionInTransit {
  /**
   * Encryption setting for data in transit between clients and brokers. Valid values: TLS, TLS_PLAINTEXT, and PLAINTEXT. Default value is TLS.
   *
   * @schema ClusterSpecForProviderEncryptionInfoEncryptionInTransit#clientBroker
   */
  readonly clientBroker?: string;

  /**
   * Whether data communication among broker nodes is encrypted. Default value: true.
   *
   * @schema ClusterSpecForProviderEncryptionInfoEncryptionInTransit#inCluster
   */
  readonly inCluster?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderEncryptionInfoEncryptionInTransit' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderEncryptionInfoEncryptionInTransit(obj: ClusterSpecForProviderEncryptionInfoEncryptionInTransit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientBroker': obj.clientBroker,
    'inCluster': obj.inCluster,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogs
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogs {
  /**
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogs#cloudwatchLogs
   */
  readonly cloudwatchLogs?: ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogs[];

  /**
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogs#firehose
   */
  readonly firehose?: ClusterSpecForProviderLoggingInfoBrokerLogsFirehose[];

  /**
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogs#s3
   */
  readonly s3?: ClusterSpecForProviderLoggingInfoBrokerLogsS3[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogs(obj: ClusterSpecForProviderLoggingInfoBrokerLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchLogs': obj.cloudwatchLogs?.map(y => toJson_ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogs(y)),
    'firehose': obj.firehose?.map(y => toJson_ClusterSpecForProviderLoggingInfoBrokerLogsFirehose(y)),
    's3': obj.s3?.map(y => toJson_ClusterSpecForProviderLoggingInfoBrokerLogsS3(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderOpenMonitoringPrometheus
 */
export interface ClusterSpecForProviderOpenMonitoringPrometheus {
  /**
   * Configuration block for JMX Exporter. See below.
   *
   * @schema ClusterSpecForProviderOpenMonitoringPrometheus#jmxExporter
   */
  readonly jmxExporter?: ClusterSpecForProviderOpenMonitoringPrometheusJmxExporter[];

  /**
   * Configuration block for Node Exporter. See below.
   *
   * @schema ClusterSpecForProviderOpenMonitoringPrometheus#nodeExporter
   */
  readonly nodeExporter?: ClusterSpecForProviderOpenMonitoringPrometheusNodeExporter[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderOpenMonitoringPrometheus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderOpenMonitoringPrometheus(obj: ClusterSpecForProviderOpenMonitoringPrometheus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmxExporter': obj.jmxExporter?.map(y => toJson_ClusterSpecForProviderOpenMonitoringPrometheusJmxExporter(y)),
    'nodeExporter': obj.nodeExporter?.map(y => toJson_ClusterSpecForProviderOpenMonitoringPrometheusNodeExporter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderRefPolicyResolution
 */
export enum ClusterSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderRefPolicyResolve
 */
export enum ClusterSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicy
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicy(obj: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicy
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicy(obj: ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess {
  /**
   * Public access type. Valida values: DISABLED, SERVICE_PROVIDED_EIPS.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess(obj: ClusterSpecForProviderBrokerNodeGroupInfoConnectivityInfoPublicAccess | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicy
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicy(obj: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicy
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicy(obj: ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo {
  /**
   * A block that contains EBS volume provisioned throughput information. To provision storage throughput, you must choose broker type kafka.m5.4xlarge or larger. See below.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo#provisionedThroughput
   */
  readonly provisionedThroughput?: ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput[];

  /**
   * The size in GiB of the EBS volume for the data drive on each broker node. Minimum value of 1 and maximum value of 16384.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo#volumeSize
   */
  readonly volumeSize?: number;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo(obj: ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'provisionedThroughput': obj.provisionedThroughput?.map(y => toJson_ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput(y)),
    'volumeSize': obj.volumeSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicy
 */
export interface ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicy(obj: ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicy
 */
export interface ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicy(obj: ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogs
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogs {
  /**
   * Controls whether provisioned throughput is enabled or not. Default value: false.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogs#enabled
   */
  readonly enabled: boolean;

  /**
   * Name of the Cloudwatch Log Group to deliver logs to.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogs#logGroup
   */
  readonly logGroup?: string;

  /**
   * Reference to a Group in cloudwatchlogs to populate logGroup.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogs#logGroupRef
   */
  readonly logGroupRef?: ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRef;

  /**
   * Selector for a Group in cloudwatchlogs to populate logGroup.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogs#logGroupSelector
   */
  readonly logGroupSelector?: ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelector;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogs(obj: ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logGroup': obj.logGroup,
    'logGroupRef': toJson_ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRef(obj.logGroupRef),
    'logGroupSelector': toJson_ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelector(obj.logGroupSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehose
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsFirehose {
  /**
   * Name of the Kinesis Data Firehose delivery stream to deliver logs to.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehose#deliveryStream
   */
  readonly deliveryStream?: string;

  /**
   * Reference to a DeliveryStream in firehose to populate deliveryStream.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehose#deliveryStreamRef
   */
  readonly deliveryStreamRef?: ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRef;

  /**
   * Selector for a DeliveryStream in firehose to populate deliveryStream.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehose#deliveryStreamSelector
   */
  readonly deliveryStreamSelector?: ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelector;

  /**
   * Controls whether provisioned throughput is enabled or not. Default value: false.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehose#enabled
   */
  readonly enabled: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsFirehose' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsFirehose(obj: ClusterSpecForProviderLoggingInfoBrokerLogsFirehose | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deliveryStream': obj.deliveryStream,
    'deliveryStreamRef': toJson_ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRef(obj.deliveryStreamRef),
    'deliveryStreamSelector': toJson_ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelector(obj.deliveryStreamSelector),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsS3 {
  /**
   * Name of the S3 bucket to deliver logs to.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3#bucketRef
   */
  readonly bucketRef?: ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3#bucketSelector
   */
  readonly bucketSelector?: ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelector;

  /**
   * Controls whether provisioned throughput is enabled or not. Default value: false.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3#enabled
   */
  readonly enabled: boolean;

  /**
   * Prefix to append to the folder name.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsS3(obj: ClusterSpecForProviderLoggingInfoBrokerLogsS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRef(obj.bucketRef),
    'bucketSelector': toJson_ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelector(obj.bucketSelector),
    'enabled': obj.enabled,
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderOpenMonitoringPrometheusJmxExporter
 */
export interface ClusterSpecForProviderOpenMonitoringPrometheusJmxExporter {
  /**
   * Indicates whether you want to enable or disable the JMX Exporter.
   *
   * @schema ClusterSpecForProviderOpenMonitoringPrometheusJmxExporter#enabledInBroker
   */
  readonly enabledInBroker: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderOpenMonitoringPrometheusJmxExporter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderOpenMonitoringPrometheusJmxExporter(obj: ClusterSpecForProviderOpenMonitoringPrometheusJmxExporter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabledInBroker': obj.enabledInBroker,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderOpenMonitoringPrometheusNodeExporter
 */
export interface ClusterSpecForProviderOpenMonitoringPrometheusNodeExporter {
  /**
   * Indicates whether you want to enable or disable the JMX Exporter.
   *
   * @schema ClusterSpecForProviderOpenMonitoringPrometheusNodeExporter#enabledInBroker
   */
  readonly enabledInBroker: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderOpenMonitoringPrometheusNodeExporter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderOpenMonitoringPrometheusNodeExporter(obj: ClusterSpecForProviderOpenMonitoringPrometheusNodeExporter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabledInBroker': obj.enabledInBroker,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicyResolution
 */
export enum ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicyResolve
 */
export enum ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicyResolution
 */
export enum ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicyResolve
 */
export enum ClusterSpecForProviderBrokerNodeGroupInfoClientSubnetsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicyResolution
 */
export enum ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicyResolve
 */
export enum ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicyResolution
 */
export enum ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicyResolve
 */
export enum ClusterSpecForProviderBrokerNodeGroupInfoSecurityGroupsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput
 */
export interface ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput {
  /**
   * Controls whether provisioned throughput is enabled or not. Default value: false.
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput#enabled
   */
  readonly enabled?: boolean;

  /**
   * Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second. The minimum value is 250. The maximum value varies between broker type. You can refer to the valid values for the maximum volume throughput at the following documentation on throughput bottlenecks
   *
   * @schema ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput#volumeThroughput
   */
  readonly volumeThroughput?: number;

}

/**
 * Converts an object of type 'ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput(obj: ClusterSpecForProviderBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'volumeThroughput': obj.volumeThroughput,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicyResolution
 */
export enum ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicyResolve
 */
export enum ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicyResolution
 */
export enum ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicyResolve
 */
export enum ClusterSpecForProviderEncryptionInfoEncryptionAtRestKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a Group in cloudwatchlogs to populate logGroup.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRef
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRef#policy
   */
  readonly policy?: ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRef(obj: ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Group in cloudwatchlogs to populate logGroup.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelector
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelector#policy
   */
  readonly policy?: ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelector(obj: ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DeliveryStream in firehose to populate deliveryStream.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRef
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRef#policy
   */
  readonly policy?: ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRef(obj: ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DeliveryStream in firehose to populate deliveryStream.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelector
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelector#policy
   */
  readonly policy?: ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelector(obj: ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRef
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRef#policy
   */
  readonly policy?: ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRef(obj: ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelector
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelector#policy
   */
  readonly policy?: ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelector(obj: ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicy
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicy(obj: ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicy
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicy(obj: ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicy
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicy(obj: ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicy
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicy(obj: ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRefPolicy
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRefPolicy(obj: ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicy
 */
export interface ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicy(obj: ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicyResolution
 */
export enum ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicyResolve
 */
export enum ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicyResolution
 */
export enum ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicyResolve
 */
export enum ClusterSpecForProviderLoggingInfoBrokerLogsCloudwatchLogsLogGroupSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicyResolution
 */
export enum ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicyResolve
 */
export enum ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicyResolution
 */
export enum ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicyResolve
 */
export enum ClusterSpecForProviderLoggingInfoBrokerLogsFirehoseDeliveryStreamSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRefPolicyResolution
 */
export enum ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRefPolicyResolve
 */
export enum ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicyResolution
 */
export enum ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicyResolve
 */
export enum ClusterSpecForProviderLoggingInfoBrokerLogsS3BucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Configuration is the Schema for the Configurations API. Upbound official provider resource for managing an amazon managed streaming for kafka configuration
 *
 * @schema Configuration
 */
export class Configuration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Configuration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.aws.upbound.io/v1beta1',
    kind: 'Configuration',
  }

  /**
   * Renders a Kubernetes manifest for "Configuration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConfigurationProps): any {
    return {
      ...Configuration.GVK,
      ...toJson_ConfigurationProps(props),
    };
  }

  /**
   * Defines a "Configuration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConfigurationProps) {
    super(scope, id, {
      ...Configuration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Configuration.GVK,
      ...toJson_ConfigurationProps(resolved),
    };
  }
}

/**
 * Configuration is the Schema for the Configurations API. Upbound official provider resource for managing an amazon managed streaming for kafka configuration
 *
 * @schema Configuration
 */
export interface ConfigurationProps {
  /**
   * @schema Configuration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConfigurationSpec defines the desired state of Configuration
   *
   * @schema Configuration#spec
   */
  readonly spec: ConfigurationSpec;

}

/**
 * Converts an object of type 'ConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProps(obj: ConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigurationSpec defines the desired state of Configuration
 *
 * @schema ConfigurationSpec
 */
export interface ConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConfigurationSpecDeletionPolicy;

  /**
   * @schema ConfigurationSpec#forProvider
   */
  readonly forProvider: ConfigurationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ConfigurationSpec#providerRef
   */
  readonly providerRef?: ConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpec(obj: ConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConfigurationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ConfigurationSpecDeletionPolicy
 */
export enum ConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConfigurationSpecForProvider
 */
export interface ConfigurationSpecForProvider {
  /**
   * Description of the configuration.
   *
   * @schema ConfigurationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * List of Apache Kafka versions which can use this configuration.
   *
   * @schema ConfigurationSpecForProvider#kafkaVersions
   */
  readonly kafkaVersions?: string[];

  /**
   * Name of the configuration.
   *
   * @schema ConfigurationSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Contents of the server.properties file. Supported properties are documented in the MSK Developer Guide.
   *
   * @schema ConfigurationSpecForProvider#serverProperties
   */
  readonly serverProperties: string;

}

/**
 * Converts an object of type 'ConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecForProvider(obj: ConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'kafkaVersions': obj.kafkaVersions?.map(y => y),
    'name': obj.name,
    'region': obj.region,
    'serverProperties': obj.serverProperties,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConfigurationSpecProviderConfigRef
 */
export interface ConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: ConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecProviderConfigRef(obj: ConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ConfigurationSpecProviderRef
 */
export interface ConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSpecProviderRef#policy
   */
  readonly policy?: ConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecProviderRef(obj: ConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsTo
 */
export interface ConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecPublishConnectionDetailsTo(obj: ConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConfigurationSpecWriteConnectionSecretToRef
 */
export interface ConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecWriteConnectionSecretToRef(obj: ConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSpecProviderConfigRefPolicy
 */
export interface ConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecProviderConfigRefPolicy(obj: ConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSpecProviderRefPolicy
 */
export interface ConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecProviderRefPolicy(obj: ConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface ConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecPublishConnectionDetailsToConfigRef(obj: ConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface ConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecPublishConnectionDetailsToMetadata(obj: ConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum ConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum ConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSpecProviderRefPolicyResolution
 */
export enum ConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSpecProviderRefPolicyResolve
 */
export enum ConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

