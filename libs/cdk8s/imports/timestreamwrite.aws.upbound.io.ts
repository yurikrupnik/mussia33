// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Database is the Schema for the Databases API. Provides a Timestream database resource.
 *
 * @schema Database
 */
export class Database extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Database"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'timestreamwrite.aws.upbound.io/v1beta1',
    kind: 'Database',
  }

  /**
   * Renders a Kubernetes manifest for "Database".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatabaseProps): any {
    return {
      ...Database.GVK,
      ...toJson_DatabaseProps(props),
    };
  }

  /**
   * Defines a "Database" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatabaseProps) {
    super(scope, id, {
      ...Database.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Database.GVK,
      ...toJson_DatabaseProps(resolved),
    };
  }
}

/**
 * Database is the Schema for the Databases API. Provides a Timestream database resource.
 *
 * @schema Database
 */
export interface DatabaseProps {
  /**
   * @schema Database#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatabaseSpec defines the desired state of Database
   *
   * @schema Database#spec
   */
  readonly spec: DatabaseSpec;

}

/**
 * Converts an object of type 'DatabaseProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseProps(obj: DatabaseProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatabaseSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatabaseSpec defines the desired state of Database
 *
 * @schema DatabaseSpec
 */
export interface DatabaseSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DatabaseSpec#deletionPolicy
   */
  readonly deletionPolicy?: DatabaseSpecDeletionPolicy;

  /**
   * @schema DatabaseSpec#forProvider
   */
  readonly forProvider: DatabaseSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DatabaseSpec#providerConfigRef
   */
  readonly providerConfigRef?: DatabaseSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DatabaseSpec#providerRef
   */
  readonly providerRef?: DatabaseSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DatabaseSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DatabaseSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DatabaseSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DatabaseSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DatabaseSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpec(obj: DatabaseSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DatabaseSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DatabaseSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DatabaseSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DatabaseSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DatabaseSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DatabaseSpecDeletionPolicy
 */
export enum DatabaseSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DatabaseSpecForProvider
 */
export interface DatabaseSpecForProvider {
  /**
   * The ARN (not Alias ARN) of the KMS key to be used to encrypt the data stored in the database. If the KMS key is not specified, the database will be encrypted with a Timestream managed KMS key located in your account. Refer to AWS managed KMS keys for more info.
   *
   * @schema DatabaseSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema DatabaseSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: DatabaseSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema DatabaseSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: DatabaseSpecForProviderKmsKeyIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DatabaseSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema DatabaseSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatabaseSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProvider(obj: DatabaseSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_DatabaseSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_DatabaseSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DatabaseSpecProviderConfigRef
 */
export interface DatabaseSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatabaseSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatabaseSpecProviderConfigRef#policy
   */
  readonly policy?: DatabaseSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DatabaseSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecProviderConfigRef(obj: DatabaseSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatabaseSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DatabaseSpecProviderRef
 */
export interface DatabaseSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatabaseSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatabaseSpecProviderRef#policy
   */
  readonly policy?: DatabaseSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DatabaseSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecProviderRef(obj: DatabaseSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatabaseSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DatabaseSpecPublishConnectionDetailsTo
 */
export interface DatabaseSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DatabaseSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DatabaseSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DatabaseSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DatabaseSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DatabaseSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatabaseSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecPublishConnectionDetailsTo(obj: DatabaseSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DatabaseSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DatabaseSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DatabaseSpecWriteConnectionSecretToRef
 */
export interface DatabaseSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DatabaseSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DatabaseSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DatabaseSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecWriteConnectionSecretToRef(obj: DatabaseSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema DatabaseSpecForProviderKmsKeyIdRef
 */
export interface DatabaseSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatabaseSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatabaseSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: DatabaseSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderKmsKeyIdRef(obj: DatabaseSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatabaseSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema DatabaseSpecForProviderKmsKeyIdSelector
 */
export interface DatabaseSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatabaseSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatabaseSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatabaseSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: DatabaseSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderKmsKeyIdSelector(obj: DatabaseSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatabaseSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatabaseSpecProviderConfigRefPolicy
 */
export interface DatabaseSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DatabaseSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DatabaseSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecProviderConfigRefPolicy(obj: DatabaseSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatabaseSpecProviderRefPolicy
 */
export interface DatabaseSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DatabaseSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DatabaseSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecProviderRefPolicy(obj: DatabaseSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToConfigRef
 */
export interface DatabaseSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DatabaseSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DatabaseSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecPublishConnectionDetailsToConfigRef(obj: DatabaseSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatabaseSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToMetadata
 */
export interface DatabaseSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatabaseSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecPublishConnectionDetailsToMetadata(obj: DatabaseSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatabaseSpecForProviderKmsKeyIdRefPolicy
 */
export interface DatabaseSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: DatabaseSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: DatabaseSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderKmsKeyIdRefPolicy(obj: DatabaseSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatabaseSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface DatabaseSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: DatabaseSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: DatabaseSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderKmsKeyIdSelectorPolicy(obj: DatabaseSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseSpecProviderConfigRefPolicyResolution
 */
export enum DatabaseSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseSpecProviderConfigRefPolicyResolve
 */
export enum DatabaseSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseSpecProviderRefPolicyResolution
 */
export enum DatabaseSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseSpecProviderRefPolicyResolve
 */
export enum DatabaseSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DatabaseSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecPublishConnectionDetailsToConfigRefPolicy(obj: DatabaseSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum DatabaseSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum DatabaseSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum DatabaseSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum DatabaseSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Table is the Schema for the Tables API. Provides a Timestream table resource.
 *
 * @schema Table
 */
export class Table extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Table"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'timestreamwrite.aws.upbound.io/v1beta1',
    kind: 'Table',
  }

  /**
   * Renders a Kubernetes manifest for "Table".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TableProps): any {
    return {
      ...Table.GVK,
      ...toJson_TableProps(props),
    };
  }

  /**
   * Defines a "Table" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TableProps) {
    super(scope, id, {
      ...Table.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Table.GVK,
      ...toJson_TableProps(resolved),
    };
  }
}

/**
 * Table is the Schema for the Tables API. Provides a Timestream table resource.
 *
 * @schema Table
 */
export interface TableProps {
  /**
   * @schema Table#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TableSpec defines the desired state of Table
   *
   * @schema Table#spec
   */
  readonly spec: TableSpec;

}

/**
 * Converts an object of type 'TableProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableProps(obj: TableProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TableSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TableSpec defines the desired state of Table
 *
 * @schema TableSpec
 */
export interface TableSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema TableSpec#deletionPolicy
   */
  readonly deletionPolicy?: TableSpecDeletionPolicy;

  /**
   * @schema TableSpec#forProvider
   */
  readonly forProvider: TableSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TableSpec#providerConfigRef
   */
  readonly providerConfigRef?: TableSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TableSpec#providerRef
   */
  readonly providerRef?: TableSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TableSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TableSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TableSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TableSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TableSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpec(obj: TableSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TableSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_TableSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TableSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TableSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TableSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema TableSpecDeletionPolicy
 */
export enum TableSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TableSpecForProvider
 */
export interface TableSpecForProvider {
  /**
   * â€“  The name of the Timestream database.
   *
   * @schema TableSpecForProvider#databaseName
   */
  readonly databaseName?: string;

  /**
   * Reference to a Database in timestreamwrite to populate databaseName.
   *
   * @schema TableSpecForProvider#databaseNameRef
   */
  readonly databaseNameRef?: TableSpecForProviderDatabaseNameRef;

  /**
   * Selector for a Database in timestreamwrite to populate databaseName.
   *
   * @schema TableSpecForProvider#databaseNameSelector
   */
  readonly databaseNameSelector?: TableSpecForProviderDatabaseNameSelector;

  /**
   * Contains properties to set on the table when enabling magnetic store writes. See Magnetic Store Write Properties below for more details.
   *
   * @schema TableSpecForProvider#magneticStoreWriteProperties
   */
  readonly magneticStoreWriteProperties?: TableSpecForProviderMagneticStoreWriteProperties[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TableSpecForProvider#region
   */
  readonly region: string;

  /**
   * The retention duration for the memory store and magnetic store. See Retention Properties below for more details. If not provided, magnetic_store_retention_period_in_days default to 73000 and memory_store_retention_period_in_hours defaults to 6.
   *
   * @schema TableSpecForProvider#retentionProperties
   */
  readonly retentionProperties?: TableSpecForProviderRetentionProperties[];

  /**
   * The name of the Timestream table.
   *
   * @schema TableSpecForProvider#tableName
   */
  readonly tableName: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema TableSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'TableSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProvider(obj: TableSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'databaseName': obj.databaseName,
    'databaseNameRef': toJson_TableSpecForProviderDatabaseNameRef(obj.databaseNameRef),
    'databaseNameSelector': toJson_TableSpecForProviderDatabaseNameSelector(obj.databaseNameSelector),
    'magneticStoreWriteProperties': obj.magneticStoreWriteProperties?.map(y => toJson_TableSpecForProviderMagneticStoreWriteProperties(y)),
    'region': obj.region,
    'retentionProperties': obj.retentionProperties?.map(y => toJson_TableSpecForProviderRetentionProperties(y)),
    'tableName': obj.tableName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TableSpecProviderConfigRef
 */
export interface TableSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableSpecProviderConfigRef#policy
   */
  readonly policy?: TableSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TableSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecProviderConfigRef(obj: TableSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TableSpecProviderRef
 */
export interface TableSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableSpecProviderRef#policy
   */
  readonly policy?: TableSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TableSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecProviderRef(obj: TableSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TableSpecPublishConnectionDetailsTo
 */
export interface TableSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TableSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TableSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TableSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TableSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TableSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TableSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecPublishConnectionDetailsTo(obj: TableSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TableSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TableSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TableSpecWriteConnectionSecretToRef
 */
export interface TableSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TableSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TableSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TableSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecWriteConnectionSecretToRef(obj: TableSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Database in timestreamwrite to populate databaseName.
 *
 * @schema TableSpecForProviderDatabaseNameRef
 */
export interface TableSpecForProviderDatabaseNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableSpecForProviderDatabaseNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableSpecForProviderDatabaseNameRef#policy
   */
  readonly policy?: TableSpecForProviderDatabaseNameRefPolicy;

}

/**
 * Converts an object of type 'TableSpecForProviderDatabaseNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderDatabaseNameRef(obj: TableSpecForProviderDatabaseNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableSpecForProviderDatabaseNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Database in timestreamwrite to populate databaseName.
 *
 * @schema TableSpecForProviderDatabaseNameSelector
 */
export interface TableSpecForProviderDatabaseNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TableSpecForProviderDatabaseNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TableSpecForProviderDatabaseNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TableSpecForProviderDatabaseNameSelector#policy
   */
  readonly policy?: TableSpecForProviderDatabaseNameSelectorPolicy;

}

/**
 * Converts an object of type 'TableSpecForProviderDatabaseNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderDatabaseNameSelector(obj: TableSpecForProviderDatabaseNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TableSpecForProviderDatabaseNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderMagneticStoreWriteProperties
 */
export interface TableSpecForProviderMagneticStoreWriteProperties {
  /**
   * A flag to enable magnetic store writes.
   *
   * @schema TableSpecForProviderMagneticStoreWriteProperties#enableMagneticStoreWrites
   */
  readonly enableMagneticStoreWrites?: boolean;

  /**
   * The location to write error reports for records rejected asynchronously during magnetic store writes. See Magnetic Store Rejected Data Location below for more details.
   *
   * @schema TableSpecForProviderMagneticStoreWriteProperties#magneticStoreRejectedDataLocation
   */
  readonly magneticStoreRejectedDataLocation?: TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation[];

}

/**
 * Converts an object of type 'TableSpecForProviderMagneticStoreWriteProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderMagneticStoreWriteProperties(obj: TableSpecForProviderMagneticStoreWriteProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableMagneticStoreWrites': obj.enableMagneticStoreWrites,
    'magneticStoreRejectedDataLocation': obj.magneticStoreRejectedDataLocation?.map(y => toJson_TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderRetentionProperties
 */
export interface TableSpecForProviderRetentionProperties {
  /**
   * The duration for which data must be stored in the magnetic store. Minimum value of 1. Maximum value of 73000.
   *
   * @schema TableSpecForProviderRetentionProperties#magneticStoreRetentionPeriodInDays
   */
  readonly magneticStoreRetentionPeriodInDays: number;

  /**
   * The duration for which data must be stored in the memory store. Minimum value of 1. Maximum value of 8766.
   *
   * @schema TableSpecForProviderRetentionProperties#memoryStoreRetentionPeriodInHours
   */
  readonly memoryStoreRetentionPeriodInHours: number;

}

/**
 * Converts an object of type 'TableSpecForProviderRetentionProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderRetentionProperties(obj: TableSpecForProviderRetentionProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'magneticStoreRetentionPeriodInDays': obj.magneticStoreRetentionPeriodInDays,
    'memoryStoreRetentionPeriodInHours': obj.memoryStoreRetentionPeriodInHours,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableSpecProviderConfigRefPolicy
 */
export interface TableSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TableSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TableSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecProviderConfigRefPolicy(obj: TableSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableSpecProviderRefPolicy
 */
export interface TableSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TableSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TableSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TableSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecProviderRefPolicy(obj: TableSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TableSpecPublishConnectionDetailsToConfigRef
 */
export interface TableSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TableSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TableSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecPublishConnectionDetailsToConfigRef(obj: TableSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TableSpecPublishConnectionDetailsToMetadata
 */
export interface TableSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TableSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TableSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecPublishConnectionDetailsToMetadata(obj: TableSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableSpecForProviderDatabaseNameRefPolicy
 */
export interface TableSpecForProviderDatabaseNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableSpecForProviderDatabaseNameRefPolicy#resolution
   */
  readonly resolution?: TableSpecForProviderDatabaseNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableSpecForProviderDatabaseNameRefPolicy#resolve
   */
  readonly resolve?: TableSpecForProviderDatabaseNameRefPolicyResolve;

}

/**
 * Converts an object of type 'TableSpecForProviderDatabaseNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderDatabaseNameRefPolicy(obj: TableSpecForProviderDatabaseNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TableSpecForProviderDatabaseNameSelectorPolicy
 */
export interface TableSpecForProviderDatabaseNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableSpecForProviderDatabaseNameSelectorPolicy#resolution
   */
  readonly resolution?: TableSpecForProviderDatabaseNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableSpecForProviderDatabaseNameSelectorPolicy#resolve
   */
  readonly resolve?: TableSpecForProviderDatabaseNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TableSpecForProviderDatabaseNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderDatabaseNameSelectorPolicy(obj: TableSpecForProviderDatabaseNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation
 */
export interface TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation {
  /**
   * Configuration of an S3 location to write error reports for records rejected, asynchronously, during magnetic store writes. See S3 Configuration below for more details.
   *
   * @schema TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation#s3Configuration
   */
  readonly s3Configuration?: TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration[];

}

/**
 * Converts an object of type 'TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation(obj: TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3Configuration': obj.s3Configuration?.map(y => toJson_TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableSpecProviderConfigRefPolicyResolution
 */
export enum TableSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableSpecProviderConfigRefPolicyResolve
 */
export enum TableSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableSpecProviderRefPolicyResolution
 */
export enum TableSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableSpecProviderRefPolicyResolve
 */
export enum TableSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TableSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TableSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TableSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TableSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecPublishConnectionDetailsToConfigRefPolicy(obj: TableSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableSpecForProviderDatabaseNameRefPolicyResolution
 */
export enum TableSpecForProviderDatabaseNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableSpecForProviderDatabaseNameRefPolicyResolve
 */
export enum TableSpecForProviderDatabaseNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableSpecForProviderDatabaseNameSelectorPolicyResolution
 */
export enum TableSpecForProviderDatabaseNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableSpecForProviderDatabaseNameSelectorPolicyResolve
 */
export enum TableSpecForProviderDatabaseNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration
 */
export interface TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration {
  /**
   * Bucket name of the customer S3 bucket.
   *
   * @schema TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration#bucketName
   */
  readonly bucketName?: string;

  /**
   * Encryption option for the customer s3 location. Options are S3 server side encryption with an S3-managed key or KMS managed key. Valid values are SSE_KMS and SSE_S3.
   *
   * @schema TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration#encryptionOption
   */
  readonly encryptionOption?: string;

  /**
   * KMS key arn for the customer s3 location when encrypting with a KMS managed key.
   *
   * @schema TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Object key prefix for the customer S3 location.
   *
   * @schema TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration#objectKeyPrefix
   */
  readonly objectKeyPrefix?: string;

}

/**
 * Converts an object of type 'TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration(obj: TableSpecForProviderMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'encryptionOption': obj.encryptionOption,
    'kmsKeyId': obj.kmsKeyId,
    'objectKeyPrefix': obj.objectKeyPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TableSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TableSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

