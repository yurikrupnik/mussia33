// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Certificate is the Schema for the Certificates API. Creates and manages an AWS IoT certificate.
 *
 * @schema Certificate
 */
export class Certificate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Certificate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iot.aws.upbound.io/v1beta1',
    kind: 'Certificate',
  }

  /**
   * Renders a Kubernetes manifest for "Certificate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateProps): any {
    return {
      ...Certificate.GVK,
      ...toJson_CertificateProps(props),
    };
  }

  /**
   * Defines a "Certificate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateProps) {
    super(scope, id, {
      ...Certificate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Certificate.GVK,
      ...toJson_CertificateProps(resolved),
    };
  }
}

/**
 * Certificate is the Schema for the Certificates API. Creates and manages an AWS IoT certificate.
 *
 * @schema Certificate
 */
export interface CertificateProps {
  /**
   * @schema Certificate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateSpec defines the desired state of Certificate
   *
   * @schema Certificate#spec
   */
  readonly spec: CertificateSpec;

}

/**
 * Converts an object of type 'CertificateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateProps(obj: CertificateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateSpec defines the desired state of Certificate
 *
 * @schema CertificateSpec
 */
export interface CertificateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateSpec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateSpecDeletionPolicy;

  /**
   * @schema CertificateSpec#forProvider
   */
  readonly forProvider: CertificateSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CertificateSpec#initProvider
   */
  readonly initProvider?: CertificateSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CertificateSpec#managementPolicies
   */
  readonly managementPolicies?: CertificateSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateSpec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpec(obj: CertificateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateSpecForProvider(obj.forProvider),
    'initProvider': toJson_CertificateSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CertificateSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CertificateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateSpecDeletionPolicy
 */
export enum CertificateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CertificateSpecForProvider
 */
export interface CertificateSpecForProvider {
  /**
   * Boolean flag to indicate if the certificate should be active
   *
   * @schema CertificateSpecForProvider#active
   */
  readonly active?: boolean;

  /**
   * The CA certificate for the certificate to be registered. If this is set, the CA needs to be registered with AWS IoT beforehand.
   *
   * @schema CertificateSpecForProvider#caPemSecretRef
   */
  readonly caPemSecretRef?: CertificateSpecForProviderCaPemSecretRef;

  /**
   * The certificate to be registered. If ca_pem is unspecified, review RegisterCertificateWithoutCA. If ca_pem is specified, review RegisterCertificate for more information on registering a certificate.
   *
   * @schema CertificateSpecForProvider#certificatePemSecretRef
   */
  readonly certificatePemSecretRef?: CertificateSpecForProviderCertificatePemSecretRef;

  /**
   * The certificate signing request. Review CreateCertificateFromCsr for more information on generating a certificate from a certificate signing request (CSR). If none is specified both the certificate and keys will be generated, review CreateKeysAndCertificate for more information on generating keys and a certificate.
   *
   * @schema CertificateSpecForProvider#csr
   */
  readonly csr?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CertificateSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'CertificateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProvider(obj: CertificateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': obj.active,
    'caPemSecretRef': toJson_CertificateSpecForProviderCaPemSecretRef(obj.caPemSecretRef),
    'certificatePemSecretRef': toJson_CertificateSpecForProviderCertificatePemSecretRef(obj.certificatePemSecretRef),
    'csr': obj.csr,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CertificateSpecInitProvider
 */
export interface CertificateSpecInitProvider {
  /**
   * Boolean flag to indicate if the certificate should be active
   *
   * @schema CertificateSpecInitProvider#active
   */
  readonly active?: boolean;

  /**
   * The certificate signing request. Review CreateCertificateFromCsr for more information on generating a certificate from a certificate signing request (CSR). If none is specified both the certificate and keys will be generated, review CreateKeysAndCertificate for more information on generating keys and a certificate.
   *
   * @schema CertificateSpecInitProvider#csr
   */
  readonly csr?: string;

}

/**
 * Converts an object of type 'CertificateSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecInitProvider(obj: CertificateSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': obj.active,
    'csr': obj.csr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CertificateSpecManagementPolicies
 */
export enum CertificateSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateSpecProviderConfigRef
 */
export interface CertificateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecProviderConfigRef#policy
   */
  readonly policy?: CertificateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderConfigRef(obj: CertificateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateSpecPublishConnectionDetailsTo
 */
export interface CertificateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsTo(obj: CertificateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateSpecWriteConnectionSecretToRef
 */
export interface CertificateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecWriteConnectionSecretToRef(obj: CertificateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The CA certificate for the certificate to be registered. If this is set, the CA needs to be registered with AWS IoT beforehand.
 *
 * @schema CertificateSpecForProviderCaPemSecretRef
 */
export interface CertificateSpecForProviderCaPemSecretRef {
  /**
   * The key to select.
   *
   * @schema CertificateSpecForProviderCaPemSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema CertificateSpecForProviderCaPemSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateSpecForProviderCaPemSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCaPemSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCaPemSecretRef(obj: CertificateSpecForProviderCaPemSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The certificate to be registered. If ca_pem is unspecified, review RegisterCertificateWithoutCA. If ca_pem is specified, review RegisterCertificate for more information on registering a certificate.
 *
 * @schema CertificateSpecForProviderCertificatePemSecretRef
 */
export interface CertificateSpecForProviderCertificatePemSecretRef {
  /**
   * The key to select.
   *
   * @schema CertificateSpecForProviderCertificatePemSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema CertificateSpecForProviderCertificatePemSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateSpecForProviderCertificatePemSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificatePemSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificatePemSecretRef(obj: CertificateSpecForProviderCertificatePemSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecProviderConfigRefPolicy
 */
export interface CertificateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderConfigRefPolicy(obj: CertificateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToConfigRef(obj: CertificateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateSpecPublishConnectionDetailsToMetadata
 */
export interface CertificateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToMetadata(obj: CertificateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecProviderConfigRefPolicyResolution
 */
export enum CertificateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecProviderConfigRefPolicyResolve
 */
export enum CertificateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * IndexingConfiguration is the Schema for the IndexingConfigurations API. Managing IoT Thing indexing.
 *
 * @schema IndexingConfiguration
 */
export class IndexingConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IndexingConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iot.aws.upbound.io/v1beta1',
    kind: 'IndexingConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "IndexingConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IndexingConfigurationProps): any {
    return {
      ...IndexingConfiguration.GVK,
      ...toJson_IndexingConfigurationProps(props),
    };
  }

  /**
   * Defines a "IndexingConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IndexingConfigurationProps) {
    super(scope, id, {
      ...IndexingConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IndexingConfiguration.GVK,
      ...toJson_IndexingConfigurationProps(resolved),
    };
  }
}

/**
 * IndexingConfiguration is the Schema for the IndexingConfigurations API. Managing IoT Thing indexing.
 *
 * @schema IndexingConfiguration
 */
export interface IndexingConfigurationProps {
  /**
   * @schema IndexingConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IndexingConfigurationSpec defines the desired state of IndexingConfiguration
   *
   * @schema IndexingConfiguration#spec
   */
  readonly spec: IndexingConfigurationSpec;

}

/**
 * Converts an object of type 'IndexingConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationProps(obj: IndexingConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IndexingConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IndexingConfigurationSpec defines the desired state of IndexingConfiguration
 *
 * @schema IndexingConfigurationSpec
 */
export interface IndexingConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IndexingConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: IndexingConfigurationSpecDeletionPolicy;

  /**
   * @schema IndexingConfigurationSpec#forProvider
   */
  readonly forProvider: IndexingConfigurationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema IndexingConfigurationSpec#initProvider
   */
  readonly initProvider?: IndexingConfigurationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema IndexingConfigurationSpec#managementPolicies
   */
  readonly managementPolicies?: IndexingConfigurationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IndexingConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: IndexingConfigurationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IndexingConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IndexingConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IndexingConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IndexingConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IndexingConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpec(obj: IndexingConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IndexingConfigurationSpecForProvider(obj.forProvider),
    'initProvider': toJson_IndexingConfigurationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_IndexingConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_IndexingConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IndexingConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IndexingConfigurationSpecDeletionPolicy
 */
export enum IndexingConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema IndexingConfigurationSpecForProvider
 */
export interface IndexingConfigurationSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema IndexingConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Thing group indexing configuration. See below.
   *
   * @schema IndexingConfigurationSpecForProvider#thingGroupIndexingConfiguration
   */
  readonly thingGroupIndexingConfiguration?: IndexingConfigurationSpecForProviderThingGroupIndexingConfiguration[];

  /**
   * Thing indexing configuration. See below.
   *
   * @schema IndexingConfigurationSpecForProvider#thingIndexingConfiguration
   */
  readonly thingIndexingConfiguration?: IndexingConfigurationSpecForProviderThingIndexingConfiguration[];

}

/**
 * Converts an object of type 'IndexingConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecForProvider(obj: IndexingConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'thingGroupIndexingConfiguration': obj.thingGroupIndexingConfiguration?.map(y => toJson_IndexingConfigurationSpecForProviderThingGroupIndexingConfiguration(y)),
    'thingIndexingConfiguration': obj.thingIndexingConfiguration?.map(y => toJson_IndexingConfigurationSpecForProviderThingIndexingConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema IndexingConfigurationSpecInitProvider
 */
export interface IndexingConfigurationSpecInitProvider {
  /**
   * Thing group indexing configuration. See below.
   *
   * @schema IndexingConfigurationSpecInitProvider#thingGroupIndexingConfiguration
   */
  readonly thingGroupIndexingConfiguration?: IndexingConfigurationSpecInitProviderThingGroupIndexingConfiguration[];

  /**
   * Thing indexing configuration. See below.
   *
   * @schema IndexingConfigurationSpecInitProvider#thingIndexingConfiguration
   */
  readonly thingIndexingConfiguration?: IndexingConfigurationSpecInitProviderThingIndexingConfiguration[];

}

/**
 * Converts an object of type 'IndexingConfigurationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecInitProvider(obj: IndexingConfigurationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'thingGroupIndexingConfiguration': obj.thingGroupIndexingConfiguration?.map(y => toJson_IndexingConfigurationSpecInitProviderThingGroupIndexingConfiguration(y)),
    'thingIndexingConfiguration': obj.thingIndexingConfiguration?.map(y => toJson_IndexingConfigurationSpecInitProviderThingIndexingConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema IndexingConfigurationSpecManagementPolicies
 */
export enum IndexingConfigurationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IndexingConfigurationSpecProviderConfigRef
 */
export interface IndexingConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IndexingConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IndexingConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: IndexingConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecProviderConfigRef(obj: IndexingConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IndexingConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IndexingConfigurationSpecPublishConnectionDetailsTo
 */
export interface IndexingConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IndexingConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IndexingConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IndexingConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IndexingConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IndexingConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecPublishConnectionDetailsTo(obj: IndexingConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IndexingConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IndexingConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IndexingConfigurationSpecWriteConnectionSecretToRef
 */
export interface IndexingConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IndexingConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IndexingConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecWriteConnectionSecretToRef(obj: IndexingConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexingConfigurationSpecForProviderThingGroupIndexingConfiguration
 */
export interface IndexingConfigurationSpecForProviderThingGroupIndexingConfiguration {
  /**
   * A list of thing group fields to index. This list cannot contain any managed fields. See below.
   *
   * @schema IndexingConfigurationSpecForProviderThingGroupIndexingConfiguration#customField
   */
  readonly customField?: IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationCustomField[];

  /**
   * Contains fields that are indexed and whose types are already known by the Fleet Indexing service. See below.
   *
   * @schema IndexingConfigurationSpecForProviderThingGroupIndexingConfiguration#managedField
   */
  readonly managedField?: IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationManagedField[];

  /**
   * Thing group indexing mode. Valid values: OFF, ON.
   *
   * @schema IndexingConfigurationSpecForProviderThingGroupIndexingConfiguration#thingGroupIndexingMode
   */
  readonly thingGroupIndexingMode?: string;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecForProviderThingGroupIndexingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecForProviderThingGroupIndexingConfiguration(obj: IndexingConfigurationSpecForProviderThingGroupIndexingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customField': obj.customField?.map(y => toJson_IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationCustomField(y)),
    'managedField': obj.managedField?.map(y => toJson_IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationManagedField(y)),
    'thingGroupIndexingMode': obj.thingGroupIndexingMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexingConfigurationSpecForProviderThingIndexingConfiguration
 */
export interface IndexingConfigurationSpecForProviderThingIndexingConfiguration {
  /**
   * Contains custom field names and their data type. See below.
   *
   * @schema IndexingConfigurationSpecForProviderThingIndexingConfiguration#customField
   */
  readonly customField?: IndexingConfigurationSpecForProviderThingIndexingConfigurationCustomField[];

  /**
   * Device Defender indexing mode. Valid values: VIOLATIONS, OFF. Default: OFF.
   *
   * @schema IndexingConfigurationSpecForProviderThingIndexingConfiguration#deviceDefenderIndexingMode
   */
  readonly deviceDefenderIndexingMode?: string;

  /**
   * Contains fields that are indexed and whose types are already known by the Fleet Indexing service. See below.
   *
   * @schema IndexingConfigurationSpecForProviderThingIndexingConfiguration#managedField
   */
  readonly managedField?: IndexingConfigurationSpecForProviderThingIndexingConfigurationManagedField[];

  /**
   * Named shadow indexing mode. Valid values: ON, OFF. Default: OFF.
   *
   * @schema IndexingConfigurationSpecForProviderThingIndexingConfiguration#namedShadowIndexingMode
   */
  readonly namedShadowIndexingMode?: string;

  /**
   * Thing connectivity indexing mode. Valid values: STATUS, OFF. Default: OFF.
   *
   * @schema IndexingConfigurationSpecForProviderThingIndexingConfiguration#thingConnectivityIndexingMode
   */
  readonly thingConnectivityIndexingMode?: string;

  /**
   * Thing indexing mode. Valid values: REGISTRY, REGISTRY_AND_SHADOW, OFF.
   *
   * @schema IndexingConfigurationSpecForProviderThingIndexingConfiguration#thingIndexingMode
   */
  readonly thingIndexingMode?: string;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecForProviderThingIndexingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecForProviderThingIndexingConfiguration(obj: IndexingConfigurationSpecForProviderThingIndexingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customField': obj.customField?.map(y => toJson_IndexingConfigurationSpecForProviderThingIndexingConfigurationCustomField(y)),
    'deviceDefenderIndexingMode': obj.deviceDefenderIndexingMode,
    'managedField': obj.managedField?.map(y => toJson_IndexingConfigurationSpecForProviderThingIndexingConfigurationManagedField(y)),
    'namedShadowIndexingMode': obj.namedShadowIndexingMode,
    'thingConnectivityIndexingMode': obj.thingConnectivityIndexingMode,
    'thingIndexingMode': obj.thingIndexingMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexingConfigurationSpecInitProviderThingGroupIndexingConfiguration
 */
export interface IndexingConfigurationSpecInitProviderThingGroupIndexingConfiguration {
  /**
   * A list of thing group fields to index. This list cannot contain any managed fields. See below.
   *
   * @schema IndexingConfigurationSpecInitProviderThingGroupIndexingConfiguration#customField
   */
  readonly customField?: IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationCustomField[];

  /**
   * Contains fields that are indexed and whose types are already known by the Fleet Indexing service. See below.
   *
   * @schema IndexingConfigurationSpecInitProviderThingGroupIndexingConfiguration#managedField
   */
  readonly managedField?: IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationManagedField[];

  /**
   * Thing group indexing mode. Valid values: OFF, ON.
   *
   * @schema IndexingConfigurationSpecInitProviderThingGroupIndexingConfiguration#thingGroupIndexingMode
   */
  readonly thingGroupIndexingMode?: string;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecInitProviderThingGroupIndexingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecInitProviderThingGroupIndexingConfiguration(obj: IndexingConfigurationSpecInitProviderThingGroupIndexingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customField': obj.customField?.map(y => toJson_IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationCustomField(y)),
    'managedField': obj.managedField?.map(y => toJson_IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationManagedField(y)),
    'thingGroupIndexingMode': obj.thingGroupIndexingMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexingConfigurationSpecInitProviderThingIndexingConfiguration
 */
export interface IndexingConfigurationSpecInitProviderThingIndexingConfiguration {
  /**
   * Contains custom field names and their data type. See below.
   *
   * @schema IndexingConfigurationSpecInitProviderThingIndexingConfiguration#customField
   */
  readonly customField?: IndexingConfigurationSpecInitProviderThingIndexingConfigurationCustomField[];

  /**
   * Device Defender indexing mode. Valid values: VIOLATIONS, OFF. Default: OFF.
   *
   * @schema IndexingConfigurationSpecInitProviderThingIndexingConfiguration#deviceDefenderIndexingMode
   */
  readonly deviceDefenderIndexingMode?: string;

  /**
   * Contains fields that are indexed and whose types are already known by the Fleet Indexing service. See below.
   *
   * @schema IndexingConfigurationSpecInitProviderThingIndexingConfiguration#managedField
   */
  readonly managedField?: IndexingConfigurationSpecInitProviderThingIndexingConfigurationManagedField[];

  /**
   * Named shadow indexing mode. Valid values: ON, OFF. Default: OFF.
   *
   * @schema IndexingConfigurationSpecInitProviderThingIndexingConfiguration#namedShadowIndexingMode
   */
  readonly namedShadowIndexingMode?: string;

  /**
   * Thing connectivity indexing mode. Valid values: STATUS, OFF. Default: OFF.
   *
   * @schema IndexingConfigurationSpecInitProviderThingIndexingConfiguration#thingConnectivityIndexingMode
   */
  readonly thingConnectivityIndexingMode?: string;

  /**
   * Thing indexing mode. Valid values: REGISTRY, REGISTRY_AND_SHADOW, OFF.
   *
   * @schema IndexingConfigurationSpecInitProviderThingIndexingConfiguration#thingIndexingMode
   */
  readonly thingIndexingMode?: string;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecInitProviderThingIndexingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecInitProviderThingIndexingConfiguration(obj: IndexingConfigurationSpecInitProviderThingIndexingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customField': obj.customField?.map(y => toJson_IndexingConfigurationSpecInitProviderThingIndexingConfigurationCustomField(y)),
    'deviceDefenderIndexingMode': obj.deviceDefenderIndexingMode,
    'managedField': obj.managedField?.map(y => toJson_IndexingConfigurationSpecInitProviderThingIndexingConfigurationManagedField(y)),
    'namedShadowIndexingMode': obj.namedShadowIndexingMode,
    'thingConnectivityIndexingMode': obj.thingConnectivityIndexingMode,
    'thingIndexingMode': obj.thingIndexingMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IndexingConfigurationSpecProviderConfigRefPolicy
 */
export interface IndexingConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IndexingConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IndexingConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IndexingConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IndexingConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecProviderConfigRefPolicy(obj: IndexingConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IndexingConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface IndexingConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IndexingConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IndexingConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IndexingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecPublishConnectionDetailsToConfigRef(obj: IndexingConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IndexingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IndexingConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface IndexingConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IndexingConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IndexingConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IndexingConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecPublishConnectionDetailsToMetadata(obj: IndexingConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationCustomField
 */
export interface IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationCustomField {
  /**
   * The name of the field.
   *
   * @schema IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationCustomField#name
   */
  readonly name?: string;

  /**
   * The data type of the field. Valid values: Number, String, Boolean.
   *
   * @schema IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationCustomField#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationCustomField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationCustomField(obj: IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationCustomField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationManagedField
 */
export interface IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationManagedField {
  /**
   * The name of the field.
   *
   * @schema IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationManagedField#name
   */
  readonly name?: string;

  /**
   * The data type of the field. Valid values: Number, String, Boolean.
   *
   * @schema IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationManagedField#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationManagedField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationManagedField(obj: IndexingConfigurationSpecForProviderThingGroupIndexingConfigurationManagedField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexingConfigurationSpecForProviderThingIndexingConfigurationCustomField
 */
export interface IndexingConfigurationSpecForProviderThingIndexingConfigurationCustomField {
  /**
   * The name of the field.
   *
   * @schema IndexingConfigurationSpecForProviderThingIndexingConfigurationCustomField#name
   */
  readonly name?: string;

  /**
   * The data type of the field. Valid values: Number, String, Boolean.
   *
   * @schema IndexingConfigurationSpecForProviderThingIndexingConfigurationCustomField#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecForProviderThingIndexingConfigurationCustomField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecForProviderThingIndexingConfigurationCustomField(obj: IndexingConfigurationSpecForProviderThingIndexingConfigurationCustomField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexingConfigurationSpecForProviderThingIndexingConfigurationManagedField
 */
export interface IndexingConfigurationSpecForProviderThingIndexingConfigurationManagedField {
  /**
   * The name of the field.
   *
   * @schema IndexingConfigurationSpecForProviderThingIndexingConfigurationManagedField#name
   */
  readonly name?: string;

  /**
   * The data type of the field. Valid values: Number, String, Boolean.
   *
   * @schema IndexingConfigurationSpecForProviderThingIndexingConfigurationManagedField#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecForProviderThingIndexingConfigurationManagedField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecForProviderThingIndexingConfigurationManagedField(obj: IndexingConfigurationSpecForProviderThingIndexingConfigurationManagedField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationCustomField
 */
export interface IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationCustomField {
  /**
   * The name of the field.
   *
   * @schema IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationCustomField#name
   */
  readonly name?: string;

  /**
   * The data type of the field. Valid values: Number, String, Boolean.
   *
   * @schema IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationCustomField#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationCustomField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationCustomField(obj: IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationCustomField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationManagedField
 */
export interface IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationManagedField {
  /**
   * The name of the field.
   *
   * @schema IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationManagedField#name
   */
  readonly name?: string;

  /**
   * The data type of the field. Valid values: Number, String, Boolean.
   *
   * @schema IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationManagedField#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationManagedField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationManagedField(obj: IndexingConfigurationSpecInitProviderThingGroupIndexingConfigurationManagedField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexingConfigurationSpecInitProviderThingIndexingConfigurationCustomField
 */
export interface IndexingConfigurationSpecInitProviderThingIndexingConfigurationCustomField {
  /**
   * The name of the field.
   *
   * @schema IndexingConfigurationSpecInitProviderThingIndexingConfigurationCustomField#name
   */
  readonly name?: string;

  /**
   * The data type of the field. Valid values: Number, String, Boolean.
   *
   * @schema IndexingConfigurationSpecInitProviderThingIndexingConfigurationCustomField#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecInitProviderThingIndexingConfigurationCustomField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecInitProviderThingIndexingConfigurationCustomField(obj: IndexingConfigurationSpecInitProviderThingIndexingConfigurationCustomField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexingConfigurationSpecInitProviderThingIndexingConfigurationManagedField
 */
export interface IndexingConfigurationSpecInitProviderThingIndexingConfigurationManagedField {
  /**
   * The name of the field.
   *
   * @schema IndexingConfigurationSpecInitProviderThingIndexingConfigurationManagedField#name
   */
  readonly name?: string;

  /**
   * The data type of the field. Valid values: Number, String, Boolean.
   *
   * @schema IndexingConfigurationSpecInitProviderThingIndexingConfigurationManagedField#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecInitProviderThingIndexingConfigurationManagedField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecInitProviderThingIndexingConfigurationManagedField(obj: IndexingConfigurationSpecInitProviderThingIndexingConfigurationManagedField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IndexingConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum IndexingConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IndexingConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum IndexingConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IndexingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IndexingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IndexingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IndexingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IndexingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IndexingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IndexingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: IndexingConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IndexingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IndexingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IndexingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IndexingConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LoggingOptions is the Schema for the LoggingOptionss API. Provides a resource to manage default logging options.
 *
 * @schema LoggingOptions
 */
export class LoggingOptions extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LoggingOptions"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iot.aws.upbound.io/v1beta1',
    kind: 'LoggingOptions',
  }

  /**
   * Renders a Kubernetes manifest for "LoggingOptions".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LoggingOptionsProps): any {
    return {
      ...LoggingOptions.GVK,
      ...toJson_LoggingOptionsProps(props),
    };
  }

  /**
   * Defines a "LoggingOptions" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LoggingOptionsProps) {
    super(scope, id, {
      ...LoggingOptions.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LoggingOptions.GVK,
      ...toJson_LoggingOptionsProps(resolved),
    };
  }
}

/**
 * LoggingOptions is the Schema for the LoggingOptionss API. Provides a resource to manage default logging options.
 *
 * @schema LoggingOptions
 */
export interface LoggingOptionsProps {
  /**
   * @schema LoggingOptions#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LoggingOptionsSpec defines the desired state of LoggingOptions
   *
   * @schema LoggingOptions#spec
   */
  readonly spec: LoggingOptionsSpec;

}

/**
 * Converts an object of type 'LoggingOptionsProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingOptionsProps(obj: LoggingOptionsProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LoggingOptionsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LoggingOptionsSpec defines the desired state of LoggingOptions
 *
 * @schema LoggingOptionsSpec
 */
export interface LoggingOptionsSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LoggingOptionsSpec#deletionPolicy
   */
  readonly deletionPolicy?: LoggingOptionsSpecDeletionPolicy;

  /**
   * @schema LoggingOptionsSpec#forProvider
   */
  readonly forProvider: LoggingOptionsSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema LoggingOptionsSpec#initProvider
   */
  readonly initProvider?: LoggingOptionsSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema LoggingOptionsSpec#managementPolicies
   */
  readonly managementPolicies?: LoggingOptionsSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LoggingOptionsSpec#providerConfigRef
   */
  readonly providerConfigRef?: LoggingOptionsSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LoggingOptionsSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LoggingOptionsSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LoggingOptionsSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LoggingOptionsSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LoggingOptionsSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingOptionsSpec(obj: LoggingOptionsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LoggingOptionsSpecForProvider(obj.forProvider),
    'initProvider': toJson_LoggingOptionsSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_LoggingOptionsSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_LoggingOptionsSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LoggingOptionsSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LoggingOptionsSpecDeletionPolicy
 */
export enum LoggingOptionsSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LoggingOptionsSpecForProvider
 */
export interface LoggingOptionsSpecForProvider {
  /**
   * The default logging level. Valid Values: "DEBUG", "INFO", "ERROR", "WARN", "DISABLED".
   *
   * @schema LoggingOptionsSpecForProvider#defaultLogLevel
   */
  readonly defaultLogLevel?: string;

  /**
   * If true all logs are disabled. The default is false.
   *
   * @schema LoggingOptionsSpecForProvider#disableAllLogs
   */
  readonly disableAllLogs?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LoggingOptionsSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ARN of the role that allows IoT to write to Cloudwatch logs.
   *
   * @schema LoggingOptionsSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema LoggingOptionsSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: LoggingOptionsSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema LoggingOptionsSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: LoggingOptionsSpecForProviderRoleArnSelector;

}

/**
 * Converts an object of type 'LoggingOptionsSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingOptionsSpecForProvider(obj: LoggingOptionsSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultLogLevel': obj.defaultLogLevel,
    'disableAllLogs': obj.disableAllLogs,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_LoggingOptionsSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_LoggingOptionsSpecForProviderRoleArnSelector(obj.roleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema LoggingOptionsSpecInitProvider
 */
export interface LoggingOptionsSpecInitProvider {
  /**
   * The default logging level. Valid Values: "DEBUG", "INFO", "ERROR", "WARN", "DISABLED".
   *
   * @schema LoggingOptionsSpecInitProvider#defaultLogLevel
   */
  readonly defaultLogLevel?: string;

  /**
   * If true all logs are disabled. The default is false.
   *
   * @schema LoggingOptionsSpecInitProvider#disableAllLogs
   */
  readonly disableAllLogs?: boolean;

}

/**
 * Converts an object of type 'LoggingOptionsSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingOptionsSpecInitProvider(obj: LoggingOptionsSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultLogLevel': obj.defaultLogLevel,
    'disableAllLogs': obj.disableAllLogs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema LoggingOptionsSpecManagementPolicies
 */
export enum LoggingOptionsSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LoggingOptionsSpecProviderConfigRef
 */
export interface LoggingOptionsSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LoggingOptionsSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LoggingOptionsSpecProviderConfigRef#policy
   */
  readonly policy?: LoggingOptionsSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LoggingOptionsSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingOptionsSpecProviderConfigRef(obj: LoggingOptionsSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LoggingOptionsSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LoggingOptionsSpecPublishConnectionDetailsTo
 */
export interface LoggingOptionsSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LoggingOptionsSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LoggingOptionsSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LoggingOptionsSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LoggingOptionsSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LoggingOptionsSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LoggingOptionsSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingOptionsSpecPublishConnectionDetailsTo(obj: LoggingOptionsSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LoggingOptionsSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LoggingOptionsSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LoggingOptionsSpecWriteConnectionSecretToRef
 */
export interface LoggingOptionsSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LoggingOptionsSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LoggingOptionsSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LoggingOptionsSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingOptionsSpecWriteConnectionSecretToRef(obj: LoggingOptionsSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema LoggingOptionsSpecForProviderRoleArnRef
 */
export interface LoggingOptionsSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LoggingOptionsSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LoggingOptionsSpecForProviderRoleArnRef#policy
   */
  readonly policy?: LoggingOptionsSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'LoggingOptionsSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingOptionsSpecForProviderRoleArnRef(obj: LoggingOptionsSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LoggingOptionsSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema LoggingOptionsSpecForProviderRoleArnSelector
 */
export interface LoggingOptionsSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LoggingOptionsSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LoggingOptionsSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LoggingOptionsSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: LoggingOptionsSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'LoggingOptionsSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingOptionsSpecForProviderRoleArnSelector(obj: LoggingOptionsSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LoggingOptionsSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LoggingOptionsSpecProviderConfigRefPolicy
 */
export interface LoggingOptionsSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoggingOptionsSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LoggingOptionsSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoggingOptionsSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LoggingOptionsSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LoggingOptionsSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingOptionsSpecProviderConfigRefPolicy(obj: LoggingOptionsSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LoggingOptionsSpecPublishConnectionDetailsToConfigRef
 */
export interface LoggingOptionsSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LoggingOptionsSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LoggingOptionsSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LoggingOptionsSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LoggingOptionsSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingOptionsSpecPublishConnectionDetailsToConfigRef(obj: LoggingOptionsSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LoggingOptionsSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LoggingOptionsSpecPublishConnectionDetailsToMetadata
 */
export interface LoggingOptionsSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LoggingOptionsSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LoggingOptionsSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LoggingOptionsSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LoggingOptionsSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingOptionsSpecPublishConnectionDetailsToMetadata(obj: LoggingOptionsSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LoggingOptionsSpecForProviderRoleArnRefPolicy
 */
export interface LoggingOptionsSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoggingOptionsSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: LoggingOptionsSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoggingOptionsSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: LoggingOptionsSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LoggingOptionsSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingOptionsSpecForProviderRoleArnRefPolicy(obj: LoggingOptionsSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LoggingOptionsSpecForProviderRoleArnSelectorPolicy
 */
export interface LoggingOptionsSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoggingOptionsSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: LoggingOptionsSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoggingOptionsSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: LoggingOptionsSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LoggingOptionsSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingOptionsSpecForProviderRoleArnSelectorPolicy(obj: LoggingOptionsSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoggingOptionsSpecProviderConfigRefPolicyResolution
 */
export enum LoggingOptionsSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoggingOptionsSpecProviderConfigRefPolicyResolve
 */
export enum LoggingOptionsSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LoggingOptionsSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LoggingOptionsSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoggingOptionsSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LoggingOptionsSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoggingOptionsSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LoggingOptionsSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LoggingOptionsSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoggingOptionsSpecPublishConnectionDetailsToConfigRefPolicy(obj: LoggingOptionsSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoggingOptionsSpecForProviderRoleArnRefPolicyResolution
 */
export enum LoggingOptionsSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoggingOptionsSpecForProviderRoleArnRefPolicyResolve
 */
export enum LoggingOptionsSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoggingOptionsSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum LoggingOptionsSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoggingOptionsSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum LoggingOptionsSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoggingOptionsSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LoggingOptionsSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoggingOptionsSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LoggingOptionsSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Policy is the Schema for the Policys API. Provides an IoT policy.
 *
 * @schema Policy
 */
export class Policy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Policy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iot.aws.upbound.io/v1beta1',
    kind: 'Policy',
  }

  /**
   * Renders a Kubernetes manifest for "Policy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PolicyProps): any {
    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(props),
    };
  }

  /**
   * Defines a "Policy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PolicyProps) {
    super(scope, id, {
      ...Policy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(resolved),
    };
  }
}

/**
 * Policy is the Schema for the Policys API. Provides an IoT policy.
 *
 * @schema Policy
 */
export interface PolicyProps {
  /**
   * @schema Policy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PolicySpec defines the desired state of Policy
   *
   * @schema Policy#spec
   */
  readonly spec: PolicySpec;

}

/**
 * Converts an object of type 'PolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyProps(obj: PolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicySpec defines the desired state of Policy
 *
 * @schema PolicySpec
 */
export interface PolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: PolicySpecDeletionPolicy;

  /**
   * @schema PolicySpec#forProvider
   */
  readonly forProvider: PolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema PolicySpec#initProvider
   */
  readonly initProvider?: PolicySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PolicySpec#managementPolicies
   */
  readonly managementPolicies?: PolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: PolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpec(obj: PolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_PolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PolicySpecDeletionPolicy
 */
export enum PolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PolicySpecForProvider
 */
export interface PolicySpecForProvider {
  /**
   * The policy document. This is a JSON formatted string. Use the IoT Developer Guide for more information on IoT Policies.
   *
   * @schema PolicySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'PolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProvider(obj: PolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policy': obj.policy,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema PolicySpecInitProvider
 */
export interface PolicySpecInitProvider {
  /**
   * The policy document. This is a JSON formatted string. Use the IoT Developer Guide for more information on IoT Policies.
   *
   * @schema PolicySpecInitProvider#policy
   */
  readonly policy?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProvider(obj: PolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policy': obj.policy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PolicySpecManagementPolicies
 */
export enum PolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PolicySpecProviderConfigRef
 */
export interface PolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecProviderConfigRef#policy
   */
  readonly policy?: PolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRef(obj: PolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PolicySpecPublishConnectionDetailsTo
 */
export interface PolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsTo(obj: PolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PolicySpecWriteConnectionSecretToRef
 */
export interface PolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecWriteConnectionSecretToRef(obj: PolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecProviderConfigRefPolicy
 */
export interface PolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRefPolicy(obj: PolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRef
 */
export interface PolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj: PolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PolicySpecPublishConnectionDetailsToMetadata
 */
export interface PolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToMetadata(obj: PolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolution
 */
export enum PolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolve
 */
export enum PolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: PolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PolicyAttachment is the Schema for the PolicyAttachments API. Provides an IoT policy attachment.
 *
 * @schema PolicyAttachment
 */
export class PolicyAttachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PolicyAttachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iot.aws.upbound.io/v1beta1',
    kind: 'PolicyAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "PolicyAttachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PolicyAttachmentProps): any {
    return {
      ...PolicyAttachment.GVK,
      ...toJson_PolicyAttachmentProps(props),
    };
  }

  /**
   * Defines a "PolicyAttachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PolicyAttachmentProps) {
    super(scope, id, {
      ...PolicyAttachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PolicyAttachment.GVK,
      ...toJson_PolicyAttachmentProps(resolved),
    };
  }
}

/**
 * PolicyAttachment is the Schema for the PolicyAttachments API. Provides an IoT policy attachment.
 *
 * @schema PolicyAttachment
 */
export interface PolicyAttachmentProps {
  /**
   * @schema PolicyAttachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PolicyAttachmentSpec defines the desired state of PolicyAttachment
   *
   * @schema PolicyAttachment#spec
   */
  readonly spec: PolicyAttachmentSpec;

}

/**
 * Converts an object of type 'PolicyAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentProps(obj: PolicyAttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PolicyAttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicyAttachmentSpec defines the desired state of PolicyAttachment
 *
 * @schema PolicyAttachmentSpec
 */
export interface PolicyAttachmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PolicyAttachmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: PolicyAttachmentSpecDeletionPolicy;

  /**
   * @schema PolicyAttachmentSpec#forProvider
   */
  readonly forProvider: PolicyAttachmentSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema PolicyAttachmentSpec#initProvider
   */
  readonly initProvider?: any;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PolicyAttachmentSpec#managementPolicies
   */
  readonly managementPolicies?: PolicyAttachmentSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PolicyAttachmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: PolicyAttachmentSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PolicyAttachmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PolicyAttachmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PolicyAttachmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PolicyAttachmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PolicyAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpec(obj: PolicyAttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PolicyAttachmentSpecForProvider(obj.forProvider),
    'initProvider': obj.initProvider,
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PolicyAttachmentSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PolicyAttachmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PolicyAttachmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PolicyAttachmentSpecDeletionPolicy
 */
export enum PolicyAttachmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PolicyAttachmentSpecForProvider
 */
export interface PolicyAttachmentSpecForProvider {
  /**
   * The name of the policy to attach.
   *
   * @schema PolicyAttachmentSpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Reference to a Policy in iot to populate policy.
   *
   * @schema PolicyAttachmentSpecForProvider#policyRef
   */
  readonly policyRef?: PolicyAttachmentSpecForProviderPolicyRef;

  /**
   * Selector for a Policy in iot to populate policy.
   *
   * @schema PolicyAttachmentSpecForProvider#policySelector
   */
  readonly policySelector?: PolicyAttachmentSpecForProviderPolicySelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PolicyAttachmentSpecForProvider#region
   */
  readonly region: string;

  /**
   * The identity to which the policy is attached.
   *
   * @schema PolicyAttachmentSpecForProvider#target
   */
  readonly target?: string;

  /**
   * Reference to a Certificate in iot to populate target.
   *
   * @schema PolicyAttachmentSpecForProvider#targetRef
   */
  readonly targetRef?: PolicyAttachmentSpecForProviderTargetRef;

  /**
   * Selector for a Certificate in iot to populate target.
   *
   * @schema PolicyAttachmentSpecForProvider#targetSelector
   */
  readonly targetSelector?: PolicyAttachmentSpecForProviderTargetSelector;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecForProvider(obj: PolicyAttachmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policy': obj.policy,
    'policyRef': toJson_PolicyAttachmentSpecForProviderPolicyRef(obj.policyRef),
    'policySelector': toJson_PolicyAttachmentSpecForProviderPolicySelector(obj.policySelector),
    'region': obj.region,
    'target': obj.target,
    'targetRef': toJson_PolicyAttachmentSpecForProviderTargetRef(obj.targetRef),
    'targetSelector': toJson_PolicyAttachmentSpecForProviderTargetSelector(obj.targetSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PolicyAttachmentSpecManagementPolicies
 */
export enum PolicyAttachmentSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PolicyAttachmentSpecProviderConfigRef
 */
export interface PolicyAttachmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicyAttachmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicyAttachmentSpecProviderConfigRef#policy
   */
  readonly policy?: PolicyAttachmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecProviderConfigRef(obj: PolicyAttachmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicyAttachmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PolicyAttachmentSpecPublishConnectionDetailsTo
 */
export interface PolicyAttachmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PolicyAttachmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PolicyAttachmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecPublishConnectionDetailsTo(obj: PolicyAttachmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PolicyAttachmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PolicyAttachmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PolicyAttachmentSpecWriteConnectionSecretToRef
 */
export interface PolicyAttachmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PolicyAttachmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PolicyAttachmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecWriteConnectionSecretToRef(obj: PolicyAttachmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Policy in iot to populate policy.
 *
 * @schema PolicyAttachmentSpecForProviderPolicyRef
 */
export interface PolicyAttachmentSpecForProviderPolicyRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicyAttachmentSpecForProviderPolicyRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicyAttachmentSpecForProviderPolicyRef#policy
   */
  readonly policy?: PolicyAttachmentSpecForProviderPolicyRefPolicy;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecForProviderPolicyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecForProviderPolicyRef(obj: PolicyAttachmentSpecForProviderPolicyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicyAttachmentSpecForProviderPolicyRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Policy in iot to populate policy.
 *
 * @schema PolicyAttachmentSpecForProviderPolicySelector
 */
export interface PolicyAttachmentSpecForProviderPolicySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PolicyAttachmentSpecForProviderPolicySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PolicyAttachmentSpecForProviderPolicySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PolicyAttachmentSpecForProviderPolicySelector#policy
   */
  readonly policy?: PolicyAttachmentSpecForProviderPolicySelectorPolicy;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecForProviderPolicySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecForProviderPolicySelector(obj: PolicyAttachmentSpecForProviderPolicySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PolicyAttachmentSpecForProviderPolicySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Certificate in iot to populate target.
 *
 * @schema PolicyAttachmentSpecForProviderTargetRef
 */
export interface PolicyAttachmentSpecForProviderTargetRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicyAttachmentSpecForProviderTargetRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicyAttachmentSpecForProviderTargetRef#policy
   */
  readonly policy?: PolicyAttachmentSpecForProviderTargetRefPolicy;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecForProviderTargetRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecForProviderTargetRef(obj: PolicyAttachmentSpecForProviderTargetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicyAttachmentSpecForProviderTargetRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Certificate in iot to populate target.
 *
 * @schema PolicyAttachmentSpecForProviderTargetSelector
 */
export interface PolicyAttachmentSpecForProviderTargetSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PolicyAttachmentSpecForProviderTargetSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PolicyAttachmentSpecForProviderTargetSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PolicyAttachmentSpecForProviderTargetSelector#policy
   */
  readonly policy?: PolicyAttachmentSpecForProviderTargetSelectorPolicy;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecForProviderTargetSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecForProviderTargetSelector(obj: PolicyAttachmentSpecForProviderTargetSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PolicyAttachmentSpecForProviderTargetSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicyAttachmentSpecProviderConfigRefPolicy
 */
export interface PolicyAttachmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicyAttachmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PolicyAttachmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicyAttachmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PolicyAttachmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecProviderConfigRefPolicy(obj: PolicyAttachmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PolicyAttachmentSpecPublishConnectionDetailsToConfigRef
 */
export interface PolicyAttachmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecPublishConnectionDetailsToConfigRef(obj: PolicyAttachmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PolicyAttachmentSpecPublishConnectionDetailsToMetadata
 */
export interface PolicyAttachmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecPublishConnectionDetailsToMetadata(obj: PolicyAttachmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicyAttachmentSpecForProviderPolicyRefPolicy
 */
export interface PolicyAttachmentSpecForProviderPolicyRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicyAttachmentSpecForProviderPolicyRefPolicy#resolution
   */
  readonly resolution?: PolicyAttachmentSpecForProviderPolicyRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicyAttachmentSpecForProviderPolicyRefPolicy#resolve
   */
  readonly resolve?: PolicyAttachmentSpecForProviderPolicyRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecForProviderPolicyRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecForProviderPolicyRefPolicy(obj: PolicyAttachmentSpecForProviderPolicyRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PolicyAttachmentSpecForProviderPolicySelectorPolicy
 */
export interface PolicyAttachmentSpecForProviderPolicySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicyAttachmentSpecForProviderPolicySelectorPolicy#resolution
   */
  readonly resolution?: PolicyAttachmentSpecForProviderPolicySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicyAttachmentSpecForProviderPolicySelectorPolicy#resolve
   */
  readonly resolve?: PolicyAttachmentSpecForProviderPolicySelectorPolicyResolve;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecForProviderPolicySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecForProviderPolicySelectorPolicy(obj: PolicyAttachmentSpecForProviderPolicySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicyAttachmentSpecForProviderTargetRefPolicy
 */
export interface PolicyAttachmentSpecForProviderTargetRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicyAttachmentSpecForProviderTargetRefPolicy#resolution
   */
  readonly resolution?: PolicyAttachmentSpecForProviderTargetRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicyAttachmentSpecForProviderTargetRefPolicy#resolve
   */
  readonly resolve?: PolicyAttachmentSpecForProviderTargetRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecForProviderTargetRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecForProviderTargetRefPolicy(obj: PolicyAttachmentSpecForProviderTargetRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PolicyAttachmentSpecForProviderTargetSelectorPolicy
 */
export interface PolicyAttachmentSpecForProviderTargetSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicyAttachmentSpecForProviderTargetSelectorPolicy#resolution
   */
  readonly resolution?: PolicyAttachmentSpecForProviderTargetSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicyAttachmentSpecForProviderTargetSelectorPolicy#resolve
   */
  readonly resolve?: PolicyAttachmentSpecForProviderTargetSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecForProviderTargetSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecForProviderTargetSelectorPolicy(obj: PolicyAttachmentSpecForProviderTargetSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicyAttachmentSpecProviderConfigRefPolicyResolution
 */
export enum PolicyAttachmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicyAttachmentSpecProviderConfigRefPolicyResolve
 */
export enum PolicyAttachmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicyAttachmentSpecForProviderPolicyRefPolicyResolution
 */
export enum PolicyAttachmentSpecForProviderPolicyRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicyAttachmentSpecForProviderPolicyRefPolicyResolve
 */
export enum PolicyAttachmentSpecForProviderPolicyRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicyAttachmentSpecForProviderPolicySelectorPolicyResolution
 */
export enum PolicyAttachmentSpecForProviderPolicySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicyAttachmentSpecForProviderPolicySelectorPolicyResolve
 */
export enum PolicyAttachmentSpecForProviderPolicySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicyAttachmentSpecForProviderTargetRefPolicyResolution
 */
export enum PolicyAttachmentSpecForProviderTargetRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicyAttachmentSpecForProviderTargetRefPolicyResolve
 */
export enum PolicyAttachmentSpecForProviderTargetRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicyAttachmentSpecForProviderTargetSelectorPolicyResolution
 */
export enum PolicyAttachmentSpecForProviderTargetSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicyAttachmentSpecForProviderTargetSelectorPolicyResolve
 */
export enum PolicyAttachmentSpecForProviderTargetSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProvisioningTemplate is the Schema for the ProvisioningTemplates API. Manages an IoT fleet provisioning template.
 *
 * @schema ProvisioningTemplate
 */
export class ProvisioningTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProvisioningTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iot.aws.upbound.io/v1beta1',
    kind: 'ProvisioningTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "ProvisioningTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProvisioningTemplateProps): any {
    return {
      ...ProvisioningTemplate.GVK,
      ...toJson_ProvisioningTemplateProps(props),
    };
  }

  /**
   * Defines a "ProvisioningTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProvisioningTemplateProps) {
    super(scope, id, {
      ...ProvisioningTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProvisioningTemplate.GVK,
      ...toJson_ProvisioningTemplateProps(resolved),
    };
  }
}

/**
 * ProvisioningTemplate is the Schema for the ProvisioningTemplates API. Manages an IoT fleet provisioning template.
 *
 * @schema ProvisioningTemplate
 */
export interface ProvisioningTemplateProps {
  /**
   * @schema ProvisioningTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProvisioningTemplateSpec defines the desired state of ProvisioningTemplate
   *
   * @schema ProvisioningTemplate#spec
   */
  readonly spec: ProvisioningTemplateSpec;

}

/**
 * Converts an object of type 'ProvisioningTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningTemplateProps(obj: ProvisioningTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProvisioningTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProvisioningTemplateSpec defines the desired state of ProvisioningTemplate
 *
 * @schema ProvisioningTemplateSpec
 */
export interface ProvisioningTemplateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProvisioningTemplateSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProvisioningTemplateSpecDeletionPolicy;

  /**
   * @schema ProvisioningTemplateSpec#forProvider
   */
  readonly forProvider: ProvisioningTemplateSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ProvisioningTemplateSpec#initProvider
   */
  readonly initProvider?: ProvisioningTemplateSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProvisioningTemplateSpec#managementPolicies
   */
  readonly managementPolicies?: ProvisioningTemplateSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProvisioningTemplateSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProvisioningTemplateSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProvisioningTemplateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProvisioningTemplateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProvisioningTemplateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProvisioningTemplateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProvisioningTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningTemplateSpec(obj: ProvisioningTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProvisioningTemplateSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProvisioningTemplateSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProvisioningTemplateSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProvisioningTemplateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProvisioningTemplateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProvisioningTemplateSpecDeletionPolicy
 */
export enum ProvisioningTemplateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProvisioningTemplateSpecForProvider
 */
export interface ProvisioningTemplateSpecForProvider {
  /**
   * The description of the fleet provisioning template.
   *
   * @schema ProvisioningTemplateSpecForProvider#description
   */
  readonly description?: string;

  /**
   * True to enable the fleet provisioning template, otherwise false.
   *
   * @schema ProvisioningTemplateSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Creates a pre-provisioning hook template. Details below.
   *
   * @schema ProvisioningTemplateSpecForProvider#preProvisioningHook
   */
  readonly preProvisioningHook?: ProvisioningTemplateSpecForProviderPreProvisioningHook[];

  /**
   * The role ARN for the role associated with the fleet provisioning template. This IoT role grants permission to provision a device.
   *
   * @schema ProvisioningTemplateSpecForProvider#provisioningRoleArn
   */
  readonly provisioningRoleArn?: string;

  /**
   * Reference to a Role in iam to populate provisioningRoleArn.
   *
   * @schema ProvisioningTemplateSpecForProvider#provisioningRoleArnRef
   */
  readonly provisioningRoleArnRef?: ProvisioningTemplateSpecForProviderProvisioningRoleArnRef;

  /**
   * Selector for a Role in iam to populate provisioningRoleArn.
   *
   * @schema ProvisioningTemplateSpecForProvider#provisioningRoleArnSelector
   */
  readonly provisioningRoleArnSelector?: ProvisioningTemplateSpecForProviderProvisioningRoleArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ProvisioningTemplateSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ProvisioningTemplateSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The JSON formatted contents of the fleet provisioning template.
   *
   * @schema ProvisioningTemplateSpecForProvider#templateBody
   */
  readonly templateBody?: string;

}

/**
 * Converts an object of type 'ProvisioningTemplateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningTemplateSpecForProvider(obj: ProvisioningTemplateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'enabled': obj.enabled,
    'preProvisioningHook': obj.preProvisioningHook?.map(y => toJson_ProvisioningTemplateSpecForProviderPreProvisioningHook(y)),
    'provisioningRoleArn': obj.provisioningRoleArn,
    'provisioningRoleArnRef': toJson_ProvisioningTemplateSpecForProviderProvisioningRoleArnRef(obj.provisioningRoleArnRef),
    'provisioningRoleArnSelector': toJson_ProvisioningTemplateSpecForProviderProvisioningRoleArnSelector(obj.provisioningRoleArnSelector),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'templateBody': obj.templateBody,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ProvisioningTemplateSpecInitProvider
 */
export interface ProvisioningTemplateSpecInitProvider {
  /**
   * The description of the fleet provisioning template.
   *
   * @schema ProvisioningTemplateSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * True to enable the fleet provisioning template, otherwise false.
   *
   * @schema ProvisioningTemplateSpecInitProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Creates a pre-provisioning hook template. Details below.
   *
   * @schema ProvisioningTemplateSpecInitProvider#preProvisioningHook
   */
  readonly preProvisioningHook?: ProvisioningTemplateSpecInitProviderPreProvisioningHook[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ProvisioningTemplateSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The JSON formatted contents of the fleet provisioning template.
   *
   * @schema ProvisioningTemplateSpecInitProvider#templateBody
   */
  readonly templateBody?: string;

}

/**
 * Converts an object of type 'ProvisioningTemplateSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningTemplateSpecInitProvider(obj: ProvisioningTemplateSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'enabled': obj.enabled,
    'preProvisioningHook': obj.preProvisioningHook?.map(y => toJson_ProvisioningTemplateSpecInitProviderPreProvisioningHook(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'templateBody': obj.templateBody,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ProvisioningTemplateSpecManagementPolicies
 */
export enum ProvisioningTemplateSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProvisioningTemplateSpecProviderConfigRef
 */
export interface ProvisioningTemplateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProvisioningTemplateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProvisioningTemplateSpecProviderConfigRef#policy
   */
  readonly policy?: ProvisioningTemplateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProvisioningTemplateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningTemplateSpecProviderConfigRef(obj: ProvisioningTemplateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProvisioningTemplateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProvisioningTemplateSpecPublishConnectionDetailsTo
 */
export interface ProvisioningTemplateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProvisioningTemplateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProvisioningTemplateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProvisioningTemplateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProvisioningTemplateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProvisioningTemplateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProvisioningTemplateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningTemplateSpecPublishConnectionDetailsTo(obj: ProvisioningTemplateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProvisioningTemplateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProvisioningTemplateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProvisioningTemplateSpecWriteConnectionSecretToRef
 */
export interface ProvisioningTemplateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProvisioningTemplateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProvisioningTemplateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProvisioningTemplateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningTemplateSpecWriteConnectionSecretToRef(obj: ProvisioningTemplateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProvisioningTemplateSpecForProviderPreProvisioningHook
 */
export interface ProvisioningTemplateSpecForProviderPreProvisioningHook {
  /**
   * The version of the payload that was sent to the target function. The only valid (and the default) payload version is "2020-04-01".
   *
   * @schema ProvisioningTemplateSpecForProviderPreProvisioningHook#payloadVersion
   */
  readonly payloadVersion?: string;

  /**
   * The ARN of the target function.
   *
   * @schema ProvisioningTemplateSpecForProviderPreProvisioningHook#targetArn
   */
  readonly targetArn?: string;

}

/**
 * Converts an object of type 'ProvisioningTemplateSpecForProviderPreProvisioningHook' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningTemplateSpecForProviderPreProvisioningHook(obj: ProvisioningTemplateSpecForProviderPreProvisioningHook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'payloadVersion': obj.payloadVersion,
    'targetArn': obj.targetArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate provisioningRoleArn.
 *
 * @schema ProvisioningTemplateSpecForProviderProvisioningRoleArnRef
 */
export interface ProvisioningTemplateSpecForProviderProvisioningRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProvisioningTemplateSpecForProviderProvisioningRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProvisioningTemplateSpecForProviderProvisioningRoleArnRef#policy
   */
  readonly policy?: ProvisioningTemplateSpecForProviderProvisioningRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ProvisioningTemplateSpecForProviderProvisioningRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningTemplateSpecForProviderProvisioningRoleArnRef(obj: ProvisioningTemplateSpecForProviderProvisioningRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProvisioningTemplateSpecForProviderProvisioningRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate provisioningRoleArn.
 *
 * @schema ProvisioningTemplateSpecForProviderProvisioningRoleArnSelector
 */
export interface ProvisioningTemplateSpecForProviderProvisioningRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProvisioningTemplateSpecForProviderProvisioningRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProvisioningTemplateSpecForProviderProvisioningRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProvisioningTemplateSpecForProviderProvisioningRoleArnSelector#policy
   */
  readonly policy?: ProvisioningTemplateSpecForProviderProvisioningRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ProvisioningTemplateSpecForProviderProvisioningRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningTemplateSpecForProviderProvisioningRoleArnSelector(obj: ProvisioningTemplateSpecForProviderProvisioningRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProvisioningTemplateSpecForProviderProvisioningRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProvisioningTemplateSpecInitProviderPreProvisioningHook
 */
export interface ProvisioningTemplateSpecInitProviderPreProvisioningHook {
  /**
   * The version of the payload that was sent to the target function. The only valid (and the default) payload version is "2020-04-01".
   *
   * @schema ProvisioningTemplateSpecInitProviderPreProvisioningHook#payloadVersion
   */
  readonly payloadVersion?: string;

  /**
   * The ARN of the target function.
   *
   * @schema ProvisioningTemplateSpecInitProviderPreProvisioningHook#targetArn
   */
  readonly targetArn?: string;

}

/**
 * Converts an object of type 'ProvisioningTemplateSpecInitProviderPreProvisioningHook' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningTemplateSpecInitProviderPreProvisioningHook(obj: ProvisioningTemplateSpecInitProviderPreProvisioningHook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'payloadVersion': obj.payloadVersion,
    'targetArn': obj.targetArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProvisioningTemplateSpecProviderConfigRefPolicy
 */
export interface ProvisioningTemplateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProvisioningTemplateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProvisioningTemplateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProvisioningTemplateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProvisioningTemplateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProvisioningTemplateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningTemplateSpecProviderConfigRefPolicy(obj: ProvisioningTemplateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProvisioningTemplateSpecPublishConnectionDetailsToConfigRef
 */
export interface ProvisioningTemplateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProvisioningTemplateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProvisioningTemplateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProvisioningTemplateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProvisioningTemplateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningTemplateSpecPublishConnectionDetailsToConfigRef(obj: ProvisioningTemplateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProvisioningTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProvisioningTemplateSpecPublishConnectionDetailsToMetadata
 */
export interface ProvisioningTemplateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProvisioningTemplateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProvisioningTemplateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProvisioningTemplateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProvisioningTemplateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningTemplateSpecPublishConnectionDetailsToMetadata(obj: ProvisioningTemplateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProvisioningTemplateSpecForProviderProvisioningRoleArnRefPolicy
 */
export interface ProvisioningTemplateSpecForProviderProvisioningRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProvisioningTemplateSpecForProviderProvisioningRoleArnRefPolicy#resolution
   */
  readonly resolution?: ProvisioningTemplateSpecForProviderProvisioningRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProvisioningTemplateSpecForProviderProvisioningRoleArnRefPolicy#resolve
   */
  readonly resolve?: ProvisioningTemplateSpecForProviderProvisioningRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ProvisioningTemplateSpecForProviderProvisioningRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningTemplateSpecForProviderProvisioningRoleArnRefPolicy(obj: ProvisioningTemplateSpecForProviderProvisioningRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProvisioningTemplateSpecForProviderProvisioningRoleArnSelectorPolicy
 */
export interface ProvisioningTemplateSpecForProviderProvisioningRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProvisioningTemplateSpecForProviderProvisioningRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ProvisioningTemplateSpecForProviderProvisioningRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProvisioningTemplateSpecForProviderProvisioningRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ProvisioningTemplateSpecForProviderProvisioningRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProvisioningTemplateSpecForProviderProvisioningRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningTemplateSpecForProviderProvisioningRoleArnSelectorPolicy(obj: ProvisioningTemplateSpecForProviderProvisioningRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProvisioningTemplateSpecProviderConfigRefPolicyResolution
 */
export enum ProvisioningTemplateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProvisioningTemplateSpecProviderConfigRefPolicyResolve
 */
export enum ProvisioningTemplateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProvisioningTemplateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProvisioningTemplateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProvisioningTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProvisioningTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProvisioningTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProvisioningTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProvisioningTemplateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProvisioningTemplateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProvisioningTemplateSpecForProviderProvisioningRoleArnRefPolicyResolution
 */
export enum ProvisioningTemplateSpecForProviderProvisioningRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProvisioningTemplateSpecForProviderProvisioningRoleArnRefPolicyResolve
 */
export enum ProvisioningTemplateSpecForProviderProvisioningRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProvisioningTemplateSpecForProviderProvisioningRoleArnSelectorPolicyResolution
 */
export enum ProvisioningTemplateSpecForProviderProvisioningRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProvisioningTemplateSpecForProviderProvisioningRoleArnSelectorPolicyResolve
 */
export enum ProvisioningTemplateSpecForProviderProvisioningRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProvisioningTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProvisioningTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProvisioningTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProvisioningTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RoleAlias is the Schema for the RoleAliass API. Provides an IoT role alias.
 *
 * @schema RoleAlias
 */
export class RoleAlias extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RoleAlias"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iot.aws.upbound.io/v1beta1',
    kind: 'RoleAlias',
  }

  /**
   * Renders a Kubernetes manifest for "RoleAlias".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RoleAliasProps): any {
    return {
      ...RoleAlias.GVK,
      ...toJson_RoleAliasProps(props),
    };
  }

  /**
   * Defines a "RoleAlias" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RoleAliasProps) {
    super(scope, id, {
      ...RoleAlias.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RoleAlias.GVK,
      ...toJson_RoleAliasProps(resolved),
    };
  }
}

/**
 * RoleAlias is the Schema for the RoleAliass API. Provides an IoT role alias.
 *
 * @schema RoleAlias
 */
export interface RoleAliasProps {
  /**
   * @schema RoleAlias#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RoleAliasSpec defines the desired state of RoleAlias
   *
   * @schema RoleAlias#spec
   */
  readonly spec: RoleAliasSpec;

}

/**
 * Converts an object of type 'RoleAliasProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAliasProps(obj: RoleAliasProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RoleAliasSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleAliasSpec defines the desired state of RoleAlias
 *
 * @schema RoleAliasSpec
 */
export interface RoleAliasSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RoleAliasSpec#deletionPolicy
   */
  readonly deletionPolicy?: RoleAliasSpecDeletionPolicy;

  /**
   * @schema RoleAliasSpec#forProvider
   */
  readonly forProvider: RoleAliasSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema RoleAliasSpec#initProvider
   */
  readonly initProvider?: RoleAliasSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RoleAliasSpec#managementPolicies
   */
  readonly managementPolicies?: RoleAliasSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RoleAliasSpec#providerConfigRef
   */
  readonly providerConfigRef?: RoleAliasSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RoleAliasSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RoleAliasSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RoleAliasSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RoleAliasSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RoleAliasSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAliasSpec(obj: RoleAliasSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RoleAliasSpecForProvider(obj.forProvider),
    'initProvider': toJson_RoleAliasSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RoleAliasSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RoleAliasSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RoleAliasSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RoleAliasSpecDeletionPolicy
 */
export enum RoleAliasSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RoleAliasSpecForProvider
 */
export interface RoleAliasSpecForProvider {
  /**
   * The name of the role alias.
   *
   * @schema RoleAliasSpecForProvider#alias
   */
  readonly alias?: string;

  /**
   * The duration of the credential, in seconds. If you do not specify a value for this setting, the default maximum of one hour is applied. This setting can have a value from 900 seconds (15 minutes) to 43200 seconds (12 hours).
   *
   * @schema RoleAliasSpecForProvider#credentialDuration
   */
  readonly credentialDuration?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RoleAliasSpecForProvider#region
   */
  readonly region: string;

  /**
   * The identity of the role to which the alias refers.
   *
   * @schema RoleAliasSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema RoleAliasSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: RoleAliasSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema RoleAliasSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: RoleAliasSpecForProviderRoleArnSelector;

}

/**
 * Converts an object of type 'RoleAliasSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAliasSpecForProvider(obj: RoleAliasSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': obj.alias,
    'credentialDuration': obj.credentialDuration,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_RoleAliasSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_RoleAliasSpecForProviderRoleArnSelector(obj.roleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema RoleAliasSpecInitProvider
 */
export interface RoleAliasSpecInitProvider {
  /**
   * The name of the role alias.
   *
   * @schema RoleAliasSpecInitProvider#alias
   */
  readonly alias?: string;

  /**
   * The duration of the credential, in seconds. If you do not specify a value for this setting, the default maximum of one hour is applied. This setting can have a value from 900 seconds (15 minutes) to 43200 seconds (12 hours).
   *
   * @schema RoleAliasSpecInitProvider#credentialDuration
   */
  readonly credentialDuration?: number;

}

/**
 * Converts an object of type 'RoleAliasSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAliasSpecInitProvider(obj: RoleAliasSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': obj.alias,
    'credentialDuration': obj.credentialDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RoleAliasSpecManagementPolicies
 */
export enum RoleAliasSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RoleAliasSpecProviderConfigRef
 */
export interface RoleAliasSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoleAliasSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoleAliasSpecProviderConfigRef#policy
   */
  readonly policy?: RoleAliasSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RoleAliasSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAliasSpecProviderConfigRef(obj: RoleAliasSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoleAliasSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RoleAliasSpecPublishConnectionDetailsTo
 */
export interface RoleAliasSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RoleAliasSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RoleAliasSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RoleAliasSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RoleAliasSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RoleAliasSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RoleAliasSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAliasSpecPublishConnectionDetailsTo(obj: RoleAliasSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RoleAliasSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RoleAliasSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RoleAliasSpecWriteConnectionSecretToRef
 */
export interface RoleAliasSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RoleAliasSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RoleAliasSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RoleAliasSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAliasSpecWriteConnectionSecretToRef(obj: RoleAliasSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema RoleAliasSpecForProviderRoleArnRef
 */
export interface RoleAliasSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoleAliasSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoleAliasSpecForProviderRoleArnRef#policy
   */
  readonly policy?: RoleAliasSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'RoleAliasSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAliasSpecForProviderRoleArnRef(obj: RoleAliasSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoleAliasSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema RoleAliasSpecForProviderRoleArnSelector
 */
export interface RoleAliasSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RoleAliasSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RoleAliasSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RoleAliasSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: RoleAliasSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'RoleAliasSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAliasSpecForProviderRoleArnSelector(obj: RoleAliasSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RoleAliasSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RoleAliasSpecProviderConfigRefPolicy
 */
export interface RoleAliasSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoleAliasSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RoleAliasSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoleAliasSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RoleAliasSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RoleAliasSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAliasSpecProviderConfigRefPolicy(obj: RoleAliasSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RoleAliasSpecPublishConnectionDetailsToConfigRef
 */
export interface RoleAliasSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoleAliasSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoleAliasSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RoleAliasSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RoleAliasSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAliasSpecPublishConnectionDetailsToConfigRef(obj: RoleAliasSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoleAliasSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RoleAliasSpecPublishConnectionDetailsToMetadata
 */
export interface RoleAliasSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RoleAliasSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RoleAliasSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RoleAliasSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RoleAliasSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAliasSpecPublishConnectionDetailsToMetadata(obj: RoleAliasSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RoleAliasSpecForProviderRoleArnRefPolicy
 */
export interface RoleAliasSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoleAliasSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: RoleAliasSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoleAliasSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: RoleAliasSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RoleAliasSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAliasSpecForProviderRoleArnRefPolicy(obj: RoleAliasSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RoleAliasSpecForProviderRoleArnSelectorPolicy
 */
export interface RoleAliasSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoleAliasSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: RoleAliasSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoleAliasSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: RoleAliasSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RoleAliasSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAliasSpecForProviderRoleArnSelectorPolicy(obj: RoleAliasSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoleAliasSpecProviderConfigRefPolicyResolution
 */
export enum RoleAliasSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoleAliasSpecProviderConfigRefPolicyResolve
 */
export enum RoleAliasSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RoleAliasSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RoleAliasSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoleAliasSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RoleAliasSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoleAliasSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RoleAliasSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RoleAliasSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAliasSpecPublishConnectionDetailsToConfigRefPolicy(obj: RoleAliasSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoleAliasSpecForProviderRoleArnRefPolicyResolution
 */
export enum RoleAliasSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoleAliasSpecForProviderRoleArnRefPolicyResolve
 */
export enum RoleAliasSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoleAliasSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum RoleAliasSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoleAliasSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum RoleAliasSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoleAliasSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RoleAliasSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoleAliasSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RoleAliasSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Thing is the Schema for the Things API. Creates and manages an AWS IoT Thing.
 *
 * @schema Thing
 */
export class Thing extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Thing"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iot.aws.upbound.io/v1beta1',
    kind: 'Thing',
  }

  /**
   * Renders a Kubernetes manifest for "Thing".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ThingProps): any {
    return {
      ...Thing.GVK,
      ...toJson_ThingProps(props),
    };
  }

  /**
   * Defines a "Thing" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ThingProps) {
    super(scope, id, {
      ...Thing.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Thing.GVK,
      ...toJson_ThingProps(resolved),
    };
  }
}

/**
 * Thing is the Schema for the Things API. Creates and manages an AWS IoT Thing.
 *
 * @schema Thing
 */
export interface ThingProps {
  /**
   * @schema Thing#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ThingSpec defines the desired state of Thing
   *
   * @schema Thing#spec
   */
  readonly spec: ThingSpec;

}

/**
 * Converts an object of type 'ThingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingProps(obj: ThingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ThingSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ThingSpec defines the desired state of Thing
 *
 * @schema ThingSpec
 */
export interface ThingSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ThingSpec#deletionPolicy
   */
  readonly deletionPolicy?: ThingSpecDeletionPolicy;

  /**
   * @schema ThingSpec#forProvider
   */
  readonly forProvider: ThingSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ThingSpec#initProvider
   */
  readonly initProvider?: ThingSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ThingSpec#managementPolicies
   */
  readonly managementPolicies?: ThingSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ThingSpec#providerConfigRef
   */
  readonly providerConfigRef?: ThingSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ThingSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ThingSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ThingSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ThingSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ThingSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingSpec(obj: ThingSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ThingSpecForProvider(obj.forProvider),
    'initProvider': toJson_ThingSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ThingSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ThingSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ThingSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ThingSpecDeletionPolicy
 */
export enum ThingSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ThingSpecForProvider
 */
export interface ThingSpecForProvider {
  /**
   * Map of attributes of the thing.
   *
   * @schema ThingSpecForProvider#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ThingSpecForProvider#region
   */
  readonly region: string;

  /**
   * The thing type name.
   *
   * @schema ThingSpecForProvider#thingTypeName
   */
  readonly thingTypeName?: string;

}

/**
 * Converts an object of type 'ThingSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingSpecForProvider(obj: ThingSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'thingTypeName': obj.thingTypeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ThingSpecInitProvider
 */
export interface ThingSpecInitProvider {
  /**
   * Map of attributes of the thing.
   *
   * @schema ThingSpecInitProvider#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * The thing type name.
   *
   * @schema ThingSpecInitProvider#thingTypeName
   */
  readonly thingTypeName?: string;

}

/**
 * Converts an object of type 'ThingSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingSpecInitProvider(obj: ThingSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'thingTypeName': obj.thingTypeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ThingSpecManagementPolicies
 */
export enum ThingSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ThingSpecProviderConfigRef
 */
export interface ThingSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThingSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThingSpecProviderConfigRef#policy
   */
  readonly policy?: ThingSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ThingSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingSpecProviderConfigRef(obj: ThingSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThingSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ThingSpecPublishConnectionDetailsTo
 */
export interface ThingSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ThingSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ThingSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ThingSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ThingSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ThingSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ThingSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingSpecPublishConnectionDetailsTo(obj: ThingSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ThingSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ThingSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ThingSpecWriteConnectionSecretToRef
 */
export interface ThingSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ThingSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ThingSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ThingSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingSpecWriteConnectionSecretToRef(obj: ThingSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ThingSpecProviderConfigRefPolicy
 */
export interface ThingSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThingSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ThingSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThingSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ThingSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ThingSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingSpecProviderConfigRefPolicy(obj: ThingSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ThingSpecPublishConnectionDetailsToConfigRef
 */
export interface ThingSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThingSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThingSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ThingSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ThingSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingSpecPublishConnectionDetailsToConfigRef(obj: ThingSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThingSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ThingSpecPublishConnectionDetailsToMetadata
 */
export interface ThingSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ThingSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ThingSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ThingSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ThingSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingSpecPublishConnectionDetailsToMetadata(obj: ThingSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThingSpecProviderConfigRefPolicyResolution
 */
export enum ThingSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThingSpecProviderConfigRefPolicyResolve
 */
export enum ThingSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ThingSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ThingSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThingSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ThingSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThingSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ThingSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ThingSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingSpecPublishConnectionDetailsToConfigRefPolicy(obj: ThingSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThingSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ThingSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThingSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ThingSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ThingGroup is the Schema for the ThingGroups API. Manages an AWS IoT Thing Group.
 *
 * @schema ThingGroup
 */
export class ThingGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ThingGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iot.aws.upbound.io/v1beta1',
    kind: 'ThingGroup',
  }

  /**
   * Renders a Kubernetes manifest for "ThingGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ThingGroupProps): any {
    return {
      ...ThingGroup.GVK,
      ...toJson_ThingGroupProps(props),
    };
  }

  /**
   * Defines a "ThingGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ThingGroupProps) {
    super(scope, id, {
      ...ThingGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ThingGroup.GVK,
      ...toJson_ThingGroupProps(resolved),
    };
  }
}

/**
 * ThingGroup is the Schema for the ThingGroups API. Manages an AWS IoT Thing Group.
 *
 * @schema ThingGroup
 */
export interface ThingGroupProps {
  /**
   * @schema ThingGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ThingGroupSpec defines the desired state of ThingGroup
   *
   * @schema ThingGroup#spec
   */
  readonly spec: ThingGroupSpec;

}

/**
 * Converts an object of type 'ThingGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupProps(obj: ThingGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ThingGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ThingGroupSpec defines the desired state of ThingGroup
 *
 * @schema ThingGroupSpec
 */
export interface ThingGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ThingGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: ThingGroupSpecDeletionPolicy;

  /**
   * @schema ThingGroupSpec#forProvider
   */
  readonly forProvider: ThingGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ThingGroupSpec#initProvider
   */
  readonly initProvider?: ThingGroupSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ThingGroupSpec#managementPolicies
   */
  readonly managementPolicies?: ThingGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ThingGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: ThingGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ThingGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ThingGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ThingGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ThingGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ThingGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpec(obj: ThingGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ThingGroupSpecForProvider(obj.forProvider),
    'initProvider': toJson_ThingGroupSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ThingGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ThingGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ThingGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ThingGroupSpecDeletionPolicy
 */
export enum ThingGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ThingGroupSpecForProvider
 */
export interface ThingGroupSpecForProvider {
  /**
   * The name of the parent Thing Group.
   *
   * @schema ThingGroupSpecForProvider#parentGroupName
   */
  readonly parentGroupName?: string;

  /**
   * Reference to a ThingGroup in iot to populate parentGroupName.
   *
   * @schema ThingGroupSpecForProvider#parentGroupNameRef
   */
  readonly parentGroupNameRef?: ThingGroupSpecForProviderParentGroupNameRef;

  /**
   * Selector for a ThingGroup in iot to populate parentGroupName.
   *
   * @schema ThingGroupSpecForProvider#parentGroupNameSelector
   */
  readonly parentGroupNameSelector?: ThingGroupSpecForProviderParentGroupNameSelector;

  /**
   * The Thing Group properties. Defined below.
   *
   * @schema ThingGroupSpecForProvider#properties
   */
  readonly properties?: ThingGroupSpecForProviderProperties[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ThingGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ThingGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThingGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpecForProvider(obj: ThingGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parentGroupName': obj.parentGroupName,
    'parentGroupNameRef': toJson_ThingGroupSpecForProviderParentGroupNameRef(obj.parentGroupNameRef),
    'parentGroupNameSelector': toJson_ThingGroupSpecForProviderParentGroupNameSelector(obj.parentGroupNameSelector),
    'properties': obj.properties?.map(y => toJson_ThingGroupSpecForProviderProperties(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ThingGroupSpecInitProvider
 */
export interface ThingGroupSpecInitProvider {
  /**
   * The Thing Group properties. Defined below.
   *
   * @schema ThingGroupSpecInitProvider#properties
   */
  readonly properties?: ThingGroupSpecInitProviderProperties[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ThingGroupSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThingGroupSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpecInitProvider(obj: ThingGroupSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'properties': obj.properties?.map(y => toJson_ThingGroupSpecInitProviderProperties(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ThingGroupSpecManagementPolicies
 */
export enum ThingGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ThingGroupSpecProviderConfigRef
 */
export interface ThingGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThingGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThingGroupSpecProviderConfigRef#policy
   */
  readonly policy?: ThingGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ThingGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpecProviderConfigRef(obj: ThingGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThingGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ThingGroupSpecPublishConnectionDetailsTo
 */
export interface ThingGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ThingGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ThingGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ThingGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ThingGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ThingGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ThingGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpecPublishConnectionDetailsTo(obj: ThingGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ThingGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ThingGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ThingGroupSpecWriteConnectionSecretToRef
 */
export interface ThingGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ThingGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ThingGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ThingGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpecWriteConnectionSecretToRef(obj: ThingGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ThingGroup in iot to populate parentGroupName.
 *
 * @schema ThingGroupSpecForProviderParentGroupNameRef
 */
export interface ThingGroupSpecForProviderParentGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThingGroupSpecForProviderParentGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThingGroupSpecForProviderParentGroupNameRef#policy
   */
  readonly policy?: ThingGroupSpecForProviderParentGroupNameRefPolicy;

}

/**
 * Converts an object of type 'ThingGroupSpecForProviderParentGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpecForProviderParentGroupNameRef(obj: ThingGroupSpecForProviderParentGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThingGroupSpecForProviderParentGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ThingGroup in iot to populate parentGroupName.
 *
 * @schema ThingGroupSpecForProviderParentGroupNameSelector
 */
export interface ThingGroupSpecForProviderParentGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ThingGroupSpecForProviderParentGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ThingGroupSpecForProviderParentGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ThingGroupSpecForProviderParentGroupNameSelector#policy
   */
  readonly policy?: ThingGroupSpecForProviderParentGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'ThingGroupSpecForProviderParentGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpecForProviderParentGroupNameSelector(obj: ThingGroupSpecForProviderParentGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ThingGroupSpecForProviderParentGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThingGroupSpecForProviderProperties
 */
export interface ThingGroupSpecForProviderProperties {
  /**
   * The Thing Group attributes. Defined below.
   *
   * @schema ThingGroupSpecForProviderProperties#attributePayload
   */
  readonly attributePayload?: ThingGroupSpecForProviderPropertiesAttributePayload[];

  /**
   * A description of the Thing Group.
   *
   * @schema ThingGroupSpecForProviderProperties#description
   */
  readonly description?: string;

}

/**
 * Converts an object of type 'ThingGroupSpecForProviderProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpecForProviderProperties(obj: ThingGroupSpecForProviderProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributePayload': obj.attributePayload?.map(y => toJson_ThingGroupSpecForProviderPropertiesAttributePayload(y)),
    'description': obj.description,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThingGroupSpecInitProviderProperties
 */
export interface ThingGroupSpecInitProviderProperties {
  /**
   * The Thing Group attributes. Defined below.
   *
   * @schema ThingGroupSpecInitProviderProperties#attributePayload
   */
  readonly attributePayload?: ThingGroupSpecInitProviderPropertiesAttributePayload[];

  /**
   * A description of the Thing Group.
   *
   * @schema ThingGroupSpecInitProviderProperties#description
   */
  readonly description?: string;

}

/**
 * Converts an object of type 'ThingGroupSpecInitProviderProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpecInitProviderProperties(obj: ThingGroupSpecInitProviderProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributePayload': obj.attributePayload?.map(y => toJson_ThingGroupSpecInitProviderPropertiesAttributePayload(y)),
    'description': obj.description,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ThingGroupSpecProviderConfigRefPolicy
 */
export interface ThingGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThingGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ThingGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThingGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ThingGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ThingGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpecProviderConfigRefPolicy(obj: ThingGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ThingGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface ThingGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThingGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThingGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ThingGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ThingGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpecPublishConnectionDetailsToConfigRef(obj: ThingGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThingGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ThingGroupSpecPublishConnectionDetailsToMetadata
 */
export interface ThingGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ThingGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ThingGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ThingGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ThingGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpecPublishConnectionDetailsToMetadata(obj: ThingGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ThingGroupSpecForProviderParentGroupNameRefPolicy
 */
export interface ThingGroupSpecForProviderParentGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThingGroupSpecForProviderParentGroupNameRefPolicy#resolution
   */
  readonly resolution?: ThingGroupSpecForProviderParentGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThingGroupSpecForProviderParentGroupNameRefPolicy#resolve
   */
  readonly resolve?: ThingGroupSpecForProviderParentGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ThingGroupSpecForProviderParentGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpecForProviderParentGroupNameRefPolicy(obj: ThingGroupSpecForProviderParentGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ThingGroupSpecForProviderParentGroupNameSelectorPolicy
 */
export interface ThingGroupSpecForProviderParentGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThingGroupSpecForProviderParentGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: ThingGroupSpecForProviderParentGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThingGroupSpecForProviderParentGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: ThingGroupSpecForProviderParentGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ThingGroupSpecForProviderParentGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpecForProviderParentGroupNameSelectorPolicy(obj: ThingGroupSpecForProviderParentGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThingGroupSpecForProviderPropertiesAttributePayload
 */
export interface ThingGroupSpecForProviderPropertiesAttributePayload {
  /**
   * Key-value map.
   *
   * @schema ThingGroupSpecForProviderPropertiesAttributePayload#attributes
   */
  readonly attributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThingGroupSpecForProviderPropertiesAttributePayload' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpecForProviderPropertiesAttributePayload(obj: ThingGroupSpecForProviderPropertiesAttributePayload | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThingGroupSpecInitProviderPropertiesAttributePayload
 */
export interface ThingGroupSpecInitProviderPropertiesAttributePayload {
  /**
   * Key-value map.
   *
   * @schema ThingGroupSpecInitProviderPropertiesAttributePayload#attributes
   */
  readonly attributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThingGroupSpecInitProviderPropertiesAttributePayload' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpecInitProviderPropertiesAttributePayload(obj: ThingGroupSpecInitProviderPropertiesAttributePayload | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThingGroupSpecProviderConfigRefPolicyResolution
 */
export enum ThingGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThingGroupSpecProviderConfigRefPolicyResolve
 */
export enum ThingGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ThingGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ThingGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThingGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ThingGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThingGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ThingGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ThingGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: ThingGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThingGroupSpecForProviderParentGroupNameRefPolicyResolution
 */
export enum ThingGroupSpecForProviderParentGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThingGroupSpecForProviderParentGroupNameRefPolicyResolve
 */
export enum ThingGroupSpecForProviderParentGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThingGroupSpecForProviderParentGroupNameSelectorPolicyResolution
 */
export enum ThingGroupSpecForProviderParentGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThingGroupSpecForProviderParentGroupNameSelectorPolicyResolve
 */
export enum ThingGroupSpecForProviderParentGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThingGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ThingGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThingGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ThingGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ThingGroupMembership is the Schema for the ThingGroupMemberships API. Adds an IoT Thing to an IoT Thing Group.
 *
 * @schema ThingGroupMembership
 */
export class ThingGroupMembership extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ThingGroupMembership"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iot.aws.upbound.io/v1beta1',
    kind: 'ThingGroupMembership',
  }

  /**
   * Renders a Kubernetes manifest for "ThingGroupMembership".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ThingGroupMembershipProps): any {
    return {
      ...ThingGroupMembership.GVK,
      ...toJson_ThingGroupMembershipProps(props),
    };
  }

  /**
   * Defines a "ThingGroupMembership" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ThingGroupMembershipProps) {
    super(scope, id, {
      ...ThingGroupMembership.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ThingGroupMembership.GVK,
      ...toJson_ThingGroupMembershipProps(resolved),
    };
  }
}

/**
 * ThingGroupMembership is the Schema for the ThingGroupMemberships API. Adds an IoT Thing to an IoT Thing Group.
 *
 * @schema ThingGroupMembership
 */
export interface ThingGroupMembershipProps {
  /**
   * @schema ThingGroupMembership#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ThingGroupMembershipSpec defines the desired state of ThingGroupMembership
   *
   * @schema ThingGroupMembership#spec
   */
  readonly spec: ThingGroupMembershipSpec;

}

/**
 * Converts an object of type 'ThingGroupMembershipProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupMembershipProps(obj: ThingGroupMembershipProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ThingGroupMembershipSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ThingGroupMembershipSpec defines the desired state of ThingGroupMembership
 *
 * @schema ThingGroupMembershipSpec
 */
export interface ThingGroupMembershipSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ThingGroupMembershipSpec#deletionPolicy
   */
  readonly deletionPolicy?: ThingGroupMembershipSpecDeletionPolicy;

  /**
   * @schema ThingGroupMembershipSpec#forProvider
   */
  readonly forProvider: ThingGroupMembershipSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ThingGroupMembershipSpec#initProvider
   */
  readonly initProvider?: ThingGroupMembershipSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ThingGroupMembershipSpec#managementPolicies
   */
  readonly managementPolicies?: ThingGroupMembershipSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ThingGroupMembershipSpec#providerConfigRef
   */
  readonly providerConfigRef?: ThingGroupMembershipSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ThingGroupMembershipSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ThingGroupMembershipSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ThingGroupMembershipSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ThingGroupMembershipSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ThingGroupMembershipSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupMembershipSpec(obj: ThingGroupMembershipSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ThingGroupMembershipSpecForProvider(obj.forProvider),
    'initProvider': toJson_ThingGroupMembershipSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ThingGroupMembershipSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ThingGroupMembershipSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ThingGroupMembershipSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ThingGroupMembershipSpecDeletionPolicy
 */
export enum ThingGroupMembershipSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ThingGroupMembershipSpecForProvider
 */
export interface ThingGroupMembershipSpecForProvider {
  /**
   * Override dynamic thing groups with static thing groups when 10-group limit is reached. If a thing belongs to 10 thing groups, and one or more of those groups are dynamic thing groups, adding a thing to a static group removes the thing from the last dynamic group.
   *
   * @schema ThingGroupMembershipSpecForProvider#overrideDynamicGroup
   */
  readonly overrideDynamicGroup?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ThingGroupMembershipSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name of the group to which you are adding a thing.
   *
   * @schema ThingGroupMembershipSpecForProvider#thingGroupName
   */
  readonly thingGroupName?: string;

  /**
   * The name of the thing to add to a group.
   *
   * @schema ThingGroupMembershipSpecForProvider#thingName
   */
  readonly thingName?: string;

}

/**
 * Converts an object of type 'ThingGroupMembershipSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupMembershipSpecForProvider(obj: ThingGroupMembershipSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'overrideDynamicGroup': obj.overrideDynamicGroup,
    'region': obj.region,
    'thingGroupName': obj.thingGroupName,
    'thingName': obj.thingName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ThingGroupMembershipSpecInitProvider
 */
export interface ThingGroupMembershipSpecInitProvider {
  /**
   * Override dynamic thing groups with static thing groups when 10-group limit is reached. If a thing belongs to 10 thing groups, and one or more of those groups are dynamic thing groups, adding a thing to a static group removes the thing from the last dynamic group.
   *
   * @schema ThingGroupMembershipSpecInitProvider#overrideDynamicGroup
   */
  readonly overrideDynamicGroup?: boolean;

  /**
   * The name of the group to which you are adding a thing.
   *
   * @schema ThingGroupMembershipSpecInitProvider#thingGroupName
   */
  readonly thingGroupName?: string;

  /**
   * The name of the thing to add to a group.
   *
   * @schema ThingGroupMembershipSpecInitProvider#thingName
   */
  readonly thingName?: string;

}

/**
 * Converts an object of type 'ThingGroupMembershipSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupMembershipSpecInitProvider(obj: ThingGroupMembershipSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'overrideDynamicGroup': obj.overrideDynamicGroup,
    'thingGroupName': obj.thingGroupName,
    'thingName': obj.thingName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ThingGroupMembershipSpecManagementPolicies
 */
export enum ThingGroupMembershipSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ThingGroupMembershipSpecProviderConfigRef
 */
export interface ThingGroupMembershipSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThingGroupMembershipSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThingGroupMembershipSpecProviderConfigRef#policy
   */
  readonly policy?: ThingGroupMembershipSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ThingGroupMembershipSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupMembershipSpecProviderConfigRef(obj: ThingGroupMembershipSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThingGroupMembershipSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ThingGroupMembershipSpecPublishConnectionDetailsTo
 */
export interface ThingGroupMembershipSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ThingGroupMembershipSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ThingGroupMembershipSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ThingGroupMembershipSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ThingGroupMembershipSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ThingGroupMembershipSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ThingGroupMembershipSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupMembershipSpecPublishConnectionDetailsTo(obj: ThingGroupMembershipSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ThingGroupMembershipSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ThingGroupMembershipSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ThingGroupMembershipSpecWriteConnectionSecretToRef
 */
export interface ThingGroupMembershipSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ThingGroupMembershipSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ThingGroupMembershipSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ThingGroupMembershipSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupMembershipSpecWriteConnectionSecretToRef(obj: ThingGroupMembershipSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ThingGroupMembershipSpecProviderConfigRefPolicy
 */
export interface ThingGroupMembershipSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThingGroupMembershipSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ThingGroupMembershipSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThingGroupMembershipSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ThingGroupMembershipSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ThingGroupMembershipSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupMembershipSpecProviderConfigRefPolicy(obj: ThingGroupMembershipSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ThingGroupMembershipSpecPublishConnectionDetailsToConfigRef
 */
export interface ThingGroupMembershipSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThingGroupMembershipSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThingGroupMembershipSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ThingGroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ThingGroupMembershipSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupMembershipSpecPublishConnectionDetailsToConfigRef(obj: ThingGroupMembershipSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThingGroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ThingGroupMembershipSpecPublishConnectionDetailsToMetadata
 */
export interface ThingGroupMembershipSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ThingGroupMembershipSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ThingGroupMembershipSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ThingGroupMembershipSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ThingGroupMembershipSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupMembershipSpecPublishConnectionDetailsToMetadata(obj: ThingGroupMembershipSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThingGroupMembershipSpecProviderConfigRefPolicyResolution
 */
export enum ThingGroupMembershipSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThingGroupMembershipSpecProviderConfigRefPolicyResolve
 */
export enum ThingGroupMembershipSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ThingGroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ThingGroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThingGroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ThingGroupMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThingGroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ThingGroupMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ThingGroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingGroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy(obj: ThingGroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThingGroupMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ThingGroupMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThingGroupMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ThingGroupMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ThingPrincipalAttachment is the Schema for the ThingPrincipalAttachments API. Provides AWS IoT Thing Principal attachment.
 *
 * @schema ThingPrincipalAttachment
 */
export class ThingPrincipalAttachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ThingPrincipalAttachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iot.aws.upbound.io/v1beta1',
    kind: 'ThingPrincipalAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "ThingPrincipalAttachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ThingPrincipalAttachmentProps): any {
    return {
      ...ThingPrincipalAttachment.GVK,
      ...toJson_ThingPrincipalAttachmentProps(props),
    };
  }

  /**
   * Defines a "ThingPrincipalAttachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ThingPrincipalAttachmentProps) {
    super(scope, id, {
      ...ThingPrincipalAttachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ThingPrincipalAttachment.GVK,
      ...toJson_ThingPrincipalAttachmentProps(resolved),
    };
  }
}

/**
 * ThingPrincipalAttachment is the Schema for the ThingPrincipalAttachments API. Provides AWS IoT Thing Principal attachment.
 *
 * @schema ThingPrincipalAttachment
 */
export interface ThingPrincipalAttachmentProps {
  /**
   * @schema ThingPrincipalAttachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ThingPrincipalAttachmentSpec defines the desired state of ThingPrincipalAttachment
   *
   * @schema ThingPrincipalAttachment#spec
   */
  readonly spec: ThingPrincipalAttachmentSpec;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentProps(obj: ThingPrincipalAttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ThingPrincipalAttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ThingPrincipalAttachmentSpec defines the desired state of ThingPrincipalAttachment
 *
 * @schema ThingPrincipalAttachmentSpec
 */
export interface ThingPrincipalAttachmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ThingPrincipalAttachmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: ThingPrincipalAttachmentSpecDeletionPolicy;

  /**
   * @schema ThingPrincipalAttachmentSpec#forProvider
   */
  readonly forProvider: ThingPrincipalAttachmentSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ThingPrincipalAttachmentSpec#initProvider
   */
  readonly initProvider?: any;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ThingPrincipalAttachmentSpec#managementPolicies
   */
  readonly managementPolicies?: ThingPrincipalAttachmentSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ThingPrincipalAttachmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: ThingPrincipalAttachmentSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ThingPrincipalAttachmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ThingPrincipalAttachmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ThingPrincipalAttachmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ThingPrincipalAttachmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentSpec(obj: ThingPrincipalAttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ThingPrincipalAttachmentSpecForProvider(obj.forProvider),
    'initProvider': obj.initProvider,
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ThingPrincipalAttachmentSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ThingPrincipalAttachmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ThingPrincipalAttachmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ThingPrincipalAttachmentSpecDeletionPolicy
 */
export enum ThingPrincipalAttachmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ThingPrincipalAttachmentSpecForProvider
 */
export interface ThingPrincipalAttachmentSpecForProvider {
  /**
   * The AWS IoT Certificate ARN or Amazon Cognito Identity ID.
   *
   * @schema ThingPrincipalAttachmentSpecForProvider#principal
   */
  readonly principal?: string;

  /**
   * Reference to a Certificate in iot to populate principal.
   *
   * @schema ThingPrincipalAttachmentSpecForProvider#principalRef
   */
  readonly principalRef?: ThingPrincipalAttachmentSpecForProviderPrincipalRef;

  /**
   * Selector for a Certificate in iot to populate principal.
   *
   * @schema ThingPrincipalAttachmentSpecForProvider#principalSelector
   */
  readonly principalSelector?: ThingPrincipalAttachmentSpecForProviderPrincipalSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ThingPrincipalAttachmentSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name of the thing.
   *
   * @schema ThingPrincipalAttachmentSpecForProvider#thing
   */
  readonly thing?: string;

  /**
   * Reference to a Thing in iot to populate thing.
   *
   * @schema ThingPrincipalAttachmentSpecForProvider#thingRef
   */
  readonly thingRef?: ThingPrincipalAttachmentSpecForProviderThingRef;

  /**
   * Selector for a Thing in iot to populate thing.
   *
   * @schema ThingPrincipalAttachmentSpecForProvider#thingSelector
   */
  readonly thingSelector?: ThingPrincipalAttachmentSpecForProviderThingSelector;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentSpecForProvider(obj: ThingPrincipalAttachmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'principal': obj.principal,
    'principalRef': toJson_ThingPrincipalAttachmentSpecForProviderPrincipalRef(obj.principalRef),
    'principalSelector': toJson_ThingPrincipalAttachmentSpecForProviderPrincipalSelector(obj.principalSelector),
    'region': obj.region,
    'thing': obj.thing,
    'thingRef': toJson_ThingPrincipalAttachmentSpecForProviderThingRef(obj.thingRef),
    'thingSelector': toJson_ThingPrincipalAttachmentSpecForProviderThingSelector(obj.thingSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ThingPrincipalAttachmentSpecManagementPolicies
 */
export enum ThingPrincipalAttachmentSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ThingPrincipalAttachmentSpecProviderConfigRef
 */
export interface ThingPrincipalAttachmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThingPrincipalAttachmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThingPrincipalAttachmentSpecProviderConfigRef#policy
   */
  readonly policy?: ThingPrincipalAttachmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentSpecProviderConfigRef(obj: ThingPrincipalAttachmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThingPrincipalAttachmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ThingPrincipalAttachmentSpecPublishConnectionDetailsTo
 */
export interface ThingPrincipalAttachmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ThingPrincipalAttachmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ThingPrincipalAttachmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ThingPrincipalAttachmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ThingPrincipalAttachmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentSpecPublishConnectionDetailsTo(obj: ThingPrincipalAttachmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ThingPrincipalAttachmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ThingPrincipalAttachmentSpecWriteConnectionSecretToRef
 */
export interface ThingPrincipalAttachmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ThingPrincipalAttachmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ThingPrincipalAttachmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentSpecWriteConnectionSecretToRef(obj: ThingPrincipalAttachmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Certificate in iot to populate principal.
 *
 * @schema ThingPrincipalAttachmentSpecForProviderPrincipalRef
 */
export interface ThingPrincipalAttachmentSpecForProviderPrincipalRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderPrincipalRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderPrincipalRef#policy
   */
  readonly policy?: ThingPrincipalAttachmentSpecForProviderPrincipalRefPolicy;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentSpecForProviderPrincipalRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentSpecForProviderPrincipalRef(obj: ThingPrincipalAttachmentSpecForProviderPrincipalRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThingPrincipalAttachmentSpecForProviderPrincipalRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Certificate in iot to populate principal.
 *
 * @schema ThingPrincipalAttachmentSpecForProviderPrincipalSelector
 */
export interface ThingPrincipalAttachmentSpecForProviderPrincipalSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderPrincipalSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderPrincipalSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderPrincipalSelector#policy
   */
  readonly policy?: ThingPrincipalAttachmentSpecForProviderPrincipalSelectorPolicy;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentSpecForProviderPrincipalSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentSpecForProviderPrincipalSelector(obj: ThingPrincipalAttachmentSpecForProviderPrincipalSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ThingPrincipalAttachmentSpecForProviderPrincipalSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Thing in iot to populate thing.
 *
 * @schema ThingPrincipalAttachmentSpecForProviderThingRef
 */
export interface ThingPrincipalAttachmentSpecForProviderThingRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderThingRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderThingRef#policy
   */
  readonly policy?: ThingPrincipalAttachmentSpecForProviderThingRefPolicy;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentSpecForProviderThingRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentSpecForProviderThingRef(obj: ThingPrincipalAttachmentSpecForProviderThingRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThingPrincipalAttachmentSpecForProviderThingRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Thing in iot to populate thing.
 *
 * @schema ThingPrincipalAttachmentSpecForProviderThingSelector
 */
export interface ThingPrincipalAttachmentSpecForProviderThingSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderThingSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderThingSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderThingSelector#policy
   */
  readonly policy?: ThingPrincipalAttachmentSpecForProviderThingSelectorPolicy;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentSpecForProviderThingSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentSpecForProviderThingSelector(obj: ThingPrincipalAttachmentSpecForProviderThingSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ThingPrincipalAttachmentSpecForProviderThingSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ThingPrincipalAttachmentSpecProviderConfigRefPolicy
 */
export interface ThingPrincipalAttachmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThingPrincipalAttachmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ThingPrincipalAttachmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThingPrincipalAttachmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ThingPrincipalAttachmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentSpecProviderConfigRefPolicy(obj: ThingPrincipalAttachmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRef
 */
export interface ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRef(obj: ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ThingPrincipalAttachmentSpecPublishConnectionDetailsToMetadata
 */
export interface ThingPrincipalAttachmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ThingPrincipalAttachmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ThingPrincipalAttachmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ThingPrincipalAttachmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentSpecPublishConnectionDetailsToMetadata(obj: ThingPrincipalAttachmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ThingPrincipalAttachmentSpecForProviderPrincipalRefPolicy
 */
export interface ThingPrincipalAttachmentSpecForProviderPrincipalRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderPrincipalRefPolicy#resolution
   */
  readonly resolution?: ThingPrincipalAttachmentSpecForProviderPrincipalRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderPrincipalRefPolicy#resolve
   */
  readonly resolve?: ThingPrincipalAttachmentSpecForProviderPrincipalRefPolicyResolve;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentSpecForProviderPrincipalRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentSpecForProviderPrincipalRefPolicy(obj: ThingPrincipalAttachmentSpecForProviderPrincipalRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ThingPrincipalAttachmentSpecForProviderPrincipalSelectorPolicy
 */
export interface ThingPrincipalAttachmentSpecForProviderPrincipalSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderPrincipalSelectorPolicy#resolution
   */
  readonly resolution?: ThingPrincipalAttachmentSpecForProviderPrincipalSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderPrincipalSelectorPolicy#resolve
   */
  readonly resolve?: ThingPrincipalAttachmentSpecForProviderPrincipalSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentSpecForProviderPrincipalSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentSpecForProviderPrincipalSelectorPolicy(obj: ThingPrincipalAttachmentSpecForProviderPrincipalSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ThingPrincipalAttachmentSpecForProviderThingRefPolicy
 */
export interface ThingPrincipalAttachmentSpecForProviderThingRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderThingRefPolicy#resolution
   */
  readonly resolution?: ThingPrincipalAttachmentSpecForProviderThingRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderThingRefPolicy#resolve
   */
  readonly resolve?: ThingPrincipalAttachmentSpecForProviderThingRefPolicyResolve;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentSpecForProviderThingRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentSpecForProviderThingRefPolicy(obj: ThingPrincipalAttachmentSpecForProviderThingRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ThingPrincipalAttachmentSpecForProviderThingSelectorPolicy
 */
export interface ThingPrincipalAttachmentSpecForProviderThingSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderThingSelectorPolicy#resolution
   */
  readonly resolution?: ThingPrincipalAttachmentSpecForProviderThingSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThingPrincipalAttachmentSpecForProviderThingSelectorPolicy#resolve
   */
  readonly resolve?: ThingPrincipalAttachmentSpecForProviderThingSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentSpecForProviderThingSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentSpecForProviderThingSelectorPolicy(obj: ThingPrincipalAttachmentSpecForProviderThingSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThingPrincipalAttachmentSpecProviderConfigRefPolicyResolution
 */
export enum ThingPrincipalAttachmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThingPrincipalAttachmentSpecProviderConfigRefPolicyResolve
 */
export enum ThingPrincipalAttachmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThingPrincipalAttachmentSpecForProviderPrincipalRefPolicyResolution
 */
export enum ThingPrincipalAttachmentSpecForProviderPrincipalRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThingPrincipalAttachmentSpecForProviderPrincipalRefPolicyResolve
 */
export enum ThingPrincipalAttachmentSpecForProviderPrincipalRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThingPrincipalAttachmentSpecForProviderPrincipalSelectorPolicyResolution
 */
export enum ThingPrincipalAttachmentSpecForProviderPrincipalSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThingPrincipalAttachmentSpecForProviderPrincipalSelectorPolicyResolve
 */
export enum ThingPrincipalAttachmentSpecForProviderPrincipalSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThingPrincipalAttachmentSpecForProviderThingRefPolicyResolution
 */
export enum ThingPrincipalAttachmentSpecForProviderThingRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThingPrincipalAttachmentSpecForProviderThingRefPolicyResolve
 */
export enum ThingPrincipalAttachmentSpecForProviderThingRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThingPrincipalAttachmentSpecForProviderThingSelectorPolicyResolution
 */
export enum ThingPrincipalAttachmentSpecForProviderThingSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThingPrincipalAttachmentSpecForProviderThingSelectorPolicyResolve
 */
export enum ThingPrincipalAttachmentSpecForProviderThingSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ThingPrincipalAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ThingType is the Schema for the ThingTypes API. Creates and manages an AWS IoT Thing Type.
 *
 * @schema ThingType
 */
export class ThingType extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ThingType"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iot.aws.upbound.io/v1beta1',
    kind: 'ThingType',
  }

  /**
   * Renders a Kubernetes manifest for "ThingType".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ThingTypeProps): any {
    return {
      ...ThingType.GVK,
      ...toJson_ThingTypeProps(props),
    };
  }

  /**
   * Defines a "ThingType" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ThingTypeProps) {
    super(scope, id, {
      ...ThingType.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ThingType.GVK,
      ...toJson_ThingTypeProps(resolved),
    };
  }
}

/**
 * ThingType is the Schema for the ThingTypes API. Creates and manages an AWS IoT Thing Type.
 *
 * @schema ThingType
 */
export interface ThingTypeProps {
  /**
   * @schema ThingType#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ThingTypeSpec defines the desired state of ThingType
   *
   * @schema ThingType#spec
   */
  readonly spec: ThingTypeSpec;

}

/**
 * Converts an object of type 'ThingTypeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingTypeProps(obj: ThingTypeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ThingTypeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ThingTypeSpec defines the desired state of ThingType
 *
 * @schema ThingTypeSpec
 */
export interface ThingTypeSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ThingTypeSpec#deletionPolicy
   */
  readonly deletionPolicy?: ThingTypeSpecDeletionPolicy;

  /**
   * @schema ThingTypeSpec#forProvider
   */
  readonly forProvider: ThingTypeSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ThingTypeSpec#initProvider
   */
  readonly initProvider?: ThingTypeSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ThingTypeSpec#managementPolicies
   */
  readonly managementPolicies?: ThingTypeSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ThingTypeSpec#providerConfigRef
   */
  readonly providerConfigRef?: ThingTypeSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ThingTypeSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ThingTypeSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ThingTypeSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ThingTypeSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ThingTypeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingTypeSpec(obj: ThingTypeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ThingTypeSpecForProvider(obj.forProvider),
    'initProvider': toJson_ThingTypeSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ThingTypeSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ThingTypeSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ThingTypeSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ThingTypeSpecDeletionPolicy
 */
export enum ThingTypeSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ThingTypeSpecForProvider
 */
export interface ThingTypeSpecForProvider {
  /**
   * Whether the thing type is deprecated. If true, no new things could be associated with this type.
   *
   * @schema ThingTypeSpecForProvider#deprecated
   */
  readonly deprecated?: boolean;

  /**
   * The name of the thing type.
   *
   * @schema ThingTypeSpecForProvider#name
   */
  readonly name?: string;

  /**
   * , Configuration block that can contain the following properties of the thing type:
   *
   * @schema ThingTypeSpecForProvider#properties
   */
  readonly properties?: ThingTypeSpecForProviderProperties[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ThingTypeSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ThingTypeSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThingTypeSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingTypeSpecForProvider(obj: ThingTypeSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deprecated': obj.deprecated,
    'name': obj.name,
    'properties': obj.properties?.map(y => toJson_ThingTypeSpecForProviderProperties(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ThingTypeSpecInitProvider
 */
export interface ThingTypeSpecInitProvider {
  /**
   * Whether the thing type is deprecated. If true, no new things could be associated with this type.
   *
   * @schema ThingTypeSpecInitProvider#deprecated
   */
  readonly deprecated?: boolean;

  /**
   * The name of the thing type.
   *
   * @schema ThingTypeSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * , Configuration block that can contain the following properties of the thing type:
   *
   * @schema ThingTypeSpecInitProvider#properties
   */
  readonly properties?: ThingTypeSpecInitProviderProperties[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ThingTypeSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThingTypeSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingTypeSpecInitProvider(obj: ThingTypeSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deprecated': obj.deprecated,
    'name': obj.name,
    'properties': obj.properties?.map(y => toJson_ThingTypeSpecInitProviderProperties(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ThingTypeSpecManagementPolicies
 */
export enum ThingTypeSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ThingTypeSpecProviderConfigRef
 */
export interface ThingTypeSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThingTypeSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThingTypeSpecProviderConfigRef#policy
   */
  readonly policy?: ThingTypeSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ThingTypeSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingTypeSpecProviderConfigRef(obj: ThingTypeSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThingTypeSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ThingTypeSpecPublishConnectionDetailsTo
 */
export interface ThingTypeSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ThingTypeSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ThingTypeSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ThingTypeSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ThingTypeSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ThingTypeSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ThingTypeSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingTypeSpecPublishConnectionDetailsTo(obj: ThingTypeSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ThingTypeSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ThingTypeSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ThingTypeSpecWriteConnectionSecretToRef
 */
export interface ThingTypeSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ThingTypeSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ThingTypeSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ThingTypeSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingTypeSpecWriteConnectionSecretToRef(obj: ThingTypeSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThingTypeSpecForProviderProperties
 */
export interface ThingTypeSpecForProviderProperties {
  /**
   * The description of the thing type.
   *
   * @schema ThingTypeSpecForProviderProperties#description
   */
  readonly description?: string;

  /**
   * A list of searchable thing attribute names.
   *
   * @schema ThingTypeSpecForProviderProperties#searchableAttributes
   */
  readonly searchableAttributes?: string[];

}

/**
 * Converts an object of type 'ThingTypeSpecForProviderProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingTypeSpecForProviderProperties(obj: ThingTypeSpecForProviderProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'searchableAttributes': obj.searchableAttributes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThingTypeSpecInitProviderProperties
 */
export interface ThingTypeSpecInitProviderProperties {
  /**
   * The description of the thing type.
   *
   * @schema ThingTypeSpecInitProviderProperties#description
   */
  readonly description?: string;

  /**
   * A list of searchable thing attribute names.
   *
   * @schema ThingTypeSpecInitProviderProperties#searchableAttributes
   */
  readonly searchableAttributes?: string[];

}

/**
 * Converts an object of type 'ThingTypeSpecInitProviderProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingTypeSpecInitProviderProperties(obj: ThingTypeSpecInitProviderProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'searchableAttributes': obj.searchableAttributes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ThingTypeSpecProviderConfigRefPolicy
 */
export interface ThingTypeSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThingTypeSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ThingTypeSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThingTypeSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ThingTypeSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ThingTypeSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingTypeSpecProviderConfigRefPolicy(obj: ThingTypeSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ThingTypeSpecPublishConnectionDetailsToConfigRef
 */
export interface ThingTypeSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThingTypeSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThingTypeSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ThingTypeSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ThingTypeSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingTypeSpecPublishConnectionDetailsToConfigRef(obj: ThingTypeSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThingTypeSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ThingTypeSpecPublishConnectionDetailsToMetadata
 */
export interface ThingTypeSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ThingTypeSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ThingTypeSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ThingTypeSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ThingTypeSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingTypeSpecPublishConnectionDetailsToMetadata(obj: ThingTypeSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThingTypeSpecProviderConfigRefPolicyResolution
 */
export enum ThingTypeSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThingTypeSpecProviderConfigRefPolicyResolve
 */
export enum ThingTypeSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ThingTypeSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ThingTypeSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThingTypeSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ThingTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThingTypeSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ThingTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ThingTypeSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThingTypeSpecPublishConnectionDetailsToConfigRefPolicy(obj: ThingTypeSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThingTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ThingTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThingTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ThingTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TopicRule is the Schema for the TopicRules API. Creates and manages an AWS IoT topic rule
 *
 * @schema TopicRule
 */
export class TopicRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TopicRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'iot.aws.upbound.io/v1beta1',
    kind: 'TopicRule',
  }

  /**
   * Renders a Kubernetes manifest for "TopicRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TopicRuleProps): any {
    return {
      ...TopicRule.GVK,
      ...toJson_TopicRuleProps(props),
    };
  }

  /**
   * Defines a "TopicRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TopicRuleProps) {
    super(scope, id, {
      ...TopicRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TopicRule.GVK,
      ...toJson_TopicRuleProps(resolved),
    };
  }
}

/**
 * TopicRule is the Schema for the TopicRules API. Creates and manages an AWS IoT topic rule
 *
 * @schema TopicRule
 */
export interface TopicRuleProps {
  /**
   * @schema TopicRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TopicRuleSpec defines the desired state of TopicRule
   *
   * @schema TopicRule#spec
   */
  readonly spec: TopicRuleSpec;

}

/**
 * Converts an object of type 'TopicRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleProps(obj: TopicRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TopicRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopicRuleSpec defines the desired state of TopicRule
 *
 * @schema TopicRuleSpec
 */
export interface TopicRuleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TopicRuleSpec#deletionPolicy
   */
  readonly deletionPolicy?: TopicRuleSpecDeletionPolicy;

  /**
   * @schema TopicRuleSpec#forProvider
   */
  readonly forProvider: TopicRuleSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema TopicRuleSpec#initProvider
   */
  readonly initProvider?: TopicRuleSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TopicRuleSpec#managementPolicies
   */
  readonly managementPolicies?: TopicRuleSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TopicRuleSpec#providerConfigRef
   */
  readonly providerConfigRef?: TopicRuleSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TopicRuleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TopicRuleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TopicRuleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TopicRuleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TopicRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpec(obj: TopicRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TopicRuleSpecForProvider(obj.forProvider),
    'initProvider': toJson_TopicRuleSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TopicRuleSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TopicRuleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TopicRuleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TopicRuleSpecDeletionPolicy
 */
export enum TopicRuleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TopicRuleSpecForProvider
 */
export interface TopicRuleSpecForProvider {
  /**
   * @schema TopicRuleSpecForProvider#cloudwatchAlarm
   */
  readonly cloudwatchAlarm?: TopicRuleSpecForProviderCloudwatchAlarm[];

  /**
   * @schema TopicRuleSpecForProvider#cloudwatchLogs
   */
  readonly cloudwatchLogs?: TopicRuleSpecForProviderCloudwatchLogs[];

  /**
   * @schema TopicRuleSpecForProvider#cloudwatchMetric
   */
  readonly cloudwatchMetric?: TopicRuleSpecForProviderCloudwatchMetric[];

  /**
   * The description of the rule.
   *
   * @schema TopicRuleSpecForProvider#description
   */
  readonly description?: string;

  /**
   * @schema TopicRuleSpecForProvider#dynamodb
   */
  readonly dynamodb?: TopicRuleSpecForProviderDynamodb[];

  /**
   * @schema TopicRuleSpecForProvider#dynamodbv2
   */
  readonly dynamodbv2?: TopicRuleSpecForProviderDynamodbv2[];

  /**
   * @schema TopicRuleSpecForProvider#elasticsearch
   */
  readonly elasticsearch?: TopicRuleSpecForProviderElasticsearch[];

  /**
   * Specifies whether the rule is enabled.
   *
   * @schema TopicRuleSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Configuration block with error action to be associated with the rule. See the documentation for cloudwatch_alarm, cloudwatch_logs, cloudwatch_metric, dynamodb, dynamodbv2, elasticsearch, firehose, http, iot_analytics, iot_events, kafka, kinesis, lambda, republish, s3, sns, sqs, step_functions, timestream configuration blocks for further configuration details.
   *
   * @schema TopicRuleSpecForProvider#errorAction
   */
  readonly errorAction?: TopicRuleSpecForProviderErrorAction[];

  /**
   * @schema TopicRuleSpecForProvider#firehose
   */
  readonly firehose?: TopicRuleSpecForProviderFirehose[];

  /**
   * @schema TopicRuleSpecForProvider#http
   */
  readonly http?: TopicRuleSpecForProviderHttp[];

  /**
   * @schema TopicRuleSpecForProvider#iotAnalytics
   */
  readonly iotAnalytics?: TopicRuleSpecForProviderIotAnalytics[];

  /**
   * @schema TopicRuleSpecForProvider#iotEvents
   */
  readonly iotEvents?: TopicRuleSpecForProviderIotEvents[];

  /**
   * @schema TopicRuleSpecForProvider#kafka
   */
  readonly kafka?: TopicRuleSpecForProviderKafka[];

  /**
   * @schema TopicRuleSpecForProvider#kinesis
   */
  readonly kinesis?: TopicRuleSpecForProviderKinesis[];

  /**
   * @schema TopicRuleSpecForProvider#lambda
   */
  readonly lambda?: TopicRuleSpecForProviderLambda[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TopicRuleSpecForProvider#region
   */
  readonly region: string;

  /**
   * @schema TopicRuleSpecForProvider#republish
   */
  readonly republish?: TopicRuleSpecForProviderRepublish[];

  /**
   * @schema TopicRuleSpecForProvider#s3
   */
  readonly s3?: TopicRuleSpecForProviderS3[];

  /**
   * @schema TopicRuleSpecForProvider#sns
   */
  readonly sns?: TopicRuleSpecForProviderSns[];

  /**
   * The SQL statement used to query the topic. For more information, see AWS IoT SQL Reference (http://docs.aws.amazon.com/iot/latest/developerguide/iot-rules.html#aws-iot-sql-reference) in the AWS IoT Developer Guide.
   *
   * @schema TopicRuleSpecForProvider#sql
   */
  readonly sql?: string;

  /**
   * The version of the SQL rules engine to use when evaluating the rule.
   *
   * @schema TopicRuleSpecForProvider#sqlVersion
   */
  readonly sqlVersion?: string;

  /**
   * @schema TopicRuleSpecForProvider#sqs
   */
  readonly sqs?: TopicRuleSpecForProviderSqs[];

  /**
   * @schema TopicRuleSpecForProvider#stepFunctions
   */
  readonly stepFunctions?: TopicRuleSpecForProviderStepFunctions[];

  /**
   * Key-value map of resource tags.
   *
   * @schema TopicRuleSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * @schema TopicRuleSpecForProvider#timestream
   */
  readonly timestream?: TopicRuleSpecForProviderTimestream[];

}

/**
 * Converts an object of type 'TopicRuleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProvider(obj: TopicRuleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchAlarm': obj.cloudwatchAlarm?.map(y => toJson_TopicRuleSpecForProviderCloudwatchAlarm(y)),
    'cloudwatchLogs': obj.cloudwatchLogs?.map(y => toJson_TopicRuleSpecForProviderCloudwatchLogs(y)),
    'cloudwatchMetric': obj.cloudwatchMetric?.map(y => toJson_TopicRuleSpecForProviderCloudwatchMetric(y)),
    'description': obj.description,
    'dynamodb': obj.dynamodb?.map(y => toJson_TopicRuleSpecForProviderDynamodb(y)),
    'dynamodbv2': obj.dynamodbv2?.map(y => toJson_TopicRuleSpecForProviderDynamodbv2(y)),
    'elasticsearch': obj.elasticsearch?.map(y => toJson_TopicRuleSpecForProviderElasticsearch(y)),
    'enabled': obj.enabled,
    'errorAction': obj.errorAction?.map(y => toJson_TopicRuleSpecForProviderErrorAction(y)),
    'firehose': obj.firehose?.map(y => toJson_TopicRuleSpecForProviderFirehose(y)),
    'http': obj.http?.map(y => toJson_TopicRuleSpecForProviderHttp(y)),
    'iotAnalytics': obj.iotAnalytics?.map(y => toJson_TopicRuleSpecForProviderIotAnalytics(y)),
    'iotEvents': obj.iotEvents?.map(y => toJson_TopicRuleSpecForProviderIotEvents(y)),
    'kafka': obj.kafka?.map(y => toJson_TopicRuleSpecForProviderKafka(y)),
    'kinesis': obj.kinesis?.map(y => toJson_TopicRuleSpecForProviderKinesis(y)),
    'lambda': obj.lambda?.map(y => toJson_TopicRuleSpecForProviderLambda(y)),
    'region': obj.region,
    'republish': obj.republish?.map(y => toJson_TopicRuleSpecForProviderRepublish(y)),
    's3': obj.s3?.map(y => toJson_TopicRuleSpecForProviderS3(y)),
    'sns': obj.sns?.map(y => toJson_TopicRuleSpecForProviderSns(y)),
    'sql': obj.sql,
    'sqlVersion': obj.sqlVersion,
    'sqs': obj.sqs?.map(y => toJson_TopicRuleSpecForProviderSqs(y)),
    'stepFunctions': obj.stepFunctions?.map(y => toJson_TopicRuleSpecForProviderStepFunctions(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'timestream': obj.timestream?.map(y => toJson_TopicRuleSpecForProviderTimestream(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema TopicRuleSpecInitProvider
 */
export interface TopicRuleSpecInitProvider {
  /**
   * @schema TopicRuleSpecInitProvider#cloudwatchAlarm
   */
  readonly cloudwatchAlarm?: TopicRuleSpecInitProviderCloudwatchAlarm[];

  /**
   * @schema TopicRuleSpecInitProvider#cloudwatchLogs
   */
  readonly cloudwatchLogs?: TopicRuleSpecInitProviderCloudwatchLogs[];

  /**
   * @schema TopicRuleSpecInitProvider#cloudwatchMetric
   */
  readonly cloudwatchMetric?: TopicRuleSpecInitProviderCloudwatchMetric[];

  /**
   * The description of the rule.
   *
   * @schema TopicRuleSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * @schema TopicRuleSpecInitProvider#dynamodb
   */
  readonly dynamodb?: TopicRuleSpecInitProviderDynamodb[];

  /**
   * @schema TopicRuleSpecInitProvider#dynamodbv2
   */
  readonly dynamodbv2?: TopicRuleSpecInitProviderDynamodbv2[];

  /**
   * @schema TopicRuleSpecInitProvider#elasticsearch
   */
  readonly elasticsearch?: TopicRuleSpecInitProviderElasticsearch[];

  /**
   * Specifies whether the rule is enabled.
   *
   * @schema TopicRuleSpecInitProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Configuration block with error action to be associated with the rule. See the documentation for cloudwatch_alarm, cloudwatch_logs, cloudwatch_metric, dynamodb, dynamodbv2, elasticsearch, firehose, http, iot_analytics, iot_events, kafka, kinesis, lambda, republish, s3, sns, sqs, step_functions, timestream configuration blocks for further configuration details.
   *
   * @schema TopicRuleSpecInitProvider#errorAction
   */
  readonly errorAction?: TopicRuleSpecInitProviderErrorAction[];

  /**
   * @schema TopicRuleSpecInitProvider#firehose
   */
  readonly firehose?: TopicRuleSpecInitProviderFirehose[];

  /**
   * @schema TopicRuleSpecInitProvider#http
   */
  readonly http?: TopicRuleSpecInitProviderHttp[];

  /**
   * @schema TopicRuleSpecInitProvider#iotAnalytics
   */
  readonly iotAnalytics?: TopicRuleSpecInitProviderIotAnalytics[];

  /**
   * @schema TopicRuleSpecInitProvider#iotEvents
   */
  readonly iotEvents?: TopicRuleSpecInitProviderIotEvents[];

  /**
   * @schema TopicRuleSpecInitProvider#kafka
   */
  readonly kafka?: TopicRuleSpecInitProviderKafka[];

  /**
   * @schema TopicRuleSpecInitProvider#kinesis
   */
  readonly kinesis?: TopicRuleSpecInitProviderKinesis[];

  /**
   * @schema TopicRuleSpecInitProvider#lambda
   */
  readonly lambda?: TopicRuleSpecInitProviderLambda[];

  /**
   * @schema TopicRuleSpecInitProvider#republish
   */
  readonly republish?: TopicRuleSpecInitProviderRepublish[];

  /**
   * @schema TopicRuleSpecInitProvider#s3
   */
  readonly s3?: TopicRuleSpecInitProviderS3[];

  /**
   * @schema TopicRuleSpecInitProvider#sns
   */
  readonly sns?: TopicRuleSpecInitProviderSns[];

  /**
   * The SQL statement used to query the topic. For more information, see AWS IoT SQL Reference (http://docs.aws.amazon.com/iot/latest/developerguide/iot-rules.html#aws-iot-sql-reference) in the AWS IoT Developer Guide.
   *
   * @schema TopicRuleSpecInitProvider#sql
   */
  readonly sql?: string;

  /**
   * The version of the SQL rules engine to use when evaluating the rule.
   *
   * @schema TopicRuleSpecInitProvider#sqlVersion
   */
  readonly sqlVersion?: string;

  /**
   * @schema TopicRuleSpecInitProvider#sqs
   */
  readonly sqs?: TopicRuleSpecInitProviderSqs[];

  /**
   * @schema TopicRuleSpecInitProvider#stepFunctions
   */
  readonly stepFunctions?: TopicRuleSpecInitProviderStepFunctions[];

  /**
   * Key-value map of resource tags.
   *
   * @schema TopicRuleSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * @schema TopicRuleSpecInitProvider#timestream
   */
  readonly timestream?: TopicRuleSpecInitProviderTimestream[];

}

/**
 * Converts an object of type 'TopicRuleSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProvider(obj: TopicRuleSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchAlarm': obj.cloudwatchAlarm?.map(y => toJson_TopicRuleSpecInitProviderCloudwatchAlarm(y)),
    'cloudwatchLogs': obj.cloudwatchLogs?.map(y => toJson_TopicRuleSpecInitProviderCloudwatchLogs(y)),
    'cloudwatchMetric': obj.cloudwatchMetric?.map(y => toJson_TopicRuleSpecInitProviderCloudwatchMetric(y)),
    'description': obj.description,
    'dynamodb': obj.dynamodb?.map(y => toJson_TopicRuleSpecInitProviderDynamodb(y)),
    'dynamodbv2': obj.dynamodbv2?.map(y => toJson_TopicRuleSpecInitProviderDynamodbv2(y)),
    'elasticsearch': obj.elasticsearch?.map(y => toJson_TopicRuleSpecInitProviderElasticsearch(y)),
    'enabled': obj.enabled,
    'errorAction': obj.errorAction?.map(y => toJson_TopicRuleSpecInitProviderErrorAction(y)),
    'firehose': obj.firehose?.map(y => toJson_TopicRuleSpecInitProviderFirehose(y)),
    'http': obj.http?.map(y => toJson_TopicRuleSpecInitProviderHttp(y)),
    'iotAnalytics': obj.iotAnalytics?.map(y => toJson_TopicRuleSpecInitProviderIotAnalytics(y)),
    'iotEvents': obj.iotEvents?.map(y => toJson_TopicRuleSpecInitProviderIotEvents(y)),
    'kafka': obj.kafka?.map(y => toJson_TopicRuleSpecInitProviderKafka(y)),
    'kinesis': obj.kinesis?.map(y => toJson_TopicRuleSpecInitProviderKinesis(y)),
    'lambda': obj.lambda?.map(y => toJson_TopicRuleSpecInitProviderLambda(y)),
    'republish': obj.republish?.map(y => toJson_TopicRuleSpecInitProviderRepublish(y)),
    's3': obj.s3?.map(y => toJson_TopicRuleSpecInitProviderS3(y)),
    'sns': obj.sns?.map(y => toJson_TopicRuleSpecInitProviderSns(y)),
    'sql': obj.sql,
    'sqlVersion': obj.sqlVersion,
    'sqs': obj.sqs?.map(y => toJson_TopicRuleSpecInitProviderSqs(y)),
    'stepFunctions': obj.stepFunctions?.map(y => toJson_TopicRuleSpecInitProviderStepFunctions(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'timestream': obj.timestream?.map(y => toJson_TopicRuleSpecInitProviderTimestream(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TopicRuleSpecManagementPolicies
 */
export enum TopicRuleSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TopicRuleSpecProviderConfigRef
 */
export interface TopicRuleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicRuleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicRuleSpecProviderConfigRef#policy
   */
  readonly policy?: TopicRuleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TopicRuleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecProviderConfigRef(obj: TopicRuleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicRuleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TopicRuleSpecPublishConnectionDetailsTo
 */
export interface TopicRuleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TopicRuleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TopicRuleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TopicRuleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TopicRuleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TopicRuleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TopicRuleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecPublishConnectionDetailsTo(obj: TopicRuleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TopicRuleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TopicRuleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TopicRuleSpecWriteConnectionSecretToRef
 */
export interface TopicRuleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TopicRuleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TopicRuleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TopicRuleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecWriteConnectionSecretToRef(obj: TopicRuleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderCloudwatchAlarm
 */
export interface TopicRuleSpecForProviderCloudwatchAlarm {
  /**
   * The CloudWatch alarm name.
   *
   * @schema TopicRuleSpecForProviderCloudwatchAlarm#alarmName
   */
  readonly alarmName?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderCloudwatchAlarm#roleArn
   */
  readonly roleArn?: string;

  /**
   * The reason for the alarm change.
   *
   * @schema TopicRuleSpecForProviderCloudwatchAlarm#stateReason
   */
  readonly stateReason?: string;

  /**
   * The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
   *
   * @schema TopicRuleSpecForProviderCloudwatchAlarm#stateValue
   */
  readonly stateValue?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderCloudwatchAlarm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderCloudwatchAlarm(obj: TopicRuleSpecForProviderCloudwatchAlarm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarmName': obj.alarmName,
    'roleArn': obj.roleArn,
    'stateReason': obj.stateReason,
    'stateValue': obj.stateValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderCloudwatchLogs
 */
export interface TopicRuleSpecForProviderCloudwatchLogs {
  /**
   * The CloudWatch log group name.
   *
   * @schema TopicRuleSpecForProviderCloudwatchLogs#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderCloudwatchLogs#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderCloudwatchLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderCloudwatchLogs(obj: TopicRuleSpecForProviderCloudwatchLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logGroupName': obj.logGroupName,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderCloudwatchMetric
 */
export interface TopicRuleSpecForProviderCloudwatchMetric {
  /**
   * The CloudWatch metric name.
   *
   * @schema TopicRuleSpecForProviderCloudwatchMetric#metricName
   */
  readonly metricName?: string;

  /**
   * The CloudWatch metric namespace name.
   *
   * @schema TopicRuleSpecForProviderCloudwatchMetric#metricNamespace
   */
  readonly metricNamespace?: string;

  /**
   * An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
   *
   * @schema TopicRuleSpecForProviderCloudwatchMetric#metricTimestamp
   */
  readonly metricTimestamp?: string;

  /**
   * The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
   *
   * @schema TopicRuleSpecForProviderCloudwatchMetric#metricUnit
   */
  readonly metricUnit?: string;

  /**
   * The CloudWatch metric value.
   *
   * @schema TopicRuleSpecForProviderCloudwatchMetric#metricValue
   */
  readonly metricValue?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderCloudwatchMetric#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderCloudwatchMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderCloudwatchMetric(obj: TopicRuleSpecForProviderCloudwatchMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricName': obj.metricName,
    'metricNamespace': obj.metricNamespace,
    'metricTimestamp': obj.metricTimestamp,
    'metricUnit': obj.metricUnit,
    'metricValue': obj.metricValue,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderDynamodb
 */
export interface TopicRuleSpecForProviderDynamodb {
  /**
   * The hash key name.
   *
   * @schema TopicRuleSpecForProviderDynamodb#hashKeyField
   */
  readonly hashKeyField?: string;

  /**
   * The hash key type. Valid values are "STRING" or "NUMBER".
   *
   * @schema TopicRuleSpecForProviderDynamodb#hashKeyType
   */
  readonly hashKeyType?: string;

  /**
   * The hash key value.
   *
   * @schema TopicRuleSpecForProviderDynamodb#hashKeyValue
   */
  readonly hashKeyValue?: string;

  /**
   * The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
   *
   * @schema TopicRuleSpecForProviderDynamodb#operation
   */
  readonly operation?: string;

  /**
   * The action payload.
   *
   * @schema TopicRuleSpecForProviderDynamodb#payloadField
   */
  readonly payloadField?: string;

  /**
   * The range key name.
   *
   * @schema TopicRuleSpecForProviderDynamodb#rangeKeyField
   */
  readonly rangeKeyField?: string;

  /**
   * The range key type. Valid values are "STRING" or "NUMBER".
   *
   * @schema TopicRuleSpecForProviderDynamodb#rangeKeyType
   */
  readonly rangeKeyType?: string;

  /**
   * The range key value.
   *
   * @schema TopicRuleSpecForProviderDynamodb#rangeKeyValue
   */
  readonly rangeKeyValue?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderDynamodb#roleArn
   */
  readonly roleArn?: string;

  /**
   * The name of the DynamoDB table.
   *
   * @schema TopicRuleSpecForProviderDynamodb#tableName
   */
  readonly tableName?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderDynamodb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderDynamodb(obj: TopicRuleSpecForProviderDynamodb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hashKeyField': obj.hashKeyField,
    'hashKeyType': obj.hashKeyType,
    'hashKeyValue': obj.hashKeyValue,
    'operation': obj.operation,
    'payloadField': obj.payloadField,
    'rangeKeyField': obj.rangeKeyField,
    'rangeKeyType': obj.rangeKeyType,
    'rangeKeyValue': obj.rangeKeyValue,
    'roleArn': obj.roleArn,
    'tableName': obj.tableName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderDynamodbv2
 */
export interface TopicRuleSpecForProviderDynamodbv2 {
  /**
   * Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
   *
   * @schema TopicRuleSpecForProviderDynamodbv2#putItem
   */
  readonly putItem?: TopicRuleSpecForProviderDynamodbv2PutItem[];

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderDynamodbv2#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderDynamodbv2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderDynamodbv2(obj: TopicRuleSpecForProviderDynamodbv2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'putItem': obj.putItem?.map(y => toJson_TopicRuleSpecForProviderDynamodbv2PutItem(y)),
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderElasticsearch
 */
export interface TopicRuleSpecForProviderElasticsearch {
  /**
   * The endpoint of your Elasticsearch domain.
   *
   * @schema TopicRuleSpecForProviderElasticsearch#endpoint
   */
  readonly endpoint?: string;

  /**
   * The unique identifier for the document you are storing.
   *
   * @schema TopicRuleSpecForProviderElasticsearch#id
   */
  readonly id?: string;

  /**
   * The Elasticsearch index where you want to store your data.
   *
   * @schema TopicRuleSpecForProviderElasticsearch#index
   */
  readonly index?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderElasticsearch#roleArn
   */
  readonly roleArn?: string;

  /**
   * The type of document you are storing.
   *
   * @schema TopicRuleSpecForProviderElasticsearch#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderElasticsearch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderElasticsearch(obj: TopicRuleSpecForProviderElasticsearch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoint': obj.endpoint,
    'id': obj.id,
    'index': obj.index,
    'roleArn': obj.roleArn,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorAction
 */
export interface TopicRuleSpecForProviderErrorAction {
  /**
   * @schema TopicRuleSpecForProviderErrorAction#cloudwatchAlarm
   */
  readonly cloudwatchAlarm?: TopicRuleSpecForProviderErrorActionCloudwatchAlarm[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#cloudwatchLogs
   */
  readonly cloudwatchLogs?: TopicRuleSpecForProviderErrorActionCloudwatchLogs[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#cloudwatchMetric
   */
  readonly cloudwatchMetric?: TopicRuleSpecForProviderErrorActionCloudwatchMetric[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#dynamodb
   */
  readonly dynamodb?: TopicRuleSpecForProviderErrorActionDynamodb[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#dynamodbv2
   */
  readonly dynamodbv2?: TopicRuleSpecForProviderErrorActionDynamodbv2[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#elasticsearch
   */
  readonly elasticsearch?: TopicRuleSpecForProviderErrorActionElasticsearch[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#firehose
   */
  readonly firehose?: TopicRuleSpecForProviderErrorActionFirehose[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#http
   */
  readonly http?: TopicRuleSpecForProviderErrorActionHttp[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#iotAnalytics
   */
  readonly iotAnalytics?: TopicRuleSpecForProviderErrorActionIotAnalytics[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#iotEvents
   */
  readonly iotEvents?: TopicRuleSpecForProviderErrorActionIotEvents[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#kafka
   */
  readonly kafka?: TopicRuleSpecForProviderErrorActionKafka[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#kinesis
   */
  readonly kinesis?: TopicRuleSpecForProviderErrorActionKinesis[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#lambda
   */
  readonly lambda?: TopicRuleSpecForProviderErrorActionLambda[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#republish
   */
  readonly republish?: TopicRuleSpecForProviderErrorActionRepublish[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#s3
   */
  readonly s3?: TopicRuleSpecForProviderErrorActionS3[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#sns
   */
  readonly sns?: TopicRuleSpecForProviderErrorActionSns[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#sqs
   */
  readonly sqs?: TopicRuleSpecForProviderErrorActionSqs[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#stepFunctions
   */
  readonly stepFunctions?: TopicRuleSpecForProviderErrorActionStepFunctions[];

  /**
   * @schema TopicRuleSpecForProviderErrorAction#timestream
   */
  readonly timestream?: TopicRuleSpecForProviderErrorActionTimestream[];

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorAction(obj: TopicRuleSpecForProviderErrorAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchAlarm': obj.cloudwatchAlarm?.map(y => toJson_TopicRuleSpecForProviderErrorActionCloudwatchAlarm(y)),
    'cloudwatchLogs': obj.cloudwatchLogs?.map(y => toJson_TopicRuleSpecForProviderErrorActionCloudwatchLogs(y)),
    'cloudwatchMetric': obj.cloudwatchMetric?.map(y => toJson_TopicRuleSpecForProviderErrorActionCloudwatchMetric(y)),
    'dynamodb': obj.dynamodb?.map(y => toJson_TopicRuleSpecForProviderErrorActionDynamodb(y)),
    'dynamodbv2': obj.dynamodbv2?.map(y => toJson_TopicRuleSpecForProviderErrorActionDynamodbv2(y)),
    'elasticsearch': obj.elasticsearch?.map(y => toJson_TopicRuleSpecForProviderErrorActionElasticsearch(y)),
    'firehose': obj.firehose?.map(y => toJson_TopicRuleSpecForProviderErrorActionFirehose(y)),
    'http': obj.http?.map(y => toJson_TopicRuleSpecForProviderErrorActionHttp(y)),
    'iotAnalytics': obj.iotAnalytics?.map(y => toJson_TopicRuleSpecForProviderErrorActionIotAnalytics(y)),
    'iotEvents': obj.iotEvents?.map(y => toJson_TopicRuleSpecForProviderErrorActionIotEvents(y)),
    'kafka': obj.kafka?.map(y => toJson_TopicRuleSpecForProviderErrorActionKafka(y)),
    'kinesis': obj.kinesis?.map(y => toJson_TopicRuleSpecForProviderErrorActionKinesis(y)),
    'lambda': obj.lambda?.map(y => toJson_TopicRuleSpecForProviderErrorActionLambda(y)),
    'republish': obj.republish?.map(y => toJson_TopicRuleSpecForProviderErrorActionRepublish(y)),
    's3': obj.s3?.map(y => toJson_TopicRuleSpecForProviderErrorActionS3(y)),
    'sns': obj.sns?.map(y => toJson_TopicRuleSpecForProviderErrorActionSns(y)),
    'sqs': obj.sqs?.map(y => toJson_TopicRuleSpecForProviderErrorActionSqs(y)),
    'stepFunctions': obj.stepFunctions?.map(y => toJson_TopicRuleSpecForProviderErrorActionStepFunctions(y)),
    'timestream': obj.timestream?.map(y => toJson_TopicRuleSpecForProviderErrorActionTimestream(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderFirehose
 */
export interface TopicRuleSpecForProviderFirehose {
  /**
   * The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
   *
   * @schema TopicRuleSpecForProviderFirehose#batchMode
   */
  readonly batchMode?: boolean;

  /**
   * The delivery stream name.
   *
   * @schema TopicRuleSpecForProviderFirehose#deliveryStreamName
   */
  readonly deliveryStreamName?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderFirehose#roleArn
   */
  readonly roleArn?: string;

  /**
   * A character separator that is used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
   *
   * @schema TopicRuleSpecForProviderFirehose#separator
   */
  readonly separator?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderFirehose' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderFirehose(obj: TopicRuleSpecForProviderFirehose | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchMode': obj.batchMode,
    'deliveryStreamName': obj.deliveryStreamName,
    'roleArn': obj.roleArn,
    'separator': obj.separator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderHttp
 */
export interface TopicRuleSpecForProviderHttp {
  /**
   * The HTTPS URL used to verify ownership of url.
   *
   * @schema TopicRuleSpecForProviderHttp#confirmationUrl
   */
  readonly confirmationUrl?: string;

  /**
   * Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
   *
   * @schema TopicRuleSpecForProviderHttp#httpHeader
   */
  readonly httpHeader?: TopicRuleSpecForProviderHttpHttpHeader[];

  /**
   * The HTTPS URL.
   *
   * @schema TopicRuleSpecForProviderHttp#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderHttp(obj: TopicRuleSpecForProviderHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confirmationUrl': obj.confirmationUrl,
    'httpHeader': obj.httpHeader?.map(y => toJson_TopicRuleSpecForProviderHttpHttpHeader(y)),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderIotAnalytics
 */
export interface TopicRuleSpecForProviderIotAnalytics {
  /**
   * The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
   *
   * @schema TopicRuleSpecForProviderIotAnalytics#batchMode
   */
  readonly batchMode?: boolean;

  /**
   * Name of AWS IOT Analytics channel.
   *
   * @schema TopicRuleSpecForProviderIotAnalytics#channelName
   */
  readonly channelName?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderIotAnalytics#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderIotAnalytics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderIotAnalytics(obj: TopicRuleSpecForProviderIotAnalytics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchMode': obj.batchMode,
    'channelName': obj.channelName,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderIotEvents
 */
export interface TopicRuleSpecForProviderIotEvents {
  /**
   * The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
   *
   * @schema TopicRuleSpecForProviderIotEvents#batchMode
   */
  readonly batchMode?: boolean;

  /**
   * The name of the AWS IoT Events input.
   *
   * @schema TopicRuleSpecForProviderIotEvents#inputName
   */
  readonly inputName?: string;

  /**
   * Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
   *
   * @schema TopicRuleSpecForProviderIotEvents#messageId
   */
  readonly messageId?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderIotEvents#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderIotEvents' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderIotEvents(obj: TopicRuleSpecForProviderIotEvents | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchMode': obj.batchMode,
    'inputName': obj.inputName,
    'messageId': obj.messageId,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderKafka
 */
export interface TopicRuleSpecForProviderKafka {
  /**
   * Properties of the Apache Kafka producer client. For more info, see the AWS documentation.
   *
   * @schema TopicRuleSpecForProviderKafka#clientProperties
   */
  readonly clientProperties?: { [key: string]: string };

  /**
   * The ARN of Kafka action's VPC aws_iot_topic_rule_destination .
   *
   * @schema TopicRuleSpecForProviderKafka#destinationArn
   */
  readonly destinationArn?: string;

  /**
   * The name of the HTTP header.
   *
   * @schema TopicRuleSpecForProviderKafka#key
   */
  readonly key?: string;

  /**
   * The Kafka message partition.
   *
   * @schema TopicRuleSpecForProviderKafka#partition
   */
  readonly partition?: string;

  /**
   * The Kafka topic for messages to be sent to the Kafka broker.
   *
   * @schema TopicRuleSpecForProviderKafka#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderKafka' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderKafka(obj: TopicRuleSpecForProviderKafka | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientProperties': ((obj.clientProperties) === undefined) ? undefined : (Object.entries(obj.clientProperties).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'destinationArn': obj.destinationArn,
    'key': obj.key,
    'partition': obj.partition,
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderKinesis
 */
export interface TopicRuleSpecForProviderKinesis {
  /**
   * The partition key.
   *
   * @schema TopicRuleSpecForProviderKinesis#partitionKey
   */
  readonly partitionKey?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderKinesis#roleArn
   */
  readonly roleArn?: string;

  /**
   * The name of the Amazon Kinesis stream.
   *
   * @schema TopicRuleSpecForProviderKinesis#streamName
   */
  readonly streamName?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderKinesis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderKinesis(obj: TopicRuleSpecForProviderKinesis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partitionKey': obj.partitionKey,
    'roleArn': obj.roleArn,
    'streamName': obj.streamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderLambda
 */
export interface TopicRuleSpecForProviderLambda {
  /**
   * The ARN of the Lambda function.
   *
   * @schema TopicRuleSpecForProviderLambda#functionArn
   */
  readonly functionArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderLambda' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderLambda(obj: TopicRuleSpecForProviderLambda | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'functionArn': obj.functionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderRepublish
 */
export interface TopicRuleSpecForProviderRepublish {
  /**
   * The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.
   *
   * @schema TopicRuleSpecForProviderRepublish#qos
   */
  readonly qos?: number;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderRepublish#roleArn
   */
  readonly roleArn?: string;

  /**
   * The Kafka topic for messages to be sent to the Kafka broker.
   *
   * @schema TopicRuleSpecForProviderRepublish#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderRepublish' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderRepublish(obj: TopicRuleSpecForProviderRepublish | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'qos': obj.qos,
    'roleArn': obj.roleArn,
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderS3
 */
export interface TopicRuleSpecForProviderS3 {
  /**
   * The Amazon S3 bucket name.
   *
   * @schema TopicRuleSpecForProviderS3#bucketName
   */
  readonly bucketName?: string;

  /**
   * The Amazon S3 canned ACL that controls access to the object identified by the object key. Valid values.
   *
   * @schema TopicRuleSpecForProviderS3#cannedAcl
   */
  readonly cannedAcl?: string;

  /**
   * The name of the HTTP header.
   *
   * @schema TopicRuleSpecForProviderS3#key
   */
  readonly key?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderS3#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderS3(obj: TopicRuleSpecForProviderS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'cannedAcl': obj.cannedAcl,
    'key': obj.key,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderSns
 */
export interface TopicRuleSpecForProviderSns {
  /**
   * The message format of the message to publish. Accepted values are "JSON" and "RAW".
   *
   * @schema TopicRuleSpecForProviderSns#messageFormat
   */
  readonly messageFormat?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderSns#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema TopicRuleSpecForProviderSns#roleArnRef
   */
  readonly roleArnRef?: TopicRuleSpecForProviderSnsRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema TopicRuleSpecForProviderSns#roleArnSelector
   */
  readonly roleArnSelector?: TopicRuleSpecForProviderSnsRoleArnSelector;

  /**
   * The ARN of the SNS topic.
   *
   * @schema TopicRuleSpecForProviderSns#targetArn
   */
  readonly targetArn?: string;

  /**
   * Reference to a Topic in sns to populate targetArn.
   *
   * @schema TopicRuleSpecForProviderSns#targetArnRef
   */
  readonly targetArnRef?: TopicRuleSpecForProviderSnsTargetArnRef;

  /**
   * Selector for a Topic in sns to populate targetArn.
   *
   * @schema TopicRuleSpecForProviderSns#targetArnSelector
   */
  readonly targetArnSelector?: TopicRuleSpecForProviderSnsTargetArnSelector;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderSns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderSns(obj: TopicRuleSpecForProviderSns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'messageFormat': obj.messageFormat,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_TopicRuleSpecForProviderSnsRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_TopicRuleSpecForProviderSnsRoleArnSelector(obj.roleArnSelector),
    'targetArn': obj.targetArn,
    'targetArnRef': toJson_TopicRuleSpecForProviderSnsTargetArnRef(obj.targetArnRef),
    'targetArnSelector': toJson_TopicRuleSpecForProviderSnsTargetArnSelector(obj.targetArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderSqs
 */
export interface TopicRuleSpecForProviderSqs {
  /**
   * The URL of the Amazon SQS queue.
   *
   * @schema TopicRuleSpecForProviderSqs#queueUrl
   */
  readonly queueUrl?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderSqs#roleArn
   */
  readonly roleArn?: string;

  /**
   * Specifies whether to use Base64 encoding.
   *
   * @schema TopicRuleSpecForProviderSqs#useBase64
   */
  readonly useBase64?: boolean;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderSqs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderSqs(obj: TopicRuleSpecForProviderSqs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'queueUrl': obj.queueUrl,
    'roleArn': obj.roleArn,
    'useBase64': obj.useBase64,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderStepFunctions
 */
export interface TopicRuleSpecForProviderStepFunctions {
  /**
   * The prefix used to generate, along with a UUID, the unique state machine execution name.
   *
   * @schema TopicRuleSpecForProviderStepFunctions#executionNamePrefix
   */
  readonly executionNamePrefix?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderStepFunctions#roleArn
   */
  readonly roleArn?: string;

  /**
   * The name of the Step Functions state machine whose execution will be started.
   *
   * @schema TopicRuleSpecForProviderStepFunctions#stateMachineName
   */
  readonly stateMachineName?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderStepFunctions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderStepFunctions(obj: TopicRuleSpecForProviderStepFunctions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executionNamePrefix': obj.executionNamePrefix,
    'roleArn': obj.roleArn,
    'stateMachineName': obj.stateMachineName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderTimestream
 */
export interface TopicRuleSpecForProviderTimestream {
  /**
   * The name of an Amazon Timestream database.
   *
   * @schema TopicRuleSpecForProviderTimestream#databaseName
   */
  readonly databaseName?: string;

  /**
   * Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
   *
   * @schema TopicRuleSpecForProviderTimestream#dimension
   */
  readonly dimension?: TopicRuleSpecForProviderTimestreamDimension[];

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderTimestream#roleArn
   */
  readonly roleArn?: string;

  /**
   * The name of the DynamoDB table.
   *
   * @schema TopicRuleSpecForProviderTimestream#tableName
   */
  readonly tableName?: string;

  /**
   * Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
   *
   * @schema TopicRuleSpecForProviderTimestream#timestamp
   */
  readonly timestamp?: TopicRuleSpecForProviderTimestreamTimestamp[];

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderTimestream' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderTimestream(obj: TopicRuleSpecForProviderTimestream | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'databaseName': obj.databaseName,
    'dimension': obj.dimension?.map(y => toJson_TopicRuleSpecForProviderTimestreamDimension(y)),
    'roleArn': obj.roleArn,
    'tableName': obj.tableName,
    'timestamp': obj.timestamp?.map(y => toJson_TopicRuleSpecForProviderTimestreamTimestamp(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderCloudwatchAlarm
 */
export interface TopicRuleSpecInitProviderCloudwatchAlarm {
  /**
   * The CloudWatch alarm name.
   *
   * @schema TopicRuleSpecInitProviderCloudwatchAlarm#alarmName
   */
  readonly alarmName?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderCloudwatchAlarm#roleArn
   */
  readonly roleArn?: string;

  /**
   * The reason for the alarm change.
   *
   * @schema TopicRuleSpecInitProviderCloudwatchAlarm#stateReason
   */
  readonly stateReason?: string;

  /**
   * The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
   *
   * @schema TopicRuleSpecInitProviderCloudwatchAlarm#stateValue
   */
  readonly stateValue?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderCloudwatchAlarm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderCloudwatchAlarm(obj: TopicRuleSpecInitProviderCloudwatchAlarm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarmName': obj.alarmName,
    'roleArn': obj.roleArn,
    'stateReason': obj.stateReason,
    'stateValue': obj.stateValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderCloudwatchLogs
 */
export interface TopicRuleSpecInitProviderCloudwatchLogs {
  /**
   * The CloudWatch log group name.
   *
   * @schema TopicRuleSpecInitProviderCloudwatchLogs#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderCloudwatchLogs#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderCloudwatchLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderCloudwatchLogs(obj: TopicRuleSpecInitProviderCloudwatchLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logGroupName': obj.logGroupName,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderCloudwatchMetric
 */
export interface TopicRuleSpecInitProviderCloudwatchMetric {
  /**
   * The CloudWatch metric name.
   *
   * @schema TopicRuleSpecInitProviderCloudwatchMetric#metricName
   */
  readonly metricName?: string;

  /**
   * The CloudWatch metric namespace name.
   *
   * @schema TopicRuleSpecInitProviderCloudwatchMetric#metricNamespace
   */
  readonly metricNamespace?: string;

  /**
   * An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
   *
   * @schema TopicRuleSpecInitProviderCloudwatchMetric#metricTimestamp
   */
  readonly metricTimestamp?: string;

  /**
   * The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
   *
   * @schema TopicRuleSpecInitProviderCloudwatchMetric#metricUnit
   */
  readonly metricUnit?: string;

  /**
   * The CloudWatch metric value.
   *
   * @schema TopicRuleSpecInitProviderCloudwatchMetric#metricValue
   */
  readonly metricValue?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderCloudwatchMetric#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderCloudwatchMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderCloudwatchMetric(obj: TopicRuleSpecInitProviderCloudwatchMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricName': obj.metricName,
    'metricNamespace': obj.metricNamespace,
    'metricTimestamp': obj.metricTimestamp,
    'metricUnit': obj.metricUnit,
    'metricValue': obj.metricValue,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderDynamodb
 */
export interface TopicRuleSpecInitProviderDynamodb {
  /**
   * The hash key name.
   *
   * @schema TopicRuleSpecInitProviderDynamodb#hashKeyField
   */
  readonly hashKeyField?: string;

  /**
   * The hash key type. Valid values are "STRING" or "NUMBER".
   *
   * @schema TopicRuleSpecInitProviderDynamodb#hashKeyType
   */
  readonly hashKeyType?: string;

  /**
   * The hash key value.
   *
   * @schema TopicRuleSpecInitProviderDynamodb#hashKeyValue
   */
  readonly hashKeyValue?: string;

  /**
   * The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
   *
   * @schema TopicRuleSpecInitProviderDynamodb#operation
   */
  readonly operation?: string;

  /**
   * The action payload.
   *
   * @schema TopicRuleSpecInitProviderDynamodb#payloadField
   */
  readonly payloadField?: string;

  /**
   * The range key name.
   *
   * @schema TopicRuleSpecInitProviderDynamodb#rangeKeyField
   */
  readonly rangeKeyField?: string;

  /**
   * The range key type. Valid values are "STRING" or "NUMBER".
   *
   * @schema TopicRuleSpecInitProviderDynamodb#rangeKeyType
   */
  readonly rangeKeyType?: string;

  /**
   * The range key value.
   *
   * @schema TopicRuleSpecInitProviderDynamodb#rangeKeyValue
   */
  readonly rangeKeyValue?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderDynamodb#roleArn
   */
  readonly roleArn?: string;

  /**
   * The name of the DynamoDB table.
   *
   * @schema TopicRuleSpecInitProviderDynamodb#tableName
   */
  readonly tableName?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderDynamodb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderDynamodb(obj: TopicRuleSpecInitProviderDynamodb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hashKeyField': obj.hashKeyField,
    'hashKeyType': obj.hashKeyType,
    'hashKeyValue': obj.hashKeyValue,
    'operation': obj.operation,
    'payloadField': obj.payloadField,
    'rangeKeyField': obj.rangeKeyField,
    'rangeKeyType': obj.rangeKeyType,
    'rangeKeyValue': obj.rangeKeyValue,
    'roleArn': obj.roleArn,
    'tableName': obj.tableName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderDynamodbv2
 */
export interface TopicRuleSpecInitProviderDynamodbv2 {
  /**
   * Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
   *
   * @schema TopicRuleSpecInitProviderDynamodbv2#putItem
   */
  readonly putItem?: TopicRuleSpecInitProviderDynamodbv2PutItem[];

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderDynamodbv2#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderDynamodbv2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderDynamodbv2(obj: TopicRuleSpecInitProviderDynamodbv2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'putItem': obj.putItem?.map(y => toJson_TopicRuleSpecInitProviderDynamodbv2PutItem(y)),
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderElasticsearch
 */
export interface TopicRuleSpecInitProviderElasticsearch {
  /**
   * The endpoint of your Elasticsearch domain.
   *
   * @schema TopicRuleSpecInitProviderElasticsearch#endpoint
   */
  readonly endpoint?: string;

  /**
   * The unique identifier for the document you are storing.
   *
   * @schema TopicRuleSpecInitProviderElasticsearch#id
   */
  readonly id?: string;

  /**
   * The Elasticsearch index where you want to store your data.
   *
   * @schema TopicRuleSpecInitProviderElasticsearch#index
   */
  readonly index?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderElasticsearch#roleArn
   */
  readonly roleArn?: string;

  /**
   * The type of document you are storing.
   *
   * @schema TopicRuleSpecInitProviderElasticsearch#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderElasticsearch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderElasticsearch(obj: TopicRuleSpecInitProviderElasticsearch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoint': obj.endpoint,
    'id': obj.id,
    'index': obj.index,
    'roleArn': obj.roleArn,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorAction
 */
export interface TopicRuleSpecInitProviderErrorAction {
  /**
   * @schema TopicRuleSpecInitProviderErrorAction#cloudwatchAlarm
   */
  readonly cloudwatchAlarm?: TopicRuleSpecInitProviderErrorActionCloudwatchAlarm[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#cloudwatchLogs
   */
  readonly cloudwatchLogs?: TopicRuleSpecInitProviderErrorActionCloudwatchLogs[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#cloudwatchMetric
   */
  readonly cloudwatchMetric?: TopicRuleSpecInitProviderErrorActionCloudwatchMetric[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#dynamodb
   */
  readonly dynamodb?: TopicRuleSpecInitProviderErrorActionDynamodb[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#dynamodbv2
   */
  readonly dynamodbv2?: TopicRuleSpecInitProviderErrorActionDynamodbv2[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#elasticsearch
   */
  readonly elasticsearch?: TopicRuleSpecInitProviderErrorActionElasticsearch[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#firehose
   */
  readonly firehose?: TopicRuleSpecInitProviderErrorActionFirehose[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#http
   */
  readonly http?: TopicRuleSpecInitProviderErrorActionHttp[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#iotAnalytics
   */
  readonly iotAnalytics?: TopicRuleSpecInitProviderErrorActionIotAnalytics[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#iotEvents
   */
  readonly iotEvents?: TopicRuleSpecInitProviderErrorActionIotEvents[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#kafka
   */
  readonly kafka?: TopicRuleSpecInitProviderErrorActionKafka[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#kinesis
   */
  readonly kinesis?: TopicRuleSpecInitProviderErrorActionKinesis[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#lambda
   */
  readonly lambda?: TopicRuleSpecInitProviderErrorActionLambda[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#republish
   */
  readonly republish?: TopicRuleSpecInitProviderErrorActionRepublish[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#s3
   */
  readonly s3?: TopicRuleSpecInitProviderErrorActionS3[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#sns
   */
  readonly sns?: TopicRuleSpecInitProviderErrorActionSns[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#sqs
   */
  readonly sqs?: TopicRuleSpecInitProviderErrorActionSqs[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#stepFunctions
   */
  readonly stepFunctions?: TopicRuleSpecInitProviderErrorActionStepFunctions[];

  /**
   * @schema TopicRuleSpecInitProviderErrorAction#timestream
   */
  readonly timestream?: TopicRuleSpecInitProviderErrorActionTimestream[];

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorAction(obj: TopicRuleSpecInitProviderErrorAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchAlarm': obj.cloudwatchAlarm?.map(y => toJson_TopicRuleSpecInitProviderErrorActionCloudwatchAlarm(y)),
    'cloudwatchLogs': obj.cloudwatchLogs?.map(y => toJson_TopicRuleSpecInitProviderErrorActionCloudwatchLogs(y)),
    'cloudwatchMetric': obj.cloudwatchMetric?.map(y => toJson_TopicRuleSpecInitProviderErrorActionCloudwatchMetric(y)),
    'dynamodb': obj.dynamodb?.map(y => toJson_TopicRuleSpecInitProviderErrorActionDynamodb(y)),
    'dynamodbv2': obj.dynamodbv2?.map(y => toJson_TopicRuleSpecInitProviderErrorActionDynamodbv2(y)),
    'elasticsearch': obj.elasticsearch?.map(y => toJson_TopicRuleSpecInitProviderErrorActionElasticsearch(y)),
    'firehose': obj.firehose?.map(y => toJson_TopicRuleSpecInitProviderErrorActionFirehose(y)),
    'http': obj.http?.map(y => toJson_TopicRuleSpecInitProviderErrorActionHttp(y)),
    'iotAnalytics': obj.iotAnalytics?.map(y => toJson_TopicRuleSpecInitProviderErrorActionIotAnalytics(y)),
    'iotEvents': obj.iotEvents?.map(y => toJson_TopicRuleSpecInitProviderErrorActionIotEvents(y)),
    'kafka': obj.kafka?.map(y => toJson_TopicRuleSpecInitProviderErrorActionKafka(y)),
    'kinesis': obj.kinesis?.map(y => toJson_TopicRuleSpecInitProviderErrorActionKinesis(y)),
    'lambda': obj.lambda?.map(y => toJson_TopicRuleSpecInitProviderErrorActionLambda(y)),
    'republish': obj.republish?.map(y => toJson_TopicRuleSpecInitProviderErrorActionRepublish(y)),
    's3': obj.s3?.map(y => toJson_TopicRuleSpecInitProviderErrorActionS3(y)),
    'sns': obj.sns?.map(y => toJson_TopicRuleSpecInitProviderErrorActionSns(y)),
    'sqs': obj.sqs?.map(y => toJson_TopicRuleSpecInitProviderErrorActionSqs(y)),
    'stepFunctions': obj.stepFunctions?.map(y => toJson_TopicRuleSpecInitProviderErrorActionStepFunctions(y)),
    'timestream': obj.timestream?.map(y => toJson_TopicRuleSpecInitProviderErrorActionTimestream(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderFirehose
 */
export interface TopicRuleSpecInitProviderFirehose {
  /**
   * The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
   *
   * @schema TopicRuleSpecInitProviderFirehose#batchMode
   */
  readonly batchMode?: boolean;

  /**
   * The delivery stream name.
   *
   * @schema TopicRuleSpecInitProviderFirehose#deliveryStreamName
   */
  readonly deliveryStreamName?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderFirehose#roleArn
   */
  readonly roleArn?: string;

  /**
   * A character separator that is used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
   *
   * @schema TopicRuleSpecInitProviderFirehose#separator
   */
  readonly separator?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderFirehose' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderFirehose(obj: TopicRuleSpecInitProviderFirehose | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchMode': obj.batchMode,
    'deliveryStreamName': obj.deliveryStreamName,
    'roleArn': obj.roleArn,
    'separator': obj.separator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderHttp
 */
export interface TopicRuleSpecInitProviderHttp {
  /**
   * The HTTPS URL used to verify ownership of url.
   *
   * @schema TopicRuleSpecInitProviderHttp#confirmationUrl
   */
  readonly confirmationUrl?: string;

  /**
   * Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
   *
   * @schema TopicRuleSpecInitProviderHttp#httpHeader
   */
  readonly httpHeader?: TopicRuleSpecInitProviderHttpHttpHeader[];

  /**
   * The HTTPS URL.
   *
   * @schema TopicRuleSpecInitProviderHttp#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderHttp(obj: TopicRuleSpecInitProviderHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confirmationUrl': obj.confirmationUrl,
    'httpHeader': obj.httpHeader?.map(y => toJson_TopicRuleSpecInitProviderHttpHttpHeader(y)),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderIotAnalytics
 */
export interface TopicRuleSpecInitProviderIotAnalytics {
  /**
   * The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
   *
   * @schema TopicRuleSpecInitProviderIotAnalytics#batchMode
   */
  readonly batchMode?: boolean;

  /**
   * Name of AWS IOT Analytics channel.
   *
   * @schema TopicRuleSpecInitProviderIotAnalytics#channelName
   */
  readonly channelName?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderIotAnalytics#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderIotAnalytics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderIotAnalytics(obj: TopicRuleSpecInitProviderIotAnalytics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchMode': obj.batchMode,
    'channelName': obj.channelName,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderIotEvents
 */
export interface TopicRuleSpecInitProviderIotEvents {
  /**
   * The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
   *
   * @schema TopicRuleSpecInitProviderIotEvents#batchMode
   */
  readonly batchMode?: boolean;

  /**
   * The name of the AWS IoT Events input.
   *
   * @schema TopicRuleSpecInitProviderIotEvents#inputName
   */
  readonly inputName?: string;

  /**
   * Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
   *
   * @schema TopicRuleSpecInitProviderIotEvents#messageId
   */
  readonly messageId?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderIotEvents#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderIotEvents' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderIotEvents(obj: TopicRuleSpecInitProviderIotEvents | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchMode': obj.batchMode,
    'inputName': obj.inputName,
    'messageId': obj.messageId,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderKafka
 */
export interface TopicRuleSpecInitProviderKafka {
  /**
   * Properties of the Apache Kafka producer client. For more info, see the AWS documentation.
   *
   * @schema TopicRuleSpecInitProviderKafka#clientProperties
   */
  readonly clientProperties?: { [key: string]: string };

  /**
   * The ARN of Kafka action's VPC aws_iot_topic_rule_destination .
   *
   * @schema TopicRuleSpecInitProviderKafka#destinationArn
   */
  readonly destinationArn?: string;

  /**
   * The name of the HTTP header.
   *
   * @schema TopicRuleSpecInitProviderKafka#key
   */
  readonly key?: string;

  /**
   * The Kafka message partition.
   *
   * @schema TopicRuleSpecInitProviderKafka#partition
   */
  readonly partition?: string;

  /**
   * The Kafka topic for messages to be sent to the Kafka broker.
   *
   * @schema TopicRuleSpecInitProviderKafka#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderKafka' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderKafka(obj: TopicRuleSpecInitProviderKafka | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientProperties': ((obj.clientProperties) === undefined) ? undefined : (Object.entries(obj.clientProperties).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'destinationArn': obj.destinationArn,
    'key': obj.key,
    'partition': obj.partition,
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderKinesis
 */
export interface TopicRuleSpecInitProviderKinesis {
  /**
   * The partition key.
   *
   * @schema TopicRuleSpecInitProviderKinesis#partitionKey
   */
  readonly partitionKey?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderKinesis#roleArn
   */
  readonly roleArn?: string;

  /**
   * The name of the Amazon Kinesis stream.
   *
   * @schema TopicRuleSpecInitProviderKinesis#streamName
   */
  readonly streamName?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderKinesis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderKinesis(obj: TopicRuleSpecInitProviderKinesis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partitionKey': obj.partitionKey,
    'roleArn': obj.roleArn,
    'streamName': obj.streamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderLambda
 */
export interface TopicRuleSpecInitProviderLambda {
  /**
   * The ARN of the Lambda function.
   *
   * @schema TopicRuleSpecInitProviderLambda#functionArn
   */
  readonly functionArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderLambda' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderLambda(obj: TopicRuleSpecInitProviderLambda | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'functionArn': obj.functionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderRepublish
 */
export interface TopicRuleSpecInitProviderRepublish {
  /**
   * The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.
   *
   * @schema TopicRuleSpecInitProviderRepublish#qos
   */
  readonly qos?: number;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderRepublish#roleArn
   */
  readonly roleArn?: string;

  /**
   * The Kafka topic for messages to be sent to the Kafka broker.
   *
   * @schema TopicRuleSpecInitProviderRepublish#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderRepublish' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderRepublish(obj: TopicRuleSpecInitProviderRepublish | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'qos': obj.qos,
    'roleArn': obj.roleArn,
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderS3
 */
export interface TopicRuleSpecInitProviderS3 {
  /**
   * The Amazon S3 bucket name.
   *
   * @schema TopicRuleSpecInitProviderS3#bucketName
   */
  readonly bucketName?: string;

  /**
   * The Amazon S3 canned ACL that controls access to the object identified by the object key. Valid values.
   *
   * @schema TopicRuleSpecInitProviderS3#cannedAcl
   */
  readonly cannedAcl?: string;

  /**
   * The name of the HTTP header.
   *
   * @schema TopicRuleSpecInitProviderS3#key
   */
  readonly key?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderS3#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderS3(obj: TopicRuleSpecInitProviderS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'cannedAcl': obj.cannedAcl,
    'key': obj.key,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderSns
 */
export interface TopicRuleSpecInitProviderSns {
  /**
   * The message format of the message to publish. Accepted values are "JSON" and "RAW".
   *
   * @schema TopicRuleSpecInitProviderSns#messageFormat
   */
  readonly messageFormat?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderSns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderSns(obj: TopicRuleSpecInitProviderSns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'messageFormat': obj.messageFormat,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderSqs
 */
export interface TopicRuleSpecInitProviderSqs {
  /**
   * The URL of the Amazon SQS queue.
   *
   * @schema TopicRuleSpecInitProviderSqs#queueUrl
   */
  readonly queueUrl?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderSqs#roleArn
   */
  readonly roleArn?: string;

  /**
   * Specifies whether to use Base64 encoding.
   *
   * @schema TopicRuleSpecInitProviderSqs#useBase64
   */
  readonly useBase64?: boolean;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderSqs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderSqs(obj: TopicRuleSpecInitProviderSqs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'queueUrl': obj.queueUrl,
    'roleArn': obj.roleArn,
    'useBase64': obj.useBase64,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderStepFunctions
 */
export interface TopicRuleSpecInitProviderStepFunctions {
  /**
   * The prefix used to generate, along with a UUID, the unique state machine execution name.
   *
   * @schema TopicRuleSpecInitProviderStepFunctions#executionNamePrefix
   */
  readonly executionNamePrefix?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderStepFunctions#roleArn
   */
  readonly roleArn?: string;

  /**
   * The name of the Step Functions state machine whose execution will be started.
   *
   * @schema TopicRuleSpecInitProviderStepFunctions#stateMachineName
   */
  readonly stateMachineName?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderStepFunctions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderStepFunctions(obj: TopicRuleSpecInitProviderStepFunctions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executionNamePrefix': obj.executionNamePrefix,
    'roleArn': obj.roleArn,
    'stateMachineName': obj.stateMachineName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderTimestream
 */
export interface TopicRuleSpecInitProviderTimestream {
  /**
   * The name of an Amazon Timestream database.
   *
   * @schema TopicRuleSpecInitProviderTimestream#databaseName
   */
  readonly databaseName?: string;

  /**
   * Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
   *
   * @schema TopicRuleSpecInitProviderTimestream#dimension
   */
  readonly dimension?: TopicRuleSpecInitProviderTimestreamDimension[];

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderTimestream#roleArn
   */
  readonly roleArn?: string;

  /**
   * The name of the DynamoDB table.
   *
   * @schema TopicRuleSpecInitProviderTimestream#tableName
   */
  readonly tableName?: string;

  /**
   * Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
   *
   * @schema TopicRuleSpecInitProviderTimestream#timestamp
   */
  readonly timestamp?: TopicRuleSpecInitProviderTimestreamTimestamp[];

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderTimestream' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderTimestream(obj: TopicRuleSpecInitProviderTimestream | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'databaseName': obj.databaseName,
    'dimension': obj.dimension?.map(y => toJson_TopicRuleSpecInitProviderTimestreamDimension(y)),
    'roleArn': obj.roleArn,
    'tableName': obj.tableName,
    'timestamp': obj.timestamp?.map(y => toJson_TopicRuleSpecInitProviderTimestreamTimestamp(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicRuleSpecProviderConfigRefPolicy
 */
export interface TopicRuleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicRuleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TopicRuleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicRuleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TopicRuleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicRuleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecProviderConfigRefPolicy(obj: TopicRuleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TopicRuleSpecPublishConnectionDetailsToConfigRef
 */
export interface TopicRuleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicRuleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicRuleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TopicRuleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TopicRuleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecPublishConnectionDetailsToConfigRef(obj: TopicRuleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TopicRuleSpecPublishConnectionDetailsToMetadata
 */
export interface TopicRuleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TopicRuleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TopicRuleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TopicRuleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecPublishConnectionDetailsToMetadata(obj: TopicRuleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderDynamodbv2PutItem
 */
export interface TopicRuleSpecForProviderDynamodbv2PutItem {
  /**
   * The name of the DynamoDB table.
   *
   * @schema TopicRuleSpecForProviderDynamodbv2PutItem#tableName
   */
  readonly tableName?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderDynamodbv2PutItem' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderDynamodbv2PutItem(obj: TopicRuleSpecForProviderDynamodbv2PutItem | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableName': obj.tableName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionCloudwatchAlarm
 */
export interface TopicRuleSpecForProviderErrorActionCloudwatchAlarm {
  /**
   * The CloudWatch alarm name.
   *
   * @schema TopicRuleSpecForProviderErrorActionCloudwatchAlarm#alarmName
   */
  readonly alarmName?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderErrorActionCloudwatchAlarm#roleArn
   */
  readonly roleArn?: string;

  /**
   * The reason for the alarm change.
   *
   * @schema TopicRuleSpecForProviderErrorActionCloudwatchAlarm#stateReason
   */
  readonly stateReason?: string;

  /**
   * The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
   *
   * @schema TopicRuleSpecForProviderErrorActionCloudwatchAlarm#stateValue
   */
  readonly stateValue?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionCloudwatchAlarm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionCloudwatchAlarm(obj: TopicRuleSpecForProviderErrorActionCloudwatchAlarm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarmName': obj.alarmName,
    'roleArn': obj.roleArn,
    'stateReason': obj.stateReason,
    'stateValue': obj.stateValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionCloudwatchLogs
 */
export interface TopicRuleSpecForProviderErrorActionCloudwatchLogs {
  /**
   * The CloudWatch log group name.
   *
   * @schema TopicRuleSpecForProviderErrorActionCloudwatchLogs#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderErrorActionCloudwatchLogs#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionCloudwatchLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionCloudwatchLogs(obj: TopicRuleSpecForProviderErrorActionCloudwatchLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logGroupName': obj.logGroupName,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionCloudwatchMetric
 */
export interface TopicRuleSpecForProviderErrorActionCloudwatchMetric {
  /**
   * The CloudWatch metric name.
   *
   * @schema TopicRuleSpecForProviderErrorActionCloudwatchMetric#metricName
   */
  readonly metricName?: string;

  /**
   * The CloudWatch metric namespace name.
   *
   * @schema TopicRuleSpecForProviderErrorActionCloudwatchMetric#metricNamespace
   */
  readonly metricNamespace?: string;

  /**
   * An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
   *
   * @schema TopicRuleSpecForProviderErrorActionCloudwatchMetric#metricTimestamp
   */
  readonly metricTimestamp?: string;

  /**
   * The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
   *
   * @schema TopicRuleSpecForProviderErrorActionCloudwatchMetric#metricUnit
   */
  readonly metricUnit?: string;

  /**
   * The CloudWatch metric value.
   *
   * @schema TopicRuleSpecForProviderErrorActionCloudwatchMetric#metricValue
   */
  readonly metricValue?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderErrorActionCloudwatchMetric#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionCloudwatchMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionCloudwatchMetric(obj: TopicRuleSpecForProviderErrorActionCloudwatchMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricName': obj.metricName,
    'metricNamespace': obj.metricNamespace,
    'metricTimestamp': obj.metricTimestamp,
    'metricUnit': obj.metricUnit,
    'metricValue': obj.metricValue,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionDynamodb
 */
export interface TopicRuleSpecForProviderErrorActionDynamodb {
  /**
   * The hash key name.
   *
   * @schema TopicRuleSpecForProviderErrorActionDynamodb#hashKeyField
   */
  readonly hashKeyField?: string;

  /**
   * The hash key type. Valid values are "STRING" or "NUMBER".
   *
   * @schema TopicRuleSpecForProviderErrorActionDynamodb#hashKeyType
   */
  readonly hashKeyType?: string;

  /**
   * The hash key value.
   *
   * @schema TopicRuleSpecForProviderErrorActionDynamodb#hashKeyValue
   */
  readonly hashKeyValue?: string;

  /**
   * The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
   *
   * @schema TopicRuleSpecForProviderErrorActionDynamodb#operation
   */
  readonly operation?: string;

  /**
   * The action payload.
   *
   * @schema TopicRuleSpecForProviderErrorActionDynamodb#payloadField
   */
  readonly payloadField?: string;

  /**
   * The range key name.
   *
   * @schema TopicRuleSpecForProviderErrorActionDynamodb#rangeKeyField
   */
  readonly rangeKeyField?: string;

  /**
   * The range key type. Valid values are "STRING" or "NUMBER".
   *
   * @schema TopicRuleSpecForProviderErrorActionDynamodb#rangeKeyType
   */
  readonly rangeKeyType?: string;

  /**
   * The range key value.
   *
   * @schema TopicRuleSpecForProviderErrorActionDynamodb#rangeKeyValue
   */
  readonly rangeKeyValue?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderErrorActionDynamodb#roleArn
   */
  readonly roleArn?: string;

  /**
   * The name of the DynamoDB table.
   *
   * @schema TopicRuleSpecForProviderErrorActionDynamodb#tableName
   */
  readonly tableName?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionDynamodb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionDynamodb(obj: TopicRuleSpecForProviderErrorActionDynamodb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hashKeyField': obj.hashKeyField,
    'hashKeyType': obj.hashKeyType,
    'hashKeyValue': obj.hashKeyValue,
    'operation': obj.operation,
    'payloadField': obj.payloadField,
    'rangeKeyField': obj.rangeKeyField,
    'rangeKeyType': obj.rangeKeyType,
    'rangeKeyValue': obj.rangeKeyValue,
    'roleArn': obj.roleArn,
    'tableName': obj.tableName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionDynamodbv2
 */
export interface TopicRuleSpecForProviderErrorActionDynamodbv2 {
  /**
   * Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
   *
   * @schema TopicRuleSpecForProviderErrorActionDynamodbv2#putItem
   */
  readonly putItem?: TopicRuleSpecForProviderErrorActionDynamodbv2PutItem[];

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderErrorActionDynamodbv2#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionDynamodbv2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionDynamodbv2(obj: TopicRuleSpecForProviderErrorActionDynamodbv2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'putItem': obj.putItem?.map(y => toJson_TopicRuleSpecForProviderErrorActionDynamodbv2PutItem(y)),
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionElasticsearch
 */
export interface TopicRuleSpecForProviderErrorActionElasticsearch {
  /**
   * The endpoint of your Elasticsearch domain.
   *
   * @schema TopicRuleSpecForProviderErrorActionElasticsearch#endpoint
   */
  readonly endpoint?: string;

  /**
   * The unique identifier for the document you are storing.
   *
   * @schema TopicRuleSpecForProviderErrorActionElasticsearch#id
   */
  readonly id?: string;

  /**
   * The Elasticsearch index where you want to store your data.
   *
   * @schema TopicRuleSpecForProviderErrorActionElasticsearch#index
   */
  readonly index?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderErrorActionElasticsearch#roleArn
   */
  readonly roleArn?: string;

  /**
   * The type of document you are storing.
   *
   * @schema TopicRuleSpecForProviderErrorActionElasticsearch#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionElasticsearch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionElasticsearch(obj: TopicRuleSpecForProviderErrorActionElasticsearch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoint': obj.endpoint,
    'id': obj.id,
    'index': obj.index,
    'roleArn': obj.roleArn,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionFirehose
 */
export interface TopicRuleSpecForProviderErrorActionFirehose {
  /**
   * The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
   *
   * @schema TopicRuleSpecForProviderErrorActionFirehose#batchMode
   */
  readonly batchMode?: boolean;

  /**
   * The delivery stream name.
   *
   * @schema TopicRuleSpecForProviderErrorActionFirehose#deliveryStreamName
   */
  readonly deliveryStreamName?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderErrorActionFirehose#roleArn
   */
  readonly roleArn?: string;

  /**
   * A character separator that is used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
   *
   * @schema TopicRuleSpecForProviderErrorActionFirehose#separator
   */
  readonly separator?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionFirehose' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionFirehose(obj: TopicRuleSpecForProviderErrorActionFirehose | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchMode': obj.batchMode,
    'deliveryStreamName': obj.deliveryStreamName,
    'roleArn': obj.roleArn,
    'separator': obj.separator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionHttp
 */
export interface TopicRuleSpecForProviderErrorActionHttp {
  /**
   * The HTTPS URL used to verify ownership of url.
   *
   * @schema TopicRuleSpecForProviderErrorActionHttp#confirmationUrl
   */
  readonly confirmationUrl?: string;

  /**
   * Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
   *
   * @schema TopicRuleSpecForProviderErrorActionHttp#httpHeader
   */
  readonly httpHeader?: TopicRuleSpecForProviderErrorActionHttpHttpHeader[];

  /**
   * The HTTPS URL.
   *
   * @schema TopicRuleSpecForProviderErrorActionHttp#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionHttp(obj: TopicRuleSpecForProviderErrorActionHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confirmationUrl': obj.confirmationUrl,
    'httpHeader': obj.httpHeader?.map(y => toJson_TopicRuleSpecForProviderErrorActionHttpHttpHeader(y)),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionIotAnalytics
 */
export interface TopicRuleSpecForProviderErrorActionIotAnalytics {
  /**
   * The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
   *
   * @schema TopicRuleSpecForProviderErrorActionIotAnalytics#batchMode
   */
  readonly batchMode?: boolean;

  /**
   * Name of AWS IOT Analytics channel.
   *
   * @schema TopicRuleSpecForProviderErrorActionIotAnalytics#channelName
   */
  readonly channelName?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderErrorActionIotAnalytics#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionIotAnalytics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionIotAnalytics(obj: TopicRuleSpecForProviderErrorActionIotAnalytics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchMode': obj.batchMode,
    'channelName': obj.channelName,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionIotEvents
 */
export interface TopicRuleSpecForProviderErrorActionIotEvents {
  /**
   * The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
   *
   * @schema TopicRuleSpecForProviderErrorActionIotEvents#batchMode
   */
  readonly batchMode?: boolean;

  /**
   * The name of the AWS IoT Events input.
   *
   * @schema TopicRuleSpecForProviderErrorActionIotEvents#inputName
   */
  readonly inputName?: string;

  /**
   * Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
   *
   * @schema TopicRuleSpecForProviderErrorActionIotEvents#messageId
   */
  readonly messageId?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderErrorActionIotEvents#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionIotEvents' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionIotEvents(obj: TopicRuleSpecForProviderErrorActionIotEvents | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchMode': obj.batchMode,
    'inputName': obj.inputName,
    'messageId': obj.messageId,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionKafka
 */
export interface TopicRuleSpecForProviderErrorActionKafka {
  /**
   * Properties of the Apache Kafka producer client. For more info, see the AWS documentation.
   *
   * @schema TopicRuleSpecForProviderErrorActionKafka#clientProperties
   */
  readonly clientProperties?: { [key: string]: string };

  /**
   * The ARN of Kafka action's VPC aws_iot_topic_rule_destination .
   *
   * @schema TopicRuleSpecForProviderErrorActionKafka#destinationArn
   */
  readonly destinationArn?: string;

  /**
   * The name of the HTTP header.
   *
   * @schema TopicRuleSpecForProviderErrorActionKafka#key
   */
  readonly key?: string;

  /**
   * The Kafka message partition.
   *
   * @schema TopicRuleSpecForProviderErrorActionKafka#partition
   */
  readonly partition?: string;

  /**
   * The Kafka topic for messages to be sent to the Kafka broker.
   *
   * @schema TopicRuleSpecForProviderErrorActionKafka#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionKafka' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionKafka(obj: TopicRuleSpecForProviderErrorActionKafka | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientProperties': ((obj.clientProperties) === undefined) ? undefined : (Object.entries(obj.clientProperties).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'destinationArn': obj.destinationArn,
    'key': obj.key,
    'partition': obj.partition,
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionKinesis
 */
export interface TopicRuleSpecForProviderErrorActionKinesis {
  /**
   * The partition key.
   *
   * @schema TopicRuleSpecForProviderErrorActionKinesis#partitionKey
   */
  readonly partitionKey?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderErrorActionKinesis#roleArn
   */
  readonly roleArn?: string;

  /**
   * The name of the Amazon Kinesis stream.
   *
   * @schema TopicRuleSpecForProviderErrorActionKinesis#streamName
   */
  readonly streamName?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionKinesis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionKinesis(obj: TopicRuleSpecForProviderErrorActionKinesis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partitionKey': obj.partitionKey,
    'roleArn': obj.roleArn,
    'streamName': obj.streamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionLambda
 */
export interface TopicRuleSpecForProviderErrorActionLambda {
  /**
   * The ARN of the Lambda function.
   *
   * @schema TopicRuleSpecForProviderErrorActionLambda#functionArn
   */
  readonly functionArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionLambda' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionLambda(obj: TopicRuleSpecForProviderErrorActionLambda | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'functionArn': obj.functionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionRepublish
 */
export interface TopicRuleSpecForProviderErrorActionRepublish {
  /**
   * The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.
   *
   * @schema TopicRuleSpecForProviderErrorActionRepublish#qos
   */
  readonly qos?: number;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderErrorActionRepublish#roleArn
   */
  readonly roleArn?: string;

  /**
   * The Kafka topic for messages to be sent to the Kafka broker.
   *
   * @schema TopicRuleSpecForProviderErrorActionRepublish#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionRepublish' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionRepublish(obj: TopicRuleSpecForProviderErrorActionRepublish | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'qos': obj.qos,
    'roleArn': obj.roleArn,
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionS3
 */
export interface TopicRuleSpecForProviderErrorActionS3 {
  /**
   * The Amazon S3 bucket name.
   *
   * @schema TopicRuleSpecForProviderErrorActionS3#bucketName
   */
  readonly bucketName?: string;

  /**
   * The Amazon S3 canned ACL that controls access to the object identified by the object key. Valid values.
   *
   * @schema TopicRuleSpecForProviderErrorActionS3#cannedAcl
   */
  readonly cannedAcl?: string;

  /**
   * The name of the HTTP header.
   *
   * @schema TopicRuleSpecForProviderErrorActionS3#key
   */
  readonly key?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderErrorActionS3#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionS3(obj: TopicRuleSpecForProviderErrorActionS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'cannedAcl': obj.cannedAcl,
    'key': obj.key,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionSns
 */
export interface TopicRuleSpecForProviderErrorActionSns {
  /**
   * The message format of the message to publish. Accepted values are "JSON" and "RAW".
   *
   * @schema TopicRuleSpecForProviderErrorActionSns#messageFormat
   */
  readonly messageFormat?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderErrorActionSns#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema TopicRuleSpecForProviderErrorActionSns#roleArnRef
   */
  readonly roleArnRef?: TopicRuleSpecForProviderErrorActionSnsRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema TopicRuleSpecForProviderErrorActionSns#roleArnSelector
   */
  readonly roleArnSelector?: TopicRuleSpecForProviderErrorActionSnsRoleArnSelector;

  /**
   * The ARN of the SNS topic.
   *
   * @schema TopicRuleSpecForProviderErrorActionSns#targetArn
   */
  readonly targetArn?: string;

  /**
   * Reference to a Topic in sns to populate targetArn.
   *
   * @schema TopicRuleSpecForProviderErrorActionSns#targetArnRef
   */
  readonly targetArnRef?: TopicRuleSpecForProviderErrorActionSnsTargetArnRef;

  /**
   * Selector for a Topic in sns to populate targetArn.
   *
   * @schema TopicRuleSpecForProviderErrorActionSns#targetArnSelector
   */
  readonly targetArnSelector?: TopicRuleSpecForProviderErrorActionSnsTargetArnSelector;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionSns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionSns(obj: TopicRuleSpecForProviderErrorActionSns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'messageFormat': obj.messageFormat,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_TopicRuleSpecForProviderErrorActionSnsRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_TopicRuleSpecForProviderErrorActionSnsRoleArnSelector(obj.roleArnSelector),
    'targetArn': obj.targetArn,
    'targetArnRef': toJson_TopicRuleSpecForProviderErrorActionSnsTargetArnRef(obj.targetArnRef),
    'targetArnSelector': toJson_TopicRuleSpecForProviderErrorActionSnsTargetArnSelector(obj.targetArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionSqs
 */
export interface TopicRuleSpecForProviderErrorActionSqs {
  /**
   * The URL of the Amazon SQS queue.
   *
   * @schema TopicRuleSpecForProviderErrorActionSqs#queueUrl
   */
  readonly queueUrl?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderErrorActionSqs#roleArn
   */
  readonly roleArn?: string;

  /**
   * Specifies whether to use Base64 encoding.
   *
   * @schema TopicRuleSpecForProviderErrorActionSqs#useBase64
   */
  readonly useBase64?: boolean;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionSqs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionSqs(obj: TopicRuleSpecForProviderErrorActionSqs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'queueUrl': obj.queueUrl,
    'roleArn': obj.roleArn,
    'useBase64': obj.useBase64,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionStepFunctions
 */
export interface TopicRuleSpecForProviderErrorActionStepFunctions {
  /**
   * The prefix used to generate, along with a UUID, the unique state machine execution name.
   *
   * @schema TopicRuleSpecForProviderErrorActionStepFunctions#executionNamePrefix
   */
  readonly executionNamePrefix?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderErrorActionStepFunctions#roleArn
   */
  readonly roleArn?: string;

  /**
   * The name of the Step Functions state machine whose execution will be started.
   *
   * @schema TopicRuleSpecForProviderErrorActionStepFunctions#stateMachineName
   */
  readonly stateMachineName?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionStepFunctions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionStepFunctions(obj: TopicRuleSpecForProviderErrorActionStepFunctions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executionNamePrefix': obj.executionNamePrefix,
    'roleArn': obj.roleArn,
    'stateMachineName': obj.stateMachineName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionTimestream
 */
export interface TopicRuleSpecForProviderErrorActionTimestream {
  /**
   * The name of an Amazon Timestream database.
   *
   * @schema TopicRuleSpecForProviderErrorActionTimestream#databaseName
   */
  readonly databaseName?: string;

  /**
   * Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
   *
   * @schema TopicRuleSpecForProviderErrorActionTimestream#dimension
   */
  readonly dimension?: TopicRuleSpecForProviderErrorActionTimestreamDimension[];

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecForProviderErrorActionTimestream#roleArn
   */
  readonly roleArn?: string;

  /**
   * The name of the DynamoDB table.
   *
   * @schema TopicRuleSpecForProviderErrorActionTimestream#tableName
   */
  readonly tableName?: string;

  /**
   * Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
   *
   * @schema TopicRuleSpecForProviderErrorActionTimestream#timestamp
   */
  readonly timestamp?: TopicRuleSpecForProviderErrorActionTimestreamTimestamp[];

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionTimestream' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionTimestream(obj: TopicRuleSpecForProviderErrorActionTimestream | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'databaseName': obj.databaseName,
    'dimension': obj.dimension?.map(y => toJson_TopicRuleSpecForProviderErrorActionTimestreamDimension(y)),
    'roleArn': obj.roleArn,
    'tableName': obj.tableName,
    'timestamp': obj.timestamp?.map(y => toJson_TopicRuleSpecForProviderErrorActionTimestreamTimestamp(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderHttpHttpHeader
 */
export interface TopicRuleSpecForProviderHttpHttpHeader {
  /**
   * The name of the HTTP header.
   *
   * @schema TopicRuleSpecForProviderHttpHttpHeader#key
   */
  readonly key?: string;

  /**
   * The value of the HTTP header.
   *
   * @schema TopicRuleSpecForProviderHttpHttpHeader#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderHttpHttpHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderHttpHttpHeader(obj: TopicRuleSpecForProviderHttpHttpHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema TopicRuleSpecForProviderSnsRoleArnRef
 */
export interface TopicRuleSpecForProviderSnsRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicRuleSpecForProviderSnsRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicRuleSpecForProviderSnsRoleArnRef#policy
   */
  readonly policy?: TopicRuleSpecForProviderSnsRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderSnsRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderSnsRoleArnRef(obj: TopicRuleSpecForProviderSnsRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicRuleSpecForProviderSnsRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema TopicRuleSpecForProviderSnsRoleArnSelector
 */
export interface TopicRuleSpecForProviderSnsRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicRuleSpecForProviderSnsRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicRuleSpecForProviderSnsRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicRuleSpecForProviderSnsRoleArnSelector#policy
   */
  readonly policy?: TopicRuleSpecForProviderSnsRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderSnsRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderSnsRoleArnSelector(obj: TopicRuleSpecForProviderSnsRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicRuleSpecForProviderSnsRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate targetArn.
 *
 * @schema TopicRuleSpecForProviderSnsTargetArnRef
 */
export interface TopicRuleSpecForProviderSnsTargetArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicRuleSpecForProviderSnsTargetArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicRuleSpecForProviderSnsTargetArnRef#policy
   */
  readonly policy?: TopicRuleSpecForProviderSnsTargetArnRefPolicy;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderSnsTargetArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderSnsTargetArnRef(obj: TopicRuleSpecForProviderSnsTargetArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicRuleSpecForProviderSnsTargetArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate targetArn.
 *
 * @schema TopicRuleSpecForProviderSnsTargetArnSelector
 */
export interface TopicRuleSpecForProviderSnsTargetArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicRuleSpecForProviderSnsTargetArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicRuleSpecForProviderSnsTargetArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicRuleSpecForProviderSnsTargetArnSelector#policy
   */
  readonly policy?: TopicRuleSpecForProviderSnsTargetArnSelectorPolicy;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderSnsTargetArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderSnsTargetArnSelector(obj: TopicRuleSpecForProviderSnsTargetArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicRuleSpecForProviderSnsTargetArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderTimestreamDimension
 */
export interface TopicRuleSpecForProviderTimestreamDimension {
  /**
   * The name of the rule.
   *
   * @schema TopicRuleSpecForProviderTimestreamDimension#name
   */
  readonly name?: string;

  /**
   * The value of the HTTP header.
   *
   * @schema TopicRuleSpecForProviderTimestreamDimension#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderTimestreamDimension' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderTimestreamDimension(obj: TopicRuleSpecForProviderTimestreamDimension | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderTimestreamTimestamp
 */
export interface TopicRuleSpecForProviderTimestreamTimestamp {
  /**
   * The precision of the timestamp value that results from the expression described in value. Valid values: SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS.
   *
   * @schema TopicRuleSpecForProviderTimestreamTimestamp#unit
   */
  readonly unit?: string;

  /**
   * The value of the HTTP header.
   *
   * @schema TopicRuleSpecForProviderTimestreamTimestamp#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderTimestreamTimestamp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderTimestreamTimestamp(obj: TopicRuleSpecForProviderTimestreamTimestamp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderDynamodbv2PutItem
 */
export interface TopicRuleSpecInitProviderDynamodbv2PutItem {
  /**
   * The name of the DynamoDB table.
   *
   * @schema TopicRuleSpecInitProviderDynamodbv2PutItem#tableName
   */
  readonly tableName?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderDynamodbv2PutItem' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderDynamodbv2PutItem(obj: TopicRuleSpecInitProviderDynamodbv2PutItem | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableName': obj.tableName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionCloudwatchAlarm
 */
export interface TopicRuleSpecInitProviderErrorActionCloudwatchAlarm {
  /**
   * The CloudWatch alarm name.
   *
   * @schema TopicRuleSpecInitProviderErrorActionCloudwatchAlarm#alarmName
   */
  readonly alarmName?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderErrorActionCloudwatchAlarm#roleArn
   */
  readonly roleArn?: string;

  /**
   * The reason for the alarm change.
   *
   * @schema TopicRuleSpecInitProviderErrorActionCloudwatchAlarm#stateReason
   */
  readonly stateReason?: string;

  /**
   * The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
   *
   * @schema TopicRuleSpecInitProviderErrorActionCloudwatchAlarm#stateValue
   */
  readonly stateValue?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionCloudwatchAlarm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionCloudwatchAlarm(obj: TopicRuleSpecInitProviderErrorActionCloudwatchAlarm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarmName': obj.alarmName,
    'roleArn': obj.roleArn,
    'stateReason': obj.stateReason,
    'stateValue': obj.stateValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionCloudwatchLogs
 */
export interface TopicRuleSpecInitProviderErrorActionCloudwatchLogs {
  /**
   * The CloudWatch log group name.
   *
   * @schema TopicRuleSpecInitProviderErrorActionCloudwatchLogs#logGroupName
   */
  readonly logGroupName?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderErrorActionCloudwatchLogs#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionCloudwatchLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionCloudwatchLogs(obj: TopicRuleSpecInitProviderErrorActionCloudwatchLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logGroupName': obj.logGroupName,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionCloudwatchMetric
 */
export interface TopicRuleSpecInitProviderErrorActionCloudwatchMetric {
  /**
   * The CloudWatch metric name.
   *
   * @schema TopicRuleSpecInitProviderErrorActionCloudwatchMetric#metricName
   */
  readonly metricName?: string;

  /**
   * The CloudWatch metric namespace name.
   *
   * @schema TopicRuleSpecInitProviderErrorActionCloudwatchMetric#metricNamespace
   */
  readonly metricNamespace?: string;

  /**
   * An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
   *
   * @schema TopicRuleSpecInitProviderErrorActionCloudwatchMetric#metricTimestamp
   */
  readonly metricTimestamp?: string;

  /**
   * The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
   *
   * @schema TopicRuleSpecInitProviderErrorActionCloudwatchMetric#metricUnit
   */
  readonly metricUnit?: string;

  /**
   * The CloudWatch metric value.
   *
   * @schema TopicRuleSpecInitProviderErrorActionCloudwatchMetric#metricValue
   */
  readonly metricValue?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderErrorActionCloudwatchMetric#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionCloudwatchMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionCloudwatchMetric(obj: TopicRuleSpecInitProviderErrorActionCloudwatchMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricName': obj.metricName,
    'metricNamespace': obj.metricNamespace,
    'metricTimestamp': obj.metricTimestamp,
    'metricUnit': obj.metricUnit,
    'metricValue': obj.metricValue,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionDynamodb
 */
export interface TopicRuleSpecInitProviderErrorActionDynamodb {
  /**
   * The hash key name.
   *
   * @schema TopicRuleSpecInitProviderErrorActionDynamodb#hashKeyField
   */
  readonly hashKeyField?: string;

  /**
   * The hash key type. Valid values are "STRING" or "NUMBER".
   *
   * @schema TopicRuleSpecInitProviderErrorActionDynamodb#hashKeyType
   */
  readonly hashKeyType?: string;

  /**
   * The hash key value.
   *
   * @schema TopicRuleSpecInitProviderErrorActionDynamodb#hashKeyValue
   */
  readonly hashKeyValue?: string;

  /**
   * The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
   *
   * @schema TopicRuleSpecInitProviderErrorActionDynamodb#operation
   */
  readonly operation?: string;

  /**
   * The action payload.
   *
   * @schema TopicRuleSpecInitProviderErrorActionDynamodb#payloadField
   */
  readonly payloadField?: string;

  /**
   * The range key name.
   *
   * @schema TopicRuleSpecInitProviderErrorActionDynamodb#rangeKeyField
   */
  readonly rangeKeyField?: string;

  /**
   * The range key type. Valid values are "STRING" or "NUMBER".
   *
   * @schema TopicRuleSpecInitProviderErrorActionDynamodb#rangeKeyType
   */
  readonly rangeKeyType?: string;

  /**
   * The range key value.
   *
   * @schema TopicRuleSpecInitProviderErrorActionDynamodb#rangeKeyValue
   */
  readonly rangeKeyValue?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderErrorActionDynamodb#roleArn
   */
  readonly roleArn?: string;

  /**
   * The name of the DynamoDB table.
   *
   * @schema TopicRuleSpecInitProviderErrorActionDynamodb#tableName
   */
  readonly tableName?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionDynamodb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionDynamodb(obj: TopicRuleSpecInitProviderErrorActionDynamodb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hashKeyField': obj.hashKeyField,
    'hashKeyType': obj.hashKeyType,
    'hashKeyValue': obj.hashKeyValue,
    'operation': obj.operation,
    'payloadField': obj.payloadField,
    'rangeKeyField': obj.rangeKeyField,
    'rangeKeyType': obj.rangeKeyType,
    'rangeKeyValue': obj.rangeKeyValue,
    'roleArn': obj.roleArn,
    'tableName': obj.tableName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionDynamodbv2
 */
export interface TopicRuleSpecInitProviderErrorActionDynamodbv2 {
  /**
   * Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
   *
   * @schema TopicRuleSpecInitProviderErrorActionDynamodbv2#putItem
   */
  readonly putItem?: TopicRuleSpecInitProviderErrorActionDynamodbv2PutItem[];

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderErrorActionDynamodbv2#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionDynamodbv2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionDynamodbv2(obj: TopicRuleSpecInitProviderErrorActionDynamodbv2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'putItem': obj.putItem?.map(y => toJson_TopicRuleSpecInitProviderErrorActionDynamodbv2PutItem(y)),
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionElasticsearch
 */
export interface TopicRuleSpecInitProviderErrorActionElasticsearch {
  /**
   * The endpoint of your Elasticsearch domain.
   *
   * @schema TopicRuleSpecInitProviderErrorActionElasticsearch#endpoint
   */
  readonly endpoint?: string;

  /**
   * The unique identifier for the document you are storing.
   *
   * @schema TopicRuleSpecInitProviderErrorActionElasticsearch#id
   */
  readonly id?: string;

  /**
   * The Elasticsearch index where you want to store your data.
   *
   * @schema TopicRuleSpecInitProviderErrorActionElasticsearch#index
   */
  readonly index?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderErrorActionElasticsearch#roleArn
   */
  readonly roleArn?: string;

  /**
   * The type of document you are storing.
   *
   * @schema TopicRuleSpecInitProviderErrorActionElasticsearch#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionElasticsearch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionElasticsearch(obj: TopicRuleSpecInitProviderErrorActionElasticsearch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoint': obj.endpoint,
    'id': obj.id,
    'index': obj.index,
    'roleArn': obj.roleArn,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionFirehose
 */
export interface TopicRuleSpecInitProviderErrorActionFirehose {
  /**
   * The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
   *
   * @schema TopicRuleSpecInitProviderErrorActionFirehose#batchMode
   */
  readonly batchMode?: boolean;

  /**
   * The delivery stream name.
   *
   * @schema TopicRuleSpecInitProviderErrorActionFirehose#deliveryStreamName
   */
  readonly deliveryStreamName?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderErrorActionFirehose#roleArn
   */
  readonly roleArn?: string;

  /**
   * A character separator that is used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
   *
   * @schema TopicRuleSpecInitProviderErrorActionFirehose#separator
   */
  readonly separator?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionFirehose' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionFirehose(obj: TopicRuleSpecInitProviderErrorActionFirehose | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchMode': obj.batchMode,
    'deliveryStreamName': obj.deliveryStreamName,
    'roleArn': obj.roleArn,
    'separator': obj.separator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionHttp
 */
export interface TopicRuleSpecInitProviderErrorActionHttp {
  /**
   * The HTTPS URL used to verify ownership of url.
   *
   * @schema TopicRuleSpecInitProviderErrorActionHttp#confirmationUrl
   */
  readonly confirmationUrl?: string;

  /**
   * Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
   *
   * @schema TopicRuleSpecInitProviderErrorActionHttp#httpHeader
   */
  readonly httpHeader?: TopicRuleSpecInitProviderErrorActionHttpHttpHeader[];

  /**
   * The HTTPS URL.
   *
   * @schema TopicRuleSpecInitProviderErrorActionHttp#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionHttp(obj: TopicRuleSpecInitProviderErrorActionHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confirmationUrl': obj.confirmationUrl,
    'httpHeader': obj.httpHeader?.map(y => toJson_TopicRuleSpecInitProviderErrorActionHttpHttpHeader(y)),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionIotAnalytics
 */
export interface TopicRuleSpecInitProviderErrorActionIotAnalytics {
  /**
   * The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
   *
   * @schema TopicRuleSpecInitProviderErrorActionIotAnalytics#batchMode
   */
  readonly batchMode?: boolean;

  /**
   * Name of AWS IOT Analytics channel.
   *
   * @schema TopicRuleSpecInitProviderErrorActionIotAnalytics#channelName
   */
  readonly channelName?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderErrorActionIotAnalytics#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionIotAnalytics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionIotAnalytics(obj: TopicRuleSpecInitProviderErrorActionIotAnalytics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchMode': obj.batchMode,
    'channelName': obj.channelName,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionIotEvents
 */
export interface TopicRuleSpecInitProviderErrorActionIotEvents {
  /**
   * The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
   *
   * @schema TopicRuleSpecInitProviderErrorActionIotEvents#batchMode
   */
  readonly batchMode?: boolean;

  /**
   * The name of the AWS IoT Events input.
   *
   * @schema TopicRuleSpecInitProviderErrorActionIotEvents#inputName
   */
  readonly inputName?: string;

  /**
   * Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
   *
   * @schema TopicRuleSpecInitProviderErrorActionIotEvents#messageId
   */
  readonly messageId?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderErrorActionIotEvents#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionIotEvents' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionIotEvents(obj: TopicRuleSpecInitProviderErrorActionIotEvents | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchMode': obj.batchMode,
    'inputName': obj.inputName,
    'messageId': obj.messageId,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionKafka
 */
export interface TopicRuleSpecInitProviderErrorActionKafka {
  /**
   * Properties of the Apache Kafka producer client. For more info, see the AWS documentation.
   *
   * @schema TopicRuleSpecInitProviderErrorActionKafka#clientProperties
   */
  readonly clientProperties?: { [key: string]: string };

  /**
   * The ARN of Kafka action's VPC aws_iot_topic_rule_destination .
   *
   * @schema TopicRuleSpecInitProviderErrorActionKafka#destinationArn
   */
  readonly destinationArn?: string;

  /**
   * The name of the HTTP header.
   *
   * @schema TopicRuleSpecInitProviderErrorActionKafka#key
   */
  readonly key?: string;

  /**
   * The Kafka message partition.
   *
   * @schema TopicRuleSpecInitProviderErrorActionKafka#partition
   */
  readonly partition?: string;

  /**
   * The Kafka topic for messages to be sent to the Kafka broker.
   *
   * @schema TopicRuleSpecInitProviderErrorActionKafka#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionKafka' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionKafka(obj: TopicRuleSpecInitProviderErrorActionKafka | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientProperties': ((obj.clientProperties) === undefined) ? undefined : (Object.entries(obj.clientProperties).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'destinationArn': obj.destinationArn,
    'key': obj.key,
    'partition': obj.partition,
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionKinesis
 */
export interface TopicRuleSpecInitProviderErrorActionKinesis {
  /**
   * The partition key.
   *
   * @schema TopicRuleSpecInitProviderErrorActionKinesis#partitionKey
   */
  readonly partitionKey?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderErrorActionKinesis#roleArn
   */
  readonly roleArn?: string;

  /**
   * The name of the Amazon Kinesis stream.
   *
   * @schema TopicRuleSpecInitProviderErrorActionKinesis#streamName
   */
  readonly streamName?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionKinesis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionKinesis(obj: TopicRuleSpecInitProviderErrorActionKinesis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partitionKey': obj.partitionKey,
    'roleArn': obj.roleArn,
    'streamName': obj.streamName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionLambda
 */
export interface TopicRuleSpecInitProviderErrorActionLambda {
  /**
   * The ARN of the Lambda function.
   *
   * @schema TopicRuleSpecInitProviderErrorActionLambda#functionArn
   */
  readonly functionArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionLambda' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionLambda(obj: TopicRuleSpecInitProviderErrorActionLambda | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'functionArn': obj.functionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionRepublish
 */
export interface TopicRuleSpecInitProviderErrorActionRepublish {
  /**
   * The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.
   *
   * @schema TopicRuleSpecInitProviderErrorActionRepublish#qos
   */
  readonly qos?: number;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderErrorActionRepublish#roleArn
   */
  readonly roleArn?: string;

  /**
   * The Kafka topic for messages to be sent to the Kafka broker.
   *
   * @schema TopicRuleSpecInitProviderErrorActionRepublish#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionRepublish' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionRepublish(obj: TopicRuleSpecInitProviderErrorActionRepublish | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'qos': obj.qos,
    'roleArn': obj.roleArn,
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionS3
 */
export interface TopicRuleSpecInitProviderErrorActionS3 {
  /**
   * The Amazon S3 bucket name.
   *
   * @schema TopicRuleSpecInitProviderErrorActionS3#bucketName
   */
  readonly bucketName?: string;

  /**
   * The Amazon S3 canned ACL that controls access to the object identified by the object key. Valid values.
   *
   * @schema TopicRuleSpecInitProviderErrorActionS3#cannedAcl
   */
  readonly cannedAcl?: string;

  /**
   * The name of the HTTP header.
   *
   * @schema TopicRuleSpecInitProviderErrorActionS3#key
   */
  readonly key?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderErrorActionS3#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionS3(obj: TopicRuleSpecInitProviderErrorActionS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'cannedAcl': obj.cannedAcl,
    'key': obj.key,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionSns
 */
export interface TopicRuleSpecInitProviderErrorActionSns {
  /**
   * The message format of the message to publish. Accepted values are "JSON" and "RAW".
   *
   * @schema TopicRuleSpecInitProviderErrorActionSns#messageFormat
   */
  readonly messageFormat?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionSns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionSns(obj: TopicRuleSpecInitProviderErrorActionSns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'messageFormat': obj.messageFormat,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionSqs
 */
export interface TopicRuleSpecInitProviderErrorActionSqs {
  /**
   * The URL of the Amazon SQS queue.
   *
   * @schema TopicRuleSpecInitProviderErrorActionSqs#queueUrl
   */
  readonly queueUrl?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderErrorActionSqs#roleArn
   */
  readonly roleArn?: string;

  /**
   * Specifies whether to use Base64 encoding.
   *
   * @schema TopicRuleSpecInitProviderErrorActionSqs#useBase64
   */
  readonly useBase64?: boolean;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionSqs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionSqs(obj: TopicRuleSpecInitProviderErrorActionSqs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'queueUrl': obj.queueUrl,
    'roleArn': obj.roleArn,
    'useBase64': obj.useBase64,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionStepFunctions
 */
export interface TopicRuleSpecInitProviderErrorActionStepFunctions {
  /**
   * The prefix used to generate, along with a UUID, the unique state machine execution name.
   *
   * @schema TopicRuleSpecInitProviderErrorActionStepFunctions#executionNamePrefix
   */
  readonly executionNamePrefix?: string;

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderErrorActionStepFunctions#roleArn
   */
  readonly roleArn?: string;

  /**
   * The name of the Step Functions state machine whose execution will be started.
   *
   * @schema TopicRuleSpecInitProviderErrorActionStepFunctions#stateMachineName
   */
  readonly stateMachineName?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionStepFunctions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionStepFunctions(obj: TopicRuleSpecInitProviderErrorActionStepFunctions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executionNamePrefix': obj.executionNamePrefix,
    'roleArn': obj.roleArn,
    'stateMachineName': obj.stateMachineName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionTimestream
 */
export interface TopicRuleSpecInitProviderErrorActionTimestream {
  /**
   * The name of an Amazon Timestream database.
   *
   * @schema TopicRuleSpecInitProviderErrorActionTimestream#databaseName
   */
  readonly databaseName?: string;

  /**
   * Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
   *
   * @schema TopicRuleSpecInitProviderErrorActionTimestream#dimension
   */
  readonly dimension?: TopicRuleSpecInitProviderErrorActionTimestreamDimension[];

  /**
   * The IAM role ARN that allows access to the CloudWatch alarm.
   *
   * @schema TopicRuleSpecInitProviderErrorActionTimestream#roleArn
   */
  readonly roleArn?: string;

  /**
   * The name of the DynamoDB table.
   *
   * @schema TopicRuleSpecInitProviderErrorActionTimestream#tableName
   */
  readonly tableName?: string;

  /**
   * Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
   *
   * @schema TopicRuleSpecInitProviderErrorActionTimestream#timestamp
   */
  readonly timestamp?: TopicRuleSpecInitProviderErrorActionTimestreamTimestamp[];

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionTimestream' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionTimestream(obj: TopicRuleSpecInitProviderErrorActionTimestream | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'databaseName': obj.databaseName,
    'dimension': obj.dimension?.map(y => toJson_TopicRuleSpecInitProviderErrorActionTimestreamDimension(y)),
    'roleArn': obj.roleArn,
    'tableName': obj.tableName,
    'timestamp': obj.timestamp?.map(y => toJson_TopicRuleSpecInitProviderErrorActionTimestreamTimestamp(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderHttpHttpHeader
 */
export interface TopicRuleSpecInitProviderHttpHttpHeader {
  /**
   * The name of the HTTP header.
   *
   * @schema TopicRuleSpecInitProviderHttpHttpHeader#key
   */
  readonly key?: string;

  /**
   * The value of the HTTP header.
   *
   * @schema TopicRuleSpecInitProviderHttpHttpHeader#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderHttpHttpHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderHttpHttpHeader(obj: TopicRuleSpecInitProviderHttpHttpHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderTimestreamDimension
 */
export interface TopicRuleSpecInitProviderTimestreamDimension {
  /**
   * The name of the rule.
   *
   * @schema TopicRuleSpecInitProviderTimestreamDimension#name
   */
  readonly name?: string;

  /**
   * The value of the HTTP header.
   *
   * @schema TopicRuleSpecInitProviderTimestreamDimension#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderTimestreamDimension' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderTimestreamDimension(obj: TopicRuleSpecInitProviderTimestreamDimension | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderTimestreamTimestamp
 */
export interface TopicRuleSpecInitProviderTimestreamTimestamp {
  /**
   * The precision of the timestamp value that results from the expression described in value. Valid values: SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS.
   *
   * @schema TopicRuleSpecInitProviderTimestreamTimestamp#unit
   */
  readonly unit?: string;

  /**
   * The value of the HTTP header.
   *
   * @schema TopicRuleSpecInitProviderTimestreamTimestamp#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderTimestreamTimestamp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderTimestreamTimestamp(obj: TopicRuleSpecInitProviderTimestreamTimestamp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicRuleSpecProviderConfigRefPolicyResolution
 */
export enum TopicRuleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicRuleSpecProviderConfigRefPolicyResolve
 */
export enum TopicRuleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TopicRuleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TopicRuleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TopicRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TopicRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicRuleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj: TopicRuleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionDynamodbv2PutItem
 */
export interface TopicRuleSpecForProviderErrorActionDynamodbv2PutItem {
  /**
   * The name of the DynamoDB table.
   *
   * @schema TopicRuleSpecForProviderErrorActionDynamodbv2PutItem#tableName
   */
  readonly tableName?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionDynamodbv2PutItem' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionDynamodbv2PutItem(obj: TopicRuleSpecForProviderErrorActionDynamodbv2PutItem | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableName': obj.tableName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionHttpHttpHeader
 */
export interface TopicRuleSpecForProviderErrorActionHttpHttpHeader {
  /**
   * The name of the HTTP header.
   *
   * @schema TopicRuleSpecForProviderErrorActionHttpHttpHeader#key
   */
  readonly key?: string;

  /**
   * The value of the HTTP header.
   *
   * @schema TopicRuleSpecForProviderErrorActionHttpHttpHeader#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionHttpHttpHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionHttpHttpHeader(obj: TopicRuleSpecForProviderErrorActionHttpHttpHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema TopicRuleSpecForProviderErrorActionSnsRoleArnRef
 */
export interface TopicRuleSpecForProviderErrorActionSnsRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsRoleArnRef#policy
   */
  readonly policy?: TopicRuleSpecForProviderErrorActionSnsRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionSnsRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionSnsRoleArnRef(obj: TopicRuleSpecForProviderErrorActionSnsRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicRuleSpecForProviderErrorActionSnsRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema TopicRuleSpecForProviderErrorActionSnsRoleArnSelector
 */
export interface TopicRuleSpecForProviderErrorActionSnsRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsRoleArnSelector#policy
   */
  readonly policy?: TopicRuleSpecForProviderErrorActionSnsRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionSnsRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionSnsRoleArnSelector(obj: TopicRuleSpecForProviderErrorActionSnsRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicRuleSpecForProviderErrorActionSnsRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate targetArn.
 *
 * @schema TopicRuleSpecForProviderErrorActionSnsTargetArnRef
 */
export interface TopicRuleSpecForProviderErrorActionSnsTargetArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsTargetArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsTargetArnRef#policy
   */
  readonly policy?: TopicRuleSpecForProviderErrorActionSnsTargetArnRefPolicy;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionSnsTargetArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionSnsTargetArnRef(obj: TopicRuleSpecForProviderErrorActionSnsTargetArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicRuleSpecForProviderErrorActionSnsTargetArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate targetArn.
 *
 * @schema TopicRuleSpecForProviderErrorActionSnsTargetArnSelector
 */
export interface TopicRuleSpecForProviderErrorActionSnsTargetArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsTargetArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsTargetArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsTargetArnSelector#policy
   */
  readonly policy?: TopicRuleSpecForProviderErrorActionSnsTargetArnSelectorPolicy;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionSnsTargetArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionSnsTargetArnSelector(obj: TopicRuleSpecForProviderErrorActionSnsTargetArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicRuleSpecForProviderErrorActionSnsTargetArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionTimestreamDimension
 */
export interface TopicRuleSpecForProviderErrorActionTimestreamDimension {
  /**
   * The name of the rule.
   *
   * @schema TopicRuleSpecForProviderErrorActionTimestreamDimension#name
   */
  readonly name?: string;

  /**
   * The value of the HTTP header.
   *
   * @schema TopicRuleSpecForProviderErrorActionTimestreamDimension#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionTimestreamDimension' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionTimestreamDimension(obj: TopicRuleSpecForProviderErrorActionTimestreamDimension | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecForProviderErrorActionTimestreamTimestamp
 */
export interface TopicRuleSpecForProviderErrorActionTimestreamTimestamp {
  /**
   * The precision of the timestamp value that results from the expression described in value. Valid values: SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS.
   *
   * @schema TopicRuleSpecForProviderErrorActionTimestreamTimestamp#unit
   */
  readonly unit?: string;

  /**
   * The value of the HTTP header.
   *
   * @schema TopicRuleSpecForProviderErrorActionTimestreamTimestamp#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionTimestreamTimestamp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionTimestreamTimestamp(obj: TopicRuleSpecForProviderErrorActionTimestreamTimestamp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicRuleSpecForProviderSnsRoleArnRefPolicy
 */
export interface TopicRuleSpecForProviderSnsRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicRuleSpecForProviderSnsRoleArnRefPolicy#resolution
   */
  readonly resolution?: TopicRuleSpecForProviderSnsRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicRuleSpecForProviderSnsRoleArnRefPolicy#resolve
   */
  readonly resolve?: TopicRuleSpecForProviderSnsRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderSnsRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderSnsRoleArnRefPolicy(obj: TopicRuleSpecForProviderSnsRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicRuleSpecForProviderSnsRoleArnSelectorPolicy
 */
export interface TopicRuleSpecForProviderSnsRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicRuleSpecForProviderSnsRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TopicRuleSpecForProviderSnsRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicRuleSpecForProviderSnsRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TopicRuleSpecForProviderSnsRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderSnsRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderSnsRoleArnSelectorPolicy(obj: TopicRuleSpecForProviderSnsRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicRuleSpecForProviderSnsTargetArnRefPolicy
 */
export interface TopicRuleSpecForProviderSnsTargetArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicRuleSpecForProviderSnsTargetArnRefPolicy#resolution
   */
  readonly resolution?: TopicRuleSpecForProviderSnsTargetArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicRuleSpecForProviderSnsTargetArnRefPolicy#resolve
   */
  readonly resolve?: TopicRuleSpecForProviderSnsTargetArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderSnsTargetArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderSnsTargetArnRefPolicy(obj: TopicRuleSpecForProviderSnsTargetArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicRuleSpecForProviderSnsTargetArnSelectorPolicy
 */
export interface TopicRuleSpecForProviderSnsTargetArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicRuleSpecForProviderSnsTargetArnSelectorPolicy#resolution
   */
  readonly resolution?: TopicRuleSpecForProviderSnsTargetArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicRuleSpecForProviderSnsTargetArnSelectorPolicy#resolve
   */
  readonly resolve?: TopicRuleSpecForProviderSnsTargetArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderSnsTargetArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderSnsTargetArnSelectorPolicy(obj: TopicRuleSpecForProviderSnsTargetArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionDynamodbv2PutItem
 */
export interface TopicRuleSpecInitProviderErrorActionDynamodbv2PutItem {
  /**
   * The name of the DynamoDB table.
   *
   * @schema TopicRuleSpecInitProviderErrorActionDynamodbv2PutItem#tableName
   */
  readonly tableName?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionDynamodbv2PutItem' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionDynamodbv2PutItem(obj: TopicRuleSpecInitProviderErrorActionDynamodbv2PutItem | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableName': obj.tableName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionHttpHttpHeader
 */
export interface TopicRuleSpecInitProviderErrorActionHttpHttpHeader {
  /**
   * The name of the HTTP header.
   *
   * @schema TopicRuleSpecInitProviderErrorActionHttpHttpHeader#key
   */
  readonly key?: string;

  /**
   * The value of the HTTP header.
   *
   * @schema TopicRuleSpecInitProviderErrorActionHttpHttpHeader#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionHttpHttpHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionHttpHttpHeader(obj: TopicRuleSpecInitProviderErrorActionHttpHttpHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionTimestreamDimension
 */
export interface TopicRuleSpecInitProviderErrorActionTimestreamDimension {
  /**
   * The name of the rule.
   *
   * @schema TopicRuleSpecInitProviderErrorActionTimestreamDimension#name
   */
  readonly name?: string;

  /**
   * The value of the HTTP header.
   *
   * @schema TopicRuleSpecInitProviderErrorActionTimestreamDimension#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionTimestreamDimension' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionTimestreamDimension(obj: TopicRuleSpecInitProviderErrorActionTimestreamDimension | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicRuleSpecInitProviderErrorActionTimestreamTimestamp
 */
export interface TopicRuleSpecInitProviderErrorActionTimestreamTimestamp {
  /**
   * The precision of the timestamp value that results from the expression described in value. Valid values: SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS.
   *
   * @schema TopicRuleSpecInitProviderErrorActionTimestreamTimestamp#unit
   */
  readonly unit?: string;

  /**
   * The value of the HTTP header.
   *
   * @schema TopicRuleSpecInitProviderErrorActionTimestreamTimestamp#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TopicRuleSpecInitProviderErrorActionTimestreamTimestamp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecInitProviderErrorActionTimestreamTimestamp(obj: TopicRuleSpecInitProviderErrorActionTimestreamTimestamp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TopicRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TopicRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TopicRuleSpecForProviderErrorActionSnsRoleArnRefPolicy
 */
export interface TopicRuleSpecForProviderErrorActionSnsRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsRoleArnRefPolicy#resolution
   */
  readonly resolution?: TopicRuleSpecForProviderErrorActionSnsRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsRoleArnRefPolicy#resolve
   */
  readonly resolve?: TopicRuleSpecForProviderErrorActionSnsRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionSnsRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionSnsRoleArnRefPolicy(obj: TopicRuleSpecForProviderErrorActionSnsRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicRuleSpecForProviderErrorActionSnsRoleArnSelectorPolicy
 */
export interface TopicRuleSpecForProviderErrorActionSnsRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TopicRuleSpecForProviderErrorActionSnsRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TopicRuleSpecForProviderErrorActionSnsRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionSnsRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionSnsRoleArnSelectorPolicy(obj: TopicRuleSpecForProviderErrorActionSnsRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicRuleSpecForProviderErrorActionSnsTargetArnRefPolicy
 */
export interface TopicRuleSpecForProviderErrorActionSnsTargetArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsTargetArnRefPolicy#resolution
   */
  readonly resolution?: TopicRuleSpecForProviderErrorActionSnsTargetArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsTargetArnRefPolicy#resolve
   */
  readonly resolve?: TopicRuleSpecForProviderErrorActionSnsTargetArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionSnsTargetArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionSnsTargetArnRefPolicy(obj: TopicRuleSpecForProviderErrorActionSnsTargetArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicRuleSpecForProviderErrorActionSnsTargetArnSelectorPolicy
 */
export interface TopicRuleSpecForProviderErrorActionSnsTargetArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsTargetArnSelectorPolicy#resolution
   */
  readonly resolution?: TopicRuleSpecForProviderErrorActionSnsTargetArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicRuleSpecForProviderErrorActionSnsTargetArnSelectorPolicy#resolve
   */
  readonly resolve?: TopicRuleSpecForProviderErrorActionSnsTargetArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicRuleSpecForProviderErrorActionSnsTargetArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicRuleSpecForProviderErrorActionSnsTargetArnSelectorPolicy(obj: TopicRuleSpecForProviderErrorActionSnsTargetArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicRuleSpecForProviderSnsRoleArnRefPolicyResolution
 */
export enum TopicRuleSpecForProviderSnsRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicRuleSpecForProviderSnsRoleArnRefPolicyResolve
 */
export enum TopicRuleSpecForProviderSnsRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicRuleSpecForProviderSnsRoleArnSelectorPolicyResolution
 */
export enum TopicRuleSpecForProviderSnsRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicRuleSpecForProviderSnsRoleArnSelectorPolicyResolve
 */
export enum TopicRuleSpecForProviderSnsRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicRuleSpecForProviderSnsTargetArnRefPolicyResolution
 */
export enum TopicRuleSpecForProviderSnsTargetArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicRuleSpecForProviderSnsTargetArnRefPolicyResolve
 */
export enum TopicRuleSpecForProviderSnsTargetArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicRuleSpecForProviderSnsTargetArnSelectorPolicyResolution
 */
export enum TopicRuleSpecForProviderSnsTargetArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicRuleSpecForProviderSnsTargetArnSelectorPolicyResolve
 */
export enum TopicRuleSpecForProviderSnsTargetArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicRuleSpecForProviderErrorActionSnsRoleArnRefPolicyResolution
 */
export enum TopicRuleSpecForProviderErrorActionSnsRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicRuleSpecForProviderErrorActionSnsRoleArnRefPolicyResolve
 */
export enum TopicRuleSpecForProviderErrorActionSnsRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicRuleSpecForProviderErrorActionSnsRoleArnSelectorPolicyResolution
 */
export enum TopicRuleSpecForProviderErrorActionSnsRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicRuleSpecForProviderErrorActionSnsRoleArnSelectorPolicyResolve
 */
export enum TopicRuleSpecForProviderErrorActionSnsRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicRuleSpecForProviderErrorActionSnsTargetArnRefPolicyResolution
 */
export enum TopicRuleSpecForProviderErrorActionSnsTargetArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicRuleSpecForProviderErrorActionSnsTargetArnRefPolicyResolve
 */
export enum TopicRuleSpecForProviderErrorActionSnsTargetArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicRuleSpecForProviderErrorActionSnsTargetArnSelectorPolicyResolution
 */
export enum TopicRuleSpecForProviderErrorActionSnsTargetArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicRuleSpecForProviderErrorActionSnsTargetArnSelectorPolicyResolve
 */
export enum TopicRuleSpecForProviderErrorActionSnsTargetArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

