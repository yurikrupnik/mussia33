// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Hub is the Schema for the Hubs API. The NetworkConnectivity Hub resource
 *
 * @schema Hub
 */
export class Hub extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Hub"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkconnectivity.gcp.upbound.io/v1beta1',
    kind: 'Hub',
  }

  /**
   * Renders a Kubernetes manifest for "Hub".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HubProps): any {
    return {
      ...Hub.GVK,
      ...toJson_HubProps(props),
    };
  }

  /**
   * Defines a "Hub" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HubProps) {
    super(scope, id, {
      ...Hub.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Hub.GVK,
      ...toJson_HubProps(resolved),
    };
  }
}

/**
 * Hub is the Schema for the Hubs API. The NetworkConnectivity Hub resource
 *
 * @schema Hub
 */
export interface HubProps {
  /**
   * @schema Hub#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HubSpec defines the desired state of Hub
   *
   * @schema Hub#spec
   */
  readonly spec: HubSpec;

}

/**
 * Converts an object of type 'HubProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HubProps(obj: HubProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HubSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HubSpec defines the desired state of Hub
 *
 * @schema HubSpec
 */
export interface HubSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema HubSpec#deletionPolicy
   */
  readonly deletionPolicy?: HubSpecDeletionPolicy;

  /**
   * @schema HubSpec#forProvider
   */
  readonly forProvider: HubSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema HubSpec#providerConfigRef
   */
  readonly providerConfigRef?: HubSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema HubSpec#providerRef
   */
  readonly providerRef?: HubSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema HubSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HubSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema HubSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HubSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HubSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HubSpec(obj: HubSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HubSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_HubSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_HubSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_HubSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HubSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema HubSpecDeletionPolicy
 */
export enum HubSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema HubSpecForProvider
 */
export interface HubSpecForProvider {
  /**
   * An optional description of the hub.
   *
   * @schema HubSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Optional labels in key:value format. For more information about labels, see Requirements for labels.
   *
   * @schema HubSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Immutable. The name of the hub. Hub names must be unique. They use the following form: projects/{project_number}/locations/global/hubs/{hub_id}
   *
   * @schema HubSpecForProvider#name
   */
  readonly name: string;

  /**
   * The project for the resource
   *
   * @schema HubSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'HubSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HubSpecForProvider(obj: HubSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema HubSpecProviderConfigRef
 */
export interface HubSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HubSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HubSpecProviderConfigRef#policy
   */
  readonly policy?: HubSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HubSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HubSpecProviderConfigRef(obj: HubSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HubSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema HubSpecProviderRef
 */
export interface HubSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema HubSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HubSpecProviderRef#policy
   */
  readonly policy?: HubSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'HubSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HubSpecProviderRef(obj: HubSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HubSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema HubSpecPublishConnectionDetailsTo
 */
export interface HubSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema HubSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HubSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HubSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HubSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HubSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HubSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HubSpecPublishConnectionDetailsTo(obj: HubSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HubSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HubSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema HubSpecWriteConnectionSecretToRef
 */
export interface HubSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HubSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HubSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HubSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HubSpecWriteConnectionSecretToRef(obj: HubSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HubSpecProviderConfigRefPolicy
 */
export interface HubSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HubSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HubSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HubSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HubSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HubSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HubSpecProviderConfigRefPolicy(obj: HubSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HubSpecProviderRefPolicy
 */
export interface HubSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HubSpecProviderRefPolicy#resolution
   */
  readonly resolution?: HubSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HubSpecProviderRefPolicy#resolve
   */
  readonly resolve?: HubSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'HubSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HubSpecProviderRefPolicy(obj: HubSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema HubSpecPublishConnectionDetailsToConfigRef
 */
export interface HubSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HubSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HubSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HubSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HubSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HubSpecPublishConnectionDetailsToConfigRef(obj: HubSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HubSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HubSpecPublishConnectionDetailsToMetadata
 */
export interface HubSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema HubSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema HubSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema HubSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HubSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HubSpecPublishConnectionDetailsToMetadata(obj: HubSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HubSpecProviderConfigRefPolicyResolution
 */
export enum HubSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HubSpecProviderConfigRefPolicyResolve
 */
export enum HubSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HubSpecProviderRefPolicyResolution
 */
export enum HubSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HubSpecProviderRefPolicyResolve
 */
export enum HubSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HubSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HubSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HubSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HubSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HubSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HubSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HubSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HubSpecPublishConnectionDetailsToConfigRefPolicy(obj: HubSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HubSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HubSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HubSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HubSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Spoke is the Schema for the Spokes API. The NetworkConnectivity Spoke resource
 *
 * @schema Spoke
 */
export class Spoke extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Spoke"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkconnectivity.gcp.upbound.io/v1beta1',
    kind: 'Spoke',
  }

  /**
   * Renders a Kubernetes manifest for "Spoke".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SpokeProps): any {
    return {
      ...Spoke.GVK,
      ...toJson_SpokeProps(props),
    };
  }

  /**
   * Defines a "Spoke" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SpokeProps) {
    super(scope, id, {
      ...Spoke.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Spoke.GVK,
      ...toJson_SpokeProps(resolved),
    };
  }
}

/**
 * Spoke is the Schema for the Spokes API. The NetworkConnectivity Spoke resource
 *
 * @schema Spoke
 */
export interface SpokeProps {
  /**
   * @schema Spoke#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SpokeSpec defines the desired state of Spoke
   *
   * @schema Spoke#spec
   */
  readonly spec: SpokeSpec;

}

/**
 * Converts an object of type 'SpokeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeProps(obj: SpokeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SpokeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SpokeSpec defines the desired state of Spoke
 *
 * @schema SpokeSpec
 */
export interface SpokeSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema SpokeSpec#deletionPolicy
   */
  readonly deletionPolicy?: SpokeSpecDeletionPolicy;

  /**
   * @schema SpokeSpec#forProvider
   */
  readonly forProvider: SpokeSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SpokeSpec#providerConfigRef
   */
  readonly providerConfigRef?: SpokeSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SpokeSpec#providerRef
   */
  readonly providerRef?: SpokeSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SpokeSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SpokeSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SpokeSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SpokeSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SpokeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpec(obj: SpokeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SpokeSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_SpokeSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SpokeSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SpokeSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SpokeSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema SpokeSpecDeletionPolicy
 */
export enum SpokeSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SpokeSpecForProvider
 */
export interface SpokeSpecForProvider {
  /**
   * An optional description of the spoke.
   *
   * @schema SpokeSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Immutable. The URI of the hub that this spoke is attached to.
   *
   * @schema SpokeSpecForProvider#hub
   */
  readonly hub?: string;

  /**
   * Reference to a Hub in networkconnectivity to populate hub.
   *
   * @schema SpokeSpecForProvider#hubRef
   */
  readonly hubRef?: SpokeSpecForProviderHubRef;

  /**
   * Selector for a Hub in networkconnectivity to populate hub.
   *
   * @schema SpokeSpecForProvider#hubSelector
   */
  readonly hubSelector?: SpokeSpecForProviderHubSelector;

  /**
   * Optional labels in key:value format. For more information about labels, see Requirements for labels.
   *
   * @schema SpokeSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.
   *
   * @schema SpokeSpecForProvider#linkedInterconnectAttachments
   */
  readonly linkedInterconnectAttachments?: SpokeSpecForProviderLinkedInterconnectAttachments[];

  /**
   * The URIs of linked Router appliance resources
   *
   * @schema SpokeSpecForProvider#linkedRouterApplianceInstances
   */
  readonly linkedRouterApplianceInstances?: SpokeSpecForProviderLinkedRouterApplianceInstances[];

  /**
   * The URIs of linked VPN tunnel resources
   *
   * @schema SpokeSpecForProvider#linkedVpnTunnels
   */
  readonly linkedVpnTunnels?: SpokeSpecForProviderLinkedVpnTunnels[];

  /**
   * The location for the resource
   *
   * @schema SpokeSpecForProvider#location
   */
  readonly location: string;

  /**
   * Immutable. The name of the spoke. Spoke names must be unique.
   *
   * @schema SpokeSpecForProvider#name
   */
  readonly name: string;

  /**
   * The project for the resource
   *
   * @schema SpokeSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'SpokeSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecForProvider(obj: SpokeSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'hub': obj.hub,
    'hubRef': toJson_SpokeSpecForProviderHubRef(obj.hubRef),
    'hubSelector': toJson_SpokeSpecForProviderHubSelector(obj.hubSelector),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'linkedInterconnectAttachments': obj.linkedInterconnectAttachments?.map(y => toJson_SpokeSpecForProviderLinkedInterconnectAttachments(y)),
    'linkedRouterApplianceInstances': obj.linkedRouterApplianceInstances?.map(y => toJson_SpokeSpecForProviderLinkedRouterApplianceInstances(y)),
    'linkedVpnTunnels': obj.linkedVpnTunnels?.map(y => toJson_SpokeSpecForProviderLinkedVpnTunnels(y)),
    'location': obj.location,
    'name': obj.name,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SpokeSpecProviderConfigRef
 */
export interface SpokeSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SpokeSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SpokeSpecProviderConfigRef#policy
   */
  readonly policy?: SpokeSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SpokeSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecProviderConfigRef(obj: SpokeSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SpokeSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SpokeSpecProviderRef
 */
export interface SpokeSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SpokeSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SpokeSpecProviderRef#policy
   */
  readonly policy?: SpokeSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SpokeSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecProviderRef(obj: SpokeSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SpokeSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SpokeSpecPublishConnectionDetailsTo
 */
export interface SpokeSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SpokeSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SpokeSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SpokeSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SpokeSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SpokeSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SpokeSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecPublishConnectionDetailsTo(obj: SpokeSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SpokeSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SpokeSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SpokeSpecWriteConnectionSecretToRef
 */
export interface SpokeSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SpokeSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SpokeSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SpokeSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecWriteConnectionSecretToRef(obj: SpokeSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Hub in networkconnectivity to populate hub.
 *
 * @schema SpokeSpecForProviderHubRef
 */
export interface SpokeSpecForProviderHubRef {
  /**
   * Name of the referenced object.
   *
   * @schema SpokeSpecForProviderHubRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SpokeSpecForProviderHubRef#policy
   */
  readonly policy?: SpokeSpecForProviderHubRefPolicy;

}

/**
 * Converts an object of type 'SpokeSpecForProviderHubRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecForProviderHubRef(obj: SpokeSpecForProviderHubRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SpokeSpecForProviderHubRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Hub in networkconnectivity to populate hub.
 *
 * @schema SpokeSpecForProviderHubSelector
 */
export interface SpokeSpecForProviderHubSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SpokeSpecForProviderHubSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SpokeSpecForProviderHubSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SpokeSpecForProviderHubSelector#policy
   */
  readonly policy?: SpokeSpecForProviderHubSelectorPolicy;

}

/**
 * Converts an object of type 'SpokeSpecForProviderHubSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecForProviderHubSelector(obj: SpokeSpecForProviderHubSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SpokeSpecForProviderHubSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SpokeSpecForProviderLinkedInterconnectAttachments
 */
export interface SpokeSpecForProviderLinkedInterconnectAttachments {
  /**
   * A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
   *
   * @schema SpokeSpecForProviderLinkedInterconnectAttachments#siteToSiteDataTransfer
   */
  readonly siteToSiteDataTransfer: boolean;

  /**
   * The URIs of linked interconnect attachment resources
   *
   * @schema SpokeSpecForProviderLinkedInterconnectAttachments#uris
   */
  readonly uris: string[];

}

/**
 * Converts an object of type 'SpokeSpecForProviderLinkedInterconnectAttachments' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecForProviderLinkedInterconnectAttachments(obj: SpokeSpecForProviderLinkedInterconnectAttachments | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'siteToSiteDataTransfer': obj.siteToSiteDataTransfer,
    'uris': obj.uris?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SpokeSpecForProviderLinkedRouterApplianceInstances
 */
export interface SpokeSpecForProviderLinkedRouterApplianceInstances {
  /**
   * The list of router appliance instances
   *
   * @schema SpokeSpecForProviderLinkedRouterApplianceInstances#instances
   */
  readonly instances: SpokeSpecForProviderLinkedRouterApplianceInstancesInstances[];

  /**
   * A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
   *
   * @schema SpokeSpecForProviderLinkedRouterApplianceInstances#siteToSiteDataTransfer
   */
  readonly siteToSiteDataTransfer: boolean;

}

/**
 * Converts an object of type 'SpokeSpecForProviderLinkedRouterApplianceInstances' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecForProviderLinkedRouterApplianceInstances(obj: SpokeSpecForProviderLinkedRouterApplianceInstances | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instances': obj.instances?.map(y => toJson_SpokeSpecForProviderLinkedRouterApplianceInstancesInstances(y)),
    'siteToSiteDataTransfer': obj.siteToSiteDataTransfer,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SpokeSpecForProviderLinkedVpnTunnels
 */
export interface SpokeSpecForProviderLinkedVpnTunnels {
  /**
   * A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
   *
   * @schema SpokeSpecForProviderLinkedVpnTunnels#siteToSiteDataTransfer
   */
  readonly siteToSiteDataTransfer: boolean;

  /**
   * The URIs of linked VPN tunnel resources.
   *
   * @schema SpokeSpecForProviderLinkedVpnTunnels#uris
   */
  readonly uris: string[];

}

/**
 * Converts an object of type 'SpokeSpecForProviderLinkedVpnTunnels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecForProviderLinkedVpnTunnels(obj: SpokeSpecForProviderLinkedVpnTunnels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'siteToSiteDataTransfer': obj.siteToSiteDataTransfer,
    'uris': obj.uris?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SpokeSpecProviderConfigRefPolicy
 */
export interface SpokeSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SpokeSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SpokeSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SpokeSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SpokeSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SpokeSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecProviderConfigRefPolicy(obj: SpokeSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SpokeSpecProviderRefPolicy
 */
export interface SpokeSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SpokeSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SpokeSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SpokeSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SpokeSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SpokeSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecProviderRefPolicy(obj: SpokeSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SpokeSpecPublishConnectionDetailsToConfigRef
 */
export interface SpokeSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SpokeSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SpokeSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SpokeSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SpokeSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecPublishConnectionDetailsToConfigRef(obj: SpokeSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SpokeSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SpokeSpecPublishConnectionDetailsToMetadata
 */
export interface SpokeSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SpokeSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SpokeSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SpokeSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SpokeSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecPublishConnectionDetailsToMetadata(obj: SpokeSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SpokeSpecForProviderHubRefPolicy
 */
export interface SpokeSpecForProviderHubRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SpokeSpecForProviderHubRefPolicy#resolution
   */
  readonly resolution?: SpokeSpecForProviderHubRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SpokeSpecForProviderHubRefPolicy#resolve
   */
  readonly resolve?: SpokeSpecForProviderHubRefPolicyResolve;

}

/**
 * Converts an object of type 'SpokeSpecForProviderHubRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecForProviderHubRefPolicy(obj: SpokeSpecForProviderHubRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SpokeSpecForProviderHubSelectorPolicy
 */
export interface SpokeSpecForProviderHubSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SpokeSpecForProviderHubSelectorPolicy#resolution
   */
  readonly resolution?: SpokeSpecForProviderHubSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SpokeSpecForProviderHubSelectorPolicy#resolve
   */
  readonly resolve?: SpokeSpecForProviderHubSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SpokeSpecForProviderHubSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecForProviderHubSelectorPolicy(obj: SpokeSpecForProviderHubSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstances
 */
export interface SpokeSpecForProviderLinkedRouterApplianceInstancesInstances {
  /**
   * The IP address on the VM to use for peering.
   *
   * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstances#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * The URI of the virtual machine resource
   *
   * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstances#virtualMachine
   */
  readonly virtualMachine?: string;

  /**
   * Reference to a Instance in compute to populate virtualMachine.
   *
   * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstances#virtualMachineRef
   */
  readonly virtualMachineRef?: SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRef;

  /**
   * Selector for a Instance in compute to populate virtualMachine.
   *
   * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstances#virtualMachineSelector
   */
  readonly virtualMachineSelector?: SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelector;

}

/**
 * Converts an object of type 'SpokeSpecForProviderLinkedRouterApplianceInstancesInstances' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecForProviderLinkedRouterApplianceInstancesInstances(obj: SpokeSpecForProviderLinkedRouterApplianceInstancesInstances | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'virtualMachine': obj.virtualMachine,
    'virtualMachineRef': toJson_SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRef(obj.virtualMachineRef),
    'virtualMachineSelector': toJson_SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelector(obj.virtualMachineSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SpokeSpecProviderConfigRefPolicyResolution
 */
export enum SpokeSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SpokeSpecProviderConfigRefPolicyResolve
 */
export enum SpokeSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SpokeSpecProviderRefPolicyResolution
 */
export enum SpokeSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SpokeSpecProviderRefPolicyResolve
 */
export enum SpokeSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SpokeSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SpokeSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SpokeSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SpokeSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SpokeSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SpokeSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SpokeSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecPublishConnectionDetailsToConfigRefPolicy(obj: SpokeSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SpokeSpecForProviderHubRefPolicyResolution
 */
export enum SpokeSpecForProviderHubRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SpokeSpecForProviderHubRefPolicyResolve
 */
export enum SpokeSpecForProviderHubRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SpokeSpecForProviderHubSelectorPolicyResolution
 */
export enum SpokeSpecForProviderHubSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SpokeSpecForProviderHubSelectorPolicyResolve
 */
export enum SpokeSpecForProviderHubSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a Instance in compute to populate virtualMachine.
 *
 * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRef
 */
export interface SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRef {
  /**
   * Name of the referenced object.
   *
   * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRef#policy
   */
  readonly policy?: SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRefPolicy;

}

/**
 * Converts an object of type 'SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRef(obj: SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in compute to populate virtualMachine.
 *
 * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelector
 */
export interface SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelector#policy
   */
  readonly policy?: SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelectorPolicy;

}

/**
 * Converts an object of type 'SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelector(obj: SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SpokeSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SpokeSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SpokeSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SpokeSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRefPolicy
 */
export interface SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRefPolicy#resolution
   */
  readonly resolution?: SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRefPolicy#resolve
   */
  readonly resolve?: SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRefPolicyResolve;

}

/**
 * Converts an object of type 'SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRefPolicy(obj: SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelectorPolicy
 */
export interface SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelectorPolicy#resolution
   */
  readonly resolution?: SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelectorPolicy#resolve
   */
  readonly resolve?: SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelectorPolicy(obj: SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRefPolicyResolution
 */
export enum SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRefPolicyResolve
 */
export enum SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelectorPolicyResolution
 */
export enum SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelectorPolicyResolve
 */
export enum SpokeSpecForProviderLinkedRouterApplianceInstancesInstancesVirtualMachineSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

